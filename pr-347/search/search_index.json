{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"anomian.html","title":"Anomian","text":"","tags":["work-in-progress","tutorial","engine"],"boost":2},{"location":"anomian.html#preface","title":"Preface","text":"<p>As in the Little Typer book, we explore some aspects of the Anoma model through a dialogue that presents the notions considered in the specification. There are two participants in this dialogue: the student, Jordan, and Anomian, the modeller. When Anomian speaks, it is in the form of a quote. Otherwise, Jordan speaks.</p> <p>Hi, I am Anomian.</p> <p>The goal of this dialogue is to illustrate what the Anoma system is about and how to model it. For the sake of concreteness, we present a few Juvix code snippets that are intended to clarify the model and help resolve potential ambiguities. Most of the data types are enumerations and inductive types. The quotes alone should convey the main idea. The Jordan interjections are to confirm, ask questions, and reiterate the concepts.</p> <p>Last, but not least, we have not only code snippets, but we fully embrace literate programming. This comes at the inconvenience of some lines of boilerplate here, but it can safely be skipped on a first reading.</p> Juvix imports <p><pre><code><pre>module anomian;import arch.node.types.basics open public;import arch.node.types.identities open;import arch.node.types.messages open hiding {EngineMsg; Mailbox};</pre></code></pre></p>","tags":["work-in-progress","tutorial","engine"],"boost":2},{"location":"anomian.html#chapter-1-the-core-players-of-the-game","title":"Chapter 1: The core players of the game","text":"<p>At the core of the Anoma model, we find engines. They do most of the heavy lifting.</p> <p>So, what do you mean by an engine?</p> <p>Think of an engine as a dynamic entity that can do stuff, much like us, and that has an engine-status that could be running, dead, or suspended.</p> <pre><code><pre>type EngineStatus :=  | Running  | Dead  | Suspended;</pre>\n\n\n<p>Todo</p>\n<ul>\n<li>Explain that if the engine is dead, next time the system steps, engines marked\n  as dead are removed from the system, similarly as a garbage collector\n  would do.</li>\n<li>Explain that the engine-status is not a property of the engine, but rather\n  a property of the engine-instance.</li>\n</ul>\n\n<p>Dynamic entity? What is dynamic about it?</p>\n\n<p>You and I are not the same person we were yesterday because some events\nhappened to us. For engines, a typical event is the reception of an\nengine-message and as a reaction to message reception, their state may\nchange. This ability to change their state is what makes them dynamic.\nHowever, notice that this change of internal state is optional. We call those\nengines that never change their state stateless engines.</p>\n\n<p>Huh, so, an engine has its own state, and that state can change by reacting to\nmessages that are sent to it. Easy.</p>\n\n<p>It's like when we receive a letter from the tax office. Once we read\nthe letter and understand it, we know that we have to pay taxes and eventually\ndo so. That letter may \"change\" us, some money may be gone.</p>\n\n<p>But wait, who really sends those messages actually?</p>\n\n<p>Any engine, including the same engine which receives the message.\nFor example, an engine could remind itself to do something by sending a message\nto itself.</p>\n\n<p>I see, and the messages can be in different languages, right? I read English\nbut not French. How are engines able to communicate with each other? Do\nthey all speak the same language?</p>\n\n<p>Each engine has its own message interface, indicating the language(s) they speak.\nThis message interface defines the format and content of the messages it can\ncomprehend and process.</p>\n\n\n\n<p>For example, let's say the engines in our model only speak English, French, and\nSpanish.</p>\n\n<pre><code><pre>syntax alias EnglishPayload := String;syntax alias FrenchPayload := String;syntax alias SpanishPayload := String;</pre>\n\n\n\n<p>If I, Anomian, speak English and French, my message interface would\nlook like this.</p>\n\n<pre><code><pre>type AnomianMsgInterface :=  | AnomianMsgEnglish@{      msg : EnglishPayload;    }  | AnomianMsgFrench@{      msg : FrenchPayload;    };</pre>\n\n\n<p>Hey, in my case, I speak English and Spanish. My message interface is the following.</p>\n<pre><code><pre>type JordanMsgInterface :=  | JordanMsgEnglish@{      msg : EnglishPayload;    }  | JordanMsgSpanish@{      msg : SpanishPayload;    };</pre>\n\n\n<p>Got it. Here is a message you can understand, Anomian.</p>\n<pre><code><pre>helloAnomian : AnomianMsgInterface :=  AnomianMsgInterface.AnomianMsgEnglish@{    msg := \"Hello!\";  };</pre>\n\n\n<p>Message Interface</p>\n<ul>\n<li>Each engine has a message interface.</li>\n</ul>\n<ul>\n<li>By construction, it is safe to assume that every engine has at least one\n  message constructor<sup>1</sup> in its message interface.</li>\n</ul>\n\n\n<p>The model defines all the message interfaces defined by engines.</p>\n\n<pre><code><pre>type MsgInterface :=  | MsgAnomian AnomianMsgInterface  | MsgJordan JordanMsgInterface;</pre></code></pre>\n\n\n<p>To see the full list of message interfaces in the current model, check out the\nsum type <code>Msg</code> in Anoma Message.</p>","tags":["work-in-progress","tutorial","engine"],"boost":2},{"location":"anomian.html#chapter-2-communication-patterns","title":"Chapter 2: Communication patterns","text":"<p>Now that we understand engines and their message interfaces, let's talk about\nhow they communicate with each other or better said, what patterns of communication\nare there.</p>\n\n<p>I can send a message to you, Anomian, either to expect a response or simply to\ninform you that I'm alive. What else can I do?</p>\n\n\n<p>There are many patterns indeed, but let us start with the most common ones.</p>\n\n<pre><code><pre>syntax alias Timeout := Nat;type CommunicationPattern :=  | FireAndForget  | RequestReply@{      timeout : Option Timeout;    }  | PubSub;</pre>\n\n\n<p>We can consider three patterns of communication. The pattern <code>FireAndForget</code>\nallows us to communicate asynchronously. One can send a message and not expect\nany response like notifications on your phone. However, if you need a response\nor result and can wait for it, we can use the <code>RequestReply</code> pattern. That is\nthe pattern that every synchronous communication uses implicitly. And finally,\nthe <code>PubSub</code> pattern (pub/sub for short) that allows us to communicate\nasynchronously and without a response, broadcasting messages to multiple\nengines.</p>\n\n\n\n\n\n<p>We can consider three purposes for a message:</p>\n<ul>\n<li>The first one is to request a reply.</li>\n<li>The second one is to reply to a request.</li>\n<li>The third one is to notify about something.</li>\n</ul>\n<p>We can represent these three cases with the <code>EngineMsgKind</code> type.</p>\n\n<pre><code><pre>type EngineMsgKind :=  | Request  | Reply  | Notify;</pre>\n\n\n<p>Summary of communication patterns</p>\n<p>We can have several communication patterns.\n</p>","tags":["work-in-progress","tutorial","engine"],"boost":2},{"location":"anomian.html#chapter-3-engine-configurations","title":"Chapter 3: Engine configurations","text":"<p>Anomian, you mentioned that engines have an internal state, a message interface,\nand specific communication patterns. Are there any other characteristics that\ndefine an engine? And what about us, are we also engines? For instance, humans\nhave attributes such as name, age, and parents. Do engines have similar\nattributes?</p>\n\n\n<p>Engines possess certain attributes. These attributes are stored in what we\ncall their engine-configuration, of type <code>EngineCfg</code>. This configuration\nis immutable through the lifetime of the engine. The configuration of an\nengine includes its parent that spawns it, its name, a virtual\nlocation where the engine runs named <code>node</code>, and some configuration parameters\ndenoted by <code>cfg</code> of an engine-specific type that instantiates the type\nparameter <code>C</code>.</p>\n\n<pre><code><pre>type EngineCfg C :=  mkCfg@{    parent : Option EngineID;    name : EngineName;    node : NodeID;    cfg : C;  };</pre>\n\n\n<p>As we say the engine configuration is immutable by design. This means that\nonce an engine is created, attributes such as the name of the engine cannot be\nchanged. If you want to change the name of an engine, you have to create a new\nengine with the new name.</p>\n\n<p>Tell me one thing about the parents of engines. Do they always know who their\nparent is? I don't know who is my father, actually.</p>\n\n\n<p>Engines might not always know who their parent is.<sup>2</sup> The absence of this information is\nstored in the engine's configuration with the <code>parent</code> field set to <code>none</code>.\nIf the parent is known, the <code>parent</code> field is set to <code>some creatorID</code>, where\n<code>creatorID</code> is the engine-identifier of the parent engine.</p>\n\n<pre><code><pre>axiom localhost : NodeID;simpleConfig : EngineCfg Unit :=  EngineCfg.mkCfg@{    parent := none;    name := \"Anomian\";    node := localhost;    cfg := unit;  };</pre>\n\n<p>So, we have one way to identify engines: by their name and their node if we know\nwhere it runs.</p>\n\n\n<p>Roughly, a node is a\nvirtual place where the engine lives and operates. This place could be known\nto be in the same neighbourhood, in which case, we can refer to it as a\nlocal engine. Otherwise, the engine is an external engine.\nHowever, note that we have not yet defined what a node is!</p>\n\n<pre><code><pre>EngineID : Type := Pair (Option NodeID) EngineName;</pre>\n\n<p>Okay, I guess that we can nevertheless start thinking about identifiers already.</p>\n<pre><code><pre>JordanID : EngineID := mkPair (some localhost) \"Jordan9121\";AnomianID : EngineID := mkPair (some localhost) \"Anomian184\";</pre></code></pre>\n\n\n<p>With engine identifiers (of type <code>EngineID</code>), we can define engine\nmessages. These messages serve as events for engines, sent to them by some\nother engine.</p>\n\n\n\n<p>An engine-message consists of a sender, a target, an optional mailbox\nidentifier, the communication pattern, what kind of message it is, and the\nmessage itself.</p>\n<p>The mailbox identifier is used to identify the mailbox of the target engine,\nthe virtual place where the message is delivered. Recall that the kind\nindicates whether the message is a command, a response, or an event, and the\npattern indicates the expected behaviour pattern for how the recipient\nshould react.</p>\n\n\n<pre><code><pre>type EngineMsg M :=  mkMsg@{    sender : EngineID;    target : EngineID;    mailbox : Option MailboxID;    pattern : CommunicationPattern;    kind : EngineMsgKind;    msg : M;  };</pre>\n\n\n<p>Hah! So let me craft a message for you, Anomian.</p>\n<pre><code><pre>jordanToAnomian : EngineMsg MsgInterface :=  EngineMsg.mkMsg@{    sender := JordanID;    target := AnomianID;    mailbox := some 1;    pattern :=      CommunicationPattern.RequestReply@{        timeout := none;      };    kind := EngineMsgKind.Request;    msg :=      MsgInterface.MsgAnomian        AnomianMsgInterface.AnomianMsgEnglish@{          msg := \"What is the meaning of life?\";        };  };</pre>\n\n\n\n<p>A reply engine-message is <code>anomianToJordan</code>.</p>\n<p>Notice that the type parameter <code>MsgInterface</code> for <code>EngineMsg</code> is the same\nas the one used in the request message, and not an engine-specific message\ninterface.</p>\n\n<pre><code><pre>anomianToJordan : EngineMsg MsgInterface :=  EngineMsg.mkMsg@{    sender := AnomianID;    target := JordanID;    mailbox := some 1;    pattern := CommunicationPattern.FireAndForget;    kind := EngineMsgKind.Reply;    msg :=      MsgInterface.MsgJordan        JordanMsgInterface.JordanMsgEnglish@{          msg := \"The meaning of life is 42.\";        };  };</pre>\n\n<p>Todo</p>\n<p>Reevaluate if the message kind is actually needed. Replies may be\nindistinguishable from notifications, following a fire-and-forget pattern to\nreply.</p>\n\n\n\n<p>The social context of an engine</p>\n<p>Each engine is known in its neighbourhood and may have connections abroad.\nIt still communicates via messages though and stays fixed in the place.</p>\n\n<p>But how can I send it? Do I have to go to the post office?</p>","tags":["work-in-progress","tutorial","engine"],"boost":2},{"location":"anomian.html#chapter-4-mailboxes-for-anyone","title":"Chapter 4: Mailboxes for anyone","text":"<p>Messages are sent to the engine's mailbox.</p>\n\n\n<p>What is a mailbox? A mailbox consists of a queue of messages and can also\ncontain additional data if needed. The data could be the state of the mailbox,\nthink of it as having extra information about the mailbox like the number of\nmessages in it.</p>\n\n<pre><code><pre>type Mailbox S M :=  mkMailbox@{    messages : List (EngineMsg M);    mailboxState : Option S;  };</pre>\n\n\n\n<p>However, engines not only have a single mailbox, but a cluster of mailboxes.\nThat is, there is at least one mailbox per engine, but there can be more.\nThe type <code>MailboxCluster</code> for the cluster of mailboxes is really a mapping of\nmailbox identifiers to the actual mailboxes.</p>\n\n<pre><code><pre>MailboxCluster (S M : Type) : Type := Map MailboxID (Mailbox S M);</pre>\n\n<p>Why bother with the mailbox cluster? One mailbox is enough, right?</p>\n\n<p>While a single mailbox would suffice for basic functionality, multiple\nmailboxes provide valuable message organisation capabilities.</p>\n\n\n\n<p>That sounds like how my email works. It is a cluster of mailboxes, and in\nprinciple, I have one big mailbox, but truly I can see it as having multiple\nmailboxes, one for each folder, such as promotions, important, family, etc.</p>\n\n\n<p>Yes, the folder analogy is great. The following diagram illustrates a mailbox\ncluster. Each mailbox<sup>3</sup> is intended to serve a specific purpose. For\nsimplicity, we refer to the entire cluster as the engine's mailbox if there is\nno confusion. In the type <code>MailboxCluster</code>, we have a map of mailbox IDs to\nmailboxes.</p>\n\n\n<pre><code>graph LR\n    MailboxCluster[\"Jordan's Mailbox Cluster\"] --&gt; Mailbox1\n    MailboxCluster --&gt; Mailbox2\n    MailboxCluster --&gt; Mailbox3\n\n    subgraph Mailbox1[\"Mailbox#1 : 'Urgent'\"]\n        Queue1(\"Queue of Messages\")\n        Data1(\"Mailbox state\")\n    end\n\n    subgraph Mailbox2[\"Mailbox #2 : 'Promotions'\"]\n        Queue2(\"Queue of Messages\")\n        Data2(\"Mailbox state\")\n    end\n\n    subgraph Mailbox3[\"Mailbox #3 : 'Family'\"]\n        Queue3(\"Queue of Messages\")\n        Data3(\"Mailbox state\")\n    end</code></pre>\n\n\n<p>You have not answered yet how mail is actually sent.</p>\n\n<p>Well, imagine for a second that the communication process is magically handled\nby one mailelf that delivers messages to the engines. When a message is sent\nto an engine, the mailelf takes the message from the sender and puts it in the\nengine's mailbox. In other words, for the moment, it suffices to assume that\nall messages are delivered eventually.</p>\n\n\n<p>Mailboxes for eventual message delivery</p>\n<p>So, yes, the main purpose of mailboxes is where the elf delivers the messages.</p>","tags":["work-in-progress","tutorial","engine"],"boost":2},{"location":"anomian.html#chapter-5-context-of-execution","title":"Chapter 5: Context of execution","text":"<p>This is quite a fancy setup for sending messages, but how do engines \"actually\"\nget things done?!</p>\n<p>I mean, we've discussed that engines have certain attributes: an identifier, a\nmessage interface, and a configuration that includes details like a parent, a\nname, and a virtual location where the engine runs. So, maybe a better\nquestion: how do engines actually run?</p>\n\n\n<p>To understand how an engine runs, we need to acknowledge that engines operate\nwithin a context of execution referred to as their engine-environment.\nThis environment, defined by the <code>EngineEnv</code> type, includes the engine's\ninternal state, its mailboxes, and an address book of known engines it can\ninteract with, including itself.</p>\n\n<pre><code><pre>AddressBook : Type := Set EngineName;type EngineEnv S Msg :=  mkEnv@{    state : S;    mailbox : MailboxCluster S Msg;    acq : AddressBook;  };</pre>\n\n\n<p>Note that engine environments do not encompass the engine's configuration,\nalthough they could. Instead, engine configurations are accessible separately\nfrom the engine environments. This separation promotes modularity.</p>\n\n\n<p>Local data of engines and the execution context</p>\n<p>Each engine has its own local data, some of which is fixed,\nand some of which is dynamic. All this data together forms the\nexecution context.</p>","tags":["work-in-progress","tutorial","engine"],"boost":2},{"location":"anomian.html#chapter-6-what-engines-can-do","title":"Chapter 6: What engines can do","text":"<p>So, refining the question: how do engines actually compute? With their\nengine-environment in place, I imagine that engines run some sort of function\nthat uses the engine-environment and a message from the mailbox. Something like\nthe following type <code>Handler</code>, where <code>S</code> is the state of the engine and <code>M</code> is\nthe message interface, and the return type is <code>ReturnSomething</code>, which can be\nwhatever we want.</p>\n<pre><code><pre>axiom ReturnSomething : Type;Handler (M S : Type) : Type := M -&gt; EngineEnv S M -&gt; ReturnSomething;</pre>\n\n\n<p>The computational aspect of an engine is what we refer to as its\nbehaviour, and it is correct to think of it as a function that takes in a\nmessage and the engine's environment. However, the return type of this\nfunction cannot be anything: the type what an engine can produce is part of the\nmodel of engines, and it is fixed for each engine.</p>\n\n<p>What exactly can an engine do if it's not just the same message passing we\nalready know?</p>\n\n\n<p>We decompose the engine's range of possible reactions into a set of\neffects. These effects describe the valid actions that the engine can perform.\nWe can represent these effects with the <code>Effect</code> type.</p>\n<p>To recall, we use the following convention for engine-related types:</p>\n<ul>\n<li><code>S</code> is the type of its internal state,</li>\n<li><code>E</code> is the type of its environment,</li>\n<li><code>M</code> is the type of its message interface.</li>\n</ul>\n\n<pre><code><pre>syntax alias TimeTrigger := Nat;type Effect S E M :=  | SendMsg@{      msg : EngineMsg M;    }  | UpdateState@{      state : S;    }  | SpawnEngine@{      engine : E;    }  | Chain@{      effects : List (Effect S E M);    }  | Schedule@{      trigger : TimeTrigger;      action : Effect S E M;    };</pre>\n\n<p>Based on the type for possible effects,<sup>4</sup> the only new aspect for me about engines is\nthat they record the need for actions to happen at a later time. We already have covered that\nengines have a parent; the <code>SpawnEngine</code> effect is the other side of the same coin.\nThe rest remains the same as before.</p>\n\n<p>Our actions are restricted by certain pre-conditions, some inherent from the\nenvironment. We only take action if the conditions are met. For engines, these\nconditions are expressed as guards.<sup>5</sup></p>\n\n<p>I got it. This mirrors our situation perfectly. Taking the tax office\nexample: when I receive a notice to pay taxes, I first assess whether I have the\nfunds available. If I do, I take action to pay; otherwise, I might postpone the\npayment.</p>\n\n\n<p>The essence of a guard is a predicate, a pre-condition, that must hold\ntrue for the engine to take action.</p>\n<p>Guards are evaluated based on incoming messages, the engine's environment, and\nthe engine's configuration. We can represent this with the type <code>Guard</code>. Since\nguards involve computation, engine's preserve these computations as part of\nthe return type of the guard, that is <code>R</code> in the type <code>Guard</code>. Thus, if the\nunderlying condition is not satisfied, the guard returns nothing. The type\nparameter <code>C</code> will be instantiated with the type for values in the engine's\nconfiguration.</p>\n\n<pre><code><pre>Guard (S M C R : Type) : Type :=  EngineMsg M -&gt; EngineEnv S M -&gt; EngineCfg C -&gt; Option R;isSatisfied  {S M C R}  (guard : Guard S M C R)  (msg : EngineMsg M)  (env : EngineEnv S M)  (cfg : EngineCfg C)  : Bool :=  case guard msg env cfg of    | none := false    | some _ := true;</pre>\n\n<p>Wait! I see an issue. What if the engine has several guards, and they are all satisfied?</p>\n\n\n<p>If several guards are satisfied, engines provide a strategy for how to act.\nThe model has the following options.</p>\n<ul>\n<li>Choose the first guard that is satisfied,</li>\n<li>choose the last guard that is satisfied,</li>\n<li>choose one of them (randomly/non-deterministically) if there are several\n  satisfied guards,</li>\n<li>check that it is the only one that is triggered, and</li>\n<li>choose all of them if all guards are satisfied.</li>\n</ul>\n<p>And recall, If no guard conditions are met, the engine decides not to act.</p>\n\n<pre><code><pre>type GuardStrategy :=  | FirstGuard  | LastGuard  | OneGuard  | UniqueGuard  | AllGuards;</pre>\n\n\n\n\n<p>Keep in mind that guards are formally speaking, a predicate with additional\ninformation. If the guards give green light, the engine will act, by means\nof actions.</p>\n\n<pre><code><pre>type GuardEval S M C R :=  mkGuardEval@{    guards : List (Guard S M C R);    strategy : GuardStrategy;  };</pre>\n\n<p>Ah, I see! So the guards act as the rules the engine follows, and the actions\nare the procedures executed when those rules are satisfied, and with the\npossible outcomes of the guards.</p>\n\n\n<p>We can now define the engine's behaviour as a function that takes in a guard\nevaluation and returns an effect.</p>\n\n<pre><code><pre>EngineBehaviour (S E M C R : Type) : Type := GuardEval S M C R -&gt; Effect S E M;</pre>\n\n\n\n<p>With the concept of an engine now complete, it is appropriate to define the\ntype <code>Engine</code>. An engine is characterised by its configuration, environment,\nand behaviour. Recall that <code>S</code> is the state of the engine, <code>E</code> is the environment,\n<code>M</code> is the message interface, <code>C</code> is the configuration, and <code>R</code> is the return\ntype for guards.</p>\n\n<pre><code><pre>type Engine (S E M C R : Type) :=  mk@{    status : EngineStatus;    cfg : EngineCfg C;    state : EngineEnv S M;    behavior : EngineBehaviour S E M C R;  };</pre>\n\n\n<p>What engines do</p>\n<p>Engines react to incoming messages, taking into account their environment.\nHow they react is governed by guards of which the engine has several,\nroughly one per relevant case. Cases may overlap, but often it is a unique case that\nperforms the reaction.</p>","tags":["work-in-progress","tutorial","engine"],"boost":2},{"location":"anomian.html#chapter-7-we-have-engines-and-now-what","title":"Chapter 7: We have engines, and now, what?","text":"<p>I think I am getting the hang of it. But what's next?</p>\n\n<p>Yes, I think we have made a good start. However, we have to fill in the\nblanks and put everything together in a single system. In the upcoming\nchapters, how the system looks like in more detail and how ensure the\nfollowing properties for engine-to-engine communication:</p>\n\n<ul>\n<li> Message delivery: All messages are eventually delivered</li>\n<li> Engine isolation: Each engine maintains independent state</li>\n<li> Type safety: All communication follows defined message interfaces</li>\n<li> Configuration immutability: Engine configurations cannot be modified after\n  creation</li>\n</ul>\n\n<p>A quick glossary of the terms we have seen so far.</p>\n\n<ul>\n<li>EngineStatus: Represents the possible states an engine can be\n   in\u2014<code>Running</code>, <code>Dead</code>, or <code>Suspended</code>.</li>\n</ul>\n<ul>\n<li>CommunicationPattern: Enumerates the types of communication patterns\n   available, such as <code>FireAndForget</code>, <code>RequestReply</code> with an optional\n   timeout, and <code>PubSub</code>.</li>\n</ul>\n<ul>\n<li>EngineMsgKind: Categorizes messages into <code>Request</code>, <code>Reply</code>, or\n   <code>Notify</code>.</li>\n</ul>\n<ul>\n<li>EngineID: A composite identifier for engines, consisting of a <code>nodeId</code>\n  and a <code>name</code>.</li>\n</ul>\n<ul>\n<li>MessageInterface: Defines the interface for messages specific to\n   different engines (<code>AnomianMsgInterface</code>, <code>JordanMsgInterface</code>) and\n   aggregates them into a general <code>MsgInterface</code>.</li>\n</ul>\n<ul>\n<li>EngineCfg: An immutable configuration for an engine, including optional\n   parent information, engine name, node ID, and a generic configuration type\n   <code>c</code>.</li>\n</ul>\n<ul>\n<li>Mailbox and MailboxCluster: Structure for message queues (<code>Mailbox</code>) and\n   a collection of mailboxes (<code>MailboxCluster</code>) indexed by <code>MailboxID</code>.</li>\n</ul>\n<ul>\n<li>EngineEnv: The execution context of an engine, comprising its state,\n   mailbox cluster, and an address book of known engines.</li>\n</ul>\n<ul>\n<li>Guard and GuardStrategy: Mechanisms to evaluate whether certain\n  conditions are met (<code>Guard</code>) and strategies to handle multiple satisfied\n  guards (<code>GuardStrategy</code>).</li>\n</ul>\n<ul>\n<li>Effect: The possible outcomes or actions an engine can perform, such as\n  sending messages, updating state, spawning new engines, chaining effects, or\n  scheduling future actions.</li>\n</ul>\n<ul>\n<li>EngineBehaviour: A function defining how an engine responds to evaluated\n  guards and decides on an effect.</li>\n</ul>\n<ul>\n<li>Engine: The core representation of an engine, combining its status,\n  configuration, state, and behaviour.</li>\n</ul>\n<ul>\n<li>EngineMsg: Structure of messages exchanged between engines, including\n  sender and target identifiers, mailbox, communication pattern, message kind,\n  and the message content itself.</li>\n</ul>\n\n\n\n\n<ol>\n<li>\n<p>The constructors are very much like message tags in\n  the paper\n  <sup>6</sup>.\u00a0\u21a9</p>\n</li>\n<li>\n<p>These engines roughly correspond to the primeval actors of Clinger <sup>7</sup>.\u00a0\u21a9</p>\n</li>\n<li>\n<p>See <sup>6</sup> for the paradigmatic example.\u00a0\u21a9</p>\n</li>\n<li>\n<p>Yes, we can do fancy monads for effects, but that's for a future version.\u00a0\u21a9</p>\n</li>\n<li>\n<p>This is in analogy to Dijkstra's Guarded Command Language.\u00a0\u21a9</p>\n</li>\n<li>\n<p>Simon Fowler, Duncan Paul Attard, Franciszek Sowul, Simon J. Gay, and Phil Trinder. Special delivery: programming with mailbox types. Proceedings of the ACM on Programming Languages, 7(ICFP):78\u2013107, August 2023. URL: http://dx.doi.org/10.1145/3607832, doi:10.1145/3607832.\u00a0\u21a9\u21a9</p>\n</li>\n<li>\n<p>William Douglas Clinger. Foundations of Actor Semantics. PhD thesis, Massachusetts Institute of Technology (MIT), 1981. URL: https://dspace.mit.edu/handle/1721.1/6935.\u00a0\u21a9</p>\n</li>\n</ol>","tags":["work-in-progress","tutorial","engine"],"boost":2},{"location":"changelog.html","title":"Change Log","text":"","tags":["changelog"]},{"location":"changelog.html#v014","title":"v0.1.4","text":"<p>This release focuses on improving the prose, layout, and documentation structure. Key changes include:</p> <ul> <li>Reorganized node architecture documentation for better clarity</li> <li>Reorganized the navigation bar to be more consistent and easier to use</li> <li>Added a new tutorial: Anomian</li> <li>Several prose improvements on engines, e.g: Mempool Worker Engine,   Executor Engine, Shard Engine</li> <li>CSS changes to improve the layout and readability of the website, like   better separation for headers and footers that improve, for example, the   readability of message interfaces</li> <li>Updated Juvix type definitions to match latest standards</li> <li>Added new definitions for Prelude</li> <li>Improved template engine documentation for easier engine creation</li> </ul>","tags":["changelog"]},{"location":"changelog.html#features","title":"Features","text":"<ul> <li>System architecture<ul> <li>#334: Add deletion criterion to delete blobs immediately</li> </ul> </li> </ul>","tags":["changelog"]},{"location":"changelog.html#fixes","title":"Fixes","text":"<ul> <li>Repository maintenance and CI<ul> <li>#297: Fixes for issues seen in v0.1.3</li> <li>#306: Add data structures and interfaces used by RM</li> <li>#307: Prose improvements for commitment, decryption, and identity   management engines</li> <li>#308: The Little Anomian</li> <li>#309: Heindel has written up their two cents on the Anomian</li> <li>#310: Heindel/Anomian review v0.2 some ideas for improvements</li> <li>#311: Prose improvements for   Mempool Worker Engine, Executor Engine, and Shard Engine's descriptions.</li> <li>#312: nix flake update to   support Juvix v0.6.9</li> <li>#313: Revision of all message interfaces but not for networking's   engines</li> <li>#314: Add more fixes for message interfaces for consistency</li> <li>#315: Add a few corrections to the Anomian doc</li> <li>#320: Update Network subsystems' engine to comply standard</li> <li>#328: Move string comparison to prelude</li> <li>#331: RM type fixes</li> <li>#332: Improve layout, documentation structure, navigation and   readability with indexes, tags and descriptions</li> <li>#336: some changes, proposed as a result of specs overall review   (revamped)</li> <li>#337: Heindel/anthony/prose 3 suggestions for fixing the markdown</li> </ul> </li> <li>System architecture<ul> <li>#334: Add missing deletion criterion to delete blobs after the   transaction</li> </ul> </li> <li>Juvix types and updates<ul> <li>#298: Update juvix v0.6.9</li> <li>#302: Prelude improvements</li> <li>#305: Add most of the types for RM specs</li> <li>#321: Add Runnable trait and make ordering engines parametric</li> <li>#329: Refactor type definitions to use simplified syntax</li> </ul> </li> </ul>","tags":["changelog"]},{"location":"changelog.html#v013","title":"v0.1.3","text":"<p>The major change in this release is the gas payment system introduced in #286, and the description of messages in the Networking subsystem introduced in #294.</p>","tags":["changelog"]},{"location":"changelog.html#fixes_1","title":"Fixes","text":"<ul> <li>Node architecture<ul> <li>#290: Fix english   description for guards to match the Juvix types in Engine Behaviour.</li> </ul> </li> <li>Repository maintenance and CI<ul> <li>#288: Improve primitive interfaces diagrams. Use LR mermaid option.</li> </ul> </li> <li>System architecture<ul> <li>#293: Fix formatting issues,   typos, warnings, and broken links related to Proving   system definitions.</li> </ul> </li> </ul> <ul> <li>Tutorial and documentation<ul> <li>#280: Guides: Add hard and soft   requirements for writing pages in the Anoma Specification.</li> <li>#284: Add minimal version of   the template (not visible in the website) and related refactors.</li> </ul> </li> </ul>","tags":["changelog"]},{"location":"changelog.html#changes","title":"Changes","text":"<ul> <li>Repository maintenance and CI<ul> <li>#296: Add next/prev buttons,   fix footer, change font, add buttons to view/edit source code, and links to   the GitHub repository.</li> </ul> </li> <li>Juvix types and updates<ul> <li>#294: Bump up Juvix version   to v0.6.9 , reorder <code>MailboxID</code> alias, and update Stdlib to v0.9.0</li> </ul> </li> </ul>","tags":["changelog"]},{"location":"changelog.html#features_1","title":"Features","text":"<ul> <li>Python-related changes<ul> <li>#291: Add new command tool   <code>nspec</code> to create new engines based on the minimal version of the Template     Engine files.</li> </ul> </li> <li>Repository maintenance and CI<ul> <li>#286: Incorporated gas   payments description. Additionally, made several improvements such as   switching to wiki-style links, adding icons, clarifying proof inputs, fixing   rendering issues, and various other enhancements.</li> </ul> </li> <li>Tutorial and documentation<ul> <li>#292: Move template/template_minimum engines to   docs/tutorial/engines folder. Update imports accordingly.</li> </ul> </li> </ul>","tags":["changelog"]},{"location":"changelog.html#v012","title":"v0.1.2","text":"<p>Progress on translating the old specification to the new Juvix codebase, fixing typechecking errors. Removed unsupported documents from the codebase. Building specs no longer requires Juvix by default - use <code>PROCESS_JUVIX=true</code> flag with mkdocs to process Juvix Markdown.</p>","tags":["changelog"]},{"location":"changelog.html#fixes_2","title":"Fixes","text":"<ul> <li>Node architecture<ul> <li>#235: Revisit Decryption Engine. Changes to the messages,   environment, and behaviour types to conform the recent template changes.</li> <li>#236: Revisit Encryption Engine and Reads Engine. These are   bundled since they rely on eachother's messages. Changes to the messages, environment, and behavior types to conform   to the recent template changes</li> <li>#262: Updatewriting conventions, Fix template   behaviour diagrams and update Mkdocs Na</li> <li>#263: To the Hardware     Subsystem section, add Local Key Value Store Engine , Logging     Engine and Local Time Series Storage Engine, Wall Clock Engine.</li> <li>#268: Add to Anoma Configuration section, the Identity Subsystem.</li> <li>#269: Fix type error due to   not making configs when spawning engines in Identity Management Engine.</li> <li>#273: Replace X Machine by X   Subsystem in the Node Architecture section.</li> </ul> </li> <li>Python-related changes<ul> <li>#271: update mkdocs juvix plugin v0.4.8</li> <li>#272: Update mkdocs juvix plugin v0.4.9</li> </ul> </li> <li>Repository maintenance and CI<ul> <li>#195: Optimize documentation build process and upgrade dependencies</li> <li>#262: Template fixes: diagrams, nav</li> <li>#266: Remove old   documentation and update table of contents: Remove basic-abstractions,   scope, applications, implementations, and several other files that were   decided not to be included in this version of the specification.</li> </ul> </li> <li>Tutorial and documentation<ul> <li>#257: Add description of our   Git workflow and new integration   branches strategy.</li> <li>#265: Rename <code>TemplateCfg</code>   to <code>TemplateLocalCfg</code>, add <code>TemplateCfg</code> similar to <code>TemplateEnv</code>, apply   the same to <code>Ticker</code>.</li> <li>#274: Update engine writing   conventions: #update-the-table-of-contents   and Table of Contents.</li> </ul> </li> <li>Juvix types and updates<ul> <li>#267: Fix all the type   checking errors in engine definitions.</li> </ul> </li> </ul>","tags":["changelog"]},{"location":"changelog.html#v011","title":"v0.1.1","text":"<p>Major revision of the engine definitions, the template, and the ticker engine.</p>","tags":["changelog"]},{"location":"changelog.html#features_2","title":"Features","text":"<ul> <li>Repository maintenance and CI<ul> <li>#217: Update template engine   files to be more consistent, use backticks for Juvix terms/types in   headlines, uncollapsed sections for type constructors arguments in template   engine files, and auxiliary sections of Juvix code are always collapsed.</li> </ul> </li> </ul>","tags":["changelog"]},{"location":"changelog.html#fixes_3","title":"Fixes","text":"<ul> <li>Node architecture<ul> <li>#219: Revisit Commitment Engine. Changes to the messages, environment, and behaviour types to conform the recent template changes.</li> <li>#253: Integration PR that   combines multiple engine-related changes: Engines: Use <code>ByteString</code> in   crypto types #242, Engines:   ByteString type definition #255,   Engines: <code>EngineMsg</code> revision #241,   EngineID: make <code>EngineName</code> compulsory #256, Engines: Engine type revision #244,  <code>EngineMsg</code>: add type param #258, Engines: add <code>GuardEval</code> and <code>ActionExec</code> #260, and Engines: Behaviour template revision #226.</li> <li>#256: Make <code>EngineName</code>   compulsory in <code>EngineID</code>.</li> </ul> </li> <li>Repository maintenance and CI<ul> <li>#218: Rename <code>EngineMessage</code>    type to <code>EngineMsg</code> and <code>mkEngineMessage</code> to <code>mkEngineMsg</code>.</li> <li>#220: Fix the deployment of    the latest version by deploying the website if the branch name is <code>main</code> or    matches the semver pattern, and add information about the version and the    commit hash to the title for reference.</li> <li>#222: Remove SML codebase as   not used any more and any other reference in the markdown files</li> <li>#225: Fix navigation table    for the identity component</li> <li>#227: Update Juvix version in Nix flake due to breaking changes, and   also the input packages while at it.</li> <li>#250: Update policy on Juvix typechecking. The whole codebase in a   PR should typecheck before merging</li> </ul> </li> <li>Tutorial and documentation<ul> <li>#257: Refactor the Git strategy: introduce integration PRs for   better overview of complex changes</li> </ul> </li> <li>Juvix types and updates<ul> <li>#221: Update the prelude to   incorporate the latest changes in the <code>Stdlib</code>, including the addition of   applicative and monad traits, and the integration of the <code>containers</code> library.   This update also includes changes to data type definitions, with the <code>@</code>   syntax now used for declaration, creation, and matching on records, and other   removals like <code>: Type</code> for implicit arguments and function-style declarations.</li> <li>#226: Update Template &amp; Ticker Behaviour according to the engine &amp; message type changes. The examples have been improved with better clarity. The documentation now uses headlines instead of collapsible boxes and definition lists instead of tables. A new diagram template has been added that illustrates conditions and effects of actions.</li> <li>#241: <code>EngineMsg</code>-related changes: rename <code>MessageID</code> to <code>EngineMsgID</code>, add <code>getEngineMsgFrom(Timestamped)Trigger</code>, and rename <code>getMessageFrom(Timestamped)Trigger</code> to <code>getMsgFrom(Timestamped)Trigger</code>.</li> <li>#242: Use <code>ByteString</code> in crypto types.</li> <li>#244: Major refactoring of   engine-related types. The <code>Engine</code> type now includes a <code>cfg</code> field of type   <code>EngineConfig</code> containing static configuration (engine name and local node   ID). For consistency, <code>EngineEnvironment</code> has been renamed to <code>EngineEnv</code>. The   <code>EngineBehaviour</code> type has undergone several changes: the conflict solver has   been removed (to be replaced by new mechanism in   #246), precomputation results are   now passed directly as action arguments, and the <code>action</code> field has been   replaced with action labels defined by label type.</li> <li>#249: Remove <code>name</code> field in Engine instances due to PR 242</li> <li>#255: Make ByteString <code>String</code> instead of <code>Nat</code></li> <li>#258: Engine-related changes: add type parameter to parameterized the type of message and rename <code>EngineConfig</code> to <code>EngineCfg</code></li> <li>#260: Revise engine behaviour type: add <code>GuardEval (Seq)</code> and <code>ActionExec (First &amp; Any)</code>, <code>EngineCfg</code>: add <code>getEngineIDFromEngineCfg</code>. Partially addresses #246.</li> </ul> </li> </ul>","tags":["changelog"]},{"location":"changelog.html#v010","title":"v0.1.0","text":"<p>This is the first release of Anoma's Spec project, following the semantic-versioning scheme. This version includes all the changes from the creation of this repository. From here on, we will keep a changelog of all the changes that are made to the project per version, with better documentation and descriptions of the changes.</p>","tags":["changelog"]},{"location":"changelog.html#breaking-changes","title":"Breaking changes","text":"<ul> <li>Node architecture<ul> <li>#179: Reorganize node architecture   documentation structure</li> <li>#192: Port identity engines to v2 template</li> </ul> </li> <li>System architecture<ul> <li>#210: Fix engine message, environment and   behavior layout</li> </ul> </li> <li>Repository maintenance and CI<ul> <li>#29: Remove unused libraries</li> <li>#30: Remove juvix hook in pro of mkdos Juvix   plugin</li> <li>#53: Setup: require only python 3.9</li> <li>#60: Restructure for v2</li> <li>#64: Change KV Storage Deletion Documentation</li> <li>#65: Delete Compute and Randomness Engines</li> <li>#69: Remove outdates files from arch1 and fix   formatting</li> <li>#104: Refactor scope, basic types, and   application architecture sections</li> <li>#115: Refactor file and folder names: add   snake_case convention</li> </ul> </li> </ul>","tags":["changelog"]},{"location":"changelog.html#bug-fixes","title":"Bug fixes","text":"<ul> <li>Repository maintenance and CI<ul> <li>#4: Fix mike</li> <li>#9: Add batch of fixes</li> <li>#10: Fix Index: quick links and remove empty types   pages</li> <li>#18: Fix TODO, add todos.py script, and more   formatting issues</li> <li>#19: Remove todos on deploy, fix wikilinks warnings</li> <li>#21: Fix whitespaces</li> <li>#22: Fix indexes generation with macros and optimize   caching</li> <li>#24: Fix minors</li> <li>#25: CI fixes</li> <li>#74: Fix broken links in navigation bar and a few   pages</li> <li>#77: Fix CI: deploy website by PRs against main, v1,   and v2</li> <li>#78: Fix: CI doesnt trigger on edits</li> <li>#91: Fix default views and deploys in the CI</li> <li>#96: Fix navigation bar and more broken links due #60</li> <li>#101: Fix typos and small improve wording</li> <li>#105: Fix warnings messages due to recent refactors</li> <li>#122: Fix support for Juvix Markdown snippets</li> <li>#123: Fix merging conflicts chris-update-basic-types</li> <li>#124: Fix tutorial nav structure and broken links in   the footer</li> <li>#132: Fix minor issues with directories and filenames</li> </ul> </li> </ul>","tags":["changelog"]},{"location":"changelog.html#features_3","title":"Features","text":"<ul> <li>Application documentation<ul> <li>#198: Add transparent RM implementation documentation</li> </ul> </li> <li>Python-related changes<ul> <li>#133: Add support for multi-line wiki-style links</li> </ul> </li> <li>Repository maintenance and CI<ul> <li>#2: Add better support for WikiLinks and other goodies</li> <li>#3: Update README and run pre-commit</li> <li>#5: Add Ubuntu dependencies to the CI</li> <li>#6: Use site_url for link generation</li> <li>#7: Add new hook for images</li> <li>#8: Add lightboxes to images, fix local image loading</li> <li>#11: Improve link resolution for urls outside nav</li> <li>#14: Add Last updated time to the footer and other   fixes</li> <li>#15: Add a more explicit MathJax config</li> <li>#17: Revised macros configuration</li> <li>#20: Refactor hooks</li> <li>#23: Add previews for PRs</li> <li>#27: Fix url indexes and improve PR previews</li> <li>#28: Add tutorial basic instructions</li> <li>#31: Translate Haskell snippets to Juvix and fix typos</li> <li>#51: Configuration Engine</li> <li>#52: Add nix flake</li> <li>#56: Add page on dynamic code loading</li> <li>#58: Homogeneous consensus for V2</li> <li>#59: Readme: tighten up install instructions</li> <li>#61: Updates kudos spec</li> <li>#63: Counter example</li> <li>#68: Add New Engine Specifications from Anoma Elixir   Database</li> <li>#75: Add proof-of-stake example</li> <li>#80: Re-introduced full execution machine for V2</li> <li>#81: Add BibTeX entries and fix configuration</li> <li>#84: Add templates for defining engine systems</li> <li>#92: Add global table of contents</li> <li>#95: Continue v2 updates</li> <li>#97: Add git branching strategy</li> <li>#98: Add citation instructions and restructure markdown   tutorials</li> <li>#99: Delete previews for closed PRs on gh-pages branch</li> <li>#100: Split CI workflows: deploy, pull-request, clean-   ups</li> <li>#103: Additional reorganization &amp; updates</li> <li>#117: Tweaks to message types in basics</li> <li>#120: Refactor tutorial organization and add a few   more on conventions</li> <li>#121: Improve look&amp;feel, organized nav, hide extra   links and move them to the footer</li> <li>#127: Update basic abstractions</li> <li>#131: Add RMv3 content</li> <li>#135: Show PR number in the site name</li> <li>#209: Add changelog management system</li> <li>#214: Add GitHub template for creating PRs</li> </ul> </li> <li>Tutorial and documentation<ul> <li>#134: Refactor tutorial for wiki-style links</li> </ul> </li> <li>Juvix types and updates<ul> <li>#128: Add new Juvix definitions from PR-84</li> <li>#130: Translate SML Identity definitions to Juvix</li> </ul> </li> </ul>","tags":["changelog"]},{"location":"everything.html","title":"Everything","text":"<pre><code><pre>module everything;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#prelude","title":"Prelude","text":"<pre><code><pre>import prelude;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#anomian","title":"Anomian","text":"<pre><code><pre>import anomian;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#system","title":"System","text":"<pre><code><pre>import arch.system.identity.identity;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#resource-machine","title":"Resource Machine","text":"<pre><code><pre>import arch.system.state.resource_machine.data_structures.transaction.transaction_with_payment;import arch.system.state.resource_machine.data_structures.transaction.transaction;import arch.system.state.resource_machine.data_structures.transaction.transaction_function;import arch.system.state.resource_machine.data_structures.transaction.delta_proof;import arch.system.state.resource_machine.data_structures.compliance_unit.compliance_proof;import arch.system.state.resource_machine.data_structures.compliance_unit.compliance_unit;import arch.system.state.resource_machine.data_structures.action.resource_logic_proof;import arch.system.state.resource_machine.data_structures.action.index;import arch.system.state.resource_machine.data_structures.resource.computable_components.resource_commitment;import arch.system.state.resource_machine.data_structures.resource.computable_components.kind;import arch.system.state.resource_machine.data_structures.resource.computable_components.nullifier;import arch.system.state.resource_machine.data_structures.resource.computable_components.delta;import arch.system.state.resource_machine.data_structures.resource.computable_components.introduction;import arch.system.state.resource_machine.data_structures.resource.index;import arch.system.state.resource_machine.primitive_interfaces.transaction_function_vm;import arch.system.state.resource_machine.primitive_interfaces.set;import arch.system.state.resource_machine.primitive_interfaces.nullifier_set;import arch.system.state.resource_machine.primitive_interfaces.map;import arch.system.state.resource_machine.primitive_interfaces.proving_system.proving_system_types;import arch.system.state.resource_machine.primitive_interfaces.proving_system.proving_system_delta;import arch.system.state.resource_machine.primitive_interfaces.fixed_size_type.fixed_size_type;import arch.system.state.resource_machine.primitive_interfaces.fixed_size_type.hash;import arch.system.state.resource_machine.primitive_interfaces.fixed_size_type.delta_hash;import arch.system.state.resource_machine.primitive_interfaces.fixed_size_type.arithmetic;import arch.system.state.resource_machine.primitive_interfaces.index;import arch.system.state.resource_machine.primitive_interfaces.ordered_set;import arch.system.state.resource_machine.primitive_interfaces.commitment_accumulator;import arch.system.state.resource_machine.notes.storage;import arch.system.state.resource_machine.notes.function_formats.transaction_function_format;import arch.system.state.resource_machine.notes.applications;import arch.system.state.resource_machine.notes.roles_and_requirements;import arch.system.state.resource_machine.notes.nockma;import arch.system.state.resource_machine.notes.nockma_runnable;import arch.system.state.resource_machine.notes.runnable;import arch.system.state.resource_machine.index;import arch.system.state.resource_machine.execution_flow.flow;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#types","title":"Types","text":"<pre><code><pre>import arch.node.types;import arch.node.types.basics;import arch.node.types.crypto;import arch.node.types.messages;import arch.node.types.identities;import arch.node.types.anoma_message;import arch.node.types.anoma_config;import arch.node.types.anoma_environment;import arch.node.types.anoma_engines;import arch.node.types.anoma;import arch.node.types.engine_environment;import arch.node.types.engine_behaviour;import arch.node.types.engine;import arch.node.types.transport;import arch.node.types.storage;import arch.node.types.router;import arch.node.integration.simulator;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#engines","title":"Engines","text":"","tags":["index","juvix"],"boost":2},{"location":"everything.html#identity","title":"Identity","text":"","tags":["index","juvix"],"boost":2},{"location":"everything.html#commitment","title":"Commitment","text":"<pre><code><pre>import arch.node.engines.commitment_messages;import arch.node.engines.commitment_config;import arch.node.engines.commitment_environment;import arch.node.engines.commitment_behaviour;import arch.node.engines.commitment;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#decryption","title":"Decryption","text":"<pre><code><pre>import arch.node.engines.decryption_messages;import arch.node.engines.decryption_config;import arch.node.engines.decryption_environment;import arch.node.engines.decryption_behaviour;import arch.node.engines.decryption;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#encryption","title":"Encryption","text":"<pre><code><pre>import arch.node.engines.encryption_messages;import arch.node.engines.encryption_config;import arch.node.engines.encryption_environment;import arch.node.engines.encryption_behaviour;import arch.node.engines.encryption;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#identity-management","title":"Identity Management","text":"<pre><code><pre>import arch.node.engines.identity_management_messages;import arch.node.engines.identity_management_config;import arch.node.engines.identity_management_environment;import arch.node.engines.identity_management_behaviour;import arch.node.engines.identity_management;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#naming","title":"Naming","text":"<pre><code><pre>import arch.node.engines.naming_messages;import arch.node.engines.naming_config;import arch.node.engines.naming_environment;import arch.node.engines.naming_behaviour;import arch.node.engines.naming;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#reads-for","title":"Reads For","text":"<pre><code><pre>import arch.node.engines.reads_for_messages;import arch.node.engines.reads_for_config;import arch.node.engines.reads_for_environment;import arch.node.engines.reads_for_behaviour;import arch.node.engines.reads_for;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#signs-for","title":"Signs For","text":"<pre><code><pre>import arch.node.engines.signs_for_messages;import arch.node.engines.signs_for_config;import arch.node.engines.signs_for_environment;import arch.node.engines.signs_for_behaviour;import arch.node.engines.signs_for;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#verification","title":"Verification","text":"<pre><code><pre>import arch.node.engines.verification_messages;import arch.node.engines.verification_config;import arch.node.engines.verification_environment;import arch.node.engines.verification_behaviour;import arch.node.engines.verification;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#hardware","title":"Hardware","text":"<pre><code><pre>import arch.node.engines.local_key_value_storage_messages;import arch.node.engines.local_key_value_storage_config;import arch.node.engines.local_key_value_storage_environment;import arch.node.engines.local_key_value_storage_behaviour;import arch.node.engines.local_key_value_storage;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#logging","title":"Logging","text":"<pre><code><pre>import arch.node.engines.logging_messages;import arch.node.engines.logging_config;import arch.node.engines.logging_environment;import arch.node.engines.logging_behaviour;import arch.node.engines.logging;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#wall-clock","title":"Wall Clock","text":"<pre><code><pre>import arch.node.engines.wall_clock_messages;import arch.node.engines.wall_clock_config;import arch.node.engines.wall_clock_environment;import arch.node.engines.wall_clock_behaviour;import arch.node.engines.wall_clock;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#local-time-series-storage","title":"Local Time Series Storage","text":"<pre><code><pre>import arch.node.engines.local_time_series_storage_messages;import arch.node.engines.local_time_series_storage_config;import arch.node.engines.local_time_series_storage_environment;import arch.node.engines.local_time_series_storage_behaviour;import arch.node.engines.local_time_series_storage;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#network-registry","title":"Network-Registry","text":"<pre><code><pre>import arch.node.engines.net_registry_messages;import arch.node.engines.net_registry_config;import arch.node.engines.net_registry_environment;import arch.node.engines.net_registry_behaviour;import arch.node.engines.net_registry;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#router","title":"Router","text":"<pre><code><pre>import arch.node.engines.router_messages;import arch.node.engines.router_config;import arch.node.engines.router_environment;import arch.node.engines.router_behaviour;import arch.node.engines.router;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#transport-protocol","title":"Transport Protocol","text":"<pre><code><pre>import arch.node.engines.transport_protocol_messages;import arch.node.engines.transport_protocol_config;import arch.node.engines.transport_protocol_environment;import arch.node.engines.transport_protocol_behaviour;import arch.node.engines.transport_protocol;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#transport-connection","title":"Transport Connection","text":"<pre><code><pre>import arch.node.engines.transport_connection_messages;import arch.node.engines.transport_connection_config;import arch.node.engines.transport_connection_environment;import arch.node.engines.transport_connection_behaviour;import arch.node.engines.transport_connection;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#pub-sub-topic","title":"Pub Sub Topic","text":"<pre><code><pre>import arch.node.engines.pub_sub_topic_messages;import arch.node.engines.pub_sub_topic_config;import arch.node.engines.pub_sub_topic_environment;import arch.node.engines.pub_sub_topic_behaviour;import arch.node.engines.pub_sub_topic;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#storage","title":"Storage","text":"<pre><code><pre>import arch.node.engines.storage_messages;import arch.node.engines.storage_config;import arch.node.engines.storage_environment;import arch.node.engines.storage_behaviour;import arch.node.engines.storage;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#mempool-worker","title":"Mempool Worker","text":"<pre><code><pre>import arch.node.engines.mempool_worker_messages;import arch.node.engines.mempool_worker_config;import arch.node.engines.mempool_worker_environment;import arch.node.engines.mempool_worker_behaviour;import arch.node.engines.mempool_worker;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#executor","title":"Executor","text":"<pre><code><pre>import arch.node.engines.executor_messages;import arch.node.engines.executor_config;import arch.node.engines.executor_environment;import arch.node.engines.executor_behaviour;import arch.node.engines.executor;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#shard","title":"Shard","text":"<pre><code><pre>import arch.node.engines.shard_messages;import arch.node.engines.shard_config;import arch.node.engines.shard_environment;import arch.node.engines.shard_behaviour;import arch.node.engines.shard;</pre></code></pre> <pre><code><pre></pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#misc","title":"Misc","text":"<pre><code><pre>import arch.node.engines.ticker_messages;import arch.node.engines.ticker_config;import arch.node.engines.ticker_environment;import arch.node.engines.ticker_behaviour;import arch.node.engines.ticker;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"everything.html#tutorial-templates","title":"Tutorial Templates","text":"<pre><code><pre>import tutorial.engines.template_messages;import tutorial.engines.template_config;import tutorial.engines.template_environment;import tutorial.engines.template_behaviour;import tutorial.engines.template;import tutorial.engines.template_minimum_messages;import tutorial.engines.template_minimum_config;import tutorial.engines.template_minimum_environment;import tutorial.engines.template_minimum_behaviour;import tutorial.engines.template_minimum;</pre></code></pre>","tags":["index","juvix"],"boost":2},{"location":"prelude.html","title":"List of basic types","text":"Juvix imports <p><pre><code><pre>module prelude;import Stdlib.Trait open public;import Stdlib.Trait.Ord open using {  Ordering;  module Ordering;  Equal;  isEqual;} public;import Stdlib.Trait.Eq open using {==} public;import Stdlib.Debug.Fail open using {failwith};import Stdlib.Data.Fixity open public;</pre></code></pre></p>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#juvix-specs-prelude","title":"Juvix Specs Prelude","text":"<p>The following are frequent and basic abstractions used in the Anoma specification.</p>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#combinators","title":"Combinators","text":"<pre><code><pre>import Stdlib.Function open using {  &lt;&lt;;  &gt;&gt;;  const;  id;  flip;  &lt;|;  |&gt;;  iterate;  &gt;-&gt;;} public;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#useful-type-classes","title":"Useful Type Classes","text":"","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#functor","title":"<code>Functor</code>","text":"<pre><code><pre>import Stdlib.Trait.Functor.Polymorphic as Functor;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#applicative","title":"<code>Applicative</code>","text":"<pre><code><pre>import Stdlib.Trait.Applicative as Applicative open using {Applicative} public;import Stdlib.Trait.Applicative as Applicative open using {Applicative} public;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#monad","title":"<code>Monad</code>","text":"<pre><code><pre>import Stdlib.Trait.Monad as Monad open using {Monad} public;import Stdlib.Trait.Monad as Monad open using {Monad} public;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#join","title":"<code>join</code>","text":"<p>Join function for monads</p> <pre><code><pre>join {M : Type -&gt; Type} {A} {{Monad M}} (mma : M (M A)) : M A := bind mma id;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#bifunctor","title":"<code>Bifunctor</code>","text":"<p>Two-argument functor</p> <pre><code><pre>traittype Bifunctor (F : Type -&gt; Type -&gt; Type) :=  mk@{    bimap {A B C D} : (A -&gt; C) -&gt; (B -&gt; D) -&gt; F A B -&gt; F C D;  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#associativeproduct","title":"<code>AssociativeProduct</code>","text":"<p>Product with associators</p> <pre><code><pre>traittype AssociativeProduct (F : Type -&gt; Type -&gt; Type) :=  mk@{    assocLeft {A B C} : F A (F B C) -&gt; F (F A B) C;    assocRight {A B C} : F (F A B) C -&gt; F A (F B C);  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#commutativeproduct","title":"<code>CommutativeProduct</code>","text":"<p>Product with commuters</p> <pre><code><pre>traittype CommutativeProduct (F : Type -&gt; Type -&gt; Type) :=  mk@{    swap {A B} : F A B -&gt; F B A;  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#unitalproduct","title":"<code>UnitalProduct</code>","text":"<p>Product with units</p> <pre><code><pre>traittype UnitalProduct U (F : Type -&gt; Type -&gt; Type) :=  mk@{    unitLeft {A} : A -&gt; F U A;    unUnitLeft {A} : F U A -&gt; A;    unitRight {A} : A -&gt; F A U;    unUnitRight {A} : F A U -&gt; A;  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#traversable","title":"<code>Traversable</code>","text":"<pre><code><pre>import Stdlib.Trait.Traversable as Traversable open using {  Traversable;  sequenceA;  traverse;} public;import Stdlib.Trait.Traversable as Traversable open using {  Traversable;  sequenceA;  traverse;} public;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#bool","title":"Bool","text":"<p>The type <code>Bool</code> represents boolean values (<code>true</code> or <code>false</code>). Used for logical operations and conditions.</p> <pre><code><pre>import Stdlib.Data.Bool as Bool open using {  Bool;  true;  false;  &amp;&amp;;  ||;  not;  or;  and;} public;</pre></code></pre> <p>For example,</p> <pre><code><pre>verdad : Bool := true;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#xor","title":"<code>xor</code>","text":"<p>Exlusive or</p> <pre><code><pre>xor (a b : Bool) : Bool :=  if     | a := not b    | else := b;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#nand","title":"<code>nand</code>","text":"<p>Not and</p> <pre><code><pre>nand (a b : Bool) : Bool := not (and a b);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#nor","title":"<code>nor</code>","text":"<p>Not or</p> <pre><code><pre>nor (a b : Bool) : Bool := not (or a b);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#nat","title":"<code>Nat</code>","text":"<p>The type <code>Nat</code> represents natural numbers (non-negative integers). Used for counting and indexing.</p> <pre><code><pre>import Stdlib.Data.Nat as Nat open using {  Nat;  zero;  suc;  natToString;  +;  sub;  *;  div;  mod;  ==;  &lt;=;  &gt;;  &lt;;  min;  max;} public;</pre></code></pre> <p>For example,</p> <pre><code><pre>ten : Nat := 10;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#pred","title":"<code>pred</code>","text":"<p>Predecessor function for natural numbers.</p> <pre><code><pre>pred (n : Nat) : Nat :=  case n of    | zero := zero    | suc k := k;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#booltonat","title":"<code>boolToNat</code>","text":"<p>Convert boolean to a Bool to a Nat in the standard way of circuits.</p> <pre><code><pre>boolToNat (b : Bool) : Nat :=  if     | b := 0    | else := 1;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#iszero","title":"<code>isZero</code>","text":"<p>Check if a natural number is zero.</p> <pre><code><pre>isZero (n : Nat) : Bool :=  case n of    | zero := true    | suc k := false;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#iseven-and-isodd","title":"<code>isEven</code> and <code>isOdd</code>","text":"<p>Parity checking functions</p> <pre><code><pre>isEven (n : Nat) : Bool := mod n 2 == 0;</pre></code></pre> <pre><code><pre>isOdd (n : Nat) : Bool := not (isEven n);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#foldnat","title":"<code>foldNat</code>","text":"<p>Fold over natural numbers.</p> <pre><code><pre>terminatingfoldNat {B} (z : B) (f : Nat -&gt; B -&gt; B) (n : Nat) : B :=  case n of    | zero := z    | suc k := f k (foldNat z f k);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#iter","title":"<code>iter</code>","text":"<p>Iteration of a function.</p> <pre><code><pre>iter {A} (f : A -&gt; A) (n : Nat) (x : A) : A := foldNat x \\{_ y := f y} n;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#exp","title":"<code>exp</code>","text":"<p>The exponentiation function.</p> <pre><code><pre>exp (base : Nat) (exponent : Nat) : Nat :=  iter \\{product := base * product} exponent 1;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#factorial","title":"<code>factorial</code>","text":"<p>The factorial function.</p> <pre><code><pre>factorial : Nat -&gt; Nat := foldNat 1 \\{k r := suc k * r};</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#gcd","title":"<code>gcd</code>","text":"<p>Greatest common divisor function.</p> <pre><code><pre>terminatinggcd (a b : Nat) : Nat :=  case b of    | zero := a    | suc _ := gcd b (mod a b);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#lcm","title":"<code>lcm</code>","text":"<p>Least common multiple function.</p> <pre><code><pre>lcm (a b : Nat) : Nat :=  case b of    | zero := zero    | suc _ :=      case a of        | zero := zero        | suc _ := div (a * b) (gcd a b);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#string","title":"<code>String</code>","text":"<p>The type <code>String</code> represents sequences of characters. Used for text and communication.</p> <pre><code><pre>import Stdlib.Data.String as String open using {String; ++str} public;</pre></code></pre> <p>For example,</p> <pre><code><pre>hello : String := \"Hello, World!\";</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#comparison-instance-for-string","title":"Comparison instance for <code>String</code>","text":"<pre><code><pre>stringCmp (s1 s2 : String) : Ordering :=  if     | s1 == s2 := Ordering.Equal    | else := Ordering.GreaterThan;instanceStringOrd : Ord String :=  Ord.mk@{    compare := stringCmp;  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#bytestring","title":"<code>ByteString</code>","text":"<pre><code><pre>ByteString : Type := String;</pre></code></pre> <p>A basic type for representing binary data.</p> <pre><code><pre>emptyByteString : ByteString := \"\";</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#unit","title":"<code>Unit</code>","text":"<p>The type <code>Unit</code> represents a type with a single value. Often used when a function does not return any meaningful value.</p> <pre><code><pre>import Stdlib.Data.Unit as Unit open using {Unit; unit} public;</pre></code></pre> <p>For example,</p> <pre><code><pre>unitValue : Unit := unit;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#trivial","title":"<code>trivial</code>","text":"<p>Unique function to the unit. Universal property of terminal object.</p> <pre><code><pre>trivial {A} : A -&gt; Unit := const unit;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#empty","title":"<code>Empty</code>","text":"<p>The type <code>Empty</code> represents a type with a single value. Often used when a function does not return any meaningful value.</p> <pre><code><pre>axiom Empty : Type;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#explode","title":"<code>explode</code>","text":"<p>Unique function from empty. Universal property of initial object.</p> <pre><code><pre>axiom explode {A} : Empty -&gt; A;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#pair-a-b","title":"<code>Pair A B</code>","text":"<p>The type <code>Pair A B</code> represents a tuple containing two elements of types <code>A</code> and <code>B</code>. Useful for grouping related values together.</p> <pre><code><pre>import Stdlib.Data.Pair as Pair;open Pair using {Pair} public;open Pair using {,};import Stdlib.Data.Pair as Pair open using {ordProductI; eqProductI} public;</pre></code></pre> <pre><code><pre>import Stdlib.Data.Fixity open;syntax alias mkPair := ,;</pre></code></pre> <p>For example,</p> <pre><code><pre>pair : Pair Nat Bool := mkPair 42 true;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#fst-and-snd","title":"<code>fst</code> and <code>snd</code>","text":"<p>Projections</p> <pre><code><pre>fst {A B} : Pair A B -&gt; A  | (mkPair a _) := a;</pre></code></pre> <pre><code><pre>snd {A B} : Pair A B -&gt; B  | (mkPair _ b) := b;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#paircommutativeproduct","title":"<code>PairCommutativeProduct</code>","text":"<p>Swap components</p> <pre><code><pre>instancePairCommutativeProduct : CommutativeProduct Pair :=  CommutativeProduct.mk@{    swap := \\{p := mkPair (snd p) (fst p)};  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#pairassociativeproduct","title":"<code>PairAssociativeProduct</code>","text":"<p>Pair associations</p> <pre><code><pre>instancePairAssociativeProduct : AssociativeProduct Pair :=  AssociativeProduct.mk@{    assocLeft :=      \\{p :=        let          pbc := snd p;        in mkPair (mkPair (fst p) (fst pbc)) (snd pbc)};    assocRight :=      \\{p :=        let          pab := fst p;        in mkPair (fst pab) (mkPair (snd pab) (snd p))};  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#pairunitalproduct","title":"<code>PairUnitalProduct</code>","text":"<p>Unit maps for pairs and units</p> <pre><code><pre>instancePairUnitalProduct : UnitalProduct Unit Pair :=  UnitalProduct.mk@{    unitLeft := \\{a := mkPair unit a};    unUnitLeft := snd;    unitRight := \\{a := mkPair a unit};    unUnitRight := \\{{A} := fst};  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#pairbifunctor","title":"<code>PairBifunctor</code>","text":"<p>Map functions over pairs</p> <pre><code><pre>instancePairBifunctor : Bifunctor Pair :=  Bifunctor.mk@{    bimap := \\{f g p := mkPair (f (fst p)) (g (snd p))};  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#fork","title":"<code>fork</code>","text":"<p>Universal property of pairs</p> <pre><code><pre>fork {A B C} (f : C -&gt; A) (g : C -&gt; B) (c : C) : Pair A B := mkPair (f c) (g c);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#result-a-b","title":"<code>Result A B</code>","text":"<p>The <code>Result A B</code> type represents either a success with a value of <code>ok x</code> with <code>x</code> of type <code>A</code> or an error with value <code>error e</code> with <code>e</code> of type <code>B</code>.</p> <pre><code><pre>import Stdlib.Data.Result.Base as Result;open Result using {Result; ok; error} public;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#either-a-b","title":"<code>Either A B</code>","text":"<p>The type <code>Either A B</code>, or sum type of <code>A</code> and <code>B</code>, represents a value of type <code>A</code> or <code>B</code>. It is equivalent to <code>Result A B</code>, however, the meaning of the values is different. There is no such thing as an error or success value in the <code>Either</code> type, instead the values are either <code>left a</code> of type <code>A</code> or <code>right b</code> of type <code>B</code>.</p> <pre><code><pre>syntax alias Either := Result;syntax alias left := error;syntax alias right := ok;</pre></code></pre> <p>For example,</p> <pre><code><pre>thisString : Either String Nat := left \"Error!\";thisNumber : Either String Nat := right 42;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#isleft-and-isright","title":"<code>isLeft</code> and <code>isRight</code>","text":"<p>Check components of either.</p> <pre><code><pre>isLeft {A B} (e : Either A B) : Bool :=  case e of    | left _ := true    | right _ := false;</pre></code></pre> <pre><code><pre>isRight {A B} (e : Either A B) : Bool :=  case e of    | left _ := false    | right _ := true;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#fromleft","title":"<code>fromLeft</code>","text":"<p>Get left element (with default)</p> <pre><code><pre>fromLeft {A B} (e : Either A B) (d : A) : A :=  case e of    | left x := x    | right _ := d;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#fromright","title":"<code>fromRight</code>","text":"<p>Get right element (with default)</p> <pre><code><pre>fromRight {A B} (e : Either A B) (d : B) : B :=  case e of    | left _ := d    | right x := x;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#eithercommutativeproduct","title":"<code>EitherCommutativeProduct</code>","text":"<p>Swap elements</p> <pre><code><pre>swapEither {A B} (e : Either A B) : Either B A :=  case e of    | left x := right x    | right x := left x;</pre></code></pre> <pre><code><pre>instanceEitherCommutativeProduct : CommutativeProduct Either :=  CommutativeProduct.mk@{    swap := swapEither;  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#eitherbifunctor","title":"<code>EitherBifunctor</code>","text":"<p>Map onto elements of either</p> <pre><code><pre>eitherBimap {A B C D} (f : A -&gt; C) (g : B -&gt; D) (e : Either A B) : Either C D :=  case e of    | left a := left (f a)    | right b := right (g b);</pre></code></pre> <pre><code>instance\nEitherBifunctor : Bifunctor Either :=\n  Bifunctor.mk@{\n    bimap := eitherBimap\n  };\n</code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#eitherunitalproduct","title":"<code>EitherUnitalProduct</code>","text":"<p>Unit maps for Either and Empty</p>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#ununitlefteither","title":"<code>unUnitLeftEither</code>","text":"<pre><code><pre>unUnitLeftEither {A} (e : Either Empty A) : A :=  case e of    | left x := explode x    | right x := x;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#ununitrighteither","title":"<code>unUnitRightEither</code>","text":"<pre><code><pre>unUnitRightEither {A} (e : Either A Empty) : A :=  case e of    | left x := x    | right x := explode x;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#eitherunitalproduct_1","title":"<code>EitherUnitalProduct</code>","text":"<p>Unit maps for Either and Empty</p> <pre><code>instance\nEitherUnitalProduct : UnitalProduct Empty Either :=\n  UnitalProduct.mk@{\n    unitLeft := right;\n    unUnitLeft := unUnitLeftEither;\n    unitRight := \\{{A} := left};\n    unUnitRight := unUnitRightEither;\n  };\n</code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#fuse","title":"<code>fuse</code>","text":"<p>Universal property of coproduct</p> <pre><code><pre>fuse {A B C} (f : A -&gt; C) (g : B -&gt; C) (e : Either A B) : C :=  case e of    | left x := f x    | right x := g x;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#eitherassociativeproduct","title":"<code>EitherAssociativeProduct</code>","text":"<p>Association functions for either</p>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#assoclefteither","title":"<code>assocLeftEither</code>","text":"<pre><code><pre>assocLeftEither {A B C} (e : Either A (Either B C)) : Either (Either A B) C :=  case e of    | left x := left (left x)    | right ebc :=      case ebc of        | left y := left (right y)        | right z := right z;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#assocrighteither","title":"<code>assocRightEither</code>","text":"<pre><code><pre>assocRightEither {A B C} (e : Either (Either A B) C) : Either A (Either B C) :=  case e of    | left eab :=      case eab of {        | left x := left x        | right y := right (left y)      }    | right z := right (right z);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#eitherassociativeproduct_1","title":"<code>EitherAssociativeProduct</code>","text":"<pre><code>instance\nEitherAssociativeProduct : AssociativeProduct Either :=\n  AssociativeProduct.mk@{\n    assocLeft := assocLeftEither;\n    assocRight := assocRightEither;\n  };\n</code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#option-a","title":"<code>Option A</code>","text":"<p>The type <code>Option A</code> represents an optional value of type <code>A</code>. It can be either <code>Some A</code> (containing a value) or <code>None</code> (no value). This type is an alias for <code>Maybe A</code> from the standard library.</p> <pre><code><pre>import Stdlib.Data.Maybe as Maybe;open Maybe using {Maybe; just; nothing};</pre></code></pre> <pre><code><pre>syntax alias Option := Maybe;syntax alias some := just;syntax alias none := nothing;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#isnone","title":"<code>isNone</code>","text":"<p>Check if an optional value is <code>none</code>:</p> <pre><code><pre>isNone {A} (x : Option A) : Bool :=  case x of    | none := true    | some _ := false;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#issome","title":"<code>isSome</code>","text":"<p>Check if an optional value is <code>some</code>:</p> <pre><code><pre>isSome {A} (x : Option A) : Bool := not (isNone x);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#fromoption","title":"<code>fromOption</code>","text":"<p>Extract the value from an <code>Option</code> term:</p> <pre><code><pre>fromOption {A} (x : Option A) (default : A) : A :=  case x of    | none := default    | some x := x;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#option","title":"<code>option</code>","text":"<p>Map over option with default</p> <pre><code><pre>option {A B} (o : Option A) (default : B) (f : A -&gt; B) : B :=  case o of    | none := default    | some x := f x;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#filteroption","title":"<code>filterOption</code>","text":"<p>Filter option according to predicate</p> <pre><code><pre>filterOption {A} (p : A -&gt; Bool) (opt : Option A) : Option A :=  case opt of    | none := none    | some x :=      if         | p x := some x        | else := none;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#list-a","title":"<code>List A</code>","text":"<p>The type <code>List A</code> represents a sequence of elements of type <code>A</code>. Used for collections and ordered data.</p> <pre><code><pre>import Stdlib.Data.List as List open using {  List;  nil;  ::;  isElement;  head;  tail;  length;  take;  drop;  ++;  reverse;  any;  all;  zip;} public;</pre></code></pre> <p>For example,</p> <pre><code><pre>numbers : List Nat := 1 :: 2 :: 3 :: nil;niceNumbers : List Nat := [1; 2; 3];</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#findindex","title":"<code>findIndex</code>","text":"<p>Get the first index of an element satisfying a predicate if such an index exists and none, otherwise.</p> <pre><code><pre>findIndex {A} (predicate : A -&gt; Bool) : List A -&gt; Option Nat  | nil := none  | (x :: xs) :=    if       | predicate x := some zero      | else :=        case findIndex predicate xs of          | none := none          | some i := some (suc i);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#last","title":"<code>last</code>","text":"<p>Get last element of a list</p> <pre><code><pre>last {A} (lst : List A) (default : A) : A := head default (reverse lst);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#most","title":"<code>most</code>","text":"<p>Get list with last element dropped</p> <pre><code><pre>most {A} (lst : List A) : List A := tail (reverse lst);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#snoc","title":"<code>snoc</code>","text":"<p>Prepend element to a list</p> <pre><code><pre>snoc {A} (xs : List A) (x : A) : List A := xs ++ [x];</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#uncons","title":"<code>uncons</code>","text":"<p>Split one layer of list</p> <pre><code><pre>uncons {A} : List A -&gt; Option (Pair A (List A))  | nil := none  | (x :: xs) := some (mkPair x xs);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#unsnoc","title":"<code>unsnoc</code>","text":"<p>Split one layer of list from the end</p> <pre><code><pre>unsnoc {A} : List A -&gt; Option (Pair (List A) A)  | nil := none  | (x :: xs) := some (mkPair (most (x :: xs)) (last xs x));</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#unfold","title":"<code>unfold</code>","text":"<p>Unfold a list, layerwise</p> <pre><code><pre>terminatingunfold {A B} (step : B -&gt; Option (Pair A B)) (seed : B) : List A :=  case step seed of    | none := nil    | some (x, seed') := x :: unfold step seed';</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#unzip","title":"<code>unzip</code>","text":"<p>Unzip a list of pairs into two lists</p> <pre><code><pre>terminatingunzip {A B} (xs : List (Pair A B)) : Pair (List A) (List B) :=  case xs of    | nil := mkPair nil nil    | p :: ps :=      let        unzipped := unzip ps;      in mkPair (fst p :: fst unzipped) (snd p :: snd unzipped);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#partitioneither","title":"<code>partitionEither</code>","text":"<p>Partition a list</p> <pre><code><pre>partitionEither {A B} (es : List (Either A B)) : Pair (List A) (List B) :=  foldr    \\{e acc :=      case e of        | left a := mkPair (a :: fst acc) (snd acc)        | right b := mkPair (fst acc) (b :: snd acc)}    (mkPair nil nil)    es;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#partitioneitherwith","title":"<code>partitionEitherWith</code>","text":"<pre><code><pre>partitionEitherWith  {A B C} (f : C -&gt; Either A B) (es : List C) : Pair (List A) (List B) :=  partitionEither (map f es);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#catoptions","title":"<code>catOptions</code>","text":"<p>Collapse list of options</p> <pre><code><pre>catOptions {A} : List (Option A) -&gt; List A :=  foldr    \\{opt acc :=      case opt of        | none := acc        | some x := x :: acc}    nil;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#maximumby","title":"<code>maximumBy</code>","text":"<p>Get the maximal element of a list.</p> <pre><code><pre>maximumBy {A B} {{Ord B}} (f : A -&gt; B) (lst : List A) : Option A :=  let    maxHelper :=      \\{curr acc :=        case acc of          | none := some curr          | some maxVal :=            if               | f curr &gt; f maxVal := some curr              | else := some maxVal};  in foldr maxHelper none lst;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#minimumby","title":"<code>minimumBy</code>","text":"<p>Get the minimal element of a list.</p> <pre><code><pre>minimalBy {A B} {{Ord B}} (f : A -&gt; B) (lst : List A) : Option A :=  let    minHelper :=      \\{curr acc :=        case acc of          | none := some curr          | some minVal :=            if               | f curr &lt; f minVal := some curr              | else := some minVal};  in foldr minHelper none lst;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#chunksof","title":"<code>chunksOf</code>","text":"<p>Splits a list into chunks of size <code>n</code>. The last chunk may be smaller than <code>n</code> if the length of the list is not divisible by <code>n</code>.</p> <p>Example:</p> <ul> <li>chunksOf 2 [1;2;3;4;5] = [[1;2]; [3;4]; [5]]</li> </ul> <pre><code><pre>terminatingchunksOf {A} : (chunkSize : Nat) -&gt; (list : List A) -&gt; List (List A)  | zero _ := nil  | _ nil := nil  | n xs := take n xs :: chunksOf n (drop n xs);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#sliding","title":"<code>sliding</code>","text":"<p>Returns all contiguous sublists of size <code>n</code>. If <code>n</code> is larger than the list length, returns empty list. If <code>n</code> is zero, returns empty list.</p> <p>Example: - sliding 2 [1;2;3;4] = [[1;2]; [2;3]; [3;4]]</p> <pre><code><pre>sliding {A} : (windowSize : Nat) -&gt; (list : List A) -&gt; List (List A)  | zero _ := nil  | n xs :=    let      len : Nat := length xs;      terminating      go : List A -&gt; List (List A)        | nil := nil        | ys :=          if             | length ys &lt; n := nil            | else := take n ys :: go (tail ys);    in if       | n &gt; len := nil      | else := go xs;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#span","title":"<code>span</code>","text":"<p>Takes a predicate and a list, and returns a tuple where:</p> <ul> <li>First element is the longest prefix of the list that satisfies the predicate</li> <li>Second element is the remainder of the list</li> </ul> <pre><code><pre>span {A} (p : A -&gt; Bool) : List A -&gt; Pair (List A) (List A)  | nil := mkPair nil nil  | (x :: xs) :=    if       | p x :=        let          (ys1, ys2) := span p xs;        in mkPair (x :: ys1) ys2      | else := mkPair nil (x :: xs);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#groupby-and-group","title":"<code>groupBy</code> and <code>group</code>","text":"<p>Groups consecutive elements in a list that satisfy a given equality predicate.</p> <p>Example:</p> <ul> <li>groupBy (==) [1;1;2;2;2;3;1;1] = [[1;1];[2;2;2];[3];[1;1]]</li> </ul> <pre><code><pre>terminatinggroupBy {A} (eq : A -&gt; A -&gt; Bool) : List A -&gt; List (List A)  | nil := nil  | (x :: xs) := case span (eq x) xs of ys1, ys2 := (x :: ys1) :: groupBy eq ys2;</pre></code></pre> <pre><code><pre>group {A} {{Eq A}} : List A -&gt; List (List A) := groupBy (==);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#nubby","title":"<code>nubBy</code>","text":"<p>Returns a list with duplicates removed according to the given equivalence function, keeping the first occurrence of each element. Unlike regular ;nub;, this function allows specifying a custom equality predicate.</p> <p>Examples:</p> <ul> <li>nubBy ({x y := mod x 3 == mod y 3}) [1;2;3;4;5;6] = [1;2;3]</li> <li>nub [1;1;2;2;3;3] = [1;2;3]</li> </ul> <pre><code><pre>nubBy {A} (eq : A -&gt; A -&gt; Bool) : List A -&gt; List A :=  let    elemBy (x : A) : List A -&gt; Bool      | nil := false      | (y :: ys) := eq x y || elemBy x ys;    go : List A -&gt; List A -&gt; List A      | acc nil := reverse acc      | acc (x :: xs) :=        if           | elemBy x acc := go acc xs          | else := go (x :: acc) xs;  in go nil;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#nub","title":"<code>nub</code>","text":"<pre><code><pre>nub {A} {{Eq A}} : List A -&gt; List A := nubBy (==);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#powerlists","title":"<code>powerlists</code>","text":"<p>Generate all possible sublists of a list. Each element can either be included or not.</p> <pre><code><pre>powerlists {A} : List A -&gt; List (List A)  | nil := nil :: nil  | (x :: xs) :=    let      rest : List (List A) := powerlists xs;      withX : List (List A) := map ((::) x) rest;    in rest ++ withX;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#set-a","title":"<code>Set A</code>","text":"<p>The type <code>Set A</code> represents a collection of unique elements of type <code>A</code>. Used for sets of values.</p> <pre><code><pre>import Stdlib.Data.Set as Set open using {  Set;  module Set;  difference;  union;  insert;  eqSetI;  ordSetI;  isSubset;} public;</pre></code></pre> <p>For example,</p> <pre><code><pre>uniqueNumbers : Set Nat := Set.fromList [1; 2; 2; 2; 3];</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#setmap","title":"<code>setMap</code>","text":"<pre><code><pre>setMap {A B} {{Ord B}} (f : A -&gt; B) (set : Set A) : Set B :=  Set.fromList (map f (Set.toList set));</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#setjoin","title":"<code>setJoin</code>","text":"<p>Collapse a set of sets into a set</p> <pre><code><pre>setJoin {A} {{Ord A}} (sets : Set (Set A)) : Set A :=  for (acc := Set.empty) (innerSet in sets) {    Set.union acc innerSet  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#disjointunion","title":"<code>disjointUnion</code>","text":"<pre><code><pre>--- Computes the disjoint union of two ;Set;s.disjointUnion {T} {{Ord T}} (s1 s2 : Set T) : Result (Set T) (Set T) :=  case Set.intersection s1 s2 of    | Set.empty := ok (Set.union s1 s2)    | s := error s;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#symmetricdifference","title":"<code>symmetricDifference</code>","text":"<p>Caclulate the symmetric difference of two sets.</p> <pre><code><pre>symmetricDifference {A} {{Ord A}} (s1 s2 : Set A) : Set A :=  let    in1not2 := difference s1 s2;    in2not1 := difference s2 s1;  in union in1not2 in2not1;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#cartesianproduct","title":"<code>cartesianProduct</code>","text":"<p>Generate the set of all cartesian products of a set.</p> <pre><code><pre>cartesianProduct  {A B} {{Ord A}} {{Ord B}} (s1 : Set A) (s2 : Set B) : Set (Pair A B) :=  let    pairsForElement (a : A) : Set (Pair A B) :=      for (acc := Set.empty) (b in s2) {        insert (mkPair a b) acc      };    pairSets : Set (Set (Pair A B)) :=      for (acc := Set.empty) (a in s1) {        insert (pairsForElement a) acc      };  in setJoin pairSets;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#powerset","title":"<code>powerset</code>","text":"<p>Generate the powerset (set of all subsets) of a set.</p> <pre><code><pre>powerset {A} {{Ord A}} (s : Set A) : Set (Set A) :=  let    elements := Set.toList s;    subLists := powerlists elements;  in Set.fromList (map Set.fromList subLists);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#ispropersubset","title":"<code>isProperSubset</code>","text":"<p>Checks if all elements of <code>set1</code> are in <code>set2</code>, and that the two sets are not the same.</p> <pre><code><pre>isProperSubset {A} {{Eq A}} {{Ord A}} (set1 set2 : Set A) : Bool :=  isSubset set1 set2 &amp;&amp; not (set1 == set2);</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#map-k-v","title":"<code>Map K V</code>","text":"<p>The type <code>Map K V</code> represents a collection of key-value pairs, sometimes called a dictionary, where keys are of type <code>K</code> and values are of type <code>V</code>.</p> <pre><code><pre>import Stdlib.Data.Map as Map public;open Map using {Map} public;</pre></code></pre> <p>For example,</p> <pre><code><pre>codeToken : Map Nat String := Map.fromList [1, \"BTC\"; 2, \"ETH\"; 3, \"ANM\"];</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#updatelookupwithkey","title":"<code>updateLookupWithKey</code>","text":"<p>Updates a value at a specific key using the update function and returns both the old value (if the key existed) and the updated map.</p> <pre><code><pre>updateLookupWithKey  {Key Value}  {{Ord Key}}  (updateFn : Key -&gt; Value -&gt; Option Value)  (k : Key)  (map : Map Key Value)  : Pair (Option Value) (Map Key Value) :=  let    oldValue : Option Value := Map.lookup k map;    newMap : Map Key Value :=      case oldValue of        | none := map        | some v :=          case updateFn k v of            | none := Map.delete k map            | some newV := Map.insert k newV map;  in oldValue, newMap;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#mapkeys","title":"<code>mapKeys</code>","text":"<p>Maps all keys in the Map to new keys using the provided function. If the mapping function is not injective (maps different keys to the same key), later entries in the map will overwrite earlier ones with the same new key.</p> <pre><code><pre>mapKeys  {Key1 Key2 Value}  {{Ord Key2}}  (fun : Key1 -&gt; Key2)  (map : Map Key1 Value)  : Map Key2 Value :=  Map.fromList    (for (acc := nil) (k, v in Map.toList map) {      (fun k, v) :: acc    });</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#restrictkeys","title":"<code>restrictKeys</code>","text":"<p>Restrict a map to only contain keys from the given set.</p> <pre><code><pre>restrictKeys  {Key Value}  {{Ord Key}}  (map : Map Key Value)  (validKeys : Set.Set Key)  : Map Key Value :=  for (acc := Map.empty) (k, v in map) {    if       | Set.isMember k validKeys := Map.insert k v acc      | else := acc  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#withoutkeys","title":"<code>withoutKeys</code>","text":"<p>Remove all entries from a map whose keys appear in the given set.</p> <pre><code><pre>withoutKeys  {Key Value}  {{Ord Key}}  (map : Map Key Value)  (invalidKeys : Set.Set Key)  : Map Key Value :=  for (acc := Map.empty) (k, v in map) {    if       | Set.isMember k invalidKeys := acc      | else := Map.insert k v acc  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#mappartition","title":"<code>mapPartition</code>","text":"<p>Split a map according to a predicate on values. Returns a pair of maps, (matching, non-matching).</p> <pre><code><pre>mapPartition  {Key Value}  {{Ord Key}}  (predicate : Value -&gt; Bool)  (map : Map Key Value)  : Pair (Map Key Value) (Map Key Value) :=  for (matching, nonMatching := Map.empty, Map.empty) (k, v in map) {    if       | predicate v := Map.insert k v matching, nonMatching      | else := matching, Map.insert k v nonMatching  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#partitionwithkey","title":"<code>partitionWithKey</code>","text":"<p>Split a map according to a predicate that can examine both key and value. Returns a pair of maps, (matching, non-matching).</p> <pre><code><pre>partitionWithKey  {Key Value}  {{Ord Key}}  (predicate : Key -&gt; Value -&gt; Bool)  (map : Map Key Value)  : Pair (Map Key Value) (Map Key Value) :=  for (matching, nonMatching := Map.empty, Map.empty) (k, v in map) {    if       | predicate k v := Map.insert k v matching, nonMatching      | else := matching, Map.insert k v nonMatching  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#mapoption","title":"<code>mapOption</code>","text":"<p>Apply a partial function to all values in the map, keeping only the entries where the function returns 'some'.</p> <pre><code><pre>mapOption  {Key Value1 Value2}  {{Ord Key}}  (f : Value1 -&gt; Option Value2)  (map : Map Key Value1)  : Map Key Value2 :=  for (acc := Map.empty) (k, v in map) {    case f v of      | none := acc      | some v' := Map.insert k v' acc  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#mapoptionwithkey","title":"<code>mapOptionWithKey</code>","text":"<p>Same as mapOption but allows the function to examine the key as well.</p> <pre><code><pre>mapOptionWithKey  {Key Value1 Value2}  {{Ord Key}}  (f : Key -&gt; Value1 -&gt; Option Value2)  (map : Map Key Value1)  : Map Key Value2 :=  for (acc := Map.empty) (k, v in map) {    case f k v of      | none := acc      | some v' := Map.insert k v' acc  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#mapeither","title":"<code>mapEither</code>","text":"<p>Apply a function that returns Either to all values in the map.</p> <pre><code><pre>mapEither  {Key Value Error Result}  {{Ord Key}}  (f : Value -&gt; Either Error Result)  (map : Map Key Value)  : Pair (Map Key Error) (Map Key Result) :=  for (lefts, rights := Map.empty, Map.empty) (k, v in map) {    case f v of      | error e := Map.insert k e lefts, rights      | ok r := lefts, Map.insert k r rights  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#mapeitherwithkey","title":"<code>mapEitherWithKey</code>","text":"<p>Same as mapEither but allows the function to examine the key as well.</p> <pre><code><pre>mapEitherWithKey  {Key Value Error Result}  {{Ord Key}}  (f : Key -&gt; Value -&gt; Either Error Result)  (map : Map Key Value)  : Pair (Map Key Error) (Map Key Result) :=  for (lefts, rights := Map.empty, Map.empty) (k, v in map) {    case f k v of      | error e := Map.insert k e lefts, rights      | ok r := lefts, Map.insert k r rights  };</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#undefined-values","title":"Undefined values","text":"<p>The term <code>undef</code> is a placeholder for unspecified values.</p>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#undef","title":"<code>undef</code>","text":"<pre><code><pre>axiom undef {A} : A;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#todo","title":"<code>TODO</code>","text":"<pre><code><pre>axiom TODO {A} : A;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"prelude.html#omap-k-v","title":"<code>OMap K V</code>","text":"<p>A simple map implementation represented as a function from keys to optional values. Note: Unlike <code>Stdlib.Data.Map</code>, this implementation does not require an <code>Ord</code> instance for the key type <code>K</code>. However, operations like <code>insert</code>, <code>delete</code>, and <code>fromList</code> require an <code>Eq</code> instance instead of an <code>Ord</code> instance.</p> <p>Meant for usage with <code>String</code> which does not have a working <code>Ord</code> instance but does have a working <code>Eq</code> instance.</p> <pre><code><pre>module OMap;  type OMap K V :=    mk@{      omap : K -&gt; Option V;    };    empty {K V} : OMap K V := OMap.mk \\{_ := none};    lookup {K V} (k : K) (m : OMap K V) : Option V := OMap.omap m k;    insert {K V} {{Eq K}} (k : K) (v : V) (m : OMap K V) : OMap K V :=    OMap.mk@{      omap :=        \\{k' :=          if             | k == k' := some v            | else := OMap.omap m k'};    };    delete {K V} {{Eq K}} (k : K) (m : OMap K V) : OMap K V :=    OMap.mk@{      omap :=        \\{k' :=          if             | k == k' := none            | else := OMap.omap m k'};    };    fromList {K V} {{Eq K}} (pairs : List (Pair K V)) : OMap K V :=    foldl \\{m (k, v) := insert k v m} empty pairs;    map {K V1 V2} (f : V1 -&gt; V2) (m : OMap K V1) : OMap K V2 :=    OMap.mk@{      omap := \\{k := Functor.map f (OMap.omap m k)};    };    mapOption {K V1 V2} (f : V1 -&gt; Option V2) (m : OMap K V1) : OMap K V2 :=    OMap.mk@{      omap :=        \\{k :=          case OMap.omap m k of            | none := none            | some v1 := f v1};    };    mapOptionWithKey    {K V1 V2} (f : K -&gt; V1 -&gt; Option V2) (m : OMap K V1) : OMap K V2 :=    OMap.mk@{      omap :=        \\{k :=          case OMap.omap m k of            | none := none            | some v1 := f k v1};    };    foldWithKeys    {K V Acc}    (f : K -&gt; V -&gt; Acc -&gt; Acc)    (init : Acc)    (keys : List K)    (m : OMap K V)    : Acc :=    foldl      \\{acc k :=        case OMap.omap m k of          | none := acc          | some v := f k v acc}      init      keys;    singleton {K V} {{Eq K}} (k : K) (v : V) : OMap K V :=    OMap.mk@{      omap :=        \\{k' :=          if             | k == k' := some v            | else := none};    };end;</pre></code></pre>","tags":["node-architecture","prelude","index"]},{"location":"arch/overview.html","title":"Anoma architecture","text":"<p>The Anoma architecture is the blueprint that defines the structure and behaviour of the components that make up the Anoma protocol. There are two high-level components: the Node architecture and the System architecture.</p>","tags":["index"],"boost":2},{"location":"arch/overview.html#node-architecture","title":"Node architecture","text":"<p>Details the internal composition of individual nodes:</p> <ul> <li>Engine-based modular architecture</li> <li>Inter-engine communication protocols</li> <li>Engine-specific behaviours and responsibilities</li> </ul>","tags":["index"],"boost":2},{"location":"arch/overview.html#system-architecture","title":"System architecture","text":"<p>Defines the high-level structure and behaviour of the distributed network, including:</p> <ul> <li>Distributed state management </li> <li>Core data types and data flow for Network operations</li> <li>System-wide properties and guarantees</li> </ul>","tags":["index"],"boost":2},{"location":"arch/integrations/adapters/index.html","title":"Protocol Adapters","text":"<p>A protocol adapter provides executor engine and shard engine functionality on a foreign blockchain protocol (adaptee) being independent of the Anoma protocol (target). In other words, it processes resource machine (RM) transactions and updates the RM state in correspondence with the adaptee's state changes.</p> <p>In order to support a protocol adapter, the adaptee protocol has to be programmable (i.e., support smart contracts).</p>","tags":["index","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/index.html#instances","title":"Instances","text":"<ul> <li>Ethereum Virtual Machine protocol adapter prototype (settlement-only)</li> </ul>","tags":["index","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html","title":"Ethereum Virtual Machine Protocol Adapter","text":"<p>The Ethereum Virtual Machine (EVM) protocol adapter is a smart contract written in Solidity that can be deployed to EVM compatible chains and roll-ups to connect them to the Anoma protocol. In general, the aim of the protocol adapter is to allow Anoma applications to be run on existing EVM-compatible chains (similar to how drivers allow an operating system to be run on different pieces of physical hardware).</p> <p>The current prototype is a settlement-only protocol adapter, i.e., it is only capable of processing fully-evaluated transaction functions and therefore does not implement the full executor engine behaviour.</p> <p>The implementation can be found in the <code>anoma/evm-protocol-adapter</code> GH repo.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#supported-networks","title":"Supported Networks","text":"<p>For the upcoming product version v0.3, only the Sepolia network will be supported.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#storage","title":"Storage","text":"<p>The protocol adapter contract inherits the following storage components as Solidity contracts:</p> <ul> <li>Commitment Accumulator</li> <li>Nullifier Set</li> <li>Blob Storage</li> </ul> <p>Only the protocol adapter can call non-view functions implemented by the storage components.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#commitment-accumulator","title":"Commitment Accumulator","text":"<p>The implementation uses a modified version of the OpenZeppelin <code>MerkleTree</code> v.5.2.0 that populates the binary tree from left to right and stores leaf indices in a hash table</p> <pre><code> mapping(bytes32 commitment =&gt; uint256 index) internal _indices;\n</code></pre> <p>allowing for commitment existence checks.</p> <p>In addition to the leaves, the modified implementation stores also the intermediary node hashes.</p> <p>Historical Merkle tree roots are stored in an OpenZeppelin <code>EnumerableSet</code> v5.2.0 allowing for existence checks.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#nullifier-set","title":"Nullifier Set","text":"<p>The implementation uses an OpenZeppelin <code>EnumerableSet</code> v5.2.0 to store nullifiers of consumed resources and allow for existence checks.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#blob-storage","title":"Blob Storage","text":"<p>The implementation uses a simple hash table to store blobs content-addressed.</p> <pre><code>mapping(bytes32 blobHash =&gt; bytes blob) internal _blobs;\n</code></pre> <p>From the list of deletion criteria, the current blob storage implementation supports the following two:</p> <pre><code>enum DeletionCriterion {\n    Immediately,\n    Never\n}\n</code></pre>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#hash-function","title":"Hash Function","text":"<p>For hashing, we compute the SHA-256 hash of the strictly ABI-encoded data. SHA-256 is available as a pre-compile in both the EVM and RISC ZERO zkVM.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#types-computable-components","title":"Types &amp; Computable Components","text":"<p>The RM-related type and computable component definitions in Solidity can be found in the <code>src/Types.sol</code> and <code>src/libs/ComputableComponents.sol</code> file, respectively.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#proving-systems","title":"Proving Systems","text":"<p>For resource logic proof and compliance proof generation, we use RISC ZERO's proving libraries.</p> <p>For proof verification, we use the RISC ZERO verifier contracts.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#resource-logic-proofs","title":"Resource Logic Proofs","text":"<p>For the current prototype and the only supported example application basic shielded Kudos , we use a specific circuit resulting in the loss of function privacy. This will be improved in future iterations.</p> <p>The associated types are defined in <code>proving/Compliance.sol</code>.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#compliance-proofs","title":"Compliance Proofs","text":"<p>Compliance units have a fixed size and contain references to one consumed and one created resource. For transaction with \\(n_\\text{consumed} \\neq n_\\text{created}\\), we expect padding resources (ephemeral resources with quantity 0) to be used.</p> <p>The associated types are defined in <code>proving/Compliance.sol</code>.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#delta-proofs","title":"Delta Proofs","text":"<p>The delta values are computed as 2D points (<code>uint256[2]</code>) on the <code>secp256k1</code> (K-256) curve and can be verified using ECDSA.</p> <p>The curve implementation is taken from Witnet's <code>eliptic-curve-solidity</code> library v0.2.1. This includes</p> <ul> <li>curve parameters</li> <li>curve addition (<code>ecAdd</code>)</li> <li>curve multiplication (<code>ecMul</code>)</li> </ul> <p>We use the zero delta public key derived from the private key <code>0</code>.</p> <p>As the message digest, we use the transaction hash that we've defined as follows (see <code>src/ProtocolAdapter.sol</code>):</p> <pre><code>function _transactionHash(bytes32[] memory tags) internal pure returns (bytes32 txHash) {\n    txHash = sha256(abi.encode(tags));\n}\n</code></pre> <p>For key recovery from the message digest and signature, we use OpenZeppelin's <code>ECDSA</code> library.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#evm-and-rm-state-correspondence","title":"EVM and RM State Correspondence","text":"<p>Taking a protocol adapter contract-centric viewpoint, we distinguish between two types of EVM state:</p> <ol> <li>Internal resource machine (RM) state being maintained inside the protocol adapter contract that is constituted by commitments, nullifiers, and blobs (see Storage).</li> <li>External state existing in smart contracts which are independent of the protocol adapter and its internal RM state.</li> </ol> <p>To interoperate with state in external contracts, the protocol adapter contract can, during transaction execution, make read and write calls to them and create and consume corresponding resources in its internal state reflecting the external state reads and writes.</p> <p>We achieve this by creating an indirection layer separating the protocol adapter from the external contract and resources that should be created and consumed in consequence. It consists of:</p> <ul> <li>A forwarder contract that<ul> <li>performs the actual state read or write calls into the target contract and returns eventual return data</li> <li>is custom-built for the target contract to call and permissionlessly deployed by 3rd parties</li> </ul> </li> </ul> <ul> <li>A calldata carrier resource (singleton) that<ul> <li>must be part of the action data structure containing the forwarder call instruction</li> <li>carries the inputs and outputs of the forwarded call</li> <li>expresses constraints over other resources that must be present and correspond to the external call</li> </ul> </li> </ul> <p>and allows the application to ensure the correspondence.</p> <p></p> <p>This works as follows:</p> <p>The protocol adapter accepts an optional <code>ForwarderCalldata</code> struct with the RM transaction object as part of the action object (see <code>src/Types.sol</code>):</p> <p><pre><code>struct ForwarderCalldata {\n    address untrustedForwarderContract;\n    bytes input;\n    bytes output;\n}\n</code></pre> The struct contains the address of the forwarder contract and <code>bytes input</code> data required for the intended state read or write calls on the target contract. It also contains the <code>bytes output</code> data that must match the data returned from the call.</p> <p>The protocol adapter ensures the <code>ForwarderCalldata</code> is part of the app data of the singleton calldata carrier resources that has a pre-determined kind being referenced in the forwarder contract.</p> <p>Note</p> <p>In the current, settlement-only protocol adapter design, the <code>output</code> data must already be known during proving time to be checked by resource logics and therefore is part of the <code>ForwarderCalldata</code> struct.</p> <p>The binding between the created calldata carrier resource and the called forwarder contract is ensured through the protocol adapter, which</p> <ol> <li>is the exclusive caller of the forwarder contract,</li> <li>ensures the presence of the created calldata carrier resource in correspondence to the call in the transaction,</li> <li>ensures that the forwarder contract call input data, call output data, and address is available in the app data entry of the created calldata carrier resource under its commitment,</li> <li>ensures that the kind of the created calldata carrier resource matches the kind being immutably referenced in the forwarder contract. This way, the calldata carrier resource logic and label are fully determined by the forwarder contract.</li> </ol> <p>Because the calldata carrier resource is a singleton, we know that the consumption of the old carrier is guaranteed through the transaction balance property.</p> <p>The created calldata carrier resource, in turn, can enforce creation or consumption of other resources corresponding to external state.</p> <p>In the following we describe the components in more detail.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#forwarder-contract","title":"Forwarder Contract","text":"<p>The forwarder contract</p> <ul> <li>is only callable by the protocol adapter</li> <li>has the address to the external contract it corresponds to</li> <li>forwards arbitrary calls to the external contract to read and write its state and changes the call context (i.e., <code>msg.sender</code> and <code>msg.data</code>)</li> <li>returns the call return data to the protocol adapter</li> </ul> <p>The resulting indirection has the purpose to keep custom logic such as</p> <ul> <li>callback logic (e.g., required by ERC-721 or ERC-1155 tokens)</li> <li>escrow logic (e.g., required to wrap owned state into resources)</li> <li>event logic (e.g., required for EVM indexers)</li> </ul> <p>separate and independent of the protocol adapter contract. This allows the forwarder contract to be custom-built and permissionlessly deployed by untrusted 3rd parties.</p> <p>Besides referencing the external contract by its address, the forwarder contract must also reference the resource kind of the associated calldata carrier resource that the protocol adapter will require be created. This allows the forwarder contract to also to enforce its own contract address to be part of the carrier resource label, which ensures that the correspondence between the forwarder and carrier resource is unique.</p> <p>Note</p> <p>The mutual dependency between - the calldata carrier resource label containing the forwarder contract address - the forwarder contract referencing the calldata carrier resource label</p> <p>can be established by deterministic deployment or post-deployment initialization of the forwarder contract.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#implementation-details","title":"Implementation Details","text":"<p>A minimal implementation is shown below:</p> <pre><code>contract ExampleForwarder is Ownable {\n  bytes32 internal immutable _CALLDATA_CARRIER_RESOURCE_KIND;\n  address internal immutable _CONTRACT;\n\n    constructor(address protocolAdapter, bytes32 calldataCarrierLogicRef) Ownable(protocolAdapter) {\n        _CALLDATA_CARRIER_RESOURCE_KIND = ComputableComponents.kind({\n            logicRef: calldataCarrierLogicRef,\n            labelRef: sha256(abi.encode(address(this)))\n        });\n    }\n\n  function forwardCall(bytes calldata input) external onlyOwner returns (bytes memory output) {\n      output = _CONTRACT.functionCall(input);\n  }\n\n  function calldataCarrierResourceKind() external view returns (bytes32 kind){\n      kind = _CALLDATA_CARRIER_RESOURCE_KIND;\n  }\n}\n</code></pre> <p>The required calldata is passed with the RM transaction object as part of the <code>Action</code> struct (see <code>src/Types.sol</code>).</p> <pre><code>struct ForwarderCalldata {\n    address untrustedForwarderContract;\n    bytes input;\n    bytes output;\n}\n</code></pre> <p>On transaction execution by the protocol adapter, the <code>ForwarderCalldata</code> struct is processed as follows:</p> <pre><code>function _executeForwarderCall(ForwarderCalldata calldata call) internal {\n    bytes memory output = IForwarder(call.untrustedForwarder).forwardCall(call.input);\n\n    if (keccak256(output) != keccak256(call.output)) {\n        revert ForwarderCallOutputMismatch({ expected: call.output, actual: output });\n    }\n}\n</code></pre> <p>The forwarder contract base class can be found in <code>src/ForwarderBase.sol</code>.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#calldata-carrier-resource","title":"Calldata Carrier Resource","text":"<p>A calldata carrier resource is a singleton (i.e., it has a unique kind ensuring that only a single instance with quantity 1 exists) being bound to an associated forwarder contract. By default, calldata carrier resources can be consumed by everyone (because their nullifier key commitment is derived from the universal identity).</p> <p>Note</p> <p>When the singleton calldata carrier resource is consumed in a transaction, subsequent transactions in the same block cannot consume it anymore. This effectively limits the current design to a single forwarder contract call per block (if the commitment of the latest, unspent calldata carrier resource is not known to the subsequent transaction ahead of time). This will be improved in upcoming protocol adapter versions.</p> <p>The calldata carrier resource object is passed to the protocol adapter together with the <code>ForwarderCalldata</code> struct (see <code>src/Types.sol</code>):</p> <pre><code>struct ResourceForwarderCalldataPair {\n    Resource carrier;\n    ForwarderCalldata call;\n}\n</code></pre> <p>This allows the protocol adapter to ensure that 1. the calldata carrier resource kind matches the one referenced in the forwarder contract and 2. a corresponding <code>action.appData</code> entry exists for the calldata carrier resource commitment tag that includes the <code>ForwarderCalldata</code>.</p> <p>The latter allows calldata carrier to inspect the <code>bytes input</code> and <code>bytes output</code> in the <code>ForwarderCalldata</code> and ensure the creation and consumption of resources corresponding to the external state reads or writes in the same action. Moreover, it can integrity check that its own label matches the <code>untrustedForwarderContract</code> address.</p> <p>This enables applications, such as wrapping ERC20 tokens into resources, which works by 1. transferring tokens from an owner into the forwarder contract via <code>transferFrom</code> and 2. initializing an owned resource with a corresponding quantity and the kind being specified in the forwarder contract.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#resources-corresponding-to-external-state","title":"Resources Corresponding to External State","text":"<p>Resources can correspond to EVM state and correspond to a specific calldata carrier resource kind being referenced in their label. Their initialization and finalization logic requires a created calldata carrier resource to be part of the same action.</p>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/integrations/adapters/evm.html#transaction-flow","title":"Transaction Flow","text":"<p>The protocol adapter transaction flow is shown below:</p> <p></p> <ol> <li>A user Alice calls a transaction function of a Juvix application to produce an ARM transaction object (here expressing an intent) as well as the instances and witnesses for the various proof types (resource logic, compliance, and delta proofs).</li> <li>The transaction function requests proofs from the RISC ZERO backend.</li> <li>The backend returns the proofs for the transaction object.</li> <li>The Anoma client sends the intent transaction object    to the intent pool.</li> <li>Another user Bob expresses his intent (see 1. to 3.).</li> <li>See 4.</li> <li>A solver Sally monitors the intent pool and sees the intent transactions by Alice and Bob and finds a match (using her algorithm).</li> <li>Sally composes the intent transactions and adds her own actions s.t. the transaction becomes balanced &amp; valid. She converts the transaction object into the format required by the EVM protocol adapter.</li> <li>Sally being connected to an Ethereum node makes an <code>eth_sendTransaction</code> call into the protocol adapter's <code>execute(Transaction tx)</code> function, which she signs with the private key of her account.</li> <li>The protocol adapter verifies the proofs from 3. by calling a RISC ZERO verifier contract deployed on the network.</li> <li>The protocol adapter makes an optional forwarder contract call by using the <code>ForwarderCalldata.input</code> data.</li> <li>The forwarder contract forwards the call to an external target contract to read from or write to its state.</li> <li>Optional return data is passed back to the forwarder contract.</li> <li>Return data (that can be empty) is passed to the protocol adapter contract allowing it to conduct integrity checks (by requiring the same data to be part of <code>action.appData</code>).</li> <li> <p>The protocol adapter updates its internal state by storing</p> <ul> <li>nullifiers of consumed resources</li> </ul> <ul> <li>commitments of created resources</li> </ul> <ul> <li>blobs with deletion criteria <code>!= DeletionCriterion.Immediately</code>.</li> </ul> </li> </ol>","tags":["work-in-progress","evm","resource-machine","protocol-adapter"],"boost":2},{"location":"arch/node/index.html","title":"Node Architecture","text":"<p>\u200b The node architecture specification concerns the state evolution of Anoma instances, broken into smaller steps<sup>1</sup> on the level of engines in nodes: - which messages are sent and received, - which computation is performed as reaction to message receptions, and - which local state changes ensue as a result.</p> <p>How message passing works is introduced in the Anomian, based on illustrative examples. On a higher level, we have a static pattern that connects two engine types with a message type if messages of this type can be sent between engine instances of the two types. An illustration of the pattern of communication between participants\u2014how they may send messages to each other\u2014is given in the following figure.</p> <ul> <li>Hardware Subsystem</li> </ul> <ul> <li>Identity Subsystem</li> </ul> <ul> <li>Ordering Subsystem</li> </ul> <ul> <li>Network Subsystem</li> </ul>","tags":["index"],"boost":2},{"location":"arch/node/index.html#message-flow","title":"Message Flow","text":"<ol> <li> <p>The technical term is the isolated turn principle <sup>2</sup>.\u00a0\u21a9</p> </li> <li> <p>Joeri De Koster, Tom Van Cutsem, and Wolfgang De Meuter. 43 years of actors: a taxonomy of actor models and their key properties. In Proceedings of the 6th International Workshop on Programming Based on Actors, Agents, and Decentralized Control, AGERE 2016, 31\u201340. New York, NY, USA, 2016. Association for Computing Machinery. URL: https://doi.org/10.1145/3001886.3001890, doi:10.1145/3001886.3001890.\u00a0\u21a9</p> </li> </ol>","tags":["index"],"boost":2},{"location":"arch/node/types.html","title":"Types","text":"<pre><code><pre>module arch.node.types;import arch.node.types.basics open public;import arch.node.types.crypto open public;import arch.node.types.identities open public;import arch.node.types.messages open public;import arch.node.types.anoma open public;import arch.node.types.engine open public;import arch.node.types.transport open public;import arch.node.types.storage open public;import arch.node.types.router open public;</pre></code></pre>","tags":["node-architecture","prelude","index"],"boost":2},{"location":"arch/node/concepts/engine.html","title":"The concept of an engine","text":"","tags":["node-architecture","concept","engine"]},{"location":"arch/node/concepts/engine.html#overview","title":"Overview","text":"<p>The model of Anoma revolves around the concept of an engine instance, an actor-like entity encapsulating all aspects of a computation process.</p> <p>An engine has the following components:</p> <ul> <li>a declaration of a message interface,</li> <li>a configuration,</li> <li>an environment, and</li> <li>a behaviour.</li> </ul> <p>Engines of the same type share the same behaviour. However, two engines of the same type may have different execution context, which in turn may lead to a different message reaction pattern (as \"observed\" by other engines).</p> <p>We often write engine, whenever the context makes clear that we refer to a term of an engine type (and not to the type itself), for the sake of brevity.</p>","tags":["node-architecture","concept","engine"]},{"location":"arch/node/concepts/engine.html#the-type-of-an-engine","title":"The type of an engine","text":"<p>The type of engines is defined in the engine module. We show the type definition here for convenience.</p> <pre><code><pre>type Engine C S B H A AM AC AE :=  mk@{    cfg : EngineCfg C;    env : EngineEnv S B H AM;    behaviour : EngineBehaviour C S B H A AM AC AE;  };</pre></code></pre>","tags":["node-architecture","concept","engine"]},{"location":"arch/node/concepts/engine.html#engine-components","title":"Engine components","text":"","tags":["node-architecture","concept","engine"]},{"location":"arch/node/concepts/engine.html#configuration","title":"Configuration","text":"<p>The configuration of an engine. The data of an engine configuration consists of:</p> <ul> <li>a parent engine,</li> <li>a name,</li> <li>a node ID, and</li> <li>a generic configuration type <code>c</code>.</li> </ul> <p>The complete definition of an engine configuration can be found in the Juvix engine configuration definition.</p>","tags":["node-architecture","concept","engine"]},{"location":"arch/node/concepts/engine.html#environment","title":"Environment","text":"<p>The execution context of an engine. The data of an engine environment consists of:</p> <ul> <li>a local state for storing engine-specific data,</li> <li>a mailbox cluster for receiving and sending messages,</li> <li>a set of acquaintances (other engines that can interact with this engine), and</li> <li>a set of active timers.</li> </ul> <p>The complete definition of an engine environment can be found in the Juvix engine environment definition.</p>","tags":["node-architecture","concept","engine"]},{"location":"arch/node/concepts/engine.html#behaviour","title":"Behaviour","text":"<p>The function that describes all possible ways in which engines react to messages. This includes:</p> <ul> <li>modifying their environment,</li> <li>sending messages to other engines,</li> <li>spawning new engine instances, and</li> <li>managing their active timers.</li> </ul> <p>The complete definition of an engine behaviour can be found in the Juvix engine behaviour definition.</p>","tags":["node-architecture","concept","engine"]},{"location":"arch/node/concepts/engine.html#useful-links","title":"Useful Links","text":"<ul> <li>Learn about the Anomian.</li> <li>Tutorials on Writing Engine Families for Anoma Spec writers.</li> <li>Example of an engine that ticks, the Ticker Engine.</li> </ul>","tags":["node-architecture","concept","engine"]},{"location":"arch/node/concepts/node.html","title":"The concept of a node","text":"","tags":["node-architecture","concept","node"]},{"location":"arch/node/concepts/node.html#overview","title":"Overview","text":"<p>A node is any Anoma-powered device. It can be a desktop computer, a smartphone, a server, or any other device that can run the Anoma software.</p> <p>What's a good abstract definition of a node?</p> <ul> <li>A node consists of ...</li> </ul>","tags":["node-architecture","concept","node"]},{"location":"arch/node/concepts/subsystem.html","title":"The concept of a subsystem","text":"<p>Subsystem</p> <p>A subsystem is a collection of engines that work together to achieve a   specific goal. The purpose of a subsystem is to provide a high-level interface   for the components that make up the node.</p>","tags":["node-architecture","concept","subsystem"]},{"location":"arch/node/concepts/subsystem.html#examples","title":"Examples","text":"<ul> <li>Hardware subsystem</li> <li>Identity subsystem</li> <li>Ordering subsystem</li> </ul>","tags":["node-architecture","concept","subsystem"]},{"location":"arch/node/engines/commitment.html","title":"Commitment Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.commitment;import prelude open;import arch.node.types.engine open;import arch.node.engines.commitment_config open public;import arch.node.engines.commitment_messages open public;import arch.node.engines.commitment_environment open public;import arch.node.engines.commitment_behaviour open public;import arch.node.types.anoma as Anoma open;open commitment_config_example;open commitment_environment_example;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","commitment","engine-definition"]},{"location":"arch/node/engines/commitment.html#commitment-engine","title":"Commitment Engine","text":"<p>The Commitment Engine provides digital signature services for a specific identity within Anoma. It acts as a secure mediator that can generate cryptographic signatures (see <code>Commitment</code>) when given data to sign (<code>Signable</code>), while keeping the signing keys secure and unexposed.</p> <p>When users request a signature through the engine (via a <code>MsgCommitmentRequest</code> message), it validates their authorisation and returns a cryptographic signature (via a <code>MsgCommitmentReply</code> message) that proves the identity authorised that specific data.</p> <p>In Anoma, Commitment Engines are only spawned by Identity Management Engines during identity creation or connection, and only users with the engine reference can request signatures. This controlled access ensures that signatures can only be generated by authorised parties while maintaining the security of the underlying signing keys.</p>","tags":["node-architecture","identity-subsystem","engine","commitment","engine-definition"]},{"location":"arch/node/engines/commitment.html#engine-components","title":"Engine components","text":"<ul> <li>Commitment Messages</li> <li>Commitment Configuration</li> <li>Commitment Environment</li> <li>Commitment Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","commitment","engine-definition"]},{"location":"arch/node/engines/commitment.html#the-type-for-a-commitment-engine","title":"The type for a commitment engine","text":"<pre><code><pre>CommitmentEngine : Type :=  Engine    CommitmentLocalCfg    CommitmentLocalState    CommitmentMailboxState    CommitmentTimerHandle    CommitmentActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","engine-definition"]},{"location":"arch/node/engines/commitment.html#example-of-a-commitment-engine","title":"Example of a commitment engine","text":"<pre><code><pre>exampleCommitmentEngine : CommitmentEngine :=  Engine.mk@{    cfg := commitmentCfg;    env := commitmentEnv;    behaviour := commitmentBehaviour;  };</pre></code></pre> <p>where <code>commitmentCfg</code> is defined as follows:</p> <pre><code><pre>commitmentCfg : CommitmentCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"commitment\";    cfg :=      CommitmentLocalCfg.mk@{        signer :=          Identity.Signer.mkSigner@{            sign := \\{_ x := Signature.Ed25519Signature \"0xabcd1234\"};          };        backend := Backend.LocalMemory;      };  };</pre></code></pre> <p><code>commitmentEnv</code> is defined as follows:</p> <pre><code><pre>axiom dummyExternalIdentity : ExternalIdentity;axiom dummyIDBackend : Backend;axiom dummySigningKey : SigningKey;commitmentEnv : CommitmentEnv :=  EngineEnv.mk@{    localState := unit;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>commitmentBehaviour</code> is defined as follows:</p> <pre><code><pre>commitmentBehaviour : CommitmentBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [commitGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","engine-definition"]},{"location":"arch/node/engines/commitment_behaviour.html","title":"Commitment Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.commitment_behaviour;import prelude open;import arch.system.identity.identity open;import arch.node.engines.commitment_messages open;import arch.node.engines.commitment_config open;import arch.node.engines.commitment_environment open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitment-behaviour","title":"Commitment Behaviour","text":"","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#overview","title":"Overview","text":"<p>The behaviour of the Commitment Engine defines how it processes incoming commitment requests and produces the corresponding commitments/signatures.</p>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitment-action-flowchart","title":"Commitment Action Flowchart","text":"","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitaction-flowchart","title":"<code>commitAction</code> flowchart","text":"<pre><code>flowchart TD\n    Start([Client Request]) --&gt; MsgReq[MsgCommitmentRequest&lt;br&gt;data: Signable]\n\n    subgraph Guard[\"commitGuard (Message Validation)\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br&gt;CommitmentRequest?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"commitAction (Processing)\"]\n        direction TB\n        Sign[Generate signature&lt;br&gt;using backend signer]\n        Sign --&gt; Success{Signature&lt;br&gt;Generated?}\n        Success --&gt;|Yes| GoodResp[Create Reply&lt;br&gt;with signature]\n        Success --&gt;|No| ErrResp[Create Reply&lt;br&gt;with error]\n    end\n\n    GoodResp --&gt; Reply[MsgCommitmentReply&lt;br&gt;commitment: Commitment&lt;br&gt;err: none]\n    ErrResp --&gt; ErrReply[MsgCommitmentReply&lt;br&gt;commitment: empty&lt;br&gt;err: Some error]\n\n    Reply --&gt; Client([Return to Client])\n    ErrReply --&gt; Client</code></pre> <code>commitAction</code> flowchart","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#explanation","title":"Explanation","text":"<ol> <li> <p>Initial Request</p> <ul> <li>A client sends a <code>MsgCommitmentRequest</code> containing data (<code>Signable</code>) that needs to be signed.</li> <li>The data must be in a format that can be signed by the backend (e.g., a byte string, transaction data, etc.).</li> </ul> </li> <li> <p>Guard Phase (<code>commitGuard</code>)</p> <ul> <li>Validates that the incoming message is a proper commitment request.</li> <li>Checks occur in the following order:<ul> <li>Verifies message type is <code>MsgCommitmentRequest</code>.</li> <li>If validation fails, request is rejected without entering the action phase.</li> <li>On success, passes control to <code>commitActionLabel</code>.</li> </ul> </li> </ul> </li> <li> <p>Action Phase (<code>commitAction</code>)</p> <ul> <li>Processes valid commitment requests through these steps:<ul> <li>Extracts the data to be signed from the request.</li> <li>Retrieves the signer from the engine's configuration.</li> <li>Attempts to generate a signature using the backend signer.</li> <li>Constructs an appropriate response message.</li> </ul> </li> </ul> </li> <li> <p>Reply Generation</p> <ul> <li>Successful Case<ul> <li>Creates <code>MsgCommitmentReply</code> with:<ul> <li><code>commitment</code>: The generated signature.</li> <li><code>err</code>: None.</li> </ul> </li> </ul> </li> <li>Error Case<ul> <li>In all error cases, returns <code>MsgCommitmentReply</code> with:<ul> <li><code>commitment</code>: Empty.</li> <li><code>err</code>: Some(error message).</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Reply Delivery</p> <ul> <li>Reply is sent back to the original requester.</li> <li>Uses mailbox 0 (default mailbox for responses).</li> </ul> </li> </ol>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#important-notes","title":"Important Notes:","text":"<ul> <li>The commitment engine is stateless - each request is handled independently.</li> </ul>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitmentactionargumentreplyto-replyto","title":"<code>CommitmentActionArgumentReplyTo ReplyTo</code>","text":"<pre><code><pre>type ReplyTo :=  mkReplyTo@{    whoAsked : Option EngineID;    mailbox : Option MailboxID;  };</pre></code></pre> <p>This action argument contains the address and mailbox ID of where the response message should be sent.</p> <code>whoAsked</code>: is the address of the engine that sent the message. <code>mailbox</code>: is the mailbox ID where the response message should be sent.","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitmentactionargument","title":"<code>CommitmentActionArgument</code>","text":"<pre><code><pre>type CommitmentActionArgument := | CommitmentActionArgumentReplyTo ReplyTo;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitmentactionarguments","title":"<code>CommitmentActionArguments</code>","text":"<pre><code><pre>CommitmentActionArguments : Type := List CommitmentActionArgument;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitmentaction","title":"<code>CommitmentAction</code>","text":"<p><pre><code><pre>CommitmentAction : Type :=  Action    CommitmentLocalCfg    CommitmentLocalState    CommitmentMailboxState    CommitmentTimerHandle    CommitmentActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitmentactioninput","title":"<code>CommitmentActionInput</code>","text":"<p><pre><code><pre>CommitmentActionInput : Type :=  ActionInput    CommitmentLocalCfg    CommitmentLocalState    CommitmentMailboxState    CommitmentTimerHandle    CommitmentActionArguments    Anoma.Msg;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitmentactioneffect","title":"<code>CommitmentActionEffect</code>","text":"<p><pre><code><pre>CommitmentActionEffect : Type :=  ActionEffect    CommitmentLocalState    CommitmentMailboxState    CommitmentTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitmentactionexec","title":"<code>CommitmentActionExec</code>","text":"<p><pre><code><pre>CommitmentActionExec : Type :=  ActionExec    CommitmentLocalCfg    CommitmentLocalState    CommitmentMailboxState    CommitmentTimerHandle    CommitmentActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitaction","title":"<code>commitAction</code>","text":"<p>Generate a commitment (signature) for the given request.</p> State update The state remains unchanged. Messages to be sent A <code>ReplyCommitment</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>commitAction (input : CommitmentActionInput) : Option CommitmentActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    tt := ActionInput.trigger input;  in case getEngineMsgFromTimestampedTrigger tt of       | some emsg :=         case emsg of {           | EngineMsg.mk@{               msg := Anoma.Msg.Commitment (CommitmentMsg.Request request);             } :=             let               signedData :=                 Signer.sign                   (CommitmentLocalCfg.signer (EngineCfg.cfg cfg))                   (CommitmentLocalCfg.backend (EngineCfg.cfg cfg))                   (RequestCommitment.data request);               responseMsg :=                 ReplyCommitment.mkReplyCommitment@{                   commitment := signedData;                   err := none;                 };             in some               ActionEffect.mk@{                 env := env;                 msgs :=                   [                     EngineMsg.mk@{                       sender := getEngineIDFromEngineCfg cfg;                       target := EngineMsg.sender emsg;                       mailbox := some 0;                       msg :=                         Anoma.Msg.Commitment (CommitmentMsg.Reply responseMsg);                     };                   ];                 timers := [];                 engines := [];               }           | _ := none         }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitactionlabel","title":"<code>commitActionLabel</code>","text":"<pre><code><pre>commitActionLabel : CommitmentActionExec := ActionExec.Seq [commitAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitmentguard","title":"<code>CommitmentGuard</code>","text":"<p> <pre><code><pre>CommitmentGuard : Type :=  Guard    CommitmentLocalCfg    CommitmentLocalState    CommitmentMailboxState    CommitmentTimerHandle    CommitmentActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitmentguardoutput","title":"<code>CommitmentGuardOutput</code>","text":"<p> <pre><code><pre>CommitmentGuardOutput : Type :=  GuardOutput    CommitmentLocalCfg    CommitmentLocalState    CommitmentMailboxState    CommitmentTimerHandle    CommitmentActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitmentguardeval","title":"<code>CommitmentGuardEval</code>","text":"<p> <pre><code><pre>CommitmentGuardEval : Type :=  GuardEval    CommitmentLocalCfg    CommitmentLocalState    CommitmentMailboxState    CommitmentTimerHandle    CommitmentActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitguard","title":"<code>commitGuard</code>","text":"Condition Message type is <code>MsgCommitmentRequest</code>. <pre><code><pre>commitGuard  (tt : TimestampedTrigger CommitmentTimerHandle Anoma.Msg)  (cfg : CommitmentCfg)  (env : CommitmentEnv)  : Option CommitmentGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some EngineMsg.mk@{             msg := Anoma.Msg.Commitment (CommitmentMsg.Request _);           } :=      some        GuardOutput.mk@{          action := commitActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#the-commitment-behaviour","title":"The Commitment behaviour","text":"","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#commitmentbehaviour","title":"<code>CommitmentBehaviour</code>","text":"<pre><code><pre>CommitmentBehaviour : Type :=  EngineBehaviour    CommitmentLocalCfg    CommitmentLocalState    CommitmentMailboxState    CommitmentTimerHandle    CommitmentActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>commitmentBehaviour : CommitmentBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [commitGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","behaviour"]},{"location":"arch/node/engines/commitment_config.html","title":"Commitment Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.commitment_config;import prelude open;import arch.node.engines.commitment_messages open;import arch.system.identity.identity as Identity;import arch.system.identity.identity as Identity;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","commitment","configuration"]},{"location":"arch/node/engines/commitment_config.html#commitment-configuration","title":"Commitment Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","commitment","configuration"]},{"location":"arch/node/engines/commitment_config.html#overview","title":"Overview","text":"<p>The commitment engine configuration contains static information for commitment engine instances, namely the signer and the backend.</p>","tags":["node-architecture","identity-subsystem","engine","commitment","configuration"]},{"location":"arch/node/engines/commitment_config.html#the-commitment-local-configuration","title":"The Commitment Local Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","commitment","configuration"]},{"location":"arch/node/engines/commitment_config.html#commitmentlocalcfg","title":"<code>CommitmentLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type CommitmentLocalCfg :=  mk@{    signer : Identity.Signer Backend Signable Commitment;    backend : Backend;  };</pre></code></pre> Arguments <code>signer</code>: The signer for the identity. <code>backend</code>: The backend to use for signing.","tags":["node-architecture","identity-subsystem","engine","commitment","configuration"]},{"location":"arch/node/engines/commitment_config.html#the-commitment-configuration","title":"The Commitment Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","commitment","configuration"]},{"location":"arch/node/engines/commitment_config.html#commitmentcfg","title":"<code>CommitmentCfg</code>","text":"<pre><code><pre>CommitmentCfg : Type := EngineCfg CommitmentLocalCfg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","configuration"]},{"location":"arch/node/engines/commitment_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>commitmentCfg : CommitmentCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"commitment\";    cfg :=      CommitmentLocalCfg.mk@{        signer :=          Identity.Signer.mkSigner@{            sign := \\{_ x := Signature.Ed25519Signature \"0xabcd1234\"};          };        backend := Backend.LocalMemory;      };  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","configuration"]},{"location":"arch/node/engines/commitment_environment.html","title":"Commitment Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.commitment_environment;import prelude open;import arch.node.engines.commitment_messages open;import arch.node.types.crypto open;import arch.node.types.engine_environment open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","commitment","environment"]},{"location":"arch/node/engines/commitment_environment.html#commitment-environment","title":"Commitment Environment","text":"","tags":["node-architecture","identity-subsystem","engine","commitment","environment"]},{"location":"arch/node/engines/commitment_environment.html#overview","title":"Overview","text":"<p>The Commitment Engine environment maintains the state necessary for generating commitments (signatures) for a specific identity. It includes the identity's signing capabilities and any necessary signing keys or handles.</p>","tags":["node-architecture","identity-subsystem","engine","commitment","environment"]},{"location":"arch/node/engines/commitment_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The Commitment Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","commitment","environment"]},{"location":"arch/node/engines/commitment_environment.html#commitmentmailboxstate","title":"<code>CommitmentMailboxState</code>","text":"<pre><code><pre>syntax alias CommitmentMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","environment"]},{"location":"arch/node/engines/commitment_environment.html#local-state","title":"Local state","text":"<p>The Commitment engine is statless.</p>","tags":["node-architecture","identity-subsystem","engine","commitment","environment"]},{"location":"arch/node/engines/commitment_environment.html#commitmentlocalstate","title":"<code>CommitmentLocalState</code>","text":"<pre><code><pre>syntax alias CommitmentLocalState := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","environment"]},{"location":"arch/node/engines/commitment_environment.html#timer-handle","title":"Timer Handle","text":"<p>The Commitment Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","commitment","environment"]},{"location":"arch/node/engines/commitment_environment.html#commitmenttimerhandle","title":"<code>CommitmentTimerHandle</code>","text":"<pre><code><pre>syntax alias CommitmentTimerHandle := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","environment"]},{"location":"arch/node/engines/commitment_environment.html#the-commitment-environment","title":"The Commitment Environment","text":"","tags":["node-architecture","identity-subsystem","engine","commitment","environment"]},{"location":"arch/node/engines/commitment_environment.html#commitmentenv","title":"<code>CommitmentEnv</code>","text":"<pre><code><pre>CommitmentEnv : Type :=  EngineEnv    CommitmentLocalState    CommitmentMailboxState    CommitmentTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","environment"]},{"location":"arch/node/engines/commitment_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>axiom dummyExternalIdentity : ExternalIdentity;axiom dummyIDBackend : Backend;axiom dummySigningKey : SigningKey;commitmentEnv : CommitmentEnv :=  EngineEnv.mk@{    localState := unit;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","environment"]},{"location":"arch/node/engines/commitment_messages.html","title":"Commitment Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.commitment_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","commitment","message-types"]},{"location":"arch/node/engines/commitment_messages.html#commitment-messages","title":"Commitment Messages","text":"","tags":["node-architecture","identity-subsystem","engine","commitment","message-types"]},{"location":"arch/node/engines/commitment_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type CommitmentMsg :=  | Request RequestCommitment  | Reply ReplyCommitment;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","message-types"]},{"location":"arch/node/engines/commitment_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","identity-subsystem","engine","commitment","message-types"]},{"location":"arch/node/engines/commitment_messages.html#request-sequence","title":"Request sequence","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant CE as Commitment Engine\n\n    C-&gt;&gt;CE: RequestCommitment(data)\n    Note over CE: Generate commitment using internal signer\n    CE--&gt;&gt;C: ReplyCommitment(commitment)</code></pre>  Sequence diagram for commitment generation.","tags":["node-architecture","identity-subsystem","engine","commitment","message-types"]},{"location":"arch/node/engines/commitment_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","identity-subsystem","engine","commitment","message-types"]},{"location":"arch/node/engines/commitment_messages.html#requestcommitment","title":"<code>RequestCommitment</code>","text":"<pre><code><pre>type RequestCommitment :=  mkRequestCommitment@{    data : Signable;  };</pre></code></pre> <p>A <code>RequestCommitment</code> instructs a commitment engine instance to produce a commitment (signature) over the provided data.</p> Arguments <code>data</code>: The data to sign.","tags":["node-architecture","identity-subsystem","engine","commitment","message-types"]},{"location":"arch/node/engines/commitment_messages.html#replycommitment","title":"<code>ReplyCommitment</code>","text":"<pre><code><pre>type ReplyCommitment :=  mkReplyCommitment@{    commitment : Commitment;    err : Option String;  };</pre></code></pre> <p>A <code>ReplyCommitment</code> contains the commitment (signature) generated by the commitment engine instance in response to a <code>RequestCommitment</code>.</p> Arguments <code>commitment</code>: The generated commitment (signature). <code>err</code>: An error message if commitment generation failed.","tags":["node-architecture","identity-subsystem","engine","commitment","message-types"]},{"location":"arch/node/engines/commitment_messages.html#commitmentmsg","title":"<code>CommitmentMsg</code>","text":"<pre><code><pre>type CommitmentMsg :=  | Request RequestCommitment  | Reply ReplyCommitment;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","commitment","message-types"]},{"location":"arch/node/engines/commitment_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Commitment Configuration</li> <li>Commitment Environment</li> <li>Commitment Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","commitment","message-types"]},{"location":"arch/node/engines/decryption.html","title":"Decryption Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.decryption;import prelude open;import arch.node.types.engine open;import arch.node.engines.decryption_config open public;import arch.node.engines.decryption_messages open public;import arch.node.engines.decryption_environment open public;import arch.node.engines.decryption_behaviour open public;import arch.node.types.anoma as Anoma open;open decryption_config_example;open decryption_environment_example;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","decryption","engine-definition"]},{"location":"arch/node/engines/decryption.html#decryption-engine","title":"Decryption Engine","text":"<p>The Decryption Engine serves as a secure decryption service for a specific identity within Anoma. It functions like a secure lockbox that can decrypt messages (ciphertext to plaintext) intended for its associated identity, while keeping the decryption keys secure and unexposed. This enables secure communication where only the intended recipient can read encrypted messages.</p> <p>When users submit encrypted data to the engine (via a <code>MsgDecryptionRequest</code> message), it validates their authorisation and returns the decrypted content (via a <code>MsgDecryptionReply</code> message) if the decryption is successful.</p> <p>In Anoma, Decryption Engines are only spawned by Identity Management Engines during identity creation or connection. Only users with the engine reference can request decryption. This ensures that encrypted data can only be decrypted by authorised parties while maintaining the security of the private decryption keys.</p>","tags":["node-architecture","identity-subsystem","engine","decryption","engine-definition"]},{"location":"arch/node/engines/decryption.html#engine-components","title":"Engine components","text":"<ul> <li>Decryption Messages</li> <li>Decryption Configuration</li> <li>Decryption Environment</li> <li>Decryption Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","decryption","engine-definition"]},{"location":"arch/node/engines/decryption.html#the-type-for-a-decryption-engine","title":"The type for a decryption engine","text":"<pre><code><pre>DecryptionEngine : Type :=  Engine    DecryptionLocalCfg    DecryptionLocalState    DecryptionMailboxState    DecryptionTimerHandle    DecryptionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","engine-definition"]},{"location":"arch/node/engines/decryption.html#example-of-a-decryption-engine","title":"Example of a decryption engine","text":"<pre><code><pre>exampleDecryptionEngine : DecryptionEngine :=  Engine.mk@{    cfg := decryptionCfg;    env := decryptionEnv;    behaviour := decryptionBehaviour;  };</pre></code></pre> <p>where <code>decryptionCfg</code> is defined as follows:</p> <pre><code><pre>decryptionCfg : DecryptionCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"decryption\";    cfg :=      DecryptionLocalCfg.mk@{        decryptor :=          Identity.Decryptor.mkDecryptor@{            decrypt := \\{_ x := some x};          };        backend := Backend.LocalMemory;      };  };</pre></code></pre> <p><code>decryptionEnv</code> is defined as follows:</p> <pre><code><pre>decryptionEnv : DecryptionEnv :=  EngineEnv.mk@{    localState := unit;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>decryptionBehaviour</code> is defined as follows:</p> <pre><code><pre>decryptionBehaviour : DecryptionBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [decryptGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","engine-definition"]},{"location":"arch/node/engines/decryption_behaviour.html","title":"Decryption Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.decryption_behaviour;import prelude open;import arch.node.types.messages open;import arch.system.identity.identity open;import arch.node.types.engine open;import arch.node.engines.decryption_config open;import arch.node.engines.decryption_environment open;import arch.node.engines.decryption_messages open;import arch.node.types.identities open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryption-behaviour","title":"Decryption Behaviour","text":"","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#overview","title":"Overview","text":"<p>The behavior of the Decryption Engine defines how it processes incoming decryption requests and produces the corresponding decrypted outputs.</p>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryption-action-flowchart","title":"Decryption Action Flowchart","text":"","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryptaction-flowchart","title":"<code>decryptAction</code> flowchart","text":"<pre><code>flowchart TD\n  Start([Client Request]) --&gt; MsgReq[MsgDecryptionRequest&lt;br/&gt;data: Ciphertext]\n\n  subgraph Guard[\"decryptGuard (Message Validation)\"]\n      MsgReq --&gt; ValidType{Is message type&lt;br/&gt;DecryptionRequest?}\n      ValidType --&gt;|No| Reject([Reject Request])\n      ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n  end\n\n  ActionEntry --&gt; Action\n\n  subgraph Action[\"decryptAction (Processing)\"]\n      direction TB\n      Decrypt[Attempt decryption&lt;br/&gt;using backend decryptor]\n      Decrypt --&gt; Success{Decryption&lt;br/&gt;Successful?}\n      Success --&gt;|Yes| GoodResp[Create Reply&lt;br/&gt;with plaintext]\n      Success --&gt;|No| ErrResp[Create Reply&lt;br/&gt;with error]\n  end\n\n  GoodResp --&gt; Reply[MsgDecryptionReply&lt;br/&gt;commitment: Plaintext&lt;br/&gt;err: none]\n  ErrResp --&gt; ErrReply[MsgDecryptionReply&lt;br/&gt;commitment: empty&lt;br/&gt;err: Some error]\n\n  Reply --&gt; Client([Return to Client])\n  ErrReply --&gt; Client\n\n  style Guard fill:#f0f7ff,stroke:#333,stroke-width:2px\n  style Action fill:#fff7f0,stroke:#333,stroke-width:2px</code></pre> <code>decryptAction</code> flowchart","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#explanation","title":"Explanation","text":"<ol> <li> <p>Initial Request</p> <ul> <li>A client sends a <code>MsgDecryptionRequest</code> containing encrypted data (<code>Ciphertext</code>).</li> <li>The ciphertext must be encrypted for the identity associated with this decryption engine.</li> <li>Any metadata needed for decryption should be included in the ciphertext structure.</li> </ul> </li> <li> <p>Guard Phase (<code>decryptGuard</code>)</p> <ul> <li>Validates incoming message structure and type.</li> <li>Validation steps:<ul> <li>Verifies message type is <code>MsgDecryptionRequest</code>.</li> <li>If validation fails, request is rejected immediately.</li> <li>On success, passes control to <code>decryptActionLabel</code>.</li> </ul> </li> </ul> </li> <li> <p>Action Phase (<code>decryptAction</code>)</p> <ul> <li>Processes valid decryption requests through these steps:<ul> <li>Extracts the ciphertext from the request.</li> <li>Retrieves the decryptor from the engine's configuration.</li> <li>Attempts to decrypt using the backend decryptor.</li> <li>Constructs appropriate response based on result.</li> </ul> </li> </ul> </li> <li> <p>Reply Generation</p> <ul> <li>Successful Case<ul> <li>Creates <code>MsgDecryptionReply</code> with:<ul> <li><code>data</code>: The decrypted plaintext.</li> <li><code>err</code>: None.</li> </ul> </li> </ul> </li> <li>Error Case<ul> <li>In all error cases, returns <code>MsgDecryptionReply</code> with:<ul> <li><code>data</code>: emptyByteString (zero-length byte string).</li> <li><code>err</code>: Some \"Decryption Failed\".</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Reply Delivery</p> <ul> <li>Reply is sent back to the original requester.</li> <li>Uses mailbox 0 (default mailbox for responses).</li> </ul> </li> </ol> <p>Note</p> <p>The commitment engine is stateless - each request is handled .</p>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#replyto","title":"<code>ReplyTo</code>","text":"<pre><code><pre>type ReplyTo :=  mkReplyTo@{    whoAsked : Option EngineID;    mailbox : Option MailboxID;  };</pre></code></pre> <p>This action argument contains the address and mailbox ID of where the response message should be sent.</p> Arguments <code>whoAsked</code>: is the address of the engine that sent the message. <code>mailbox</code>: is the mailbox ID where the response message should be sent.","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryptionactionargument","title":"<code>DecryptionActionArgument</code>","text":"<pre><code><pre>type DecryptionActionArgument := | DecryptionActionArgumentReplyTo ReplyTo;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryptionactionarguments","title":"<code>DecryptionActionArguments</code>","text":"<pre><code><pre>DecryptionActionArguments : Type := List DecryptionActionArgument;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryptionaction","title":"<code>DecryptionAction</code>","text":"<p><pre><code><pre>DecryptionAction : Type :=  Action    DecryptionLocalCfg    DecryptionLocalState    DecryptionMailboxState    DecryptionTimerHandle    DecryptionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryptionactioninput","title":"<code>DecryptionActionInput</code>","text":"<p><pre><code><pre>DecryptionActionInput : Type :=  ActionInput    DecryptionLocalCfg    DecryptionLocalState    DecryptionMailboxState    DecryptionTimerHandle    DecryptionActionArguments    Anoma.Msg;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryptionactioneffect","title":"<code>DecryptionActionEffect</code>","text":"<p><pre><code><pre>DecryptionActionEffect : Type :=  ActionEffect    DecryptionLocalState    DecryptionMailboxState    DecryptionTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryptionactionexec","title":"<code>DecryptionActionExec</code>","text":"<p><pre><code><pre>DecryptionActionExec : Type :=  ActionExec    DecryptionLocalCfg    DecryptionLocalState    DecryptionMailboxState    DecryptionTimerHandle    DecryptionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryptaction","title":"<code>decryptAction</code>","text":"<p>Process a decryption request.</p> State update The state remains unchanged. Messages to be sent A <code>ReplyDecryption</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>decryptAction (input : DecryptionActionInput) : Option DecryptionActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    tt := ActionInput.trigger input;  in case getEngineMsgFromTimestampedTrigger tt of       | some emsg :=         case EngineMsg.msg emsg of {           | Anoma.Msg.Decryption (DecryptionMsg.Request request) :=             let               decryptedData :=                 Decryptor.decrypt                   (DecryptionLocalCfg.decryptor (EngineCfg.cfg cfg))                   (DecryptionLocalCfg.backend (EngineCfg.cfg cfg))                   (RequestDecryption.data request);               responseMsg :=                 case decryptedData of                   | none :=                     ReplyDecryption.mkReplyDecryption@{                       data := emptyByteString;                       err := some \"Decryption Failed\";                     }                   | some plaintext :=                     ReplyDecryption.mkReplyDecryption@{                       data := plaintext;                       err := none;                     };             in some               ActionEffect.mk@{                 env := env;                 msgs :=                   [                     EngineMsg.mk@{                       sender := getEngineIDFromEngineCfg cfg;                       target := EngineMsg.sender emsg;                       mailbox := some 0;                       msg :=                         Anoma.Msg.Decryption (DecryptionMsg.Reply responseMsg);                     };                   ];                 timers := [];                 engines := [];               }           | _ := none         }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryptactionlabel","title":"<code>decryptActionLabel</code>","text":"<pre><code><pre>decryptActionLabel : DecryptionActionExec := ActionExec.Seq [decryptAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryptionguard","title":"<code>DecryptionGuard</code>","text":"<p> <pre><code><pre>DecryptionGuard : Type :=  Guard    DecryptionLocalCfg    DecryptionLocalState    DecryptionMailboxState    DecryptionTimerHandle    DecryptionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryptionguardoutput","title":"<code>DecryptionGuardOutput</code>","text":"<p> <pre><code><pre>DecryptionGuardOutput : Type :=  GuardOutput    DecryptionLocalCfg    DecryptionLocalState    DecryptionMailboxState    DecryptionTimerHandle    DecryptionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryptionguardeval","title":"<code>DecryptionGuardEval</code>","text":"<p> <pre><code><pre>DecryptionGuardEval : Type :=  GuardEval    DecryptionLocalCfg    DecryptionLocalState    DecryptionMailboxState    DecryptionTimerHandle    DecryptionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryptguard","title":"<code>decryptGuard</code>","text":"Condition Message type is <code>MsgDecryptionRequest</code>. <pre><code><pre>decryptGuard  (tt : TimestampedTrigger DecryptionTimerHandle Anoma.Msg)  (cfg : DecryptionCfg)  (env : DecryptionEnv)  : Option DecryptionGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some EngineMsg.mk@{             msg := Anoma.Msg.Decryption (DecryptionMsg.Request _);           } :=      some        GuardOutput.mk@{          action := decryptActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#the-decryption-behavior","title":"The Decryption Behavior","text":"","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#decryptionbehaviour","title":"<code>DecryptionBehaviour</code>","text":"<pre><code><pre>DecryptionBehaviour : Type :=  EngineBehaviour    DecryptionLocalCfg    DecryptionLocalState    DecryptionMailboxState    DecryptionTimerHandle    DecryptionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>decryptionBehaviour : DecryptionBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [decryptGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","behaviour"]},{"location":"arch/node/engines/decryption_config.html","title":"Decryption Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.decryption_config;import prelude open;import arch.node.engines.decryption_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.system.identity.identity as Identity;import arch.system.identity.identity as Identity;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","decryption","configuration"]},{"location":"arch/node/engines/decryption_config.html#decryption-configuration","title":"Decryption Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","decryption","configuration"]},{"location":"arch/node/engines/decryption_config.html#overview","title":"Overview","text":"<p>The decryption engine configuration contains static information for decryption engine instances.</p>","tags":["node-architecture","identity-subsystem","engine","decryption","configuration"]},{"location":"arch/node/engines/decryption_config.html#the-decryption-local-configuration","title":"The Decryption Local Configuration","text":"<p>The configuration of a Decryption Engine instance includes the identity's decryption capabilities.</p>","tags":["node-architecture","identity-subsystem","engine","decryption","configuration"]},{"location":"arch/node/engines/decryption_config.html#decryptionlocalcfg","title":"<code>DecryptionLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type DecryptionLocalCfg :=  mk@{    decryptor : Identity.Decryptor Backend Plaintext Ciphertext;    backend : Backend;  };</pre></code></pre> Arguments <code>decryptor</code>: The decryptor for the decrypting. <code>backend</code>: The backend to use for decryption.","tags":["node-architecture","identity-subsystem","engine","decryption","configuration"]},{"location":"arch/node/engines/decryption_config.html#the-decryption-configuration","title":"The Decryption Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","decryption","configuration"]},{"location":"arch/node/engines/decryption_config.html#decryptioncfg","title":"<code>DecryptionCfg</code>","text":"<pre><code><pre>DecryptionCfg : Type := EngineCfg DecryptionLocalCfg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","configuration"]},{"location":"arch/node/engines/decryption_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>decryptionCfg : DecryptionCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"decryption\";    cfg :=      DecryptionLocalCfg.mk@{        decryptor :=          Identity.Decryptor.mkDecryptor@{            decrypt := \\{_ x := some x};          };        backend := Backend.LocalMemory;      };  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","configuration"]},{"location":"arch/node/engines/decryption_environment.html","title":"Decryption Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.decryption_environment;import prelude open;import arch.node.engines.decryption_messages open;import arch.node.types.engine_environment open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.anoma_message as Anoma open;import arch.system.identity.identity open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","decryption","environment"]},{"location":"arch/node/engines/decryption_environment.html#decryption-environment","title":"Decryption Environment","text":"","tags":["node-architecture","identity-subsystem","engine","decryption","environment"]},{"location":"arch/node/engines/decryption_environment.html#overview","title":"Overview","text":"<p>Each Decryption Engine instance is associated with a specific identity and handles decryption requests for that identity. The environment maintains the necessary state for decryption operations.</p>","tags":["node-architecture","identity-subsystem","engine","decryption","environment"]},{"location":"arch/node/engines/decryption_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The Decryption Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","decryption","environment"]},{"location":"arch/node/engines/decryption_environment.html#decryptionmailboxstate","title":"<code>DecryptionMailboxState</code>","text":"<pre><code><pre>syntax alias DecryptionMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","environment"]},{"location":"arch/node/engines/decryption_environment.html#local-state","title":"Local state","text":"<p>The decryption engine is stateless.</p>","tags":["node-architecture","identity-subsystem","engine","decryption","environment"]},{"location":"arch/node/engines/decryption_environment.html#decryptionlocalstate","title":"<code>DecryptionLocalState</code>","text":"<pre><code><pre>syntax alias DecryptionLocalState := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","environment"]},{"location":"arch/node/engines/decryption_environment.html#timer-handle","title":"Timer Handle","text":"<p>The Decryption Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","decryption","environment"]},{"location":"arch/node/engines/decryption_environment.html#decryptiontimerhandle","title":"<code>DecryptionTimerHandle</code>","text":"<pre><code><pre>syntax alias DecryptionTimerHandle := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","environment"]},{"location":"arch/node/engines/decryption_environment.html#the-decryption-environment","title":"The Decryption Environment","text":"","tags":["node-architecture","identity-subsystem","engine","decryption","environment"]},{"location":"arch/node/engines/decryption_environment.html#decryptionenv","title":"<code>DecryptionEnv</code>","text":"<pre><code><pre>DecryptionEnv : Type :=  EngineEnv    DecryptionLocalState    DecryptionMailboxState    DecryptionTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","environment"]},{"location":"arch/node/engines/decryption_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>decryptionEnv : DecryptionEnv :=  EngineEnv.mk@{    localState := unit;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","environment"]},{"location":"arch/node/engines/decryption_messages.html","title":"Decryption Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.decryption_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","decryption","message-types"]},{"location":"arch/node/engines/decryption_messages.html#decryption-messages","title":"Decryption Messages","text":"","tags":["node-architecture","identity-subsystem","engine","decryption","message-types"]},{"location":"arch/node/engines/decryption_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type DecryptionMsg :=  | Request RequestDecryption  | Reply ReplyDecryption;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","message-types"]},{"location":"arch/node/engines/decryption_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","identity-subsystem","engine","decryption","message-types"]},{"location":"arch/node/engines/decryption_messages.html#request-sequence","title":"Request sequence","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant DE as Decryption Engine\n\n    C-&gt;&gt;DE: RequestDecryption(encryptedData)\n    Note over DE: Attempt to decrypt data\n    alt Decryption Successful\n        DE--&gt;&gt;C: ReplyDecryption(decryptedData, err=none)\n    else Decryption Failed\n        DE--&gt;&gt;C: ReplyDecryption(emptyByteString, err=\"Decryption Failed\")\n    end</code></pre>  Sequence diagram for decryption.","tags":["node-architecture","identity-subsystem","engine","decryption","message-types"]},{"location":"arch/node/engines/decryption_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","identity-subsystem","engine","decryption","message-types"]},{"location":"arch/node/engines/decryption_messages.html#requestdecryption","title":"<code>RequestDecryption</code>","text":"<pre><code><pre>type RequestDecryption :=  mkRequestDecryption@{    data : Ciphertext;  };</pre></code></pre> <p>A <code>RequestDecryption</code> instructs a decryption engine instance to decrypt data.</p> Arguments <code>data</code>: The encrypted ciphertext to decrypt.","tags":["node-architecture","identity-subsystem","engine","decryption","message-types"]},{"location":"arch/node/engines/decryption_messages.html#replydecryption","title":"<code>ReplyDecryption</code>","text":"<pre><code><pre>type ReplyDecryption :=  mkReplyDecryption@{    data : Plaintext;    err : Option String;  };</pre></code></pre> <p>A <code>ReplyDecryption</code> contains the data decrypted by a decryption engine instance in response to a <code>RequestDecryption</code>.</p> Arguments <code>data</code>: The decrypted data. <code>err</code>: An error message if decryption failed.","tags":["node-architecture","identity-subsystem","engine","decryption","message-types"]},{"location":"arch/node/engines/decryption_messages.html#decryptionmsg","title":"<code>DecryptionMsg</code>","text":"<pre><code><pre>type DecryptionMsg :=  | Request RequestDecryption  | Reply ReplyDecryption;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","decryption","message-types"]},{"location":"arch/node/engines/decryption_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Decryption Configuration</li> <li>Decryption Environment</li> <li>Decryption Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","decryption","message-types"]},{"location":"arch/node/engines/encryption.html","title":"Encryption Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.encryption;import prelude open;import arch.node.types.engine open;import arch.node.engines.encryption_messages open public;import arch.node.engines.encryption_environment open public;import arch.node.engines.encryption_behaviour open public;import arch.node.engines.encryption_config open public;import arch.node.engines.encryption_messages open public;import arch.node.engines.encryption_environment open public;import arch.node.engines.encryption_behaviour open public;import arch.node.types.anoma as Anoma open;open encryption_config_example;open encryption_environment_example;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","encryption","engine-definition"]},{"location":"arch/node/engines/encryption.html#encryption-engine","title":"Encryption Engine","text":"<p>The Encryption Engine provides encryption services within Anoma, allowing data to be securely encrypted for specific identities while supporting flexible encryption policies through integration with reads-for relationships. One may think of it as a smart mail service that can seal messages so that only intended recipients can read them, with the additional ability to consider pre-approved sharing relationships when sealing the message.</p> <p>When users request encryption (via a <code>MsgEncryptionRequest</code> message), they provide the data to encrypt (a <code>Plaintext</code>), the target identity (an <code>ExternalIdentity</code>), and whether to consider reads-for relationships (<code>useReadsFor</code>). The engine has two main operating modes:</p> Direct encryption (<code>useReadsFor: false</code>) <p>The engine immediately encrypts the data for the specified identity and returns the encrypted result (via s <code>MsgEncryptionReply</code> containing a <code>Ciphertext</code>).</p> ReadsFor-aware encryption (<code>useReadsFor: true</code>) <p>The engine first queries a ReadsFor Engine to check for any relevant reads-for relationships, then encrypts the data in a way that respects these relationships. This mode enables scenarios where data should be accessible not just to the direct recipient, but also to other identities with approved access rights.</p> On spawning <p>The engine is spawned by the system when encryption services are needed and operates statelessly except when handling reads-for queries. For reads-for cases, it maintains a temporary queue of pending encryption requests while waiting for relationship evidence.</p>","tags":["node-architecture","identity-subsystem","engine","encryption","engine-definition"]},{"location":"arch/node/engines/encryption.html#engine-components","title":"Engine components","text":"<ul> <li>Encryption Messages</li> <li>Encryption Configuration</li> <li>Encryption Environment</li> <li>Encryption Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","encryption","engine-definition"]},{"location":"arch/node/engines/encryption.html#type","title":"Type","text":"<pre><code><pre>EncryptionEngine : Type :=  Engine    EncryptionLocalCfg    EncryptionLocalState    EncryptionMailboxState    EncryptionTimerHandle    EncryptionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","engine-definition"]},{"location":"arch/node/engines/encryption.html#example-of-a-encryption-engine","title":"Example of a encryption engine","text":"<pre><code><pre>exampleEncryptionEngine : EncryptionEngine :=  Engine.mk@{    cfg := encryptionCfg;    env := encryptionEnv;    behaviour := encryptionBehaviour;  };</pre></code></pre> <p>where <code>encryptionCfg</code> is defined as follows:</p> <pre><code><pre>encryptionCfg : EncryptionCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"encryption\";    cfg :=      EncryptionLocalCfg.mk@{        encryptor :=          \\{_ _ :=            Encryptor.mkEncryptor@{              encrypt := \\{_ x := x};              encryptorHash :=                HASH.mkHASH@{                  ordKey :=                    OrdKey.mkOrdKey@{                      compare := Ord.compare;                    };                  hash := \\{x := \"0x1234abcd\"};                };            }};        backend := Backend.LocalMemory;        readsForEngineAddress := mkPair none \"Blah\";      };  };</pre></code></pre> <p><code>encryptionEnv</code> is defined as follows:</p> <pre><code><pre>encryptionEnv : EncryptionEnv :=  EngineEnv.mk@{    localState :=      EncryptionLocalState.mk@{        pendingRequests := Map.empty;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>encryptionBehaviour</code> is defined as follows:</p> <pre><code><pre>encryptionBehaviour : EncryptionBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [encryptGuard; readsForReplyGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","engine-definition"]},{"location":"arch/node/engines/encryption_behaviour.html","title":"Encryption Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.encryption_behaviour;import prelude open;import arch.system.identity.identity open hiding {ExternalIdentity};import arch.node.engines.encryption_environment open;import arch.node.engines.encryption_messages open;import arch.node.engines.encryption_config open;import arch.node.engines.reads_for_messages open;import arch.node.types.anoma as Anoma open;import arch.node.types.engine open;import arch.node.types.identities open;import arch.node.types.messages open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#encryption-behaviour","title":"Encryption Behaviour","text":"","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#overview","title":"Overview","text":"<p>The behavior of the Encryption Engine defines how it processes incoming encryption requests and produces the corresponding responses.</p>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#encryption-action-flowcharts","title":"Encryption Action Flowcharts","text":"","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#encryptaction-flowchart","title":"<code>encryptAction</code> flowchart","text":"<pre><code>flowchart TD\n    Start([Client Request]) --&gt; MsgReq[MsgEncryptionRequest&lt;br/&gt;data: Plaintext&lt;br/&gt;externalIdentity: ExternalIdentity&lt;br/&gt;useReadsFor: Bool]\n\n    subgraph Guard[\"encryptGuard\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br/&gt;EncryptionRequest?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"encryptAction\"]\n        direction TB\n        CheckReadsFor{useReadsFor?}\n        CheckReadsFor --&gt;|No| DirectPath[Get encryptor&lt;br/&gt;Encrypt directly]\n        CheckReadsFor --&gt;|Yes| CheckPending{Previous requests&lt;br/&gt;for this identity?}\n        CheckPending --&gt;|Yes| Queue[Add to pending requests]\n        CheckPending --&gt;|No| Init[Initialize pending requests&lt;br/&gt;Send ReadsFor query]\n        DirectPath --&gt; CreateResp[Create response]\n    end\n\n    CreateResp --&gt; DirectResponse[MsgEncryptionReply&lt;br/&gt;ciphertext: Ciphertext&lt;br/&gt;err: none]\n    Queue &amp; Init --&gt; Wait([Await ReadsFor Reply])\n    DirectResponse --&gt; Client([Return to Client])</code></pre> <code>encryptAction</code> flowchart","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#explanation","title":"Explanation","text":"<ol> <li> <p>Initial Request</p> <ul> <li>A client sends a <code>MsgEncryptionRequest</code> containing:<ul> <li><code>data</code>: The plaintext that needs to be encrypted</li> <li><code>externalIdentity</code>: The target identity to encrypt for</li> <li><code>useReadsFor</code>: Boolean flag indicating whether to use reads-for relationships</li> </ul> </li> </ul> </li> <li> <p>Guard Phase (<code>encryptGuard</code>)</p> <ul> <li>Validates that the incoming message is a proper encryption request</li> <li>Checks occur in the following order:<ul> <li>Verifies message type is <code>MsgEncryptionRequest</code></li> <li>If validation fails, request is rejected without entering the action phase</li> <li>On success, passes control to <code>encryptActionLabel</code></li> </ul> </li> </ul> </li> <li> <p>Action Phase (<code>encryptAction</code>)</p> <ul> <li>First decision point: Check <code>useReadsFor</code> flag</li> </ul> <ul> <li>Direct Path (<code>useReadsFor: false</code>):<ul> <li>Gets encryptor from engine's configuration</li> <li>Encrypts data directly for the target identity using empty evidence set</li> <li>Creates <code>MsgEncryptionReply</code> with:<ul> <li><code>ciphertext</code>: The encrypted data</li> <li><code>err</code>: None</li> </ul> </li> <li>Returns response immediately to client</li> </ul> </li> </ul> <ul> <li>ReadsFor Path (<code>useReadsFor: true</code>):<ul> <li>Checks if there are existing pending requests for this identity</li> <li>If this is the first request:<ul> <li>Initializes a new pending request list</li> <li>Adds current request to the list</li> <li>Sends <code>MsgQueryReadsForEvidenceRequest</code> to ReadsFor engine</li> <li>Awaits reply</li> </ul> </li> <li>If there are existing pending requests:<ul> <li>Adds current request to existing pending list</li> <li>Awaits existing query's reply</li> </ul> </li> <li>No immediate response is sent to client</li> </ul> </li> </ul> </li> <li> <p>State Changes</p> <ul> <li>Direct Path: No state changes</li> <li>ReadsFor Path: Updates <code>pendingRequests</code> map in local state<ul> <li>Key: <code>externalIdentity</code></li> <li>Value: List of pending requests (pairs of requester ID and plaintext)</li> </ul> </li> </ul> </li> <li> <p>Messages Generated</p> <ul> <li>Direct Path:<ul> <li><code>MsgEncryptionReply</code> sent back to requester</li> <li>Sends to mailbox 0 (the default)</li> </ul> </li> <li>ReadsFor Path:<ul> <li>If first request: <code>MsgQueryReadsForEvidenceRequest</code> sent to ReadsFor engine</li> <li>No immediate response to requester</li> </ul> </li> </ul> </li> </ol>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#handlereadsforreplyaction-flowchart","title":"<code>handleReadsForReplyAction</code> flowchart","text":"<pre><code>flowchart TD\n    Start([ReadsFor Reply]) --&gt; Reply[MsgQueryReadsForEvidenceReply&lt;br/&gt;evidence: ReadsForEvidence&lt;br/&gt;externalIdentity: ExternalIdentity]\n\n    subgraph Guard[\"readsForReplyGuard\"]\n        Reply --&gt; ValidSource{From correct&lt;br/&gt;ReadsFor engine?}\n        ValidSource --&gt;|No| Reject([Reject Reply])\n        ValidSource --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"handleReadsForReplyAction\"]\n        direction TB\n        GetReqs[Get pending requests&lt;br/&gt;for this identity]\n        GetReqs --&gt; Process[For each request:&lt;br/&gt;Encrypt with evidence]\n        Process --&gt; Clear[Clear pending requests]\n    end\n\n    Clear --&gt; Responses[Send MsgEncryptionReply&lt;br/&gt;to each waiting client]\n    Responses --&gt; Client([Return to Clients])</code></pre> <code>handleReadsForReplyAction</code> flowchart","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#explanation_1","title":"Explanation","text":"<ol> <li> <p>Initial Input</p> <ul> <li>The ReadsFor Engine sends a <code>MsgQueryReadsForEvidenceReply</code> containing:<ul> <li><code>evidence</code>: The ReadsFor evidence for the requested identity</li> <li><code>externalIdentity</code>: The identity the evidence relates to</li> <li><code>err</code>: Optional error message if evidence retrieval failed</li> </ul> </li> </ul> </li> <li> <p>Guard Phase (<code>readsForReplyGuard</code>)</p> <ul> <li>Validates incoming message in following order:<ul> <li>Checks message type is <code>MsgQueryReadsForEvidenceReply</code></li> <li>Verifies the message sender matches the configured ReadsFor engine address</li> <li>If either check fails, request is rejected without entering action phase</li> <li>On success, passes control to <code>handleReadsForReplyActionLabel</code></li> </ul> </li> </ul> </li> <li> <p>Action Phase (<code>handleReadsForReplyAction</code>)</p> <ul> <li>Processing occurs in these steps:<ul> <li>Retrieves all pending encryption requests for the specified identity from state</li> <li>For each pending request:<ul> <li>Gets encryptor from configuration</li> <li>Applies ReadsFor evidence to encryptor</li> <li>Encrypts the pending plaintext data</li> <li>Creates response message with encrypted result</li> </ul> </li> <li>Clears all processed requests from the pending queue</li> <li>Sends responses to all waiting clients</li> </ul> </li> </ul> </li> <li> <p>Response Generation</p> <ul> <li>For each pending request, creates <code>MsgEncryptionReply</code> with:<ul> <li><code>ciphertext</code>: The encrypted data using the provided evidence</li> <li><code>err</code>: None for successful encryption</li> </ul> </li> </ul> </li> <li> <p>Response Delivery</p> <ul> <li>Each response is sent back to its original requester</li> <li>Uses mailbox  0 (the default) for all responses</li> </ul> </li> </ol> <p>Important Notes</p> <ul> <li>All pending requests for an identity are processed in a single batch when evidence arrives</li> <li>The same evidence is used for all pending requests for that identity</li> <li>If no pending requests exist for the identity when evidence arrives, the evidence is discarded</li> </ul>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#replyto","title":"<code>ReplyTo</code>","text":"<pre><code><pre>type ReplyTo :=  mkReplyTo@{    whoAsked : Option EngineID;    mailbox : Option MailboxID;  };</pre></code></pre> <p>This action argument contains the address and mailbox ID of where the response message should be sent.</p> Arguments <code>whoAsked</code>: is the address of the engine that sent the message. <code>mailbox</code>: is the mailbox ID where the response message should be sent.","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#encryptionactionargument","title":"<code>EncryptionActionArgument</code>","text":"<pre><code><pre>type EncryptionActionArgument := | EncryptionActionArgumentReplyTo ReplyTo;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#encryptionactionarguments","title":"<code>EncryptionActionArguments</code>","text":"<pre><code><pre>EncryptionActionArguments : Type := List EncryptionActionArgument;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#encryptionaction","title":"<code>EncryptionAction</code>","text":"<p><pre><code><pre>EncryptionAction : Type :=  Action    EncryptionLocalCfg    EncryptionLocalState    EncryptionMailboxState    EncryptionTimerHandle    EncryptionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#encryptionactioninput","title":"<code>EncryptionActionInput</code>","text":"<p><pre><code><pre>EncryptionActionInput : Type :=  ActionInput    EncryptionLocalCfg    EncryptionLocalState    EncryptionMailboxState    EncryptionTimerHandle    EncryptionActionArguments    Anoma.Msg;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#encryptionactioneffect","title":"<code>EncryptionActionEffect</code>","text":"<p><pre><code><pre>EncryptionActionEffect : Type :=  ActionEffect    EncryptionLocalState    EncryptionMailboxState    EncryptionTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#encryptionactionexec","title":"<code>EncryptionActionExec</code>","text":"<p><pre><code><pre>EncryptionActionExec : Type :=  ActionExec    EncryptionLocalCfg    EncryptionLocalState    EncryptionMailboxState    EncryptionTimerHandle    EncryptionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#encryptaction","title":"<code>encryptAction</code>","text":"<p>Process an encryption request.</p> State update If <code>useReadsFor</code> is true, the state is updated to store pending requests. Otherwise, the state remains unchanged. Messages to be sent If <code>useReadsFor</code> is false, a <code>ReplyEncrypt</code> message is sent back to the requester. If <code>useReadsFor</code> is true and it's the first request for this identity, a <code>QueryReadsForEvidenceRequest</code> is sent to the ReadsFor Engine. Engines to be spawned No engines are created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>encryptAction (input : EncryptionActionInput) : Option EncryptionActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    tt := ActionInput.trigger input;    localState := EngineEnv.localState env;  in case getEngineMsgFromTimestampedTrigger tt of       | some emsg :=         case EngineMsg.msg emsg of {           | Anoma.Msg.Encryption (EncryptionMsg.Request (RequestEncrypt.mkRequestEncrypt data externalIdentity useReadsFor)) :=             case useReadsFor of {               | false :=                 some                   ActionEffect.mk@{                     env := env;                     msgs :=                       [                         EngineMsg.mk@{                           sender := getEngineIDFromEngineCfg cfg;                           target := EngineMsg.sender emsg;                           mailbox := some 0;                           msg :=                             Anoma.Msg.Encryption                               (EncryptionMsg.Reply                                 ReplyEncrypt.mkReplyEncrypt@{                                   ciphertext :=                                     Encryptor.encrypt                                       (EncryptionLocalCfg.encryptor                                         (EngineCfg.cfg cfg)                                         Set.empty                                         externalIdentity)                                       (EncryptionLocalCfg.backend                                         (EngineCfg.cfg cfg))                                       data;                                   err := none;                                 });                         };                       ];                     timers := [];                     engines := [];                   }               | true :=                 let                   existingRequests :=                     Map.lookup                       externalIdentity                       (EncryptionLocalState.pendingRequests localState);                   newPendingList :=                     case existingRequests of                       | some reqs :=                         reqs ++ [mkPair (EngineMsg.sender emsg) data]                       | none := [mkPair (EngineMsg.sender emsg) data];                   newLocalState :=                     localState@EncryptionLocalState{pendingRequests := Map.insert                       externalIdentity                       newPendingList                       (EncryptionLocalState.pendingRequests localState)};                 in some                   ActionEffect.mk@{                     env := env@EngineEnv{localState := newLocalState};                     msgs :=                       case existingRequests of                         | some _ := []                         | none :=                           [                             EngineMsg.mk@{                               sender := getEngineIDFromEngineCfg cfg;                               target :=                                 EncryptionLocalCfg.readsForEngineAddress                                   (EngineCfg.cfg cfg);                               mailbox := some 0;                               msg :=                                 Anoma.Msg.ReadsFor                                   (ReadsForMsg.QueryReadsForEvidenceRequest                                     RequestQueryReadsForEvidence.mkRequestQueryReadsForEvidence@{                                       externalIdentity := externalIdentity;                                     });                             };                           ];                     timers := [];                     engines := [];                   }             }           | _ := none         }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#handlereadsforreplyaction","title":"<code>handleReadsForReplyAction</code>","text":"<p>Process <code>reads-for</code> evidence response.</p> State update The state is updated to remove processed pending requests. Messages to be sent <code>ReplyEncrypt</code> messages are sent to all requesters who were waiting for this ReadsFor evidence. Engines to be spawned No engines are created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>handleReadsForReplyAction  (input : EncryptionActionInput) : Option EncryptionActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    tt := ActionInput.trigger input;    localState := EngineEnv.localState env;  in case getEngineMsgFromTimestampedTrigger tt of       | some emsg :=         case EngineMsg.msg emsg of {           | Anoma.Msg.ReadsFor (ReadsForMsg.QueryReadsForEvidenceReply (ReplyQueryReadsForEvidence.mkReplyQueryReadsForEvidence externalIdentity evidence err)) :=             case               Map.lookup                 externalIdentity                 (EncryptionLocalState.pendingRequests localState)             of {               | some reqs :=                 let                   newLocalState :=                     localState@EncryptionLocalState{pendingRequests := Map.delete                       externalIdentity                       (EncryptionLocalState.pendingRequests localState)};                 in some                   ActionEffect.mk@{                     env := env@EngineEnv{localState := newLocalState};                     msgs :=                       map                         \\{req :=                           let                             whoAsked := fst req;                             data := snd req;                           in EngineMsg.mk@{                                sender := getEngineIDFromEngineCfg cfg;                                target := whoAsked;                                mailbox := some 0;                                msg :=                                  Anoma.Msg.Encryption                                    (EncryptionMsg.Reply                                      ReplyEncrypt.mkReplyEncrypt@{                                        ciphertext :=                                          Encryptor.encrypt                                            (EncryptionLocalCfg.encryptor                                              (EngineCfg.cfg cfg)                                              evidence                                              externalIdentity)                                            (EncryptionLocalCfg.backend                                              (EngineCfg.cfg cfg))                                            data;                                        err := none;                                      });                              }}                         reqs;                     timers := [];                     engines := [];                   }               | none := none             }           | _ := none         }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#encryptactionlabel","title":"<code>encryptActionLabel</code>","text":"<pre><code><pre>encryptActionLabel : EncryptionActionExec := ActionExec.Seq [encryptAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#handlereadsforreplyactionlabel","title":"<code>handleReadsForReplyActionLabel</code>","text":"<pre><code><pre>handleReadsForReplyActionLabel : EncryptionActionExec :=  ActionExec.Seq [handleReadsForReplyAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#encryptionguard","title":"<code>EncryptionGuard</code>","text":"<p> <pre><code><pre>EncryptionGuard : Type :=  Guard    EncryptionLocalCfg    EncryptionLocalState    EncryptionMailboxState    EncryptionTimerHandle    EncryptionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#encryptionguardoutput","title":"<code>EncryptionGuardOutput</code>","text":"<p> <pre><code><pre>EncryptionGuardOutput : Type :=  GuardOutput    EncryptionLocalCfg    EncryptionLocalState    EncryptionMailboxState    EncryptionTimerHandle    EncryptionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#encryptguard","title":"<code>encryptGuard</code>","text":"Condition Message type is <code>MsgEncryptionRequest</code>. <pre><code><pre>encryptGuard  (tt : TimestampedTrigger EncryptionTimerHandle Anoma.Msg)  (cfg : EncryptionCfg)  (env : EncryptionEnv)  : Option EncryptionGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some EngineMsg.mk@{             msg := Anoma.Msg.Encryption (EncryptionMsg.Request _);           } :=      some        GuardOutput.mk@{          action := encryptActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#readsforreplyguard","title":"<code>readsForReplyGuard</code>","text":"<pre><code><pre>readsForReplyGuard  (tt : TimestampedTrigger EncryptionTimerHandle Anoma.Msg)  (cfg : EncryptionCfg)  (env : EncryptionEnv)  : Option EncryptionGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some emsg :=      case EngineMsg.msg emsg of {        | Anoma.Msg.ReadsFor (ReadsForMsg.QueryReadsForEvidenceReply _) :=          case            isEqual              (Ord.compare                (EngineMsg.sender emsg)                (EncryptionLocalCfg.readsForEngineAddress (EngineCfg.cfg cfg)))          of {            | true :=              some                GuardOutput.mk@{                  action := handleReadsForReplyActionLabel;                  args := [];                }            | false := none          }        | _ := none      }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#the-encryption-behaviour","title":"The Encryption Behaviour","text":"","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#encryptionbehaviour","title":"<code>EncryptionBehaviour</code>","text":"<pre><code><pre>EncryptionBehaviour : Type :=  EngineBehaviour    EncryptionLocalCfg    EncryptionLocalState    EncryptionMailboxState    EncryptionTimerHandle    EncryptionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>encryptionBehaviour : EncryptionBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [encryptGuard; readsForReplyGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","behaviour"]},{"location":"arch/node/engines/encryption_config.html","title":"Encryption Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.encryption_config;import prelude open;import arch.node.engines.encryption_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.system.identity.identity open hiding {ExternalIdentity};</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","encryption","configuration"]},{"location":"arch/node/engines/encryption_config.html#encryption-configuration","title":"Encryption Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","encryption","configuration"]},{"location":"arch/node/engines/encryption_config.html#overview","title":"Overview","text":"<p>The Encryption engine configuration contains static information for Encryption engine instances.</p>","tags":["node-architecture","identity-subsystem","engine","encryption","configuration"]},{"location":"arch/node/engines/encryption_config.html#the-encryption-local-configuration","title":"The Encryption Local Configuration","text":"<p>The configuration of an <code>Encryption</code> Engine instance includes the identity's encryption capabilities, the address of an associated <code>ReadsFor</code> engine, and a specific backend.</p>","tags":["node-architecture","identity-subsystem","engine","encryption","configuration"]},{"location":"arch/node/engines/encryption_config.html#encryptionlocalcfg","title":"<code>EncryptionLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type EncryptionLocalCfg :=  mk@{    encryptor      : Set ReadsForEvidence        -&gt; ExternalIdentity        -&gt; Encryptor ByteString Backend Plaintext Ciphertext;    backend : Backend;    readsForEngineAddress : EngineID;  };</pre></code></pre> Arguments <code>encryptor</code>: Function to generate encryptor for a set of evidence and an identity. <code>backend</code>: The backend to use for encryption. <code>readsForEngineAddress</code>: The address of the associated ReadFor engine.","tags":["node-architecture","identity-subsystem","engine","encryption","configuration"]},{"location":"arch/node/engines/encryption_config.html#the-encryption-configuration","title":"The Encryption Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","encryption","configuration"]},{"location":"arch/node/engines/encryption_config.html#encryptioncfg","title":"<code>EncryptionCfg</code>","text":"<pre><code><pre>EncryptionCfg : Type := EngineCfg EncryptionLocalCfg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","configuration"]},{"location":"arch/node/engines/encryption_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>encryptionCfg : EncryptionCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"encryption\";    cfg :=      EncryptionLocalCfg.mk@{        encryptor :=          \\{_ _ :=            Encryptor.mkEncryptor@{              encrypt := \\{_ x := x};              encryptorHash :=                HASH.mkHASH@{                  ordKey :=                    OrdKey.mkOrdKey@{                      compare := Ord.compare;                    };                  hash := \\{x := \"0x1234abcd\"};                };            }};        backend := Backend.LocalMemory;        readsForEngineAddress := mkPair none \"Blah\";      };  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","configuration"]},{"location":"arch/node/engines/encryption_environment.html","title":"Encryption Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.encryption_environment;import prelude open;import arch.node.engines.encryption_messages open;import arch.node.types.engine_environment open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","encryption","environment"]},{"location":"arch/node/engines/encryption_environment.html#encryption-engine-environment","title":"<code>Encryption</code> Engine Environment","text":"","tags":["node-architecture","identity-subsystem","engine","encryption","environment"]},{"location":"arch/node/engines/encryption_environment.html#overview","title":"Overview","text":"<p>The <code>Encryption</code> Engine is stateless and does not maintain any internal state between requests. It relies on external information (like the <code>reads_for</code> relationships) for its operations.</p>","tags":["node-architecture","identity-subsystem","engine","encryption","environment"]},{"location":"arch/node/engines/encryption_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The <code>Encryption</code> Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","encryption","environment"]},{"location":"arch/node/engines/encryption_environment.html#encryptionmailboxstate","title":"<code>EncryptionMailboxState</code>","text":"<pre><code><pre>syntax alias EncryptionMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","environment"]},{"location":"arch/node/engines/encryption_environment.html#local-state","title":"Local state","text":"<p>The local state of an <code>Encryption</code> Engine instance contains a map to a list of pending requests which require <code>ReadsFor</code> information which is requested from the associated <code>ReadsFor</code> engine.</p>","tags":["node-architecture","identity-subsystem","engine","encryption","environment"]},{"location":"arch/node/engines/encryption_environment.html#encryptionlocalstate","title":"<code>EncryptionLocalState</code>","text":"<pre><code><pre>type EncryptionLocalState :=  mk@{    pendingRequests : Map ExternalIdentity (List (Pair EngineID Plaintext));  };</pre></code></pre> Arguments <code>pendingRequests</code>: The backlog of encryption requests still in processing.","tags":["node-architecture","identity-subsystem","engine","encryption","environment"]},{"location":"arch/node/engines/encryption_environment.html#timer-handle","title":"Timer Handle","text":"<p>The Encryption Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","encryption","environment"]},{"location":"arch/node/engines/encryption_environment.html#encryptiontimerhandle","title":"<code>EncryptionTimerHandle</code>","text":"<pre><code><pre>syntax alias EncryptionTimerHandle := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","environment"]},{"location":"arch/node/engines/encryption_environment.html#the-encryption-environment","title":"The Encryption Environment","text":"","tags":["node-architecture","identity-subsystem","engine","encryption","environment"]},{"location":"arch/node/engines/encryption_environment.html#encryptionenv","title":"<code>EncryptionEnv</code>","text":"<pre><code><pre>EncryptionEnv : Type :=  EngineEnv    EncryptionLocalState    EncryptionMailboxState    EncryptionTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","environment"]},{"location":"arch/node/engines/encryption_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>encryptionEnv : EncryptionEnv :=  EngineEnv.mk@{    localState :=      EncryptionLocalState.mk@{        pendingRequests := Map.empty;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","environment"]},{"location":"arch/node/engines/encryption_messages.html","title":"Encryption Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.encryption_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","encryption","message-types"]},{"location":"arch/node/engines/encryption_messages.html#encryption-messages","title":"Encryption Messages","text":"","tags":["node-architecture","identity-subsystem","engine","encryption","message-types"]},{"location":"arch/node/engines/encryption_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type EncryptionMsg :=  | Request RequestEncrypt  | Reply ReplyEncrypt;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","message-types"]},{"location":"arch/node/engines/encryption_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","identity-subsystem","engine","encryption","message-types"]},{"location":"arch/node/engines/encryption_messages.html#encryption-sequence-without-readsfor-evidence","title":"Encryption sequence (without <code>ReadsFor</code> evidence)","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant EE as Encryption Engine\n\n    C-&gt;&gt;EE: RequestEncrypt (useReadsFor: false)\n    Note over EE: Encrypt commitment\n    EE--&gt;&gt;C: ReplyEncrypt</code></pre>  Sequence diagram for encryption (no reads for).","tags":["node-architecture","identity-subsystem","engine","encryption","message-types"]},{"location":"arch/node/engines/encryption_messages.html#encryption-sequence-with-readsfor-evidence","title":"Encryption sequence (with <code>ReadsFor</code> evidence)","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant EE as Encryption Engine\n    participant RE as ReadsFor Engine\n\n    C-&gt;&gt;EE: RequestEncrypt (useReadsFor: true)\n    EE-&gt;&gt;RE: QueryReadsForEvidenceRequest\n    Note over RE: Retrieve evidence\n    RE--&gt;&gt;EE: QueryReadsForEvidenceReply\n    Note over EE: Encrypt commitment using ReadsFor evidence\n    EE--&gt;&gt;C: ReplyEncrypt</code></pre>  Sequence diagram for encryption (with <code>reads_for</code> evidence).","tags":["node-architecture","identity-subsystem","engine","encryption","message-types"]},{"location":"arch/node/engines/encryption_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","identity-subsystem","engine","encryption","message-types"]},{"location":"arch/node/engines/encryption_messages.html#requestencrypt","title":"<code>RequestEncrypt</code>","text":"<pre><code><pre>type RequestEncrypt :=  mkRequestEncrypt@{    data : Plaintext;    externalIdentity : ExternalIdentity;    useReadsFor : Bool;  };</pre></code></pre> <p>A <code>RequestEncrypt</code> instructs the Encryption Engine to encrypt data to a particular external identity, possibly using known <code>reads_for</code> relationships.</p> Arguments <code>data</code>: The data to encrypt. <code>externalIdentity</code>: The external identity requesting encryption. <code>useReadsFor</code>: Whether to use known <code>reads_for</code> relationships or not.","tags":["node-architecture","identity-subsystem","engine","encryption","message-types"]},{"location":"arch/node/engines/encryption_messages.html#replyencrypt","title":"<code>ReplyEncrypt</code>","text":"<pre><code><pre>type ReplyEncrypt :=  mkReplyEncrypt@{    ciphertext : Ciphertext;    err : Option String;  };</pre></code></pre> <p>A <code>ReplyEncrypt</code> contains the data encrypted by the Encryption Engine in response to a <code>RequestEncrypt</code>.</p> Arguments <code>ciphertext</code>: The encrypted data. <code>err</code>: An error message if encryption failed.","tags":["node-architecture","identity-subsystem","engine","encryption","message-types"]},{"location":"arch/node/engines/encryption_messages.html#encryptionmsg","title":"<code>EncryptionMsg</code>","text":"<pre><code><pre>type EncryptionMsg :=  | Request RequestEncrypt  | Reply ReplyEncrypt;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","encryption","message-types"]},{"location":"arch/node/engines/encryption_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Encryption Configuration</li> <li>Encryption Environment</li> <li>Encryption Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","encryption","message-types"]},{"location":"arch/node/engines/executor.html","title":"Executor Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.executor;import prelude open;import arch.node.types.engine open;import arch.node.engines.executor_config open public;import arch.node.engines.executor_messages open public;import arch.node.engines.executor_environment open public;import arch.node.engines.executor_behaviour open public;import arch.node.types.anoma as Anoma open;open executor_config_example;open executor_environment_example;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","executor","engine-definition"]},{"location":"arch/node/engines/executor.html#executor-engine","title":"Executor Engine","text":"<p>The Executor Engine is responsible for executing transaction programs in Anoma, serving as the computational core that processes state transitions within the system. It operates as part of a distributed execution system, working in concert with Shard Engines that manage state access and Mempool Worker engines that take orders and spawn Executor engines based on those orders. Each Executor Engine instance is spawned to handle the execution of a single transaction in the form of a program which it is spawned with, making them ephemeral components that exist solely for the duration of their assigned transaction's lifecycle.</p> <p>At its core, an Executor Engine receives read responses from shards and uses these to step through the transaction program's execution. Each transaction program defines a sequence of operations that may read from or write to various keys in the system's state. The Executor doesn't directly access this state - instead, it coordinates with Shard engines that manage actual state access.</p> <p>The primary interface for the Executor Engine consists of three main message types that facilitate its operation. It receives <code>ShardMsgKVSRead</code> messages from Shards containing the data for requested state reads. For each read, the Executor applies this data to advance the transaction program's execution, potentially generating new read requests (<code>ShardMsgKVSReadRequest</code>) or write operations (<code>ShardMsgKVSWrite</code>) that are sent to the appropriate Shards. Once execution is complete, it sends an <code>ExecutorMsgExecutorFinished</code> message to both the Worker that spawned it and the transaction's issuer, containing a summary of all reads and writes performed during execution.</p>","tags":["node-architecture","ordering-subsystem","engine","executor","engine-definition"]},{"location":"arch/node/engines/executor.html#engine-components","title":"Engine components","text":"<ul> <li>Executor Messages</li> <li>Executor Configuration</li> <li>Executor Environment</li> <li>Executor Behaviour</li> </ul>","tags":["node-architecture","ordering-subsystem","engine","executor","engine-definition"]},{"location":"arch/node/engines/executor.html#the-type-for-an-executor-engine","title":"The type for an executor engine","text":"<p>The executor engine is designed to be \"agnostic\" to choices of virtual machines and data formats, assuming only that the executable will run step by step (possibly involving program state updates) and interaction with replicated state machine state is via a key value storage interface.</p> <pre><code><pre>ExecutorEngine : Type :=  Engine    ExecutorLocalCfg    ExecutorLocalState    ExecutorMailboxState    ExecutorTimerHandle    ExecutorActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","engine-definition"]},{"location":"arch/node/engines/executor.html#example-of-an-executor-engine","title":"Example of an executor engine","text":"<pre><code><pre>exampleExecutorEngine : ExecutorEngine :=  Engine.mk@{    cfg := executorCfg;    env := executorEnv;    behaviour := executorBehaviour;  };</pre></code></pre> <p>where <code>executorCfg</code> is defined as follows:</p> <pre><code><pre>executorCfg : ExecutorCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"executor\";    cfg :=      ExecutorLocalCfg.mk@{        timestamp := 0;        executable := Noun.Atom 0;        lazy_read_keys := Set.empty;        eager_read_keys := Set.empty;        will_write_keys := Set.empty;        may_write_keys := Set.empty;        worker := mkPair none \"\";        issuer := mkPair none \"\";        keyToShard := \\{_ := mkPair none \"shard\"};      };  };</pre></code></pre> <p><code>executorEnv</code> is defined as follows:</p> <pre><code><pre>executorEnv : ExecutorEnv :=  EngineEnv.mk@{    localState :=      ExecutorLocalState.mk@{        program_state :=          NockmaProgramState.mk@{            current_noun := Noun.Atom 0;            storage := emptyStorage;            gas_limit := 0;          };        completed_reads := Map.empty;        completed_writes := Map.empty;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>executorBehaviour</code> is defined as follows:</p> <pre><code><pre>executorBehaviour : ExecutorBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [processReadGuard];  };</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","engine-definition"]},{"location":"arch/node/engines/executor_behaviour.html","title":"Executor Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.executor_behaviour;import Stdlib.Data.Set as Set;import arch.node.engines.executor_messages open;import arch.node.engines.executor_config open;import arch.node.engines.executor_environment open;import arch.node.engines.shard_messages open;import prelude open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;import arch.system.state.resource_machine.notes.runnable open;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#executor-behaviour","title":"Executor Behaviour","text":"","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#overview","title":"Overview","text":"<p>The executor behaviour defines how it processes incoming read responses and performs state transitions to execute the transaction program.</p>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#executor-action-flowcharts","title":"Executor Action Flowcharts","text":"","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#processread-flowchart","title":"<code>processRead</code> Flowchart","text":"<pre><code>flowchart TD\n    Start([Receive Message]) --&gt; Msg[ShardMsgKVSRead&lt;br/&gt;key: KVSKey&lt;br/&gt;data: KVSDatum]\n\n    subgraph Guard[\"processReadGuard\"]\n        Msg --&gt; CheckMsg{Is message&lt;br/&gt;ShardMsgKVSRead?}\n        CheckMsg --&gt;|No| Reject([Reject Message])\n        CheckMsg --&gt;|Yes| ValidTS{Matching&lt;br/&gt;timestamp?}\n        ValidTS --&gt;|No| Reject\n        ValidTS --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"processReadAction\"]\n        direction TB\n        ComputeStale[\"Compute stale locks:&lt;br/&gt;1. Find uncompleted reads&lt;br/&gt;2. Find uncompleted writes&lt;br/&gt;3. Create cleanup messages\"]\n        ExecStep[Execute program step&lt;br/&gt;with read data]\n        ExecStep --&gt; StepResult{Step&lt;br/&gt;Result?}\n        StepResult --&gt;|Error| ErrBranch[Create error response&lt;br/&gt;with read/write history]\n        StepResult --&gt;|Success| SuccessBranch[Update program state&lt;br/&gt;Track completed read]\n        SuccessBranch --&gt; CheckHalt{Program&lt;br/&gt;Halted?}\n        CheckHalt --&gt;|Yes| FinishOk[Create success response&lt;br/&gt;with read/write history]\n        CheckHalt --&gt;|No| GenMsgs[Generate messages for&lt;br/&gt;new reads/writes]\n    end\n\n    ErrBranch --&gt; AddStaleErr[Add stale lock&lt;br/&gt;cleanup messages]\n    FinishOk --&gt; AddStaleOk[Add stale lock&lt;br/&gt;cleanup messages]\n\n    GenMsgs --&gt; Parse[Parse step outputs]\n\n    subgraph ProcessOutputs[\"Process Step Outputs\"]\n        Parse --&gt; CheckType{Output&lt;br/&gt;Type?}\n        CheckType --&gt;|Read Request| ReadBranch[Create KVSReadRequest&lt;br/&gt;if key in read sets]\n        CheckType --&gt;|Write Request| WriteBranch[Create KVSWrite&lt;br/&gt;if key in write sets]\n\n        ReadBranch --&gt; ValidRead{Key in&lt;br/&gt;read sets?}\n        ValidRead --&gt;|Yes| AddRead[Add to read&lt;br/&gt;message list]\n        ValidRead --&gt;|No| SkipRead[Skip invalid&lt;br/&gt;read request]\n\n        WriteBranch --&gt; ValidWrite{Key in&lt;br/&gt;write sets?}\n        ValidWrite --&gt;|Yes| AddWrite[Add to write&lt;br/&gt;message list]\n        ValidWrite --&gt;|No| SkipWrite[Skip invalid&lt;br/&gt;write request]\n    end\n\n    AddRead --&gt; Collect[Collect all&lt;br/&gt;generated messages]\n    AddWrite --&gt; Collect\n    SkipRead --&gt; Collect\n    SkipWrite --&gt; Collect\n\n    subgraph StaleComputation[\"Stale Lock Processing\"]\n        ComputeStale --&gt; FindReads[Find difference between&lt;br/&gt;lazy_read_keys and&lt;br/&gt;completed reads]\n        ComputeStale --&gt; FindWrites[Find difference between&lt;br/&gt;may_write_keys and&lt;br/&gt;completed writes]\n        FindReads --&gt; CreateRead[Create cleanup read&lt;br/&gt;messages with actual=false]\n        FindWrites --&gt; CreateWrite[Create cleanup write&lt;br/&gt;messages with datum=none]\n        CreateRead &amp; CreateWrite --&gt; CombineMsgs[Combine cleanup messages]\n    end\n\n    CombineMsgs -.-&gt; AddStaleErr\n    CombineMsgs -.-&gt; AddStaleOk\n\n    AddStaleErr --&gt; NotifyFail[Send ExecutorFinished&lt;br/&gt;with error + cleanup messages]\n    AddStaleOk --&gt; NotifySuccess[Send ExecutorFinished&lt;br/&gt;with success + cleanup messages]\n    Collect --&gt; SendMsgs[Send generated&lt;br/&gt;read/write messages]\n\n    NotifyFail &amp; NotifySuccess &amp; SendMsgs --&gt; End([Complete])</code></pre> <code>processRead</code> flowchart showing read handling and execution steps","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#explanation","title":"Explanation","text":"<ol> <li> <p>Initial Request Processing</p> <ul> <li>A client sends a <code>ShardMsgKVSRead</code> message containing:<ul> <li><code>key</code>: The state key that was read.</li> <li><code>data</code>: The actual data value for that key.</li> <li>A timestamp that identifies this execution context.</li> </ul> </li> <li>The message first passes through the guard phase which:<ul> <li>Validates the message is a <code>ShardMsgKVSRead</code>.</li> <li>Ensures the timestamp matches this executor's configured timestamp.</li> <li>Rejects messages that fail either check.</li> <li>Routes valid messages to the action phase.</li> </ul> </li> </ul> </li> <li> <p>Program Execution</p> <ul> <li>The action phase begins by executing the next program step:<ul> <li>Takes the current program state as context.</li> <li>Provides the newly read key-value pair as input.</li> <li>Produces either an error or a new program state with outputs.</li> </ul> </li> <li>On error:<ul> <li>Creates response detailing why execution failed.</li> <li>Includes lists of all completed reads and writes.</li> <li>Triggers stale lock cleanup before responding.</li> </ul> </li> <li>On success:<ul> <li>Updates internal program state with execution results.</li> <li>Records the completed read in its tracking.</li> <li>Determines if program has halted or continues.</li> </ul> </li> </ul> </li> <li> <p>Continuation Flow</p> <ul> <li>If program hasn't halted:<ul> <li>Processes program outputs to generate new messages.</li> <li>For read requests:<ul> <li>Validates key is in allowed read sets (lazy or eager).</li> <li>Creates <code>KVSReadRequest</code> messages for valid reads.</li> </ul> </li> <li>For write operations:<ul> <li>Validates key is in allowed write sets (will or may).</li> <li>Creates <code>KVSWrite</code> messages for valid writes</li> </ul> </li> <li>Sends all generated messages to appropriate shards.</li> <li>Awaits next read response to continue execution.</li> </ul> </li> </ul> </li> <li> <p>Completion Flow</p> <ul> <li>When program halts (either naturally or from error):<ul> <li>Computes stale lock information:<ul> <li>Finds difference between lazy_read_keys and actual reads.</li> <li>Finds difference between may_write_keys and actual writes.</li> </ul> </li> <li>Generates cleanup messages:<ul> <li><code>KVSReadRequest</code> with actual=false for unused reads.</li> <li><code>KVSWrite</code> with datum=none for unused writes.</li> </ul> </li> <li>Creates <code>ExecutorFinished</code> message containing:<ul> <li>Success/failure status</li> <li>Complete list of values read</li> <li>Complete list of values written</li> </ul> </li> <li>Sends cleanup messages and finished notification.</li> <li>Terminates executor instance.</li> </ul> </li> </ul> </li> <li> <p>Reply Delivery</p> <ul> <li>All responses are sent back using:<ul> <li>Executor's ID as sender.</li> <li>Original requester as target.</li> <li>Mailbox 0 (default response mailbox).</li> </ul> </li> <li>Three possible response patterns:<ul> <li>Error case: ExecutorFinished (success=false) + stale cleanup.</li> <li>Success case: ExecutorFinished (success=true) + stale cleanup.</li> <li>Continuation case: New read/write messages.</li> </ul> </li> </ul> </li> </ol>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#executoractionarguments","title":"<code>ExecutorActionArguments</code>","text":"<pre><code><pre>syntax alias ExecutorActionArguments := Unit;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#executoraction","title":"<code>ExecutorAction</code>","text":"<p><pre><code><pre>ExecutorAction : Type :=  Action    ExecutorLocalCfg    ExecutorLocalState    ExecutorMailboxState    ExecutorTimerHandle    ExecutorActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#executoractioninput","title":"<code>ExecutorActionInput</code>","text":"<p><pre><code><pre>ExecutorActionInput : Type :=  ActionInput    ExecutorLocalCfg    ExecutorLocalState    ExecutorMailboxState    ExecutorTimerHandle    ExecutorActionArguments    Anoma.Msg;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#executoractioneffect","title":"<code>ExecutorActionEffect</code>","text":"<p><pre><code><pre>ExecutorActionEffect : Type :=  ActionEffect    ExecutorLocalState    ExecutorMailboxState    ExecutorTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#executoractionexec","title":"<code>ExecutorActionExec</code>","text":"<p><pre><code><pre>ExecutorActionExec : Type :=  ActionExec    ExecutorLocalCfg    ExecutorLocalState    ExecutorMailboxState    ExecutorTimerHandle    ExecutorActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#processreadaction","title":"<code>processReadAction</code>","text":"<p>Process a read response and execute the next program step.</p> State update Updates the program state with executed step results and tracks completed reads/writes Messages to be sent <ul> <li>Read/Write messages to shards based on program outputs</li> </ul> <ul> <li>Notification messages for stale locks if program halts</li> </ul> <ul> <li>ExecutorFinished message if program halts</li> </ul> Engines to be spawned No engines are created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>processReadAction  (input : ExecutorActionInput) : Option (ExecutorActionEffect) :=  let    cfg := EngineCfg.cfg (ActionInput.cfg input);    env := ActionInput.env input;    trigger := ActionInput.trigger input;  in case getMsgFromTimestampedTrigger trigger of       | some (Msg.Shard (ShardMsg.KVSRead KVSReadMsg.mkKVSReadMsg@{                                             key := readKey;                                             data := readValue;                                           })) :=         let           envelope             (target : EngineID) (msg : Anoma.Msg) : EngineMsg Anoma.Msg :=             EngineMsg.mk@{               sender := getEngineIDFromEngineCfg (ActionInput.cfg input);               target := target;               mailbox := some 0;               msg := msg;             };           local := EngineEnv.localState env;           reads := ExecutorLocalState.completed_reads local;           writes := ExecutorLocalState.completed_writes local;           staleReadMsg (key : KVSKey) : EngineMsg Anoma.Msg :=             envelope               (ExecutorLocalCfg.keyToShard cfg key)               (Msg.Shard                 (ShardMsg.KVSReadRequest                   KVSReadRequestMsg.mkKVSReadRequestMsg@{                     timestamp := ExecutorLocalCfg.timestamp cfg;                     key := key;                     actual := false;                   }));           staleWriteMsg (key : KVSKey) : EngineMsg Anoma.Msg :=             envelope               (ExecutorLocalCfg.keyToShard cfg key)               (Msg.Shard                 (ShardMsg.KVSWrite                   KVSWriteMsg.mkKVSWriteMsg@{                     timestamp := ExecutorLocalCfg.timestamp cfg;                     key := key;                     datum := none;                   }));           staleReadLocations :=             Set.difference               (ExecutorLocalCfg.lazy_read_keys cfg)               (Set.fromList (Map.keys reads));           readStaleMsgs := map staleReadMsg (Set.toList staleReadLocations);           staleWriteLocations :=             Set.difference               (ExecutorLocalCfg.may_write_keys cfg)               (Set.fromList (Map.keys writes));           writeStaleMsgs := map staleWriteMsg (Set.toList staleWriteLocations);           staleMsgs := readStaleMsgs ++ writeStaleMsgs;           stepInput := mkPair readKey readValue;           stepResult :=             Runnable.executeStep               (ExecutorLocalCfg.executable cfg)               (ExecutorLocalState.program_state local)               stepInput;         in case stepResult of {              | error err :=                let                  local := EngineEnv.localState env;                  finishedMsg :=                    envelope                      (ExecutorLocalCfg.issuer cfg)                      (Msg.Executor                        (ExecutorMsg.ExecutorFinished                          ExecutorFinishedMsg.mkExecutorFinishedMsg@{                            success := false;                            values_read :=                              mkPair readKey readValue :: Map.toList reads;                            values_written := Map.toList writes;                          }));                in some                  ActionEffect.mk@{                    env := env;                    msgs := finishedMsg :: staleMsgs;                    timers := [];                    engines := [];                  }              | ok (mkPair program' outputs) :=                let                  accReads                    (key : KVSKey)                    (msgs : List (EngineMsg Anoma.Msg))                    : List (EngineMsg Anoma.Msg) :=                    let                      msg :=                        envelope                          (ExecutorLocalCfg.keyToShard cfg key)                          (Msg.Shard                            (ShardMsg.KVSReadRequest                              KVSReadRequestMsg.mkKVSReadRequestMsg@{                                timestamp := ExecutorLocalCfg.timestamp cfg;                                key := key;                                actual := true;                              }));                    in case                         or                           (Set.isMember                             key                             (ExecutorLocalCfg.lazy_read_keys cfg))                           (Set.isMember                             key                             (ExecutorLocalCfg.eager_read_keys cfg))                       of                         | true := msg :: msgs                         | false := msgs;                  accWrites                    (key : KVSKey)                    (value : KVSDatum)                    (msgs : List (EngineMsg Anoma.Msg))                    : List (EngineMsg Anoma.Msg) :=                    let                      msg :=                        envelope                          (ExecutorLocalCfg.keyToShard cfg key)                          (Msg.Shard                            (ShardMsg.KVSWrite                              KVSWriteMsg.mkKVSWriteMsg@{                                timestamp := ExecutorLocalCfg.timestamp cfg;                                key := key;                                datum := some value;                              }));                    in case                         or                           (Set.isMember                             key                             (ExecutorLocalCfg.will_write_keys cfg))                           (Set.isMember                             key                             (ExecutorLocalCfg.may_write_keys cfg))                       of                         | true := msg :: msgs                         | false := msgs;                  sendHelper                    (acc : Pair ExecutorLocalState (List (EngineMsg Anoma.Msg)))                    (out : Either KVSKey (Pair KVSKey KVSDatum))                    : Pair ExecutorLocalState (List (EngineMsg Anoma.Msg)) :=                    let                      state := fst acc;                      msgs := snd acc;                    in case out of                         | left key := mkPair state (accReads key msgs)                         | right (mkPair key value) :=                           let                             newState :=                               state@ExecutorLocalState{completed_writes := Map.insert                                 key                                 value                                 (ExecutorLocalState.completed_writes state)};                           in mkPair newState (accWrites key value msgs);                  initial :=                    mkPair                      local@ExecutorLocalState{                        program_state := program';                        completed_reads := Map.insert                          readKey                          readValue                          (ExecutorLocalState.completed_reads local);                      }                      [];                  final := foldl sendHelper initial outputs;                  newLocalState := fst final;                  msgList := snd final;                  newEnv := env@EngineEnv{localState := newLocalState};                in case Runnable.halted program' of {                     | false :=                       some                         ActionEffect.mk@{                           env := newEnv;                           msgs := msgList;                           timers := [];                           engines := [];                         }                     | true :=                       let                         finishedMsg :=                           envelope                             (ExecutorLocalCfg.issuer cfg)                             (Msg.Executor                               (ExecutorMsg.ExecutorFinished                                 ExecutorFinishedMsg.mkExecutorFinishedMsg@{                                   success := true;                                   values_read := Map.toList reads;                                   values_written := Map.toList writes;                                 }));                       in some                         ActionEffect.mk@{                           env := newEnv;                           msgs := msgList ++ finishedMsg :: staleMsgs;                           timers := [];                           engines := [];                         }                   }            }       | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#action-labels","title":"Action Labels","text":"<pre><code><pre>processReadActionLabel : ExecutorActionExec :=  ActionExec.Seq [processReadAction];</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#executorguard","title":"<code>ExecutorGuard</code>","text":"<p> <pre><code><pre>ExecutorGuard : Type :=  Guard    ExecutorLocalCfg    ExecutorLocalState    ExecutorMailboxState    ExecutorTimerHandle    ExecutorActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#executorguardoutput","title":"<code>ExecutorGuardOutput</code>","text":"<p> <pre><code><pre>ExecutorGuardOutput : Type :=  GuardOutput    ExecutorLocalCfg    ExecutorLocalState    ExecutorMailboxState    ExecutorTimerHandle    ExecutorActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#executorguardeval","title":"<code>ExecutorGuardEval</code>","text":"<p> <pre><code><pre>ExecutorGuardEval : Type :=  GuardEval    ExecutorLocalCfg    ExecutorLocalState    ExecutorMailboxState    ExecutorTimerHandle    ExecutorActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#processreadguard","title":"<code>processReadGuard</code>","text":"<p>Guard for processing read responses.</p> <pre><code><pre>processReadGuard  (trigger : TimestampedTrigger ExecutorTimerHandle Anoma.Msg)  (cfg : ExecutorCfg)  (env : ExecutorEnv)  : Option ExecutorGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{             msg := Msg.Shard (ShardMsg.KVSRead KVSReadMsg.mkKVSReadMsg@{                                                  timestamp := timestamp;                                                  key := _;                                                  data := _;                                                });           } :=      case timestamp == ExecutorLocalCfg.timestamp (EngineCfg.cfg cfg) of {        | true :=          some            GuardOutput.mk@{              action := processReadActionLabel;              args := unit;            }        | false := none      }    | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#the-executor-behaviour","title":"The Executor Behaviour","text":"","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#executorbehaviour","title":"<code>ExecutorBehaviour</code>","text":"<pre><code><pre>ExecutorBehaviour : Type :=  EngineBehaviour    ExecutorLocalCfg    ExecutorLocalState    ExecutorMailboxState    ExecutorTimerHandle    ExecutorActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>executorBehaviour : ExecutorBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [processReadGuard];  };</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","behaviour"]},{"location":"arch/node/engines/executor_config.html","title":"Executor Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.executor_config;import prelude open;import arch.node.engines.executor_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.system.state.resource_machine.notes.nockma open;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","executor","configuration"]},{"location":"arch/node/engines/executor_config.html#executor-configuration","title":"Executor Configuration","text":"","tags":["node-architecture","ordering-subsystem","engine","executor","configuration"]},{"location":"arch/node/engines/executor_config.html#overview","title":"Overview","text":"<p>The executor configuration contains static information needed for execution: the transaction program, access rights, and notification targets.</p>","tags":["node-architecture","ordering-subsystem","engine","executor","configuration"]},{"location":"arch/node/engines/executor_config.html#the-executor-local-configuration","title":"The Executor Local Configuration","text":"","tags":["node-architecture","ordering-subsystem","engine","executor","configuration"]},{"location":"arch/node/engines/executor_config.html#executorlocalcfg","title":"<code>ExecutorLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type ExecutorLocalCfg :=  mk@{    timestamp : TxFingerprint;    executable : Executable;    lazy_read_keys : Set KVSKey;    eager_read_keys : Set KVSKey;    will_write_keys : Set KVSKey;    may_write_keys : Set KVSKey;    worker : EngineID;    issuer : EngineID;    keyToShard : KVSKey -&gt; EngineID;  };</pre></code></pre> Arguments <code>timestamp</code> The logical timestamp representing when this transaction executes in the ordering <code>executable</code> The transaction's executable code <code>lazy_read_keys</code> Keys that may be read during execution <code>eager_read_keys</code> Keys that will definitely be read <code>will_write_keys</code> Keys that will definitely be written <code>may_write_keys</code> Keys that might be written <code>worker</code> ID of the worker engine to notify on completion <code>issuer</code> ID of the transaction sender to notify on completion","tags":["node-architecture","ordering-subsystem","engine","executor","configuration"]},{"location":"arch/node/engines/executor_config.html#the-executor-configuration","title":"The Executor Configuration","text":"","tags":["node-architecture","ordering-subsystem","engine","executor","configuration"]},{"location":"arch/node/engines/executor_config.html#executorcfg","title":"<code>ExecutorCfg</code>","text":"<pre><code><pre>ExecutorCfg : Type := EngineCfg ExecutorLocalCfg;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","configuration"]},{"location":"arch/node/engines/executor_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>executorCfg : ExecutorCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"executor\";    cfg :=      ExecutorLocalCfg.mk@{        timestamp := 0;        executable := Noun.Atom 0;        lazy_read_keys := Set.empty;        eager_read_keys := Set.empty;        will_write_keys := Set.empty;        may_write_keys := Set.empty;        worker := mkPair none \"\";        issuer := mkPair none \"\";        keyToShard := \\{_ := mkPair none \"shard\"};      };  };</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","configuration"]},{"location":"arch/node/engines/executor_environment.html","title":"Executor Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.executor_environment;import prelude open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.engine_environment open;import arch.node.engines.executor_messages open;import arch.node.types.anoma_message as Anoma open;import arch.system.state.resource_machine.notes.nockma open;import arch.system.state.resource_machine.notes.runnable open;import arch.system.state.resource_machine.notes.nockma_runnable open;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","executor","environment"]},{"location":"arch/node/engines/executor_environment.html#executor-environment","title":"Executor Environment","text":"","tags":["node-architecture","ordering-subsystem","engine","executor","environment"]},{"location":"arch/node/engines/executor_environment.html#overview","title":"Overview","text":"<p>The executor environment maintains state needed during transaction execution including completed reads/writes and program state.</p>","tags":["node-architecture","ordering-subsystem","engine","executor","environment"]},{"location":"arch/node/engines/executor_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The executor engine does not require complex mailbox states.</p>","tags":["node-architecture","ordering-subsystem","engine","executor","environment"]},{"location":"arch/node/engines/executor_environment.html#executormailboxstate","title":"<code>ExecutorMailboxState</code>","text":"<pre><code><pre>syntax alias ExecutorMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","environment"]},{"location":"arch/node/engines/executor_environment.html#local-state","title":"Local state","text":"","tags":["node-architecture","ordering-subsystem","engine","executor","environment"]},{"location":"arch/node/engines/executor_environment.html#executorlocalstate","title":"<code>ExecutorLocalState</code>","text":"<pre><code><pre>type ExecutorLocalState :=  mk@{    program_state : ProgramState;    completed_reads : Map KVSKey KVSDatum;    completed_writes : Map KVSKey KVSDatum;  };</pre></code></pre> Arguments <code>program_state</code> Current state of the executing program <code>completed_reads</code> Map of keys to values that have been successfully read <code>completed_writes</code> Map of keys to values that have been successfully written","tags":["node-architecture","ordering-subsystem","engine","executor","environment"]},{"location":"arch/node/engines/executor_environment.html#timer-handle","title":"Timer Handle","text":"<p>The executor engine does not require timer handles.</p>","tags":["node-architecture","ordering-subsystem","engine","executor","environment"]},{"location":"arch/node/engines/executor_environment.html#executortimerhandle","title":"<code>ExecutorTimerHandle</code>","text":"<pre><code><pre>syntax alias ExecutorTimerHandle := Unit;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","environment"]},{"location":"arch/node/engines/executor_environment.html#the-executor-environment","title":"The Executor Environment","text":"","tags":["node-architecture","ordering-subsystem","engine","executor","environment"]},{"location":"arch/node/engines/executor_environment.html#executorenv","title":"<code>ExecutorEnv</code>","text":"<pre><code><pre>ExecutorEnv : Type :=  EngineEnv    ExecutorLocalState    ExecutorMailboxState    ExecutorTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","environment"]},{"location":"arch/node/engines/executor_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>executorEnv : ExecutorEnv :=  EngineEnv.mk@{    localState :=      ExecutorLocalState.mk@{        program_state :=          NockmaProgramState.mk@{            current_noun := Noun.Atom 0;            storage := emptyStorage;            gas_limit := 0;          };        completed_reads := Map.empty;        completed_writes := Map.empty;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","environment"]},{"location":"arch/node/engines/executor_messages.html","title":"Executor Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.executor_messages;import prelude open;import arch.node.types.basics open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","executor","message-types"]},{"location":"arch/node/engines/executor_messages.html#executor-messages","title":"Executor Messages","text":"<p>These are the specific messages that the Executor engine can receive/respond to.</p>","tags":["node-architecture","ordering-subsystem","engine","executor","message-types"]},{"location":"arch/node/engines/executor_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type ExecutorMsg := | ExecutorFinished ExecutorFinishedMsg;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","message-types"]},{"location":"arch/node/engines/executor_messages.html#message-sequence-diagram","title":"Message sequence diagram","text":"","tags":["node-architecture","ordering-subsystem","engine","executor","message-types"]},{"location":"arch/node/engines/executor_messages.html#execution-flow","title":"Execution flow","text":"<pre><code>sequenceDiagram\n    participant Executor\n    participant Shard\n    participant Worker\n\n    Executor-&gt;&gt;Shard: KVSReadRequest\n    Shard-&gt;&gt;Executor: KVSRead\n    Executor-&gt;&gt;Shard: KVSWrite\n    Executor-&gt;&gt;Worker: ExecutorFinished</code></pre>  Basic execution flow sequence showing interaction with shards and completion notification","tags":["node-architecture","ordering-subsystem","engine","executor","message-types"]},{"location":"arch/node/engines/executor_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","ordering-subsystem","engine","executor","message-types"]},{"location":"arch/node/engines/executor_messages.html#executorfinishedmsg","title":"<code>ExecutorFinishedMsg</code>","text":"<p>Notification that execution is complete.</p> <pre><code><pre>type ExecutorFinishedMsg :=  mkExecutorFinishedMsg@{    success : Bool;    values_read : List (Pair KVSKey KVSDatum);    values_written : List (Pair KVSKey KVSDatum);  };</pre></code></pre> Arguments <code>success</code> Whether execution completed successfully <code>values_read</code> List of all key-value pairs that were read <code>values_written</code> List of all key-value pairs that were written","tags":["node-architecture","ordering-subsystem","engine","executor","message-types"]},{"location":"arch/node/engines/executor_messages.html#executormsg","title":"<code>ExecutorMsg</code>","text":"<pre><code><pre>type ExecutorMsg := | ExecutorFinished ExecutorFinishedMsg;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","executor","message-types"]},{"location":"arch/node/engines/executor_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Executor Configuration</li> <li>Executor Environment</li> <li>Executor Behaviour</li> </ul>","tags":["node-architecture","ordering-subsystem","engine","executor","message-types"]},{"location":"arch/node/engines/identity_management.html","title":"Identity Management Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.identity_management;import prelude open;import arch.node.types.engine open;import arch.node.engines.identity_management_messages open public;import arch.node.engines.identity_management_environment open public;import arch.node.engines.identity_management_behaviour open public;import arch.node.engines.identity_management_config open public;import arch.node.engines.identity_management_messages open public;import arch.node.engines.identity_management_environment open public;import arch.node.engines.identity_management_behaviour open public;import arch.node.types.anoma as Anoma open;open identity_management_config_example;open identity_management_environment_example;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","identity-management","engine-definition"]},{"location":"arch/node/engines/identity_management.html#identitymanagement-engine","title":"IdentityManagement Engine","text":"<p>The Identity Management Engine serves as the central coordinator for identity operations within Anoma, managing the entire lifecycle of identities across various storage systems (called \"backends\"). These backends provide a service such as creating new identities, connecting to existing ones, and managing their cryptographic capabilities (commiting and decrypting), while abstracting away the complexity of different storage systems (e.g., local memory, hardware devices, browser extensions, and remote machines).</p> <p>Users can request new identity generation (via a <code>MsgIdentityManagementGenerateIdentityRequest</code> message) or connection to existing identities (via a <code>MsgIdentityManagementConnectIdentityRequest</code> message), specifying their desired capabilities. The Capabilities system in Anoma provides fine-grained control over what operations an identity can perform. Each identity can have commitment (signing) capabilities, decryption capabilities, or both. When you create or connect to an identity, you specify exactly which capabilities you need (via a term of the <code>Capabilities</code> type), and the Identity Management Engine ensures you only get access to those specific operations. <code>CapabilityCommit</code> allows an identity to sign data - useful when you need to prove authenticity or authorize actions but don't need to read encrypted messages. <code>CapabilityDecrypt</code> enables decryption of messages intended for that identity - essential when you need to receive encrypted communications but don't need to sign anything. <code>CapabilityCommitAndDecrypt</code> provides both abilities, letting an identity both sign data and decrypt messages.</p> <p>When connecting to an existing identity, you can request a subset of that identity's capabilities but never more than it has. For example, if an identity was created with only <code>CapabilityCommit</code>, you cannot request decryption capabilities when connecting to it. The Identity Management Engine enforces these restrictions and will return an error if you request capabilities that are not available.</p> <p>The Identity Management Engine handles the creation or connection process and returns references to the appropriate Commitment and Decryption  engines (via either a <code>ReplyGenerateIdentity</code> or <code>MsgIdentityManagementConnectIdentityRequest</code> message) that provide the requested capabilities. These engines are newly created in the case of identity creation. Which engines are spawned are determined by the requested capabilities.</p> <p>Identity Management Engines maintain a registry of active identities and their capabilities. When an identity is no longer needed, it can be cleanly removed (via a <code>MsgIdentityManagementDeleteIdentityRequest</code> message).</p>","tags":["node-architecture","identity-subsystem","engine","identity-management","engine-definition"]},{"location":"arch/node/engines/identity_management.html#engine-components","title":"Engine components","text":"<ul> <li>Identity Management Messages</li> <li>Identity Management Configuration</li> <li>Identity Management Environment</li> <li>Identity Management Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","identity-management","engine-definition"]},{"location":"arch/node/engines/identity_management.html#type","title":"Type","text":"<pre><code><pre>IdentityManagementEngine : Type :=  Engine    IdentityManagementLocalCfg    IdentityManagementLocalState    IdentityManagementMailboxState    IdentityManagementTimerHandle    IdentityManagementActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","engine-definition"]},{"location":"arch/node/engines/identity_management.html#example-of-a-identity-management-engine","title":"Example of a identity management engine","text":"<pre><code><pre>exampleIdentityManagementEngine : IdentityManagementEngine :=  Engine.mk@{    cfg := identityManagementCfg;    env := identityManagementEnv;    behaviour := identityManagementBehaviour;  };</pre></code></pre> <p>where <code>identityManagementCfg</code> is defined as follows:</p> <pre><code><pre>identityManagementCfg : IdentityManagementCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"identity management\";    cfg := IdentityManagementLocalCfg.mk;  };</pre></code></pre> <p><code>identityManagementEnv</code> is defined as follows:</p> <pre><code><pre>identityManagementEnv : IdentityManagementEnv :=  EngineEnv.mk@{    localState :=      IdentityManagementLocalState.mk@{        identities := Map.empty;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>identityManagementBehaviour</code> is defined as follows:</p> <pre><code><pre>identityManagementBehaviour : IdentityManagementBehaviour :=  EngineBehaviour.mk@{    guards :=      GuardEval.First        [generateIdentityGuard; connectIdentityGuard; deleteIdentityGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","engine-definition"]},{"location":"arch/node/engines/identity_management_behaviour.html","title":"Identity Management Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.identity_management_behaviour;import prelude open;import arch.node.engines.commitment_config open;import arch.node.engines.decryption_config open;import arch.node.engines.commitment_environment open;import arch.node.engines.decryption_environment open;import arch.node.engines.identity_management_environment open;import arch.node.engines.identity_management_messages open;import arch.node.engines.identity_management_config open;import arch.node.types.anoma as Anoma open;import arch.node.types.engine open;import arch.node.types.engine_environment open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.system.identity.identity open hiding {ExternalIdentity};</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#identity-management-behaviour","title":"Identity Management Behaviour","text":"","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#overview","title":"Overview","text":"<p>The behaviour of the Identity Management Engine defines how it coordinates committing/signing and decrypting operations through the spawning of engines for these functions along with maintaining a database which may be modified through the creation, connection, and deletion of identities associated with specific capabilities.</p>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#identity-management-action-flowcharts","title":"Identity Management Action Flowcharts","text":"","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#generateidentityaction-flowchart","title":"<code>generateIdentityAction</code> flowchart","text":"<pre><code>flowchart TD\n    Start([Generate Request]) --&gt; MsgReq[MsgIdentityManagementGenerateIdentityRequest&lt;br/&gt;backend: Backend&lt;br/&gt;params: IDParams&lt;br/&gt;capabilities: Capabilities]\n\n    subgraph Guard[\"generateIdentityGuard\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br/&gt;GenerateIdentityRequest?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"generateIdentityAction\"]\n        direction TB\n        Check{Identity already&lt;br/&gt;exists?}\n        Check --&gt;|Yes| ErrExists[Create Error Reply]\n        Check --&gt;|No| Create[Create new identity info]\n        Create --&gt; SpawnEngines{Which capabilities?}\n        SpawnEngines --&gt;|Commit| SpawnCommit[Spawn Commitment Engine]\n        SpawnEngines --&gt;|Decrypt| SpawnDecrypt[Spawn Decryption Engine]\n        SpawnEngines --&gt;|Both| SpawnBoth[Spawn Both Engines]\n        SpawnCommit &amp; SpawnDecrypt &amp; SpawnBoth --&gt; UpdateState[Update registry]\n    end\n\n    UpdateState --&gt; Reply[Success Reply&lt;br/&gt;with engine IDs]\n    ErrExists --&gt; ErrReply[Error Reply]\n    Reply &amp; ErrReply --&gt; Client([Return to Client])</code></pre> <code>generateIdentityAction</code> flowchart","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#explanation","title":"Explanation","text":"<ol> <li> <p>Initial Request</p> <ul> <li>A client sends a <code>MsgIdentityManagementGenerateIdentityRequest</code> containing:<ul> <li><code>backend</code>: Specifies backend to be used</li> <li><code>params</code>: Cryptographic parameters</li> <li><code>capabilities</code>: Which capabilities are needed (commit, decrypt, or both)</li> </ul> </li> <li>The requesting identity must not already exist in the system</li> </ul> </li> <li> <p>Guard Phase (<code>generateIdentityGuard</code>)</p> <ul> <li>Validates incoming message structure and type</li> <li>Validation steps:<ul> <li>Verifies message type is <code>MsgIdentityManagementGenerateIdentityRequest</code></li> <li>If validation fails, request is rejected immediately</li> <li>On success, passes control to <code>generateIdentityActionLabel</code></li> </ul> </li> </ul> </li> <li> <p>Action Phase (<code>generateIdentityAction</code>)</p> <ul> <li>Processes valid generation requests through these steps:<ul> <li>Checks if requesting identity already exists in registry</li> <li>Creates new identity info with specified backend and capabilities</li> <li>Spawns appropriate engine(s) based on requested capabilities</li> <li>Updates identity registry with new identity and engine references</li> <li>Constructs appropriate response based on result</li> </ul> </li> </ul> </li> <li> <p>Reply Generation</p> <ul> <li>Successful Case<ul> <li>Creates <code>MsgIdentityManagementGenerateIdentityReply</code> with:<ul> <li><code>commitmentEngine</code>: Engine ID if commit capability requested, None otherwise</li> <li><code>decryptionEngine</code>: Engine ID if decrypt capability requested, None otherwise</li> <li><code>externalIdentity</code>: ID of the newly created identity</li> <li><code>err</code>: None</li> </ul> </li> </ul> </li> <li>Error Case<ul> <li>Creates <code>MsgIdentityManagementGenerateIdentityReply</code> with:<ul> <li><code>commitmentEngine</code>: None</li> <li><code>decryptionEngine</code>: None</li> <li><code>externalIdentity</code>: Requester's ID</li> <li><code>err</code>: Some \"Identity already exists\"</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Reply Delivery</p> <ul> <li>Reply is sent back to the original requester</li> <li>Uses mailbox 0 (default mailbox for responses)</li> </ul> </li> </ol>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#connectidentityaction-flowchart","title":"<code>connectIdentityAction</code> flowchart","text":"<pre><code>flowchart TD\n    Start([Connect Request]) --&gt; MsgReq[MsgIdentityManagementConnectIdentityRequest&lt;br/&gt;externalIdentity: EngineID&lt;br/&gt;backend: Backend&lt;br/&gt;capabilities: Capabilities]\n\n    subgraph Guard[\"connectIdentityGuard\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br/&gt;ConnectIdentityRequest?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"connectIdentityAction\"]\n        direction TB\n        Check{Requesting Identity&lt;br/&gt;exists?}\n        Check --&gt;|Yes| ErrExists[Create Error Reply]\n        Check --&gt;|No| FindExternal{External Identity&lt;br/&gt;exists?}\n        FindExternal --&gt;|No| ErrNotFound[Error: Not Found]\n        FindExternal --&gt;|Yes| CheckCaps{Requested capabilities&lt;br/&gt;subset of original?}\n        CheckCaps --&gt;|No| ErrCaps[Error: Invalid Capabilities]\n        CheckCaps --&gt;|Yes| CopyEngines[Copy Engine References]\n        CopyEngines --&gt; UpdateState[Update registry]\n    end\n\n    UpdateState --&gt; Reply[Success Reply&lt;br/&gt;with engine IDs]\n    ErrExists &amp; ErrNotFound &amp; ErrCaps --&gt; ErrReply[Error Reply]\n    Reply &amp; ErrReply --&gt; Client([Return to Client])</code></pre> <code>connectIdentityAction</code> flowchart","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#explanation_1","title":"Explanation","text":"<ol> <li> <p>Initial Request</p> <ul> <li>A client sends a <code>MsgIdentityManagementConnectIdentityRequest</code> containing:<ul> <li><code>externalIdentity</code>: ID of the existing identity to connect to</li> <li><code>backend</code>: Backend to use</li> <li><code>capabilities</code>: Which subset of the original identity's capabilities are requested</li> </ul> </li> <li>The requesting identity must not already exist in the system</li> <li>The external identity must exist and have at least the requested capabilities</li> </ul> </li> <li> <p>Guard Phase (<code>connectIdentityGuard</code>)</p> <ul> <li>Validates incoming message structure and type</li> <li>Validation steps:<ul> <li>Verifies message type is <code>MsgIdentityManagementConnectIdentityRequest</code></li> <li>If validation fails, request is rejected immediately</li> <li>On success, passes control to <code>connectIdentityActionLabel</code></li> </ul> </li> </ul> </li> <li> <p>Action Phase (<code>connectIdentityAction</code>)</p> <ul> <li>Processes valid connection requests through these steps:<ul> <li>Verifies requesting identity doesn't already exist</li> <li>Checks if external identity exists in registry</li> <li>Validates requested capabilities are subset of original</li> <li>Copies relevant engine references based on capabilities</li> <li>Updates identity registry with new connected identity</li> <li>Constructs appropriate response based on result</li> </ul> </li> </ul> </li> <li> <p>Reply Generation</p> <ul> <li>Successful Case<ul> <li>Creates <code>MsgIdentityManagementConnectIdentityReply</code> with:<ul> <li><code>commitmentEngine</code>: Copied engine ID if commit capability requested, None otherwise</li> <li><code>decryptionEngine</code>: Copied engine ID if decrypt capability requested, None otherwise</li> <li><code>err</code>: None</li> </ul> </li> </ul> </li> <li>Error Cases<ul> <li>Creates <code>MsgIdentityManagementConnectIdentityReply</code> with:<ul> <li><code>commitmentEngine</code>: None</li> <li><code>decryptionEngine</code>: None</li> <li><code>err</code>: Some error message:<ul> <li>\"Identity already exists\" if requesting identity exists</li> <li>\"External identity not found\" if target doesn't exist</li> <li>\"Capabilities not available\" if capability subset invalid</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Reply Delivery</p> <ul> <li>Reply is sent back to the original requester</li> <li>Uses mailbox 0 (default mailbox for responses)</li> </ul> </li> </ol>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#deleteidentityaction-flowchart","title":"<code>deleteIdentityAction</code> flowchart","text":"<pre><code>flowchart TD\n    Start([Delete Request]) --&gt; MsgReq[MsgIdentityManagementDeleteIdentityRequest&lt;br/&gt;externalIdentity: EngineID&lt;br/&gt;backend: Backend]\n\n    subgraph Guard[\"deleteIdentityGuard\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br/&gt;DeleteIdentityRequest?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"deleteIdentityAction\"]\n        direction TB\n        Check{Identity exists?}\n        Check --&gt;|No| ErrNoExist[Create Error Reply]\n        Check --&gt;|Yes| Delete[Remove from registry]\n    end\n\n    Delete --&gt; Reply[Success Reply]\n    ErrNoExist --&gt; ErrReply[Error Reply]\n    Reply &amp; ErrReply --&gt; Client([Return to Client])\n\n    style Guard fill:#f0f7ff,stroke:#333,stroke-width:2px\n    style Action fill:#fff7f0,stroke:#333,stroke-width:2px</code></pre> <code>deleteIdentityAction</code> flowchart","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#explanation_2","title":"Explanation","text":"<ol> <li> <p>Initial Request</p> <ul> <li>A client sends a <code>MsgIdentityManagementDeleteIdentityRequest</code> containing:<ul> <li><code>externalIdentity</code>: ID of the identity to delete</li> <li><code>backend</code>: Backend system where the identity exists</li> </ul> </li> <li>The identity to be deleted must exist in the system</li> </ul> </li> <li> <p>Guard Phase (<code>deleteIdentityGuard</code>)</p> <ul> <li>Validates incoming message structure and type</li> <li>Validation steps:<ul> <li>Verifies message type is <code>MsgIdentityManagementDeleteIdentityRequest</code></li> <li>If validation fails, request is rejected immediately</li> <li>On success, passes control to <code>deleteIdentityActionLabel</code></li> </ul> </li> </ul> </li> <li> <p>Action Phase (<code>deleteIdentityAction</code>)</p> <ul> <li>Processes valid deletion requests through these steps:<ul> <li>Verifies identity exists in registry</li> <li>Removes identity and associated engine references from registry</li> <li>Constructs appropriate response based on result</li> </ul> </li> </ul> </li> <li> <p>Reply Generation</p> <ul> <li>Successful Case<ul> <li>Creates <code>MsgIdentityManagementDeleteIdentityReply</code> with:<ul> <li><code>err</code>: None</li> </ul> </li> </ul> </li> <li>Error Case<ul> <li>Creates <code>MsgIdentityManagementDeleteIdentityReply</code> with:<ul> <li><code>err</code>: Some \"Identity does not exist\"</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Reply Delivery</p> <ul> <li>Reply is sent back to the original requester</li> <li>Uses mailbox 0 (default mailbox for responses)</li> </ul> </li> </ol> <p>Important Notes</p> <ul> <li>All spawned engines inherit the backend from the generation request</li> <li>Engine references are managed through the identity management engine's state</li> <li>Capabilities can only be restricted when connecting, never expanded</li> <li>The system maintains a mapping between identities and their associated engine references</li> <li>Each identity maintains its own separate set of engines</li> <li>State updates are atomic - either all parts succeed or none do</li> </ul>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#messagefrom","title":"<code>MessageFrom</code>","text":"<pre><code><pre>type MessageFrom :=  mkMessageFrom@{    whoAsked : Option EngineID;    mailbox : Option MailboxID;  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#identitymanagementactionargument","title":"<code>IdentityManagementActionArgument</code>","text":"<pre><code><pre>type IdentityManagementActionArgument :=  | IdentityManagementActionArgumentMessageFrom MessageFrom;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#identitymanagementactionarguments","title":"<code>IdentityManagementActionArguments</code>","text":"<pre><code><pre>IdentityManagementActionArguments : Type :=  List IdentityManagementActionArgument;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#identitymanagementaction","title":"<code>IdentityManagementAction</code>","text":"<p><pre><code><pre>IdentityManagementAction : Type :=  Action    IdentityManagementLocalCfg    IdentityManagementLocalState    IdentityManagementMailboxState    IdentityManagementTimerHandle    IdentityManagementActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#identitymanagementactioninput","title":"<code>IdentityManagementActionInput</code>","text":"<p><pre><code><pre>IdentityManagementActionInput : Type :=  ActionInput    IdentityManagementLocalCfg    IdentityManagementLocalState    IdentityManagementMailboxState    IdentityManagementTimerHandle    IdentityManagementActionArguments    Anoma.Msg;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#identitymanagementactioneffect","title":"<code>IdentityManagementActionEffect</code>","text":"<p><pre><code><pre>IdentityManagementActionEffect : Type :=  ActionEffect    IdentityManagementLocalState    IdentityManagementMailboxState    IdentityManagementTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#identitymanagementactionexec","title":"IdentityManagementActionExec","text":"<p><pre><code><pre>IdentityManagementActionExec : Type :=  ActionExec    IdentityManagementLocalCfg    IdentityManagementLocalState    IdentityManagementMailboxState    IdentityManagementTimerHandle    IdentityManagementActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#hascommitcapability","title":"<code>hasCommitCapability</code>","text":"<p><pre><code><pre>hasCommitCapability (capabilities : Capabilities) : Bool :=  case capabilities of    | Capabilities.Commit := true    | Capabilities.CommitAndDecrypt := true    | _ := false;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#hasdecryptcapability","title":"<code>hasDecryptCapability</code>","text":"<p><pre><code><pre>hasDecryptCapability (capabilities : Capabilities) : Bool :=  case capabilities of    | Capabilities.Decrypt := true    | Capabilities.CommitAndDecrypt := true    | _ := false;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#issubsetcapabilities","title":"<code>isSubsetCapabilities</code>","text":"<p><pre><code><pre>isSubsetCapabilities  (requested : Capabilities) (available : Capabilities) : Bool :=  (not (hasCommitCapability requested) || hasCommitCapability available)    &amp;&amp; not (hasDecryptCapability requested)    || hasDecryptCapability available;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#updateidentityandspawnengines","title":"<code>updateIdentityAndSpawnEngines</code>","text":"<p><pre><code><pre>updateIdentityAndSpawnEngines  (env : IdentityManagementEnv)  (cfg : IdentityManagementCfg)  (backend' : Backend)  (whoAsked : EngineID)  (identityInfo : IdentityInfo)  (capabilities' : Capabilities)  : Pair IdentityInfo (List (Pair Cfg Env)) :=  let    decryptionConfig : DecryptionCfg :=      EngineCfg.mk@{        node := EngineCfg.node cfg;        name := nameGen \"decryptor\" (snd whoAsked) whoAsked;        cfg :=          DecryptionLocalCfg.mk@{            decryptor := genDecryptor backend';            backend := backend';          };      };    decryptionEnv : DecryptionEnv :=      EngineEnv.mk@{        localState := unit;        mailboxCluster := Map.empty;        acquaintances := Set.empty;        timers := [];      };    decryptionEng : Pair Cfg Env :=      mkPair        (Cfg.CfgDecryption decryptionConfig)        (Env.EnvDecryption decryptionEnv);    commitmentConfig : CommitmentCfg :=      EngineCfg.mk@{        node := EngineCfg.node cfg;        name := nameGen \"committer\" (snd whoAsked) whoAsked;        cfg :=          CommitmentLocalCfg.mk@{            signer := genSigner backend';            backend := backend';          };      };    commitmentEnv : CommitmentEnv :=      EngineEnv.mk@{        localState := unit;        mailboxCluster := Map.empty;        acquaintances := Set.empty;        timers := [];      };    commitmentEng : Pair Cfg Env :=      mkPair        (Cfg.CfgCommitment commitmentConfig)        (Env.EnvCommitment commitmentEnv);  in case capabilities' of       | Capabilities.CommitAndDecrypt :=         let           spawnedEngines := [decryptionEng; commitmentEng];           commitmentEngineName := nameGen \"committer\" (snd whoAsked) whoAsked;           decryptionEngineName := nameGen \"decryptor\" (snd whoAsked) whoAsked;           updatedIdentityInfo1 :=             identityInfo@IdentityInfo{               commitmentEngine := some (mkPair none commitmentEngineName);               decryptionEngine := some (mkPair none decryptionEngineName);             };         in mkPair updatedIdentityInfo1 spawnedEngines       | Capabilities.Commit :=         let           spawnedEngines := [commitmentEng];           commitmentEngineName := nameGen \"committer\" (snd whoAsked) whoAsked;           updatedIdentityInfo1 :=             identityInfo@IdentityInfo{commitmentEngine := some               (mkPair none commitmentEngineName)};         in mkPair updatedIdentityInfo1 spawnedEngines       | Capabilities.Decrypt :=         let           spawnedEngines := [decryptionEng];           decryptionEngineName := nameGen \"decryptor\" (snd whoAsked) whoAsked;           updatedIdentityInfo1 :=             identityInfo@IdentityInfo{decryptionEngine := some               (mkPair none decryptionEngineName)};         in mkPair updatedIdentityInfo1 spawnedEngines;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#copyenginesforcapabilities","title":"<code>copyEnginesForCapabilities</code>","text":"<p><pre><code><pre>copyEnginesForCapabilities  (env : IdentityManagementEnv)  (whoAsked : EngineID)  (externalIdentityInfo : IdentityInfo)  (requestedCapabilities : Capabilities)  : IdentityInfo :=  let    newIdentityInfo :=      IdentityInfo.mkIdentityInfo@{        backend := IdentityInfo.backend externalIdentityInfo;        capabilities := requestedCapabilities;        commitmentEngine :=          case hasCommitCapability requestedCapabilities of            | true := IdentityInfo.commitmentEngine externalIdentityInfo            | false := none;        decryptionEngine :=          case hasDecryptCapability requestedCapabilities of            | true := IdentityInfo.decryptionEngine externalIdentityInfo            | false := none;      };  in newIdentityInfo;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#generateidentityaction","title":"<code>generateIdentityAction</code>","text":"State update A new identity is created and added to the identities map if it doesn't exist. Messages to be sent A GenerateIdentityReply message containing the new identity info or error. Engines to be spawned Commitment and/or Decryption engines based on capabilities. Timer updates No timers are set or cancelled. <pre><code><pre>generateIdentityAction  (input : IdentityManagementActionInput)  : Option IdentityManagementActionEffect :=  let    env := ActionInput.env input;    local := EngineEnv.localState env;    identities := IdentityManagementLocalState.identities local;    trigger := ActionInput.trigger input;  in case getEngineMsgFromTimestampedTrigger trigger of       | some emsg :=         let           whoAsked := EngineMsg.sender emsg;         in case Map.lookup whoAsked identities of {              | some _ :=                some                  ActionEffect.mk@{                    env := env;                    msgs :=                      [                        EngineMsg.mk@{                          sender :=                            getEngineIDFromEngineCfg (ActionInput.cfg input);                          target := whoAsked;                          mailbox := some 0;                          msg :=                            Msg.IdentityManagement                              (IdentityManagementMsg.GenerateIdentityReply                                ReplyGenerateIdentity.mkReplyGenerateIdentity@{                                  commitmentEngine := none;                                  decryptionEngine := none;                                  externalIdentity := whoAsked;                                  err := some \"Identity already exists\";                                });                        };                      ];                    timers := [];                    engines := [];                  }              | none :=                case emsg of {                  | EngineMsg.mk@{                      msg := Anoma.Msg.IdentityManagement (IdentityManagementMsg.GenerateIdentityRequest (RequestGenerateIdentity.mkRequestGenerateIdentity backend' params' capabilities'));                    } :=                    let                      identityInfo :=                        IdentityInfo.mkIdentityInfo@{                          backend := backend';                          capabilities := capabilities';                          commitmentEngine := none;                          decryptionEngine := none;                        };                      pair' :=                        updateIdentityAndSpawnEngines                          env                          (ActionInput.cfg input)                          backend'                          whoAsked                          identityInfo                          capabilities';                      updatedIdentityInfo := fst pair';                      spawnedEnginesFinal := snd pair';                      updatedIdentities :=                        Map.insert whoAsked updatedIdentityInfo identities;                      newLocalState :=                        local@IdentityManagementLocalState{identities := updatedIdentities};                      newEnv' := env@EngineEnv{localState := newLocalState};                    in some                      ActionEffect.mk@{                        env := newEnv';                        msgs :=                          [                            EngineMsg.mk@{                              sender :=                                getEngineIDFromEngineCfg                                  (ActionInput.cfg input);                              target := whoAsked;                              mailbox := some 0;                              msg :=                                Msg.IdentityManagement                                  (IdentityManagementMsg.GenerateIdentityReply                                    ReplyGenerateIdentity.mkReplyGenerateIdentity@{                                      commitmentEngine :=                                        IdentityInfo.commitmentEngine                                          updatedIdentityInfo;                                      decryptionEngine :=                                        IdentityInfo.decryptionEngine                                          updatedIdentityInfo;                                      externalIdentity := whoAsked;                                      err := none;                                    });                            };                          ];                        timers := [];                        engines := spawnedEnginesFinal;                      }                  | _ := none                }            }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#connectidentityaction","title":"<code>connectIdentityAction</code>","text":"State update A new identity is created with copied capabilities if valid. Messages to be sent A <code>ConnectIdentityReply</code> message with confirmation or error. Engines to be spawned No new engines are spawned. Timer updates No timers are set or cancelled. <pre><code><pre>connectIdentityAction  (input : IdentityManagementActionInput)  : Option IdentityManagementActionEffect :=  let    env := ActionInput.env input;    local := EngineEnv.localState env;    identities := IdentityManagementLocalState.identities local;    trigger := ActionInput.trigger input;  in case getEngineMsgFromTimestampedTrigger trigger of       | some emsg :=         let           whoAsked := EngineMsg.sender emsg;         in case Map.lookup whoAsked identities of {              | some _ :=                some                  ActionEffect.mk@{                    env := env;                    msgs :=                      [                        EngineMsg.mk@{                          sender :=                            getEngineIDFromEngineCfg (ActionInput.cfg input);                          target := whoAsked;                          mailbox := some 0;                          msg :=                            Msg.IdentityManagement                              (IdentityManagementMsg.ConnectIdentityReply                                ReplyConnectIdentity.mkReplyConnectIdentity@{                                  commitmentEngine := none;                                  decryptionEngine := none;                                  err := some \"Identity already exists\";                                });                        };                      ];                    timers := [];                    engines := [];                  }              | none :=                case emsg of {                  | EngineMsg.mk@{                      msg := Anoma.Msg.IdentityManagement (IdentityManagementMsg.ConnectIdentityRequest (RequestConnectIdentity.mkRequestConnectIdentity externalIdentity' backend' capabilities'));                    } :=                    case Map.lookup externalIdentity' identities of {                      | none :=                        some                          ActionEffect.mk@{                            env := env;                            msgs :=                              [                                EngineMsg.mk@{                                  sender :=                                    getEngineIDFromEngineCfg                                      (ActionInput.cfg input);                                  target := whoAsked;                                  mailbox := some 0;                                  msg :=                                    Msg.IdentityManagement                                      (IdentityManagementMsg.ConnectIdentityReply                                        ReplyConnectIdentity.mkReplyConnectIdentity@{                                          commitmentEngine := none;                                          decryptionEngine := none;                                          err :=                                            some \"External identity not found\";                                        });                                };                              ];                            timers := [];                            engines := [];                          }                      | some externalIdentityInfo :=                        if                           | isSubsetCapabilities                            capabilities'                            (IdentityInfo.capabilities externalIdentityInfo) :=                            let                              newIdentityInfo :=                                copyEnginesForCapabilities                                  env                                  whoAsked                                  externalIdentityInfo                                  capabilities';                              updatedIdentities :=                                Map.insert whoAsked newIdentityInfo identities;                              newLocalState :=                                local@IdentityManagementLocalState{identities := updatedIdentities};                              newEnv' :=                                env@EngineEnv{localState := newLocalState};                            in some                              ActionEffect.mk@{                                env := newEnv';                                msgs :=                                  [                                    EngineMsg.mk@{                                      sender :=                                        getEngineIDFromEngineCfg                                          (ActionInput.cfg input);                                      target := whoAsked;                                      mailbox := some 0;                                      msg :=                                        Msg.IdentityManagement                                          (IdentityManagementMsg.ConnectIdentityReply                                            ReplyConnectIdentity.mkReplyConnectIdentity@{                                              commitmentEngine :=                                                IdentityInfo.commitmentEngine                                                  newIdentityInfo;                                              decryptionEngine :=                                                IdentityInfo.decryptionEngine                                                  newIdentityInfo;                                              err := none;                                            });                                    };                                  ];                                timers := [];                                engines := [];                              }                          | else :=                            some                              ActionEffect.mk@{                                env := env;                                msgs :=                                  [                                    EngineMsg.mk@{                                      sender :=                                        getEngineIDFromEngineCfg                                          (ActionInput.cfg input);                                      target := whoAsked;                                      mailbox := some 0;                                      msg :=                                        Msg.IdentityManagement                                          (IdentityManagementMsg.ConnectIdentityReply                                            ReplyConnectIdentity.mkReplyConnectIdentity@{                                              commitmentEngine := none;                                              decryptionEngine := none;                                              err :=                                                some                                                  \"Capabilities not available\";                                            });                                    };                                  ];                                timers := [];                                engines := [];                              }                    }                  | _ := none                }            }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#deleteidentityaction","title":"<code>deleteIdentityAction</code>","text":"State update Removes the specified identity if it exists. Messages to be sent A DeleteIdentityReply message with confirmation or error. Engines to be spawned No engines are spawned. Timer updates No timers are set or cancelled. <pre><code><pre>deleteIdentityAction  (input : IdentityManagementActionInput)  : Option IdentityManagementActionEffect :=  let    env := ActionInput.env input;    local := EngineEnv.localState env;    identities := IdentityManagementLocalState.identities local;    trigger := ActionInput.trigger input;  in case getEngineMsgFromTimestampedTrigger trigger of       | some emsg :=         let           whoAsked := EngineMsg.sender emsg;         in case emsg of {              | EngineMsg.mk@{                  msg := Anoma.Msg.IdentityManagement (IdentityManagementMsg.DeleteIdentityRequest (RequestDeleteIdentity.mkRequestDeleteIdentity externalIdentity backend'));                } :=                case Map.lookup externalIdentity identities of {                  | none :=                    some                      ActionEffect.mk@{                        env := env;                        msgs :=                          [                            EngineMsg.mk@{                              sender :=                                getEngineIDFromEngineCfg                                  (ActionInput.cfg input);                              target := whoAsked;                              mailbox := some 0;                              msg :=                                Msg.IdentityManagement                                  (IdentityManagementMsg.DeleteIdentityReply                                    ReplyDeleteIdentity.mkReplyDeleteIdentity@{                                      err := some \"Identity does not exist\";                                    });                            };                          ];                        timers := [];                        engines := [];                      }                  | some _ :=                    let                      updatedIdentities :=                        Map.delete externalIdentity identities;                      newLocalState :=                        local@IdentityManagementLocalState{identities := updatedIdentities};                      newEnv' := env@EngineEnv{localState := newLocalState};                    in some                      ActionEffect.mk@{                        env := newEnv';                        msgs :=                          [                            EngineMsg.mk@{                              sender :=                                getEngineIDFromEngineCfg                                  (ActionInput.cfg input);                              target := whoAsked;                              mailbox := some 0;                              msg :=                                Msg.IdentityManagement                                  (IdentityManagementMsg.DeleteIdentityReply                                    ReplyDeleteIdentity.mkReplyDeleteIdentity@{                                      err := none;                                    });                            };                          ];                        timers := [];                        engines := [];                      }                }              | _ := none            }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#generateidentityactionlabel","title":"<code>generateIdentityActionLabel</code>","text":"<pre><code><pre>generateIdentityActionLabel : IdentityManagementActionExec :=  ActionExec.Seq [generateIdentityAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#connectidentityactionlabel","title":"<code>connectIdentityActionLabel</code>","text":"<pre><code><pre>connectIdentityActionLabel : IdentityManagementActionExec :=  ActionExec.Seq [connectIdentityAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#deleteidentityactionlabel","title":"<code>deleteIdentityActionLabel</code>","text":"<pre><code><pre>deleteIdentityActionLabel : IdentityManagementActionExec :=  ActionExec.Seq [deleteIdentityAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#identitymanagementguard","title":"<code>IdentityManagementGuard</code>","text":"<p> <pre><code><pre>IdentityManagementGuard : Type :=  Guard    IdentityManagementLocalCfg    IdentityManagementLocalState    IdentityManagementMailboxState    IdentityManagementTimerHandle    IdentityManagementActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#identitymanagementguardoutput","title":"<code>IdentityManagementGuardOutput</code>","text":"<p> <pre><code><pre>IdentityManagementGuardOutput : Type :=  GuardOutput    IdentityManagementLocalCfg    IdentityManagementLocalState    IdentityManagementMailboxState    IdentityManagementTimerHandle    IdentityManagementActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#identitymanagementguardeval","title":"<code>IdentityManagementGuardEval</code>","text":"<p> <pre><code><pre>IdentityManagementGuardEval : Type :=  GuardEval    IdentityManagementLocalCfg    IdentityManagementLocalState    IdentityManagementMailboxState    IdentityManagementTimerHandle    IdentityManagementActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#generateidentityguard","title":"<code>generateIdentityGuard</code>","text":"Condition Message type is MsgIdentityManagementGenerateIdentityRequest. <pre><code><pre>generateIdentityGuard  (trigger : TimestampedTrigger IdentityManagementTimerHandle Anoma.Msg)  (cfg : IdentityManagementCfg)  (env : IdentityManagementEnv)  : Option IdentityManagementGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{             msg := Anoma.Msg.IdentityManagement (IdentityManagementMsg.GenerateIdentityRequest _);           } :=      some        GuardOutput.mk@{          action := generateIdentityActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#connectidentityguard","title":"<code>connectIdentityGuard</code>","text":"Condition Message type is <code>MsgIdentityManagementConnectIdentityRequest</code>. <pre><code><pre>connectIdentityGuard  (trigger : TimestampedTrigger IdentityManagementTimerHandle Anoma.Msg)  (cfg : IdentityManagementCfg)  (env : IdentityManagementEnv)  : Option IdentityManagementGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{             msg := Anoma.Msg.IdentityManagement (IdentityManagementMsg.ConnectIdentityRequest _);           } :=      some        GuardOutput.mk@{          action := connectIdentityActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#deleteidentityguard","title":"<code>deleteIdentityGuard</code>","text":"Condition Message type is <code>MsgIdentityManagementDeleteIdentityRequest</code>. <pre><code><pre>deleteIdentityGuard  (trigger : TimestampedTrigger IdentityManagementTimerHandle Anoma.Msg)  (cfg : IdentityManagementCfg)  (env : IdentityManagementEnv)  : Option IdentityManagementGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{             msg := Anoma.Msg.IdentityManagement (IdentityManagementMsg.DeleteIdentityRequest _);           } :=      some        GuardOutput.mk@{          action := deleteIdentityActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#the-identity-management-behaviour","title":"The Identity Management Behaviour","text":"","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#identitymanagementbehaviour","title":"<code>IdentityManagementBehaviour</code>","text":"<pre><code><pre>IdentityManagementBehaviour : Type :=  EngineBehaviour    IdentityManagementLocalCfg    IdentityManagementLocalState    IdentityManagementMailboxState    IdentityManagementTimerHandle    IdentityManagementActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>identityManagementBehaviour : IdentityManagementBehaviour :=  EngineBehaviour.mk@{    guards :=      GuardEval.First        [generateIdentityGuard; connectIdentityGuard; deleteIdentityGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","behaviour"]},{"location":"arch/node/engines/identity_management_config.html","title":"Identity Management Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.identity_management_config;import prelude open;import arch.node.engines.identity_management_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","identity-management","configuration"]},{"location":"arch/node/engines/identity_management_config.html#identity-management-configuration","title":"Identity Management Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","identity-management","configuration"]},{"location":"arch/node/engines/identity_management_config.html#overview","title":"Overview","text":"<p>The Identity Management engine configuration contains static information for Identity Management engine instances.</p>","tags":["node-architecture","identity-subsystem","engine","identity-management","configuration"]},{"location":"arch/node/engines/identity_management_config.html#the-identity-management-local-configuration","title":"The Identity Management Local Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","identity-management","configuration"]},{"location":"arch/node/engines/identity_management_config.html#identitymanagementlocalcfg","title":"<code>IdentityManagementLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type IdentityManagementLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","configuration"]},{"location":"arch/node/engines/identity_management_config.html#the-identity-management-configuration","title":"The Identity Management Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","identity-management","configuration"]},{"location":"arch/node/engines/identity_management_config.html#identitymanagementcfg","title":"<code>IdentityManagementCfg</code>","text":"<pre><code><pre>IdentityManagementCfg : Type := EngineCfg IdentityManagementLocalCfg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","configuration"]},{"location":"arch/node/engines/identity_management_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>identityManagementCfg : IdentityManagementCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"identity management\";    cfg := IdentityManagementLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","configuration"]},{"location":"arch/node/engines/identity_management_environment.html","title":"Identity Management Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.identity_management_environment;import prelude open;import arch.node.types.messages open;import arch.node.types.crypto open;import arch.node.types.identities open;import arch.node.types.engine_environment open;import arch.node.engines.identity_management_messages open;import arch.node.types.anoma_message as Anoma open;import arch.system.identity.identity open hiding {ExternalIdentity};</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","identity-management","environment"]},{"location":"arch/node/engines/identity_management_environment.html#identity-management-environment","title":"Identity Management Environment","text":"","tags":["node-architecture","identity-subsystem","engine","identity-management","environment"]},{"location":"arch/node/engines/identity_management_environment.html#overview","title":"Overview","text":"<p>The Identity Management Engine's environment maintains the state necessary for managing identities, including information about connected identities, backends, and capabilities.</p> Auxiliary Juvix code <p><pre><code><pre>axiom genDecryptor : Backend -&gt; Decryptor Backend Plaintext Ciphertext;axiom genSigner : Backend -&gt; Signer Backend Signable Commitment;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","identity-management","environment"]},{"location":"arch/node/engines/identity_management_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The Identity Management Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","identity-management","environment"]},{"location":"arch/node/engines/identity_management_environment.html#identitymanagementmailboxstate","title":"<code>IdentityManagementMailboxState</code>","text":"<pre><code><pre>syntax alias IdentityManagementMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","environment"]},{"location":"arch/node/engines/identity_management_environment.html#local-state","title":"Local state","text":"<p>The local state of the Identity Management Engine includes information about the identities it manages.</p>","tags":["node-architecture","identity-subsystem","engine","identity-management","environment"]},{"location":"arch/node/engines/identity_management_environment.html#identityinfo","title":"<code>IdentityInfo</code>","text":"<pre><code><pre>type IdentityInfo :=  mkIdentityInfo@{    backend : Backend;    capabilities : Capabilities;    commitmentEngine : Option EngineID;    decryptionEngine : Option EngineID;  };</pre></code></pre> Arguments <code>backend</code>: The backend associated with this identity. <code>capabilities</code>: The capabilities available to this identity. <code>commitmentEngine</code>: Optional reference to the commitment engine for this identity. <code>decryptionEngine</code>: Optional reference to the decryption engine for this identity.","tags":["node-architecture","identity-subsystem","engine","identity-management","environment"]},{"location":"arch/node/engines/identity_management_environment.html#identitymanagementlocalstate","title":"<code>IdentityManagementLocalState</code>","text":"<pre><code><pre>type IdentityManagementLocalState :=  mk@{    identities : Map EngineID IdentityInfo;  };</pre></code></pre> Arguments <code>identities</code>: Map of engine IDs to their corresponding identity information.","tags":["node-architecture","identity-subsystem","engine","identity-management","environment"]},{"location":"arch/node/engines/identity_management_environment.html#timer-handle","title":"Timer Handle","text":"<p>The Identity Management Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","identity-management","environment"]},{"location":"arch/node/engines/identity_management_environment.html#identitymanagementtimerhandle","title":"<code>IdentityManagementTimerHandle</code>","text":"<pre><code><pre>syntax alias IdentityManagementTimerHandle := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","environment"]},{"location":"arch/node/engines/identity_management_environment.html#the-identity-management-environment","title":"The Identity Management Environment","text":"","tags":["node-architecture","identity-subsystem","engine","identity-management","environment"]},{"location":"arch/node/engines/identity_management_environment.html#identitymanagementenv","title":"<code>IdentityManagementEnv</code>","text":"<pre><code><pre>IdentityManagementEnv : Type :=  EngineEnv    IdentityManagementLocalState    IdentityManagementMailboxState    IdentityManagementTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","environment"]},{"location":"arch/node/engines/identity_management_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>identityManagementEnv : IdentityManagementEnv :=  EngineEnv.mk@{    localState :=      IdentityManagementLocalState.mk@{        identities := Map.empty;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","environment"]},{"location":"arch/node/engines/identity_management_messages.html","title":"Identity Management Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.identity_management_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/identity_management_messages.html#identity-management-messages","title":"Identity Management Messages","text":"","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/identity_management_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type IdentityManagementMsg :=  | GenerateIdentityRequest RequestGenerateIdentity  | GenerateIdentityReply ReplyGenerateIdentity  | ConnectIdentityRequest RequestConnectIdentity  | ConnectIdentityReply ReplyConnectIdentity  | DeleteIdentityRequest RequestDeleteIdentity  | DeleteIdentityReply ReplyDeleteIdentity;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/identity_management_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/identity_management_messages.html#generating-an-identity","title":"Generating an identity","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant IdentityManagementEngine\n    participant CommitmentEngine\n    participant DecryptionEngine\n\n    Client-&gt;&gt;IdentityManagementEngine: RequestGenerateIdentity\n    Note over IdentityManagementEngine: Create new identity\n    IdentityManagementEngine-&gt;&gt;CommitmentEngine: Spawn (if requested)\n    IdentityManagementEngine-&gt;&gt;DecryptionEngine: Spawn (if requested)\n    IdentityManagementEngine-&gt;&gt;Client: ReplyGenerateIdentity</code></pre>  Generating an identity","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/identity_management_messages.html#connecting-to-an-existing-identity","title":"Connecting to an existing identity","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant IdentityManagementEngine\n\n    Client-&gt;&gt;IdentityManagementEngine: RequestConnectIdentity\n    Note over IdentityManagementEngine: Check external identity\n    Note over IdentityManagementEngine: Verify capabilities\n    Note over IdentityManagementEngine: Copy engine references\n    IdentityManagementEngine-&gt;&gt;Client: ReplyConnectIdentity</code></pre>  Connecting to an existing identity","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/identity_management_messages.html#deleting-an-identity","title":"Deleting an identity","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant IdentityManagementEngine\n\n    Client-&gt;&gt;IdentityManagementEngine: RequestDeleteIdentity\n    Note over IdentityManagementEngine: Check if identity exists\n    Note over IdentityManagementEngine: Delete identity if exists\n    IdentityManagementEngine-&gt;&gt;Client: ReplyDeleteIdentity</code></pre>  Deleting an identity","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/identity_management_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/identity_management_messages.html#requestgenerateidentity","title":"<code>RequestGenerateIdentity</code>","text":"<pre><code><pre>type RequestGenerateIdentity :=  mkRequestGenerateIdentity@{    backend : Backend;    params : IDParams;    capabilities : Capabilities;  };</pre></code></pre> <p>A <code>RequestGenerateIdentity</code> instructs the Identity Management Engine to generate a new identity using the specified backend, parameters, and capabilities.</p> Arguments <code>backend</code>: The backend to use for identity generation. <code>params</code>: Parameters to pass to the backend. <code>capabilities</code>: Capabilities to request (e.g., commitment, decryption, or both).","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/identity_management_messages.html#replygenerateidentity","title":"<code>ReplyGenerateIdentity</code>","text":"<pre><code><pre>type ReplyGenerateIdentity :=  mkReplyGenerateIdentity@{    commitmentEngine : Option EngineID;    decryptionEngine : Option EngineID;    externalIdentity : EngineID;    err : Option String;  };</pre></code></pre> <p>A <code>ReplyGenerateIdentity</code> provides the handles to the decryption and commitment engine instances for the newly generated identity, or an error if a failure occurred.</p> Arguments <code>commitmentEngine</code>: Reference to the newly instantiated commitment engine. <code>decryptionEngine</code>: Reference to the newly instantiated decryption engine. <code>externalIdentity</code>: The external identity of the newly created identity. <code>err</code>: An error message if identity generation failed.","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/identity_management_messages.html#requestconnectidentity","title":"<code>RequestConnectIdentity</code>","text":"<pre><code><pre>type RequestConnectIdentity :=  mkRequestConnectIdentity@{    externalIdentity : EngineID;    backend : Backend;    capabilities : Capabilities;  };</pre></code></pre> <p>A <code>RequestConnectIdentity</code> instructs the Identity Management Engine to connect to an existing identity using the specified backend.</p> Arguments <code>externalIdentity</code>: The external identity to connect. <code>backend</code>: The backend to use for the connection. <code>capabilities</code>: Capabilities to request (e.g., commitment, decryption, or both).","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/identity_management_messages.html#replyconnectidentity","title":"<code>ReplyConnectIdentity</code>","text":"<pre><code><pre>type ReplyConnectIdentity :=  mkReplyConnectIdentity@{    commitmentEngine : Option EngineID;    decryptionEngine : Option EngineID;    err : Option String;  };</pre></code></pre> <p>A <code>ReplyConnectIdentity</code> provides the handles to the decryption and commitment engine instances for the connected identity, or an error if a failure occurred.</p> Arguments <code>commitmentEngine</code>: Reference to the newly connected commitment engine. <code>decryptionEngine</code>: Reference to the newly connected decryption engine. <code>err</code>: An error message if identity connection failed.","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/identity_management_messages.html#requestdeleteidentity","title":"<code>RequestDeleteIdentity</code>","text":"<pre><code><pre>type RequestDeleteIdentity :=  mkRequestDeleteIdentity@{    externalIdentity : EngineID;    backend : Backend;  };</pre></code></pre> <p>A <code>RequestDeleteIdentity</code> instructs the Identity Management Engine to delete an existing identity using the specified backend.</p> Arguments <code>externalIdentity</code>: The external identity to delete. <code>backend</code>: The backend to use for deletion.","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/identity_management_messages.html#replydeleteidentity","title":"<code>ReplyDeleteIdentity</code>","text":"<pre><code><pre>type ReplyDeleteIdentity :=  mkReplyDeleteIdentity@{    err : Option String;  };</pre></code></pre> <p>A <code>ReplyDeleteIdentity</code> provides the response from an attempt to delete an identity.</p> Arguments <code>err</code>: An error message if identity deletion failed.","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/identity_management_messages.html#identitymanagementmsg","title":"<code>IdentityManagementMsg</code>","text":"<pre><code><pre>type IdentityManagementMsg :=  | GenerateIdentityRequest RequestGenerateIdentity  | GenerateIdentityReply ReplyGenerateIdentity  | ConnectIdentityRequest RequestConnectIdentity  | ConnectIdentityReply ReplyConnectIdentity  | DeleteIdentityRequest RequestDeleteIdentity  | DeleteIdentityReply ReplyDeleteIdentity;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/identity_management_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Identity Management Configuration</li> <li>Identity Management Environment</li> <li>Identity Management Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","identity-management","message-types"]},{"location":"arch/node/engines/local_key_value_storage.html","title":"Local Key Value Storage Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.local_key_value_storage;import prelude open;import arch.node.types.engine open;import arch.node.engines.local_key_value_storage_messages open public;import arch.node.engines.local_key_value_storage_environment open public;import arch.node.engines.local_key_value_storage_behaviour open public;import arch.node.engines.local_key_value_storage_config open public;import arch.node.types.anoma as Anoma open;open local_key_value_storage_config_example;open local_key_value_storage_environment_example;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","engine-definition"]},{"location":"arch/node/engines/local_key_value_storage.html#local-key-value-storage-engine","title":"Local Key-Value Storage Engine","text":"<p>The Local Key-Value Storage Engine handles persistent storage and retrieval of data in a key-value format on the local machine.</p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","engine-definition"]},{"location":"arch/node/engines/local_key_value_storage.html#purpose","title":"Purpose","text":"<p>The Local Key-Value Storage Engine provides local storage and retrieval of data in a key-value format. It supports storing, retrieving and deleting key-value pairs while notifying interested parties of changes.</p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","engine-definition"]},{"location":"arch/node/engines/local_key_value_storage.html#engine-components","title":"Engine components","text":"<ul> <li>Local Key Value Storage Messages</li> <li>Local Key Value Storage Configuration</li> <li>Local Key Value Storage Environment</li> <li>Local Key Value Storage Behaviour</li> </ul>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","engine-definition"]},{"location":"arch/node/engines/local_key_value_storage.html#type","title":"Type","text":"<pre><code><pre>LocalKVStorageEngine : Type :=  Engine    LocalKVStorageLocalCfg    LocalKVStorageLocalState    LocalKVStorageMailboxState    LocalKVStorageTimerHandle    LocalKVStorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","engine-definition"]},{"location":"arch/node/engines/local_key_value_storage.html#example-of-a-local-key-value-storage-engine","title":"Example of a local key-value storage engine","text":"<pre><code><pre>exampleLocalKVStorageEngine : LocalKVStorageEngine :=  Engine.mk@{    cfg := localKVStorageCfg;    env := localKVStorageEnv;    behaviour := localKVStorageBehaviour;  };</pre></code></pre> <p>where <code>localKVStorageCfg</code> is defined as follows:</p> <pre><code><pre>localKVStorageCfg : LocalKVStorageCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"key value storage\";    cfg := LocalKVStorageLocalCfg.mk;  };</pre></code></pre> <p><code>localKVStorageEnv</code> is defined as follows:</p> <pre><code><pre>localKVStorageEnv : LocalKVStorageEnv :=  EngineEnv.mk@{    localState :=      LocalKVStorageLocalState.mk@{        storage := Map.empty;        localClock := 0;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>localKVStorageBehaviour</code> is defined as follows:</p> <pre><code><pre>localKVStorageBehaviour : LocalKVStorageBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [getValueGuard; setValueGuard; deleteValueGuard];  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","engine-definition"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html","title":"Local Key Value Storage Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.local_key_value_storage_behaviour;import arch.node.engines.local_key_value_storage_messages open;import arch.node.engines.local_key_value_storage_config open;import arch.node.engines.local_key_value_storage_environment open;import prelude open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#local-key-value-storage-behaviour","title":"Local Key-Value Storage Behaviour","text":"","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#overview","title":"Overview","text":"<p>The Local Key-Value Storage engine processes get, set, and delete operations on key-value pairs.</p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#localkvstorageactionargument","title":"<code>LocalKVStorageActionArgument</code>","text":"<pre><code><pre>type LocalKVStorageActionArgument := | LocalKVStorageReplyTo EngineID;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#localkvstorageactionarguments","title":"<code>LocalKVStorageActionArguments</code>","text":"<pre><code><pre>LocalKVStorageActionArguments : Type := List LocalKVStorageActionArgument;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#localkvstorageaction","title":"<code>LocalKVStorageAction</code>","text":"<p> <pre><code><pre>LocalKVStorageAction : Type :=  Action    LocalKVStorageLocalCfg    LocalKVStorageLocalState    LocalKVStorageMailboxState    LocalKVStorageTimerHandle    LocalKVStorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#localkvstorageactioninput","title":"<code>LocalKVStorageActionInput</code>","text":"<p> <pre><code><pre>LocalKVStorageActionInput : Type :=  ActionInput    LocalKVStorageLocalCfg    LocalKVStorageLocalState    LocalKVStorageMailboxState    LocalKVStorageTimerHandle    LocalKVStorageActionArguments    Anoma.Msg;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#localkvstorageactioneffect","title":"<code>LocalKVStorageActionEffect</code>","text":"<p> <pre><code><pre>LocalKVStorageActionEffect : Type :=  ActionEffect    LocalKVStorageLocalState    LocalKVStorageMailboxState    LocalKVStorageTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#localkvstorageactionexec","title":"<code>LocalKVStorageActionExec</code>","text":"<p> <pre><code><pre>LocalKVStorageActionExec : Type :=  ActionExec    LocalKVStorageLocalCfg    LocalKVStorageLocalState    LocalKVStorageMailboxState    LocalKVStorageTimerHandle    LocalKVStorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#getvalueaction","title":"<code>getValueAction</code>","text":"<p>Retrieve a value from storage by key.</p> State update The state remains unchanged. Messages to be sent A <code>GetValueKVStoreReply</code> message with the requested value. Engines to be spawned No engines are created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>getValueAction  (input : LocalKVStorageActionInput) : Option LocalKVStorageActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    local := EngineEnv.localState env;    storage := LocalKVStorageLocalState.storage local;    trigger := ActionInput.trigger input;  in case getEngineMsgFromTimestampedTrigger trigger of       | some emsg :=         case emsg of {           | EngineMsg.mk@{               msg := Anoma.Msg.LocalKVStorage (LocalKVStorageMsg.GetValueRequest req);             } :=             some               ActionEffect.mk@{                 env := env;                 msgs :=                   [                     EngineMsg.mk@{                       sender := getEngineIDFromEngineCfg cfg;                       target := EngineMsg.sender emsg;                       mailbox := some 0;                       msg :=                         Anoma.Msg.LocalKVStorage                           (LocalKVStorageMsg.GetValueReply                             GetValueKVStoreReply.mkGetValueKVStoreReply@{                               key := GetValueKVStoreRequest.key req;                               value :=                                 fromOption                                   (Map.lookup                                     (GetValueKVStoreRequest.key req)                                     storage)                                   \"\";                             });                     };                   ];                 timers := [];                 engines := [];               }           | _ := none         }       | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#setvalueaction","title":"<code>setValueAction</code>","text":"<p>Store a value in storage with given key.</p> State update The storage map is updated with new key-value pair. Messages to be sent A <code>SetValueKVStoreReply</code> message indicating success/failure. Several <code>LocalKVStorageMsgValueChanged</code> messages to those interested engines. Engines to be spawned No engines are created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>setValueAction  (input : LocalKVStorageActionInput) : Option LocalKVStorageActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    local := EngineEnv.localState env;    storage := LocalKVStorageLocalState.storage local;    trigger := ActionInput.trigger input;    newTime := advanceTime (LocalKVStorageLocalState.localClock local);  in case getEngineMsgFromTimestampedTrigger trigger of       | some emsg :=         case emsg of {           | EngineMsg.mk@{               msg := Anoma.Msg.LocalKVStorage (LocalKVStorageMsg.SetValueRequest req);             } :=             let               key := SetValueKVStoreRequest.key req;               value := SetValueKVStoreRequest.value req;               newStorage := Map.insert key value storage;               newLocal :=                 local@LocalKVStorageLocalState{                   storage := newStorage;                   localClock := newTime;                 };               newEnv := env@EngineEnv{localState := newLocal};               responseMsg :=                 EngineMsg.mk@{                   sender := getEngineIDFromEngineCfg cfg;                   target := EngineMsg.sender emsg;                   mailbox := some 0;                   msg :=                     Anoma.Msg.LocalKVStorage                       (LocalKVStorageMsg.SetValueReply                         SetValueKVStoreReply.mkSetValueKVStoreReply@{                           key := key;                           success := true;                         });                 };               notificationMsg :=                 \\{target :=                   EngineMsg.mk@{                     sender := getEngineIDFromEngineCfg cfg;                     target := target;                     mailbox := some 0;                     msg :=                       Anoma.Msg.LocalKVStorage                         (LocalKVStorageMsg.ValueChanged                           ValueChangedKVStore.mkValueChangedKVStore@{                             key := key;                             value := value;                             timestamp := newTime;                           });                   }};               notificationMsgs :=                 map notificationMsg (getNotificationTargets key);             in some               ActionEffect.mk@{                 env := newEnv;                 msgs := responseMsg :: notificationMsgs;                 timers := [];                 engines := [];               }           | _ := none         }       | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#deletevalueaction","title":"<code>deleteValueAction</code>","text":"<p>Remove a value from storage by key.</p> State update The storage map is updated to remove the key-value pair. Messages to be sent A <code>DeleteValueKVStoreReply message</code> indicating success/failure. Several <code>LocalKVStorageMsgValueChanged</code> messages to those interested engines. Engines to be spawned No engines are created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>deleteValueAction  (input : LocalKVStorageActionInput) : Option LocalKVStorageActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    local := EngineEnv.localState env;    storage := LocalKVStorageLocalState.storage local;    trigger := ActionInput.trigger input;    newTime := advanceTime (LocalKVStorageLocalState.localClock local);  in case getEngineMsgFromTimestampedTrigger trigger of       | some emsg :=         case emsg of {           | EngineMsg.mk@{               msg := Anoma.Msg.LocalKVStorage (LocalKVStorageMsg.DeleteValueRequest req);             } :=             let               key := DeleteValueKVStoreRequest.key req;               newStorage := Map.delete key storage;               newLocal :=                 local@LocalKVStorageLocalState{                   storage := newStorage;                   localClock := newTime;                 };               newEnv := env@EngineEnv{localState := newLocal};               responseMsg :=                 EngineMsg.mk@{                   sender := getEngineIDFromEngineCfg cfg;                   target := EngineMsg.sender emsg;                   mailbox := some 0;                   msg :=                     Anoma.Msg.LocalKVStorage                       (LocalKVStorageMsg.DeleteValueReply                         DeleteValueKVStoreReply.mkDeleteValueKVStoreReply@{                           key := key;                           success := true;                         });                 };               notificationMsg :=                 \\{target :=                   EngineMsg.mk@{                     sender := getEngineIDFromEngineCfg cfg;                     target := target;                     mailbox := some 0;                     msg :=                       Anoma.Msg.LocalKVStorage                         (LocalKVStorageMsg.ValueChanged                           ValueChangedKVStore.mkValueChangedKVStore@{                             key := key;                             value := \"\";                             timestamp := newTime;                           });                   }};               notificationMsgs :=                 map notificationMsg (getNotificationTargets key);             in some               ActionEffect.mk@{                 env := newEnv;                 msgs := responseMsg :: notificationMsgs;                 timers := [];                 engines := [];               }           | _ := none         }       | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#getvalueactionlabel","title":"<code>getValueActionLabel</code>","text":"<pre><code><pre>getValueActionLabel : LocalKVStorageActionExec :=  ActionExec.Seq [getValueAction];</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#setvalueactionlabel","title":"<code>setValueActionLabel</code>","text":"<pre><code><pre>setValueActionLabel : LocalKVStorageActionExec :=  ActionExec.Seq [setValueAction];</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#deletevalueactionlabel","title":"<code>deleteValueActionLabel</code>","text":"<pre><code><pre>deleteValueActionLabel : LocalKVStorageActionExec :=  ActionExec.Seq [deleteValueAction];</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#localkvstorageguard","title":"<code>LocalKVStorageGuard</code>","text":"<p> <pre><code><pre>LocalKVStorageGuard : Type :=  Guard    LocalKVStorageLocalCfg    LocalKVStorageLocalState    LocalKVStorageMailboxState    LocalKVStorageTimerHandle    LocalKVStorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#localkvstorageguardoutput","title":"<code>LocalKVStorageGuardOutput</code>","text":"<p> <pre><code><pre>LocalKVStorageGuardOutput : Type :=  GuardOutput    LocalKVStorageLocalCfg    LocalKVStorageLocalState    LocalKVStorageMailboxState    LocalKVStorageTimerHandle    LocalKVStorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#localkvstorageguardeval","title":"<code>LocalKVStorageGuardEval</code>","text":"<p> <pre><code><pre>LocalKVStorageGuardEval : Type :=  GuardEval    LocalKVStorageLocalCfg    LocalKVStorageLocalState    LocalKVStorageMailboxState    LocalKVStorageTimerHandle    LocalKVStorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#getvalueguard","title":"<code>getValueGuard</code>","text":"Condition Message type is <code>LocalKVStorageMsg.GetValueRequest</code>. <pre><code><pre>getValueGuard  (trigger : LocalKVStorageTimestampedTrigger)  (cfg : LocalKVStorageCfg)  (env : LocalKVStorageEnv)  : Option LocalKVStorageGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{             msg := Anoma.Msg.LocalKVStorage (LocalKVStorageMsg.GetValueRequest _);           } :=      some        GuardOutput.mk@{          action := getValueActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#setvalueguard","title":"<code>setValueGuard</code>","text":"Condition Message type is <code>LocalKVStorageMsg.SetValueRequest</code>. <pre><code><pre>setValueGuard  (trigger : LocalKVStorageTimestampedTrigger)  (cfg : LocalKVStorageCfg)  (env : LocalKVStorageEnv)  : Option LocalKVStorageGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{             msg := Anoma.Msg.LocalKVStorage (LocalKVStorageMsg.SetValueRequest _);           } :=      some        GuardOutput.mk@{          action := setValueActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#deletevalueguard","title":"<code>deleteValueGuard</code>","text":"Condition Message type is <code>LocalKVStorageMsg.DeleteValueRequest</code>. <pre><code><pre>deleteValueGuard  (trigger : LocalKVStorageTimestampedTrigger)  (cfg : LocalKVStorageCfg)  (env : LocalKVStorageEnv)  : Option LocalKVStorageGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{             msg := Anoma.Msg.LocalKVStorage (LocalKVStorageMsg.DeleteValueRequest _);           } :=      some        GuardOutput.mk@{          action := deleteValueActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#the-local-key-value-storage-behaviour","title":"The Local Key-Value Storage behaviour","text":"","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#localkvstoragebehaviour","title":"<code>LocalKVStorageBehaviour</code>","text":"<pre><code><pre>LocalKVStorageBehaviour : Type :=  EngineBehaviour    LocalKVStorageLocalCfg    LocalKVStorageLocalState    LocalKVStorageMailboxState    LocalKVStorageTimerHandle    LocalKVStorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>localKVStorageBehaviour : LocalKVStorageBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [getValueGuard; setValueGuard; deleteValueGuard];  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#local-key-value-storage-action-flowcharts","title":"Local Key-Value Storage Action Flowcharts","text":"","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#getvalue-flowchart","title":"<code>getValue</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;LocalKVStorageMsgGetValueRequest]\n  end\n\n  G(getValueGuard)\n  A(getValueAction)\n\n  C --&gt; G -- *getValueActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EMsg&gt;LocalKVStorageMsgGetValueReply&lt;br/&gt;key, value]\n  end</code></pre>  getValue flowchart","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#setvalue-flowchart","title":"<code>setValue</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;LocalKVStorageMsgSetValueRequest]\n  end\n\n  G(setValueGuard)\n  A(setValueAction)\n\n  C --&gt; G -- *setValueActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(storage := Map.insert key value storage)]\n    EMsg&gt;LocalKVStorageMsgSetValueReply&lt;br/&gt;success]\n  end</code></pre>  setValue flowchart","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_behaviour.html#deletevalue-flowchart","title":"<code>deleteValue</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;LocalKVStorageMsgDeleteValueRequest]\n  end\n\n  G(deleteValueGuard)\n  A(deleteValueAction)\n\n  C --&gt; G -- *deleteValueActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(storage := Map.delete key storage)]\n    EMsg&gt;LocalKVStorageMsgDeleteValueReply&lt;br/&gt;success]\n  end</code></pre>  deleteValue flowchart","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","behaviour"]},{"location":"arch/node/engines/local_key_value_storage_config.html","title":"Local Key Value Storage Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.local_key_value_storage_config;import prelude open;import arch.node.engines.local_key_value_storage_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","configuration"]},{"location":"arch/node/engines/local_key_value_storage_config.html#local-key-value-storage-configuration","title":"Local Key Value Storage Configuration","text":"","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","configuration"]},{"location":"arch/node/engines/local_key_value_storage_config.html#overview","title":"Overview","text":"<p>The Local Key Value Storage engine configuration contains static information for Local Key Value Storage engine instances.</p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","configuration"]},{"location":"arch/node/engines/local_key_value_storage_config.html#the-local-key-value-storage-local-configuration","title":"The Local Key Value Storage Local Configuration","text":"","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","configuration"]},{"location":"arch/node/engines/local_key_value_storage_config.html#localkvstoragelocalcfg","title":"<code>LocalKVStorageLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type LocalKVStorageLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","configuration"]},{"location":"arch/node/engines/local_key_value_storage_config.html#the-local-key-value-storage-configuration","title":"The Local Key Value Storage Configuration","text":"","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","configuration"]},{"location":"arch/node/engines/local_key_value_storage_config.html#localkvstoragecfg","title":"<code>LocalKVStorageCfg</code>","text":"<pre><code><pre>LocalKVStorageCfg : Type := EngineCfg LocalKVStorageLocalCfg;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","configuration"]},{"location":"arch/node/engines/local_key_value_storage_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>localKVStorageCfg : LocalKVStorageCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"key value storage\";    cfg := LocalKVStorageLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","configuration"]},{"location":"arch/node/engines/local_key_value_storage_environment.html","title":"Local Key Value Storage Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.local_key_value_storage_environment;import prelude open;import arch.node.engines.local_key_value_storage_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","environment"]},{"location":"arch/node/engines/local_key_value_storage_environment.html#local-key-value-storage-environment","title":"Local Key-Value Storage Environment","text":"","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","environment"]},{"location":"arch/node/engines/local_key_value_storage_environment.html#overview","title":"Overview","text":"<p>The Local Key-Value Storage Engine provides local storage and retrieval of data in a key-value format.</p> Auxiliary Juvix code <p><pre><code><pre>axiom getNotificationTargets : StorageKey -&gt; List EngineID;axiom advanceTime : EpochTimestamp -&gt; EpochTimestamp;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","environment"]},{"location":"arch/node/engines/local_key_value_storage_environment.html#mailbox-state-types","title":"Mailbox state types","text":"","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","environment"]},{"location":"arch/node/engines/local_key_value_storage_environment.html#localkvstoragemailboxstate","title":"<code>LocalKVStorageMailboxState</code>","text":"<pre><code><pre>syntax alias LocalKVStorageMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","environment"]},{"location":"arch/node/engines/local_key_value_storage_environment.html#local-state","title":"Local state","text":"","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","environment"]},{"location":"arch/node/engines/local_key_value_storage_environment.html#localkvstoragelocalstate","title":"<code>LocalKVStorageLocalState</code>","text":"<pre><code><pre>type LocalKVStorageLocalState :=  mk@{    storage : Map StorageKey StorageValue;    localClock : EpochTimestamp;  };</pre></code></pre> Arguments <code>storage</code> The key-value store mapping keys to values. <code>localClock</code> The local time of the engine, used to make timestamps.","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","environment"]},{"location":"arch/node/engines/local_key_value_storage_environment.html#timer-handles","title":"Timer handles","text":"","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","environment"]},{"location":"arch/node/engines/local_key_value_storage_environment.html#localkvstoragetimerhandle","title":"<code>LocalKVStorageTimerHandle</code>","text":"<pre><code><pre>syntax alias LocalKVStorageTimerHandle := Unit;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","environment"]},{"location":"arch/node/engines/local_key_value_storage_environment.html#localkvstoragetimestampedtrigger","title":"<code>LocalKVStorageTimestampedTrigger</code>","text":"<pre><code><pre>LocalKVStorageTimestampedTrigger : Type :=  TimestampedTrigger LocalKVStorageTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","environment"]},{"location":"arch/node/engines/local_key_value_storage_environment.html#the-local-key-value-storage-environment","title":"The Local Key-Value Storage Environment","text":"","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","environment"]},{"location":"arch/node/engines/local_key_value_storage_environment.html#localkvstorageenv","title":"<code>LocalKVStorageEnv</code>","text":"<pre><code><pre>LocalKVStorageEnv : Type :=  EngineEnv    LocalKVStorageLocalState    LocalKVStorageMailboxState    LocalKVStorageTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","environment"]},{"location":"arch/node/engines/local_key_value_storage_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>localKVStorageEnv : LocalKVStorageEnv :=  EngineEnv.mk@{    localState :=      LocalKVStorageLocalState.mk@{        storage := Map.empty;        localClock := 0;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","environment"]},{"location":"arch/node/engines/local_key_value_storage_messages.html","title":"Local Key Value Storage Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.local_key_value_storage_messages;import prelude open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#local-key-value-storage-messages","title":"Local Key-Value Storage Messages","text":"<p>These are the messages that the Local Key-Value Storage engine can receive/respond to.</p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type LocalKVStorageMsg :=  | GetValueRequest GetValueKVStoreRequest  | GetValueReply GetValueKVStoreReply  | SetValueRequest SetValueKVStoreRequest  | SetValueReply SetValueKVStoreReply  | DeleteValueRequest DeleteValueKVStoreRequest  | DeleteValueReply DeleteValueKVStoreReply  | ValueChanged ValueChangedKVStore;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#get-value-requestresponse-flow","title":"Get value request/response flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant KVStorage\n\n    Client -&gt;&gt;+ KVStorage: GetValueKVStoreRequest\n    KVStorage --&gt;&gt;- Client: GetValueKVStoreReply</code></pre>  Get Value Request/Reply Flow","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#set-value-requestresponse-flow","title":"Set value request/response flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant KVStorage\n\n    Client -&gt;&gt;+ KVStorage: SetValueKVStoreRequest\n    KVStorage --&gt;&gt;- Client: SetValueKVStoreReply</code></pre>  Set Value Request/Reply Flow","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#delete-value-requestresponse-flow","title":"Delete value request/response flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant KVStorage\n\n    Client -&gt;&gt;+ KVStorage: DeleteValueKVStoreRequest\n    KVStorage --&gt;&gt;- Client: DeleteValueKVStoreReply</code></pre>  Delete Value Request/Reply Flow","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#message-types","title":"Message types","text":"Auxiliary Juvix code <p><pre><code><pre>syntax alias StorageKey := String;syntax alias StorageValue := String;syntax alias EpochTimestamp := Nat;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#getvaluekvstorerequest","title":"<code>GetValueKVStoreRequest</code>","text":"<p>Request to get a value from storage.</p> <pre><code><pre>type GetValueKVStoreRequest :=  mkGetValueKVStoreRequest@{    key : StorageKey;  };</pre></code></pre> Arguments <code>key</code> The key that maps to the requested value in the KV-store.","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#getvaluekvstorereply","title":"<code>GetValueKVStoreReply</code>","text":"<p>Reply containing requested value.</p> <pre><code><pre>type GetValueKVStoreReply :=  mkGetValueKVStoreReply@{    key : StorageKey;    value : StorageValue;  };</pre></code></pre> Arguments <code>key</code> The key that maps to the requested value in the KV-store. <code>value</code> The requested value from the KV-store.","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#setvaluekvstorerequest","title":"<code>SetValueKVStoreRequest</code>","text":"<p>Request to set a value in storage.</p> <pre><code><pre>type SetValueKVStoreRequest :=  mkSetValueKVStoreRequest@{    key : StorageKey;    value : StorageValue;  };</pre></code></pre> Arguments <code>key</code> The key that identifies the data in the KV-store. <code>value</code> The value to store in the KV-store.","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#setvaluekvstorereply","title":"<code>SetValueKVStoreReply</code>","text":"<p>Reply indicating success/failure of set operation.</p> <pre><code><pre>type SetValueKVStoreReply :=  mkSetValueKVStoreReply@{    key : StorageKey;    success : Bool;  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#deletevaluekvstorerequest","title":"<code>DeleteValueKVStoreRequest</code>","text":"<p>Request to delete a value from storage.</p> <pre><code><pre>type DeleteValueKVStoreRequest :=  mkDeleteValueKVStoreRequest@{    key : StorageKey;  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#deletevaluekvstorereply","title":"<code>DeleteValueKVStoreReply</code>","text":"<p>Reply indicating success/failure of a delete operation.</p> <pre><code><pre>type DeleteValueKVStoreReply :=  mkDeleteValueKVStoreReply@{    key : StorageKey;    success : Bool;  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#valuechangedkvstore","title":"<code>ValueChangedKVStore</code>","text":"<p>Notification that a value has changed.</p> <pre><code><pre>type ValueChangedKVStore :=  mkValueChangedKVStore@{    key : StorageKey;    value : StorageValue;    timestamp : EpochTimestamp;  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#localkvstoragemsg","title":"<code>LocalKVStorageMsg</code>","text":"<pre><code><pre>type LocalKVStorageMsg :=  | GetValueRequest GetValueKVStoreRequest  | GetValueReply GetValueKVStoreReply  | SetValueRequest SetValueKVStoreRequest  | SetValueReply SetValueKVStoreReply  | DeleteValueRequest DeleteValueKVStoreRequest  | DeleteValueReply DeleteValueKVStoreReply  | ValueChanged ValueChangedKVStore;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_key_value_storage_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Local Key Value Storage Configuration</li> <li>Local Key Value Storage Environment</li> <li>Local Key Value Storage Behaviour</li> </ul>","tags":["node-architecture","hardware-subsystem","engine","local-key-value-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage.html","title":"Local Time Series Storage Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.local_time_series_storage;import prelude open;import arch.node.types.engine open;import arch.node.engines.local_time_series_storage_messages open public;import arch.node.engines.local_time_series_storage_config open public;import arch.node.engines.local_time_series_storage_environment open public;import arch.node.engines.local_time_series_storage_behaviour open public;import arch.node.types.anoma as Anoma open;open local_ts_storage_config_example;open local_ts_storage_environment_example;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","engine-definition"]},{"location":"arch/node/engines/local_time_series_storage.html#local-time-series-storage-engine","title":"Local Time Series Storage Engine","text":"<p>The Local Time Series Storage Engine provides local storage and retrieval of time series data.</p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","engine-definition"]},{"location":"arch/node/engines/local_time_series_storage.html#purpose","title":"Purpose","text":"<p>The Local Time Series Storage Engine manages local storage and retrieval of time series data. It provides functions for recording new data, retrieving existing data, and deleting data when needed.</p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","engine-definition"]},{"location":"arch/node/engines/local_time_series_storage.html#engine-components","title":"Engine components","text":"<ul> <li>Local Time Series Storage Messages</li> <li>Local Time Series Storage Configuration</li> <li>Local Time Series Storage Environment</li> <li>Local Time Series Storage Behaviour</li> </ul>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","engine-definition"]},{"location":"arch/node/engines/local_time_series_storage.html#type","title":"Type","text":"<pre><code><pre>LocalTSStorageEngine : Type :=  Engine    LocalTSStorageLocalCfg    LocalTSStorageLocalState    LocalTSStorageMailboxState    LocalTSStorageTimerHandle    LocalTSStorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","engine-definition"]},{"location":"arch/node/engines/local_time_series_storage.html#example-of-a-local-time-series-storage-engine","title":"Example of a local time series storage engine","text":"<pre><code><pre>exampleLocalTSStorageEngine : LocalTSStorageEngine :=  Engine.mk@{    cfg := localTSStorageCfg;    env := localTSStorageEnv;    behaviour := localTSStorageBehaviour;  };</pre></code></pre> <p>where <code>localTSStorageCfg</code> is defined as follows:</p> <pre><code><pre>localTSStorageCfg : LocalTSStorageCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"local time series storage\";    cfg := LocalTSStorageLocalCfg.mk;  };</pre></code></pre> <p><code>localTSStorageEnv</code> is defined as follows:</p> <pre><code><pre>localTSStorageEnv : LocalTSStorageEnv :=  EngineEnv.mk@{    localState :=      LocalTSStorageLocalState.mk@{        db := \"\";        localClock := 0;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>localTSStorageBehaviour</code> is defined as follows:</p> <pre><code><pre>localTSStorageBehaviour : LocalTSStorageBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [getDataGuard; recordDataGuard; deleteDataGuard];  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","engine-definition"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html","title":"Local Time Series Storage Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.local_time_series_storage_behaviour;import arch.node.engines.local_time_series_storage_messages open;import arch.node.engines.local_time_series_storage_config open;import arch.node.engines.local_time_series_storage_environment open;import prelude open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#local-time-series-storage-behaviour","title":"Local Time Series Storage Behaviour","text":"","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#overview","title":"Overview","text":"<p>A time series storage engine acts as a database that can store, retrieve, and delete time series data.</p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#localtsstorageactionargument","title":"<code>LocalTSStorageActionArgument</code>","text":"<pre><code><pre>type LocalTSStorageActionArgument := Unit;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#localtsstorageactionarguments","title":"<code>LocalTSStorageActionArguments</code>","text":"<pre><code><pre>LocalTSStorageActionArguments : Type := List LocalTSStorageActionArgument;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#localtsstorageaction","title":"<code>LocalTSStorageAction</code>","text":"<p> <pre><code><pre>LocalTSStorageAction : Type :=  Action    LocalTSStorageLocalCfg    LocalTSStorageLocalState    LocalTSStorageMailboxState    LocalTSStorageTimerHandle    LocalTSStorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#localtsstorageactioninput","title":"<code>LocalTSStorageActionInput</code>","text":"<p> <pre><code><pre>LocalTSStorageActionInput : Type :=  ActionInput    LocalTSStorageLocalCfg    LocalTSStorageLocalState    LocalTSStorageMailboxState    LocalTSStorageTimerHandle    LocalTSStorageActionArguments    Anoma.Msg;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#localtsstorageactioneffect","title":"<code>LocalTSStorageActionEffect</code>","text":"<p> <pre><code><pre>LocalTSStorageActionEffect : Type :=  ActionEffect    LocalTSStorageLocalState    LocalTSStorageMailboxState    LocalTSStorageTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#localtsstorageactionexec","title":"<code>LocalTSStorageActionExec</code>","text":"<p> <pre><code><pre>LocalTSStorageActionExec : Type :=  ActionExec    LocalTSStorageLocalCfg    LocalTSStorageLocalState    LocalTSStorageMailboxState    LocalTSStorageTimerHandle    LocalTSStorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#getdataaction","title":"<code>getDataAction</code>","text":"<p>Get data from the time series database.</p> State update The state remains unchanged. Messages to be sent A <code>GetDataTSStorageDBReply</code> message with the requested data. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>getDataAction  (input : LocalTSStorageActionInput) : Option LocalTSStorageActionEffect :=  let    env := ActionInput.env input;    trigger := ActionInput.trigger input;    cfg := ActionInput.cfg input;    local := EngineEnv.localState env;  in case getEngineMsgFromTimestampedTrigger trigger of       | some EngineMsg.mk@{                msg := Anoma.Msg.LocalTSStorage (LocalTSStorageMsg.GetRequest request);                sender := sender;              } :=         let           result :=             queryDB               (LocalTSStorageLocalState.db local)               (GetDataTSStorageDBRequest.query request);         in case result of {              | some data :=                some                  ActionEffect.mk@{                    env := env;                    msgs :=                      [                        EngineMsg.mk@{                          sender := getEngineIDFromEngineCfg cfg;                          target := sender;                          mailbox := some 0;                          msg :=                            Anoma.Msg.LocalTSStorage                              (LocalTSStorageMsg.GetReply                                GetDataTSStorageDBReply.mkGetDataTSStorageDBReply@{                                  query :=                                    GetDataTSStorageDBRequest.query request;                                  data := data;                                });                        };                      ];                    timers := [];                    engines := [];                  }              | none := none            }       | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#recorddataaction","title":"<code>recordDataAction</code>","text":"<p>Record new data in the time series database.</p> State update Updates the database with new time series data, if successful. Messages to be sent A <code>RecordDataTSStorageDBReply</code> message indicating success/failure. Several <code>DataChangedTSStorageDB</code> messages to those interested engines, if successful. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>recordDataAction  (input : LocalTSStorageActionInput) : Option LocalTSStorageActionEffect :=  let    env := ActionInput.env input;    trigger := ActionInput.trigger input;    cfg := ActionInput.cfg input;    local := EngineEnv.localState env;    newTime := advanceTime (LocalTSStorageLocalState.localClock local);  in case getEngineMsgFromTimestampedTrigger trigger of       | some EngineMsg.mk@{                msg := Anoma.Msg.LocalTSStorage (LocalTSStorageMsg.RecordRequest request);                sender := sender;              } :=         let           query := RecordDataTSStorageDBRequest.query request;           db := LocalTSStorageLocalState.db local;           data := queryDB db query;         in case data of {              | some value :=                let                  newDb := updateDB db query value;                  newEnv :=                    env@EngineEnv{localState := LocalTSStorageLocalState.mk@{                                                  db := newDb;                                                  localClock := newTime;                                                }};                  responseMsg :=                    EngineMsg.mk@{                      sender := getEngineIDFromEngineCfg cfg;                      target := sender;                      mailbox := some 0;                      msg :=                        Anoma.Msg.LocalTSStorage                          (LocalTSStorageMsg.DeleteReply                            DeleteDataTSStorageDBReply.mkDeleteDataTSStorageDBReply@{                              query := query;                              success := true;                            });                    };                  notificationMsg :=                    \\{target :=                      EngineMsg.mk@{                        sender := getEngineIDFromEngineCfg cfg;                        target := target;                        mailbox := some 0;                        msg :=                          Anoma.Msg.LocalTSStorage                            (LocalTSStorageMsg.DataChanged                              DataChangedTSStorageDB.mkDataChangedTSStorageDB@{                                query := query;                                data := value;                                timestamp := newTime;                              });                      }};                  notificationMsgs :=                    map notificationMsg (getNotificationTargets query);                in some                  ActionEffect.mk@{                    env := newEnv;                    msgs := responseMsg :: notificationMsgs;                    timers := [];                    engines := [];                  }              | none :=                some                  ActionEffect.mk@{                    env := env;                    msgs :=                      [                        EngineMsg.mk@{                          sender := getEngineIDFromEngineCfg cfg;                          target := sender;                          mailbox := some 0;                          msg :=                            Anoma.Msg.LocalTSStorage                              (LocalTSStorageMsg.RecordReply                                RecordDataTSStorageDBReply.mkRecordDataTSStorageDBReply@{                                  query := query;                                  success := false;                                });                        };                      ];                    timers := [];                    engines := [];                  }            }       | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#deletedataaction","title":"<code>deleteDataAction</code>","text":"<p>Delete data from the time series database.</p> State update Updates the database by removing specified time series data, if successful. Messages to be sent A <code>DeleteDataTSStorageDBReply</code> message indicating success/failure. Several <code>DataChangedTSStorageDB</code> messages to those interested engines, if successful. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>deleteDataAction  (input : LocalTSStorageActionInput) : Option LocalTSStorageActionEffect :=  let    env := ActionInput.env input;    trigger := ActionInput.trigger input;    cfg := ActionInput.cfg input;    local := EngineEnv.localState env;    newTime := advanceTime (LocalTSStorageLocalState.localClock local);  in case getEngineMsgFromTimestampedTrigger trigger of       | some EngineMsg.mk@{                msg := Anoma.Msg.LocalTSStorage (LocalTSStorageMsg.DeleteRequest request);                sender := sender;              } :=         let           query := DeleteDataTSStorageDBRequest.query request;           db := LocalTSStorageLocalState.db local;           data := queryDB db query;         in case data of {              | some value :=                let                  newDb := updateDB db query \"\";                  newEnv :=                    env@EngineEnv{localState := LocalTSStorageLocalState.mk@{                                                  db := newDb;                                                  localClock := newTime;                                                }};                  responseMsg :=                    EngineMsg.mk@{                      sender := getEngineIDFromEngineCfg cfg;                      target := sender;                      mailbox := some 0;                      msg :=                        Anoma.Msg.LocalTSStorage                          (LocalTSStorageMsg.DeleteReply                            DeleteDataTSStorageDBReply.mkDeleteDataTSStorageDBReply@{                              query := query;                              success := true;                            });                    };                  notificationMsg :=                    \\{target :=                      EngineMsg.mk@{                        sender := getEngineIDFromEngineCfg cfg;                        target := target;                        mailbox := some 0;                        msg :=                          Anoma.Msg.LocalTSStorage                            (LocalTSStorageMsg.DataChanged                              DataChangedTSStorageDB.mkDataChangedTSStorageDB@{                                query := query;                                data := value;                                timestamp := newTime;                              });                      }};                  notificationMsgs :=                    map notificationMsg (getNotificationTargets query);                in some                  ActionEffect.mk@{                    env := newEnv;                    msgs := responseMsg :: notificationMsgs;                    timers := [];                    engines := [];                  }              | none :=                some                  ActionEffect.mk@{                    env := env;                    msgs :=                      [                        EngineMsg.mk@{                          sender := getEngineIDFromEngineCfg cfg;                          target := sender;                          mailbox := some 0;                          msg :=                            Anoma.Msg.LocalTSStorage                              (LocalTSStorageMsg.DeleteReply                                DeleteDataTSStorageDBReply.mkDeleteDataTSStorageDBReply@{                                  query := query;                                  success := false;                                });                        };                      ];                    timers := [];                    engines := [];                  }            }       | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#getdataactionlabel","title":"<code>getDataActionLabel</code>","text":"<pre><code><pre>getDataActionLabel : LocalTSStorageActionExec := ActionExec.Seq [getDataAction];</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#recorddataactionlabel","title":"<code>recordDataActionLabel</code>","text":"<pre><code><pre>recordDataActionLabel : LocalTSStorageActionExec :=  ActionExec.Seq [recordDataAction];</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#deletedataactionlabel","title":"<code>deleteDataActionLabel</code>","text":"<pre><code><pre>deleteDataActionLabel : LocalTSStorageActionExec :=  ActionExec.Seq [deleteDataAction];</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#localtsstorageguard","title":"<code>LocalTSStorageGuard</code>","text":"<p> <pre><code><pre>LocalTSStorageGuard : Type :=  Guard    LocalTSStorageLocalCfg    LocalTSStorageLocalState    LocalTSStorageMailboxState    LocalTSStorageTimerHandle    LocalTSStorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#localtsstorageguardoutput","title":"<code>LocalTSStorageGuardOutput</code>","text":"<p> <pre><code><pre>LocalTSStorageGuardOutput : Type :=  GuardOutput    LocalTSStorageLocalCfg    LocalTSStorageLocalState    LocalTSStorageMailboxState    LocalTSStorageTimerHandle    LocalTSStorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#localtsstorageguardeval","title":"<code>LocalTSStorageGuardEval</code>","text":"<p> <pre><code><pre>LocalTSStorageGuardEval : Type :=  GuardEval    LocalTSStorageLocalCfg    LocalTSStorageLocalState    LocalTSStorageMailboxState    LocalTSStorageTimerHandle    LocalTSStorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#getdataguard","title":"<code>getDataGuard</code>","text":"Condition Message type is <code>LocalTSStorageMsgGetRequest</code>. <pre><code><pre>getDataGuard  (trigger : LocalTSStorageTimestampedTrigger)  (cfg : LocalTSStorageCfg)  (env : LocalTSStorageEnv)  : Option LocalTSStorageGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{             msg := Anoma.Msg.LocalTSStorage (LocalTSStorageMsg.GetRequest _);           } :=      some        GuardOutput.mk@{          action := getDataActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#recorddataguard","title":"<code>recordDataGuard</code>","text":"Condition Message type is <code>LocalTSStorageMsgRecordRequest</code>. <pre><code><pre>recordDataGuard  (trigger : LocalTSStorageTimestampedTrigger)  (cfg : LocalTSStorageCfg)  (env : LocalTSStorageEnv)  : Option LocalTSStorageGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{             msg := Anoma.Msg.LocalTSStorage (LocalTSStorageMsg.RecordRequest _);           } :=      some        GuardOutput.mk@{          action := recordDataActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#deletedataguard","title":"<code>deleteDataGuard</code>","text":"Condition Message type is <code>LocalTSStorageMsgDeleteRequest</code>. <pre><code><pre>deleteDataGuard  (trigger : LocalTSStorageTimestampedTrigger)  (cfg : LocalTSStorageCfg)  (env : LocalTSStorageEnv)  : Option LocalTSStorageGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{             msg := Anoma.Msg.LocalTSStorage (LocalTSStorageMsg.DeleteRequest _);           } :=      some        GuardOutput.mk@{          action := deleteDataActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#the-local-time-series-storage-behaviour","title":"The Local Time Series Storage Behaviour","text":"","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#localtsstoragebehaviour","title":"<code>LocalTSStorageBehaviour</code>","text":"<pre><code><pre>LocalTSStorageBehaviour : Type :=  EngineBehaviour    LocalTSStorageLocalCfg    LocalTSStorageLocalState    LocalTSStorageMailboxState    LocalTSStorageTimerHandle    LocalTSStorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>localTSStorageBehaviour : LocalTSStorageBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [getDataGuard; recordDataGuard; deleteDataGuard];  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#local-time-series-storage-action-flowcharts","title":"Local Time Series Storage Action Flowcharts","text":"","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#getdata-flowchart","title":"<code>getData</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;LocalTSStorageMsgGetRequest]\n  end\n\n  G(getDataGuard)\n  A(getDataAction)\n\n  C --&gt; G -- *getDataActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EMsg&gt;LocalTSStorageMsgGetReply]\n  end</code></pre> <code>getData</code> flowchart","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#recorddata-flowchart","title":"<code>recordData</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;LocalTSStorageMsgRecordRequest]\n  end\n\n  G(recordDataGuard)\n  A(recordDataAction)\n\n  C --&gt; G -- *recordDataActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(DB update)]\n    EMsg1&gt;LocalTSStorageMsgRecordReply]\n    EMsg2&gt;LocalTSStorageMsgDataChanged]\n  end</code></pre> <code>recordData</code> flowchart","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_behaviour.html#deletedata-flowchart","title":"<code>deleteData</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;LocalTSStorageMsgDeleteRequest]\n  end\n\n  G(deleteDataGuard)\n  A(deleteDataAction)\n\n  C --&gt; G -- *deleteDataActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(DB update)]\n    EMsg1&gt;LocalTSStorageMsgDeleteReply]\n    EMsg2&gt;LocalTSStorageMsgDataChanged]\n  end</code></pre> <code>deleteData</code> flowchart","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","behaviour"]},{"location":"arch/node/engines/local_time_series_storage_config.html","title":"Local Time Series Storage Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.local_time_series_storage_config;import prelude open;import arch.node.engines.local_time_series_storage_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","configuration"]},{"location":"arch/node/engines/local_time_series_storage_config.html#local-time-series-storage-configuration","title":"Local Time Series Storage Configuration","text":"","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","configuration"]},{"location":"arch/node/engines/local_time_series_storage_config.html#overview","title":"Overview","text":"<p>The Local Time Series Storage engine configuration contains static information for Local Time Series Storage engine instances.</p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","configuration"]},{"location":"arch/node/engines/local_time_series_storage_config.html#the-local-time-series-storage-local-configuration","title":"The Local Time Series Storage Local Configuration","text":"","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","configuration"]},{"location":"arch/node/engines/local_time_series_storage_config.html#localtsstoragelocalcfg","title":"<code>LocalTSStorageLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type LocalTSStorageLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","configuration"]},{"location":"arch/node/engines/local_time_series_storage_config.html#the-local-time-series-storage-configuration","title":"The Local Time Series Storage Configuration","text":"","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","configuration"]},{"location":"arch/node/engines/local_time_series_storage_config.html#localtsstoragecfg","title":"<code>LocalTSStorageCfg</code>","text":"<pre><code><pre>LocalTSStorageCfg : Type := EngineCfg LocalTSStorageLocalCfg;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","configuration"]},{"location":"arch/node/engines/local_time_series_storage_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>localTSStorageCfg : LocalTSStorageCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"local time series storage\";    cfg := LocalTSStorageLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","configuration"]},{"location":"arch/node/engines/local_time_series_storage_environment.html","title":"Local Time Series Storage Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.local_time_series_storage_environment;import prelude open;import arch.node.engines.local_time_series_storage_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","environment"]},{"location":"arch/node/engines/local_time_series_storage_environment.html#local-time-series-storage-environment","title":"Local Time Series Storage Environment","text":"","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","environment"]},{"location":"arch/node/engines/local_time_series_storage_environment.html#overview","title":"Overview","text":"<p>The Local Time Series Storage Engine maintains a database of time series data with query and update capabilities.</p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","environment"]},{"location":"arch/node/engines/local_time_series_storage_environment.html#mailbox-state","title":"Mailbox state","text":"<pre><code><pre>syntax alias LocalTSStorageMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","environment"]},{"location":"arch/node/engines/local_time_series_storage_environment.html#local-state","title":"Local state","text":"Auxiliary Juvix code <p><pre><code><pre>syntax alias Database := String;axiom updateDB : Database -&gt; TSStorageDBQuery -&gt; TSStorageDBData -&gt; Database;axiom queryDB : Database -&gt; TSStorageDBQuery -&gt; Option TSStorageDBData;axiom getNotificationTargets : TSStorageDBQuery -&gt; List EngineID;axiom advanceTime : EpochTimestamp -&gt; EpochTimestamp;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","environment"]},{"location":"arch/node/engines/local_time_series_storage_environment.html#localtsstoragelocalstate","title":"<code>LocalTSStorageLocalState</code>","text":"<pre><code><pre>type LocalTSStorageLocalState :=  mk@{    db : Database;    localClock : EpochTimestamp;  };</pre></code></pre> Arguments <code>db</code> The database storing the time series data. <code>localClock</code> The local time of the engine, used to make timestamps.","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","environment"]},{"location":"arch/node/engines/local_time_series_storage_environment.html#timer-handle","title":"Timer Handle","text":"<pre><code><pre>syntax alias LocalTSStorageTimerHandle := Unit;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","environment"]},{"location":"arch/node/engines/local_time_series_storage_environment.html#localtsstoragetimestampedtrigger","title":"<code>LocalTSStorageTimestampedTrigger</code>","text":"<pre><code><pre>LocalTSStorageTimestampedTrigger : Type :=  TimestampedTrigger LocalTSStorageTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","environment"]},{"location":"arch/node/engines/local_time_series_storage_environment.html#the-local-time-series-storage-environment","title":"The Local Time Series Storage Environment","text":"","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","environment"]},{"location":"arch/node/engines/local_time_series_storage_environment.html#localtsstorageenv","title":"<code>LocalTSStorageEnv</code>","text":"<pre><code><pre>LocalTSStorageEnv : Type :=  EngineEnv    LocalTSStorageLocalState    LocalTSStorageMailboxState    LocalTSStorageTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","environment"]},{"location":"arch/node/engines/local_time_series_storage_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>localTSStorageEnv : LocalTSStorageEnv :=  EngineEnv.mk@{    localState :=      LocalTSStorageLocalState.mk@{        db := \"\";        localClock := 0;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","environment"]},{"location":"arch/node/engines/local_time_series_storage_messages.html","title":"Local Time Series Storage Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.local_time_series_storage_messages;import prelude open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#local-time-series-storage-messages","title":"Local Time Series Storage Messages","text":"<p>These are the messages that the Local Time Series Storage engine can receive/respond to.</p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type LocalTSStorageMsg :=  | GetRequest GetDataTSStorageDBRequest  | GetReply GetDataTSStorageDBReply  | RecordRequest RecordDataTSStorageDBRequest  | RecordReply RecordDataTSStorageDBReply  | DeleteRequest DeleteDataTSStorageDBRequest  | DeleteReply DeleteDataTSStorageDBReply  | DataChanged DataChangedTSStorageDB;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#getdatatsstoragedbrequest-and-getdatatsstoragedbreply","title":"<code>GetDataTSStorageDBRequest</code> and <code>GetDataTSStorageDBReply</code>","text":"<pre><code>sequenceDiagram\n    participant AnyEngine\n    participant LocalTSStorageDB\n\n    AnyEngine -&gt;&gt; LocalTSStorageDB: GetDataTSStorageDBRequest\n    LocalTSStorageDB -&gt;&gt; AnyEngine: GetDataTSStorageDBReply</code></pre>  Sequence diagram: Get data flow","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#recorddatatsstoragedbrequest-and-recorddatatsstoragedbreply","title":"<code>RecordDataTSStorageDBRequest</code> and <code>RecordDataTSStorageDBReply</code>","text":"<pre><code>sequenceDiagram\n    participant AnyEngine\n    participant LocalTSStorageDB\n\n    AnyEngine -&gt;&gt; LocalTSStorageDB: RecordDataTSStorageDBRequest\n    LocalTSStorageDB -&gt;&gt; AnyEngine: RecordDataTSStorageDBReply</code></pre>  Sequence diagram: Record data flow","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#deletedatatsstoragedbrequest-and-deletedatatsstoragedbreply","title":"<code>DeleteDataTSStorageDBRequest</code> and <code>DeleteDataTSStorageDBReply</code>","text":"<pre><code>sequenceDiagram\n    participant AnyEngine\n    participant LocalTSStorageDB\n\n    AnyEngine -&gt;&gt; LocalTSStorageDB: DeleteDataTSStorageDBRequest\n    LocalTSStorageDB -&gt;&gt; AnyEngine: DeleteDataTSStorageDBReply</code></pre>  Sequence diagram: Delete data flow","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#message-types","title":"Message types","text":"Auxiliary Juvix code <p><pre><code><pre>syntax alias TSStorageDBQuery := String;syntax alias TSStorageDBData := String;syntax alias EpochTimestamp := Nat;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#getdatatsstoragedbrequest","title":"<code>GetDataTSStorageDBRequest</code>","text":"<pre><code><pre>type GetDataTSStorageDBRequest :=  mkGetDataTSStorageDBRequest@{    query : TSStorageDBQuery;  };</pre></code></pre> Arguments <code>query</code> The query to find the requested time series data in the DB.","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#getdatatsstoragedbreply","title":"<code>GetDataTSStorageDBReply</code>","text":"<pre><code><pre>type GetDataTSStorageDBReply :=  mkGetDataTSStorageDBReply@{    query : TSStorageDBQuery;    data : TSStorageDBData;  };</pre></code></pre> Arguments <code>query</code> The query to find the requested time series data in the DB. <code>data</code> The requested time series data.","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#recorddatatsstoragedbrequest","title":"<code>RecordDataTSStorageDBRequest</code>","text":"<pre><code><pre>type RecordDataTSStorageDBRequest :=  mkRecordDataTSStorageDBRequest@{    query : TSStorageDBQuery;  };</pre></code></pre> Arguments <code>query</code> <p>The query that expresses the addition of the time series data into the DB.</p>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#recorddatatsstoragedbreply","title":"<code>RecordDataTSStorageDBReply</code>","text":"<pre><code><pre>type RecordDataTSStorageDBReply :=  mkRecordDataTSStorageDBReply@{    query : TSStorageDBQuery;    success : Bool;  };</pre></code></pre> Arguments <code>query</code> The query that expresses the recording of the time series data into the DB. <code>success</code> The success of the operation, indicating if the data was stored successfully or not.","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#deletedatatsstoragedbrequest","title":"<code>DeleteDataTSStorageDBRequest</code>","text":"<pre><code><pre>type DeleteDataTSStorageDBRequest :=  mkDeleteDataTSStorageDBRequest@{    query : TSStorageDBQuery;  };</pre></code></pre> Arguments <code>query</code> The query that expresses the deletion of the time series data from the DB.","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#deletedatatsstoragedbreply","title":"<code>DeleteDataTSStorageDBReply</code>","text":"<pre><code><pre>type DeleteDataTSStorageDBReply :=  mkDeleteDataTSStorageDBReply@{    query : TSStorageDBQuery;    success : Bool;  };</pre></code></pre> Arguments <code>query</code> The query that expresses the deletion of the time series data from the DB. <code>success</code> The success of the operation, indicating if the data was deleted successfully or not.","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#datachangedtsstoragedb","title":"<code>DataChangedTSStorageDB</code>","text":"<pre><code><pre>type DataChangedTSStorageDB :=  mkDataChangedTSStorageDB@{    query : TSStorageDBQuery;    data : TSStorageDBData;    timestamp : EpochTimestamp;  };</pre></code></pre> Arguments <code>query</code> The query that expresses the change of the time series DB. <code>data</code> The changed time series data. <code>timestamp</code> The wall clock time of the moment the data was changed.","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#localtsstoragemsg","title":"<code>LocalTSStorageMsg</code>","text":"<pre><code><pre>type LocalTSStorageMsg :=  | GetRequest GetDataTSStorageDBRequest  | GetReply GetDataTSStorageDBReply  | RecordRequest RecordDataTSStorageDBRequest  | RecordReply RecordDataTSStorageDBReply  | DeleteRequest DeleteDataTSStorageDBRequest  | DeleteReply DeleteDataTSStorageDBReply  | DataChanged DataChangedTSStorageDB;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/local_time_series_storage_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Local Time Series Storage Configuration</li> <li>Local Time Series Storage Environment</li> <li>Local Time Series Storage Behaviour</li> </ul>","tags":["node-architecture","hardware-subsystem","engine","local-time-series-storage","message-types"]},{"location":"arch/node/engines/logging.html","title":"Logging Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.logging;import prelude open;import arch.node.types.engine open;import arch.node.engines.logging_messages open public;import arch.node.engines.logging_environment open public;import arch.node.engines.logging_behaviour open public;import arch.node.engines.logging_config open public;import arch.node.types.anoma as Anoma open;open logging_config_example;open logging_environment_example;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","logging","engine-definition"]},{"location":"arch/node/engines/logging.html#logging-engine","title":"Logging Engine","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","engine-definition"]},{"location":"arch/node/engines/logging.html#purpose","title":"Purpose","text":"<p>The Logging Engine provides capabilities for recording, monitoring, analyzing, and managing events and activities locally on the physical machine that the Anoma node is running. It supports diagnostic efforts, security monitoring, performance optimization, and historical analysis to ensure stability, security, and efficiency.</p>","tags":["node-architecture","hardware-subsystem","engine","logging","engine-definition"]},{"location":"arch/node/engines/logging.html#engine-components","title":"Engine components","text":"<ul> <li>Logging Messages</li> <li>Logging Configuration</li> <li>Logging Environment</li> <li>Logging Behaviour</li> </ul>","tags":["node-architecture","hardware-subsystem","engine","logging","engine-definition"]},{"location":"arch/node/engines/logging.html#type","title":"Type","text":"<pre><code><pre>LoggingEngine : Type :=  Engine    LoggingLocalCfg    LoggingLocalState    LoggingMailboxState    LoggingTimerHandle    LoggingActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","engine-definition"]},{"location":"arch/node/engines/logging.html#example-of-a-logging-engine","title":"Example of a logging engine","text":"<pre><code><pre>exampleLoggingEngine : LoggingEngine :=  Engine.mk@{    cfg := loggingCfg;    env := loggingEnv;    behaviour := loggingBehaviour;  };</pre></code></pre> <p>where <code>loggingCfg</code> is defined as follows:</p> <pre><code><pre>loggingCfg : LoggingCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"logging\";    cfg := LoggingLocalCfg.mk;  };</pre></code></pre> <p><code>loggingEnv</code> is defined as follows:</p> <pre><code><pre>loggingEnv : LoggingEnv :=  EngineEnv.mk@{    localState :=      LoggingLocalState.mk@{        logbook := [];      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>loggingBehaviour</code> is defined as follows:</p> <pre><code><pre>loggingBehaviour : LoggingBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [appendLogGuard];  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","engine-definition"]},{"location":"arch/node/engines/logging_behaviour.html","title":"Logging Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.logging_behaviour;import arch.node.engines.logging_messages open;import arch.node.engines.logging_config open;import arch.node.engines.logging_environment open;import prelude open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#logging-behaviour","title":"Logging Behaviour","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#overview","title":"Overview","text":"<p>A logging engine maintains a logbook of entries and provides the capability to append new entries.</p>","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#loggingactionargument","title":"<code>LoggingActionArgument</code>","text":"<pre><code><pre>type LoggingActionArgument := Unit;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#loggingactionarguments","title":"<code>LoggingActionArguments</code>","text":"<pre><code><pre>LoggingActionArguments : Type := List LoggingActionArgument;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#loggingaction","title":"<code>LoggingAction</code>","text":"<p> <pre><code><pre>LoggingAction : Type :=  Action    LoggingLocalCfg    LoggingLocalState    LoggingMailboxState    LoggingTimerHandle    LoggingActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#loggingactioninput","title":"<code>LoggingActionInput</code>","text":"<p> <pre><code><pre>LoggingActionInput : Type :=  ActionInput    LoggingLocalCfg    LoggingLocalState    LoggingMailboxState    LoggingTimerHandle    LoggingActionArguments    Anoma.Msg;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#loggingactioneffect","title":"<code>LoggingActionEffect</code>","text":"<p> <pre><code><pre>LoggingActionEffect : Type :=  ActionEffect    LoggingLocalState    LoggingMailboxState    LoggingTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#loggingactionexec","title":"<code>LoggingActionExec</code>","text":"<p> <pre><code><pre>LoggingActionExec : Type :=  ActionExec    LoggingLocalCfg    LoggingLocalState    LoggingMailboxState    LoggingTimerHandle    LoggingActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#appendlogaction","title":"<code>appendLogAction</code>","text":"<p>Append new log entry to the logbook.</p> State update Add the new log entry to the logbook. Messages to be sent No messages are sent by this action. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>appendLogAction (input : LoggingActionInput) : Option LoggingActionEffect :=  let    env := ActionInput.env input;    trigger := ActionInput.trigger input;  in case getEngineMsgFromTimestampedTrigger trigger of       | some EngineMsg.mk@{                msg := Anoma.Msg.Logging (LoggingMsg.Append AppendValue.mk@{                                                              value := value;                                                            });              } :=         let           currentLogbook :=             LoggingLocalState.logbook (EngineEnv.localState env);           newLogbook := value :: currentLogbook;         in some           ActionEffect.mk@{             env :=               env@EngineEnv{localState := LoggingLocalState.mk@{                                             logbook := newLogbook;                                           }};             msgs := [];             timers := [];             engines := [];           }       | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#appendlogactionlabel","title":"<code>appendLogActionLabel</code>","text":"<pre><code><pre>appendLogActionLabel : LoggingActionExec := ActionExec.Seq [appendLogAction];</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code <p><pre><code><pre>LoggingGuard : Type :=  Guard    LoggingLocalCfg    LoggingLocalState    LoggingMailboxState    LoggingTimerHandle    LoggingActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;LoggingGuardOutput : Type :=  GuardOutput    LoggingLocalCfg    LoggingLocalState    LoggingMailboxState    LoggingTimerHandle    LoggingActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;LoggingGuardEval : Type :=  GuardEval    LoggingLocalCfg    LoggingLocalState    LoggingMailboxState    LoggingTimerHandle    LoggingActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#appendlogguard","title":"<code>appendLogGuard</code>","text":"<p>Guard for append log action.</p> Condition Message type is <code>Append</code>. <pre><code><pre>appendLogGuard  (trigger : LoggingTimestampedTrigger)  (cfg : LoggingCfg)  (env : LoggingEnv)  : Option LoggingGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{msg := Anoma.Msg.Logging (LoggingMsg.Append _)} :=      some        GuardOutput.mk@{          action := appendLogActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#the-logging-behaviour","title":"The Logging behaviour","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#loggingbehaviour","title":"<code>LoggingBehaviour</code>","text":"<pre><code><pre>LoggingBehaviour : Type :=  EngineBehaviour    LoggingLocalCfg    LoggingLocalState    LoggingMailboxState    LoggingTimerHandle    LoggingActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>loggingBehaviour : LoggingBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [appendLogGuard];  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#logging-action-flowchart","title":"Logging Action Flowchart","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_behaviour.html#appendlog-flowchart","title":"<code>appendLog</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;Append]\n  end\n\n  G(appendLogGuard)\n  A(appendLogAction)\n\n  C --&gt; G -- *appendLogActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(Update logbook)]\n  end</code></pre> <code>appendLog</code> flowchart","tags":["node-architecture","hardware-subsystem","engine","logging","behaviour"]},{"location":"arch/node/engines/logging_config.html","title":"Logging Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.logging_config;import prelude open;import arch.node.engines.logging_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","logging","configuration"]},{"location":"arch/node/engines/logging_config.html#logging-configuration","title":"Logging Configuration","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","configuration"]},{"location":"arch/node/engines/logging_config.html#overview","title":"Overview","text":"<p>The logging engine configuration contains static information for logging engine instances.</p>","tags":["node-architecture","hardware-subsystem","engine","logging","configuration"]},{"location":"arch/node/engines/logging_config.html#the-logging-local-configuration","title":"The Logging Local Configuration","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","configuration"]},{"location":"arch/node/engines/logging_config.html#logginglocalcfg","title":"<code>LoggingLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type LoggingLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","configuration"]},{"location":"arch/node/engines/logging_config.html#the-logging-configuration","title":"The Logging Configuration","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","configuration"]},{"location":"arch/node/engines/logging_config.html#loggingcfg","title":"<code>LoggingCfg</code>","text":"<pre><code><pre>LoggingCfg : Type := EngineCfg LoggingLocalCfg;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","configuration"]},{"location":"arch/node/engines/logging_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>loggingCfg : LoggingCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"logging\";    cfg := LoggingLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","configuration"]},{"location":"arch/node/engines/logging_environment.html","title":"Logging Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.logging_environment;import prelude open;import arch.node.engines.logging_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","logging","environment"]},{"location":"arch/node/engines/logging_environment.html#logging-environment","title":"Logging Environment","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","environment"]},{"location":"arch/node/engines/logging_environment.html#overview","title":"Overview","text":"<p>The logging environment maintains the state necessary for recording logs locally on the physical machine.</p>","tags":["node-architecture","hardware-subsystem","engine","logging","environment"]},{"location":"arch/node/engines/logging_environment.html#mailbox-state-types","title":"Mailbox state types","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","environment"]},{"location":"arch/node/engines/logging_environment.html#loggingmailboxstate","title":"<code>LoggingMailboxState</code>","text":"<pre><code><pre>syntax alias LoggingMailboxState := Unit;</pre></code></pre> <p>The logging engine does not require complex mailbox states.</p>","tags":["node-architecture","hardware-subsystem","engine","logging","environment"]},{"location":"arch/node/engines/logging_environment.html#local-state","title":"Local state","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","environment"]},{"location":"arch/node/engines/logging_environment.html#logginglocalstate","title":"<code>LoggingLocalState</code>","text":"<pre><code><pre>type LoggingLocalState :=  mk@{    logbook : List String;  };</pre></code></pre> Arguments <code>logbook</code> List of log entries stored as strings.","tags":["node-architecture","hardware-subsystem","engine","logging","environment"]},{"location":"arch/node/engines/logging_environment.html#timer-handles","title":"Timer handles","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","environment"]},{"location":"arch/node/engines/logging_environment.html#loggingtimerhandle","title":"<code>LoggingTimerHandle</code>","text":"<pre><code><pre>syntax alias LoggingTimerHandle := Unit;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","environment"]},{"location":"arch/node/engines/logging_environment.html#loggingtimestampedtrigger","title":"<code>LoggingTimestampedTrigger</code>","text":"<pre><code><pre>LoggingTimestampedTrigger : Type :=  TimestampedTrigger LoggingTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","environment"]},{"location":"arch/node/engines/logging_environment.html#the-logging-environment","title":"The Logging Environment","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","environment"]},{"location":"arch/node/engines/logging_environment.html#loggingenv","title":"<code>LoggingEnv</code>","text":"<pre><code><pre>LoggingEnv : Type :=  EngineEnv LoggingLocalState LoggingMailboxState LoggingTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","environment"]},{"location":"arch/node/engines/logging_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>loggingEnv : LoggingEnv :=  EngineEnv.mk@{    localState :=      LoggingLocalState.mk@{        logbook := [];      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","environment"]},{"location":"arch/node/engines/logging_messages.html","title":"Logging Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.logging_messages;import prelude open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","logging","message-types"]},{"location":"arch/node/engines/logging_messages.html#logging-messages","title":"Logging Messages","text":"<p>These are the messages that the Logging engine can receive/respond to.</p>","tags":["node-architecture","hardware-subsystem","engine","logging","message-types"]},{"location":"arch/node/engines/logging_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type LoggingMsg := | Append AppendValue;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","message-types"]},{"location":"arch/node/engines/logging_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","message-types"]},{"location":"arch/node/engines/logging_messages.html#appending-a-log-entry","title":"Appending a log entry","text":"<pre><code>sequenceDiagram\n    participant LocalEngine\n    participant LoggingEngine\n\n    LocalEngine -&gt;&gt; LoggingEngine: Append\n    Note over LoggingEngine: Appends the value to logbook</code></pre>  A local engine sends a log entry to be appended to the logbook","tags":["node-architecture","hardware-subsystem","engine","logging","message-types"]},{"location":"arch/node/engines/logging_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","hardware-subsystem","engine","logging","message-types"]},{"location":"arch/node/engines/logging_messages.html#appendvalue","title":"<code>AppendValue</code>","text":"<pre><code><pre>type AppendValue :=  mk@{    value : String;  };</pre></code></pre> Arguments <code>value</code>: The value in string format to be added to the logbook.","tags":["node-architecture","hardware-subsystem","engine","logging","message-types"]},{"location":"arch/node/engines/logging_messages.html#loggingmsg","title":"<code>LoggingMsg</code>","text":"<pre><code><pre>type LoggingMsg := | Append AppendValue;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","logging","message-types"]},{"location":"arch/node/engines/logging_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Logging Configuration</li> <li>Logging Environment</li> <li>Logging Behaviour</li> </ul>","tags":["node-architecture","hardware-subsystem","engine","logging","message-types"]},{"location":"arch/node/engines/mempool_worker.html","title":"Mempool Worker Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.mempool_worker;import prelude open;import arch.node.types.engine open;import arch.node.engines.mempool_worker_config open public;import arch.node.engines.mempool_worker_messages open public;import arch.node.engines.mempool_worker_environment open public;import arch.node.engines.mempool_worker_behaviour open public;import arch.node.types.anoma as Anoma open;open mempool_worker_config_example;open mempool_worker_environment_example;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","engine-definition"]},{"location":"arch/node/engines/mempool_worker.html#mempool-worker-engine","title":"Mempool Worker Engine","text":"<p>The Mempool Worker Engine serves as a transaction coordinator in Anoma, managing the critical process of ordering transactions and orchestrating their execution. Think of it as a traffic controller that not only assigns each transaction a unique position in line (via a timestamp called a TxFingerprint), but also ensures all the necessary resources (state access) are locked and ready before execution begins. In the current version of Anoma (up to v0.2), there is only a single Mempool Worker Engine instance, making it the central coordinator for all transaction processing.</p> <p>When users or solvers submit transactions (via <code>MempoolWorkerMsgTransactionRequest</code>), the Worker examines the transaction's label to understand what state it may need to access - which keys it may read from and/or write to. It assigns each transaction a unique fingerprint (called a <code>timestamp</code>) that establishes its position in the execution order, and returns an acknowledgment (<code>MempoolWorkerMsgTransactionAck</code>) to the submitter. This acknowledgment includes a signature over the transaction hash and metadata, providing proof of acceptance into the processing pipeline.</p> <p>The Worker's core responsibility is managing a sophisticated locking protocol that ensures transactions can execute safely and efficiently. For each transaction, it sends <code>KVSAcquireLock</code> messages to all Shards that manage keys the transaction needs to access. These locks specify which keys will definitely be read (<code>eager_read_keys</code>), which might be read (<code>lazy_read_keys</code>), which will definitely be written (<code>will_write_keys</code>), and which might be written (<code>may_write_keys</code>). The Shards respond with <code>KVSLockAcquired</code> messages once they've recorded these access intentions.</p> <p>A crucial part of the Worker's job is tracking the \"seen-all\" points - timestamps before which all Shards have processed all relevant lock requests. It maintains two such points: <code>seen_all_writes</code> for write locks and <code>seen_all_reads</code> for read locks. When Shards confirm lock acquisition, the Worker updates these points and broadcasts them to all Shards via <code>UpdateSeenAll</code> messages. This information is vital for the Shards to know when they can safely process read requests and perform state updates, as it guarantees no earlier lock requests are still pending.</p> <p>For each transaction, the Worker spawns an Executor Engine (configured with the transaction's program and access rights) and maintains a mapping between Executors and their transactions. As Executors complete their work, they notify the Worker via <code>ExecutorMsgExecutorFinished</code> messages containing summaries of what was read and written. The Worker collects these execution summaries, maintaining a record of transaction processing outcomes.</p> <p>The Mempool Worker's state tracks pending transactions and their corresponding Executors, maintains the mapping of transactions to their fingerprints, collects lock acquisition confirmations, tracks the seen-all barriers, and stores execution summaries. This state allows it to provide the ordering and coordination services needed for Anoma's parallel execution model, where multiple transactions can process simultaneously so long as their state access patterns don't conflict, ensuring serializability.</p>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","engine-definition"]},{"location":"arch/node/engines/mempool_worker.html#purpose","title":"Purpose","text":"<p>Workers are one of the mempool engines and, up to v0.2, they are the only one and there is only a single worker.</p> <p>The worker receives transaction requests from users and solvers and batches these transaction requests, assigning a unique TxFingerprint to every new transaction. Each transaction candidate will be sent to an Executor inside an ExecuteTransaction message. Once the worker has received a KVSLockAcquired for every part of the transaction request's label (from the shards of the same Anoma validator in response to KVSAcquireLock-messages), it knows that this transaction candidate has been \"seen\" by all Shards, which implies that all shards are prepared to process lock requests from execution processes (see KVSReadRequest and KVSWrite for details). This information about locks being recorded is distributed to all shards via UpdateSeenAll messages, which contain the most recent TxFingerprint for which it is certain that all Shards have \"seen\" this transaction candidate and all previous ones from the same worker (and they are thus prepared to grant locks). Note that if shards receive transaction candidates in a different order than the final total order of transactions, UpdateSeenAll messages are necessary to avoid that shards grant locks before all locks of previous transaction executions have been served.</p> <p>Workers also are in charge of collecting and curating logs of transaction execution. Success is equivalent to all reads and writes being successful and an ExecutorFinished-message from the executor that was spawned to execute the message.</p>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","engine-definition"]},{"location":"arch/node/engines/mempool_worker.html#engine-components","title":"Engine components","text":"<ul> <li>Mempool Worker Messages</li> <li>Mempool Worker Configuration</li> <li>Mempool Worker Environment</li> <li>Mempool Worker Behaviour</li> </ul>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","engine-definition"]},{"location":"arch/node/engines/mempool_worker.html#the-type-for-a-mempool-worker-engine","title":"The type for a mempool worker engine","text":"<pre><code><pre>MempoolWorkerEngine : Type :=  Engine    MempoolWorkerLocalCfg    MempoolWorkerLocalState    MempoolWorkerMailboxState    MempoolWorkerTimerHandle    MempoolWorkerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","engine-definition"]},{"location":"arch/node/engines/mempool_worker.html#example-of-a-mempool-worker-engine","title":"Example of a mempool worker engine","text":"<pre><code><pre>exampleMempoolWorkerEngine : MempoolWorkerEngine :=  Engine.mk@{    cfg := mempoolWorkerCfg;    env := mempoolWorkerEnv;    behaviour := mempoolWorkerBehaviour;  };</pre></code></pre> <p>where <code>mempoolWorkerCfg</code> is defined as follows:</p> <pre><code><pre>mempoolWorkerCfg : MempoolWorkerCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"mempool worker\";    cfg :=      MempoolWorkerLocalCfg.mk@{        keyToShard := \\{_ := mkPair none \"shard\"};      };  };</pre></code></pre> <p>where <code>mempoolWorkerEnv</code> is defined as follows:</p> <pre><code><pre>mempoolWorkerEnv : MempoolWorkerEnv :=  EngineEnv.mk@{    localState :=      MempoolWorkerLocalState.mk@{        batch_number := 0;        transactions := Map.empty;        transactionEngines := Map.empty;        locks_acquired := [];        seen_all_writes := 0;        seen_all_reads := 0;        execution_summaries := Map.empty;        gensym := 0;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>mempoolWorkerBehaviour</code> is defined as follows:</p> <pre><code><pre>mempoolWorkerBehaviour : MempoolWorkerBehaviour :=  EngineBehaviour.mk@{    guards :=      GuardEval.First        [transactionRequestGuard; lockAcquiredGuard; executorFinishedGuard];  };</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","engine-definition"]},{"location":"arch/node/engines/mempool_worker_behaviour.html","title":"Mempool Worker Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.mempool_worker_behaviour;import arch.node.engines.mempool_worker_messages open;import arch.node.engines.mempool_worker_config open;import arch.node.engines.mempool_worker_environment open;import arch.node.engines.shard_messages open;import arch.node.engines.executor_messages open;import arch.node.engines.executor_config open;import arch.node.engines.executor_environment open;import prelude open;import Stdlib.Data.Nat open;import Stdlib.Data.List as List;import Stdlib.Data.Set as Set;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;import arch.system.state.resource_machine.notes.runnable open;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#mempool-worker-behaviour","title":"Mempool Worker Behaviour","text":"","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#overview","title":"Overview","text":"<p>A mempool worker acts as a transaction coordinator, receiving transaction requests, managing their execution lifecycle, and coordinating with shards and executors.</p> Auxiliary Juvix code <p><pre><code><pre>sign  : TxFingerprint    -&gt; TransactionCandidate KVSKey KVSKey Executable    -&gt; Signature := \\{txfp  := Signature.Ed25519Signature (natToString txfp)};hash : TxFingerprint -&gt; TransactionCandidate KVSKey KVSKey Executable -&gt; Hash :=  \\{txfp  := txfp};","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#mempool-worker-action-flowcharts","title":"Mempool Worker Action Flowcharts","text":"","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#transactionrequestaction-flowchart","title":"<code>transactionRequestAction</code> flowchart","text":"<p>```mermaidflowchart TD\n    Start([Client Request]) --&gt; MsgReq[MempoolWorkerMsg.TransactionRequesttx: TransactionCandidate]</p>\n<pre><code>subgraph Guard[\"transactionRequestGuard\"]\n    MsgReq --&gt; ValidType{Is message type&lt;br/&gt;TransactionRequest?}\n    ValidType --&gt;|No| Reject([Reject Request])\n    ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\nend\n\nActionEntry --&gt; Action\n\nsubgraph Action[\"transactionRequestAction\"]\n    direction TB\n    GenFP[Generate new fingerprint&lt;br/&gt;from gensym]\n    GenFP --&gt; SpawnEx[Create Executor Config&lt;br/&gt;with access rights]\n    SpawnEx --&gt; UpdateState[Update local state:&lt;br/&gt;- Increment gensym&lt;br/&gt;- Add to transactions map&lt;br/&gt;- Add to engine map]\n    UpdateState --&gt; PrepLocks[Prepare lock requests&lt;br/&gt;for each shard]\nend\n\nPrepLocks --&gt; Msgs\n\nsubgraph Msgs[Messages and Effects]\n    MsgAck[TransactionAck to client&lt;br/&gt;with fingerprint &amp; signature]\n    MsgLock[KVSAcquireLock to shards&lt;br/&gt;with read/write keys]\n    SpawnEng[Spawn Executor Engine]\nend\n\nstyle Guard fill:#f0f7ff,stroke:#333,stroke-width:2px\nstyle Action fill:#fff7f0,stroke:#333,stroke-width:2px\nstyle Msgs fill:#f7fff0,stroke:#333,stroke-width:2px\n</code></pre>\n<p><code>``\n\n&lt;figcaption markdown=\"span\"&gt;</code>transactionRequestAction` flowchart\n\n\n</p>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#explanation","title":"Explanation","text":"<ol>\n<li>Initial Request<ul>\n<li>A client sends a <code>MempoolWorkerMsg.TransactionRequest</code> containing:<ul>\n<li><code>tx</code>: The transaction candidate to be ordered and executed.</li>\n<li><code>resubmission</code>: Optional reference to a previous occurrence (currently unused).</li>\n</ul>\n</li>\n<li>The transaction candidate includes its program code and access patterns (what it will read/write).\n</li>\n</ul>\n</li>\n<li>Guard Phase (<code>transactionRequestGuard</code>)<ul>\n<li>Verifies message type is <code>MempoolWorkerMsg.TransactionRequest</code>.</li>\n<li>If validation fails, request is rejected.</li>\n<li>On success, passes control to <code>transactionRequestActionLabel</code>.\n</li>\n</ul>\n</li>\n<li>Action Phase (<code>transactionRequestAction</code>)<ul>\n<li>Generates new fingerprint by incrementing gensym counter.</li>\n<li>Creates Executor configuration with:<ul>\n<li>Timestamp set to new fingerprint.</li>\n<li>Executable code from transaction.</li>\n<li>Access rights from transaction label.</li>\n<li>References to worker and transaction issuer.</li>\n</ul>\n</li>\n<li>Updates local state:<ul>\n<li>Increments gensym counter.</li>\n<li>Adds transaction to transactions map.</li>\n<li>Records executor ID to fingerprint mapping.</li>\n</ul>\n</li>\n<li>Prepares lock requests for each affected shard by:<ul>\n<li>Grouping keys by shard.</li>\n<li>Creating appropriate lock request messages.\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Reply Generation<ul>\n<li>Messages sent:<ul>\n<li>To client: <code>MempoolWorkerMsgTransactionAck</code> containing:<ul>\n<li><code>tx_hash</code>: Hash of the transaction</li>\n<li><code>batch_number</code>: Current batch number</li>\n<li><code>worker_id</code>: This worker's ID</li>\n<li><code>signature</code>: Worker's signature over above fields</li>\n</ul>\n</li>\n<li>To shards: <code>KVSAcquireLock</code> messages for each affected shard containing:<ul>\n<li><code>lazy_read_keys</code>: Keys that might be read</li>\n<li><code>eager_read_keys</code>: Keys that will definitely be read</li>\n<li><code>will_write_keys</code>: Keys that will definitely be written</li>\n<li><code>may_write_keys</code>: Keys that might be written</li>\n<li><code>worker</code>: This worker's ID</li>\n<li><code>executor</code>: ID of spawned executor</li>\n<li><code>timestamp</code>: Generated fingerprint\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Replys and Effects<ul>\n<li>Reply Delivery<ul>\n<li>All messages are sent with mailbox 0 (default response mailbox).</li>\n<li>Transaction acknowledgment is sent back to original requester.</li>\n<li>Lock requests are sent to all relevant shards.</li>\n</ul>\n</li>\n<li>Engines spawned:<ul>\n<li>Creates new Executor engine with generated configuration.\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#important-notes","title":"Important Notes:","text":"<ul>\n<li>The fingerprint generation via a gensym is a simple version of what could be a more complex process\n</li>\n</ul>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#lockacquiredaction-flowchart","title":"<code>lockAcquiredAction</code> flowchart","text":"<p>\n\n<code>mermaid\nflowchart TD\n    Start([Shard Reply]) --&gt; MsgReq[ShardMsg.KVSLockAcquired&lt;br/&gt;timestamp: TxFingerprint]\n\n    subgraph Guard[\"lockAcquiredGuard\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br/&gt;LockAcquired?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"lockAcquiredAction\"]\n        direction TB\n        AddLock[Add lock to acquired list]\n        AddLock --&gt; CalcMax[Calculate max consecutive:&lt;br/&gt;- Writes locked&lt;br/&gt;- Reads locked]\n        CalcMax --&gt; UpdateBarriers[Update seen_all barriers:&lt;br/&gt;- seen_all_writes&lt;br/&gt;- seen_all_reads]\n    end\n\n    UpdateBarriers --&gt; Msgs\n\n    subgraph Msgs[Messages and Effects]\n        BcastWrite[UpdateSeenAll to shards&lt;br/&gt;for write barrier]\n        BcastRead[UpdateSeenAll to shards&lt;br/&gt;for read barrier]\n    end</code>\n\n<code>lockAcquiredAction</code> flowchart","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#explanation_1","title":"Explanation","text":"<ol>\n<li>\n<p>Initial Message</p>\n<ul>\n<li>A Mempool Worker receives a <code>ShardMsg.KVSLockAcquired</code> message from a Shard engine.</li>\n<li>The message contains:<ul>\n<li><code>timestamp</code>: The TxFingerprint identifying which transaction's locks were acquired.</li>\n<li>(Implicit) The sender of the message identifies which shard has confirmed the locks.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Guard Phase (<code>lockAcquiredGuard</code>)</p>\n<ul>\n<li>Verifies message type is <code>ShardMsg.KVSLockAcquired</code>.</li>\n<li>If validation fails, request is rejected.</li>\n<li>On success, passes control to <code>lockAcquiredActionLabel</code>.</li>\n</ul>\n</li>\n<li>\n<p>Action Phase (<code>lockAcquiredAction</code>)</p>\n<ul>\n<li>Adds the new lock to the <code>locks_acquired</code> list in state.</li>\n<li>Calculates new maximum consecutive sequence points by analyzing the lock history:<ul>\n<li>For writes: Finds highest fingerprint where all prior write locks are confirmed.</li>\n<li>For reads: Finds highest fingerprint where all prior read locks are confirmed.</li>\n</ul>\n</li>\n<li>Updates internal barriers (<code>seen_all_writes</code> and <code>seen_all_reads</code>) based on calculations.</li>\n<li>Constructs appropriate update messages for all shards.</li>\n</ul>\n</li>\n<li>\n<p>Reply Generation</p>\n<ul>\n<li>Constructs <code>ShardMsgUpdateSeenAll</code> messages for every shard, containing:<ul>\n<li>For write barrier updates:<ul>\n<li><code>timestamp</code>: New <code>seen_all_writes</code> value.</li>\n<li><code>write</code>: true.</li>\n</ul>\n</li>\n<li>For read barrier updates:<ul>\n<li><code>timestamp</code>: New <code>seen_all_reads</code> value.</li>\n<li><code>write</code>: false.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Message Delivery</p>\n<ul>\n<li>Update messages are broadcast to all shards in the system.</li>\n<li>Uses mailbox 0 (the standard mailbox for responses).</li>\n</ul>\n</li>\n</ol>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#executorfinishedaction-flowchart","title":"<code>executorFinishedAction</code> flowchart","text":"<pre><code>flowchart TD\n    Start([Executor Reply]) --&gt; MsgReq[ExecutorMsg.ExecutorFinished&lt;br/&gt;success: Bool&lt;br/&gt;values_read: List KeyValue&lt;br/&gt;values_written: List KeyValue]\n\n    subgraph Guard[\"executorFinishedGuard\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br/&gt;ExecutorFinished?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"executorFinishedAction\"]\n        direction TB\n        FindTx{Lookup transaction&lt;br/&gt;for executor}\n        FindTx --&gt;|Not Found| NoAction[Do Nothing]\n        FindTx --&gt;|Found| Store[Store execution summary&lt;br/&gt;in local state]\n    end\n\n    Store --&gt; Effects\n    NoAction --&gt; NoEffect([No Effect])\n\n    subgraph Effects[Effects]\n        State[Update execution summaries&lt;br/&gt;in local state]\n    end</code></pre>\n\n<code>executorFinishedAction</code> flowchart","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#explanation_2","title":"Explanation","text":"<ol>\n<li>\n<p>Initial Request</p>\n<ul>\n<li>An executor sends a <code>MsgExecutorFinished</code> containing:<ul>\n<li><code>success</code>: Boolean indicating if execution completed successfully.</li>\n<li><code>values_read</code>: List of all key-value pairs that were read during execution.</li>\n<li><code>values_written</code>: List of all key-value pairs that were written during execution.</li>\n</ul>\n</li>\n<li>This message represents the completion of a transaction's execution lifecycle.</li>\n</ul>\n</li>\n<li>\n<p>Guard Phase (<code>executorFinishedGuard</code>)</p>\n<ul>\n<li>Verifies message type is <code>ExecutorMsg.ExecutorFinished</code>.</li>\n<li>If validation fails, request is rejected immediately.</li>\n<li>On success, passes control to <code>executorFinishedLabel</code>.</li>\n</ul>\n</li>\n<li>\n<p>Action Phase (<code>executorFinishedAction</code>)</p>\n<ul>\n<li>Processes valid executor completion notifications through these steps:<ul>\n<li>Looks up the transaction associated with the sending executor in the <code>transactionEngines</code> map.</li>\n<li>If no transaction is found, the notification is ignored (this shouldn't happen in normal operation).</li>\n<li>If transaction is found, stores the execution summary in the <code>execution_summaries</code> map.</li>\n<li>The summary is indexed by the transaction's fingerprint for later reference.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Reply Generation</p>\n<ul>\n<li>Successful Case<ul>\n<li>Updates local state with the new execution summary.</li>\n<li>No response messages are generated.</li>\n</ul>\n</li>\n<li>Error Case<ul>\n<li>If executor not found in mapping, quietly fails.</li>\n<li>No error responses are sent</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>State Update</p>\n<ul>\n<li>Updates the worker's local state:<ul>\n<li>Adds new entry to <code>execution_summaries</code> map.</li>\n<li>Maps transaction fingerprint to its execution results.</li>\n</ul>\n</li>\n<li>No messages are sent.</li>\n</ul>\n</li>\n</ol>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#mempoolworkeractionargument","title":"<code>MempoolWorkerActionArgument</code>","text":"<pre><code><pre>syntax alias MempoolWorkerActionArgument := Unit;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#mempoolworkeractionarguments","title":"<code>MempoolWorkerActionArguments</code>","text":"<pre><code><pre>MempoolWorkerActionArguments : Type := List MempoolWorkerActionArgument;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code\n<p><pre><code><pre>MempoolWorkerAction : Type :=  Action    MempoolWorkerLocalCfg    MempoolWorkerLocalState    MempoolWorkerMailboxState    MempoolWorkerTimerHandle    MempoolWorkerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;MempoolWorkerActionInput : Type :=  ActionInput    MempoolWorkerLocalCfg    MempoolWorkerLocalState    MempoolWorkerMailboxState    MempoolWorkerTimerHandle    MempoolWorkerActionArguments    Anoma.Msg;MempoolWorkerActionEffect : Type :=  ActionEffect    MempoolWorkerLocalState    MempoolWorkerMailboxState    MempoolWorkerTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;MempoolWorkerActionExec : Type :=  ActionExec    MempoolWorkerLocalCfg    MempoolWorkerLocalState    MempoolWorkerMailboxState    MempoolWorkerTimerHandle    MempoolWorkerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#transactionrequestaction","title":"<code>transactionRequestAction</code>","text":"<p>Action processing a new transaction request.</p>\n\nState update\n\n<ul>\n<li>Increments gensym counter<ul>\n<li>Adds transaction to transactions maps with new fingerprint</li>\n</ul>\n</li>\n</ul>\n\nMessages to be sent\n\n<ul>\n<li><code>TransactionAck</code> to requester<ul>\n<li><code>KVSAcquireLock</code> messages to relevant shards</li>\n</ul>\n</li>\n</ul>\n\nEngines to be spawned\n\n<ul>\n<li>Creates new Executor Engine for the transaction</li>\n</ul>\n\nTimer updates\nNo timers are set or cancelled.\n\n\n<pre><code><pre>transactionRequestAction  {{rinst : Runnable KVSKey KVSDatum Executable ProgramState}}  (input : MempoolWorkerActionInput)  : Option MempoolWorkerActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    local := EngineEnv.localState env;    trigger := ActionInput.trigger input;    keyToShard := MempoolWorkerLocalCfg.keyToShard (EngineCfg.cfg cfg);  in case getEngineMsgFromTimestampedTrigger trigger of       | some emsg :=         case emsg of {           | EngineMsg.mk@{               sender := sender;               target := _;               mailbox := _;               msg := Anoma.Msg.MempoolWorker (MempoolWorkerMsg.TransactionRequest request);             } :=             let               fingerprint := MempoolWorkerLocalState.gensym local + 1;               worker_id := getEngineIDFromEngineCfg cfg;               candidate := TransactionRequest.tx request;               executor_name := nameGen \"executor\" (snd worker_id) worker_id;               executor_id := mkPair none executor_name;               executorCfg :=                 Anoma.Cfg.CfgExecutor                   EngineCfg.mk@{                     node := EngineCfg.node cfg;                     name := executor_name;                     cfg :=                       ExecutorLocalCfg.mk@{                         timestamp := fingerprint;                         executable :=                           TransactionCandidate.executable candidate;                         lazy_read_keys := Set.empty;                         eager_read_keys :=                           Set.fromList                             (TransactionLabel.read                               (TransactionCandidate.label candidate));                         will_write_keys :=                           Set.fromList                             (TransactionLabel.write                               (TransactionCandidate.label candidate));                         may_write_keys := Set.empty;                         worker := worker_id;                         issuer := sender;                         keyToShard := keyToShard;                       };                   };               executorEnv :=                 Anoma.Env.EnvExecutor                   EngineEnv.mk@{                     localState :=                       ExecutorLocalState.mk@{                         program_state := Runnable.startingState {{rinst}};                         completed_reads := Map.empty;                         completed_writes := Map.empty;                       };                     mailboxCluster := Map.empty;                     acquaintances := Set.empty;                     timers := [];                   };               newState :=                 local@MempoolWorkerLocalState{                   gensym := fingerprint;                   transactions := Map.insert                     fingerprint                     candidate                     (MempoolWorkerLocalState.transactions local);                   transactionEngines := Map.insert                     executor_id                     fingerprint                     (MempoolWorkerLocalState.transactionEngines local);                 };               newEnv := env@EngineEnv{localState := newState};               read_keys :=                 Set.fromList                   (TransactionLabel.read                     (TransactionCandidate.label candidate));               write_keys :=                 Set.fromList                   (TransactionLabel.write                     (TransactionCandidate.label candidate));               shards :=                 Set.toList                   (Set.map keyToShard (Set.union read_keys write_keys));               shardMsgs :=                 map                   \\{shard :=                     let                       shard_read_keys :=                         Set.filter                           \\{key := snd (keyToShard key) == snd shard}                           read_keys;                       shard_write_keys :=                         Set.filter                           \\{key := snd (keyToShard key) == snd shard}                           write_keys;                       lockRequest :=                         KVSAcquireLockMsg.mkKVSAcquireLockMsg@{                           lazy_read_keys := Set.empty;                           eager_read_keys := shard_read_keys;                           will_write_keys := shard_write_keys;                           may_write_keys := Set.empty;                           worker := worker_id;                           executor := executor_id;                           timestamp := fingerprint;                         };                     in EngineMsg.mk@{                          sender := worker_id;                          target := shard;                          mailbox := some 0;                          msg :=                            Anoma.Msg.Shard                              (ShardMsg.KVSAcquireLock lockRequest);                        }}                   shards;               ackMsg :=                 EngineMsg.mk@{                   sender := worker_id;                   target := sender;                   mailbox := some 0;                   msg :=                     Anoma.Msg.MempoolWorker                       (MempoolWorkerMsg.TransactionAck                         TransactionAck.mkTransactionAck@{                           tx_hash := hash fingerprint candidate;                           batch_number :=                             MempoolWorkerLocalState.batch_number local;                           batch_start := 0;                           worker_id := worker_id;                           signature := sign fingerprint candidate;                         });                 };             in some               ActionEffect.mk@{                 env := newEnv;                 msgs := ackMsg :: shardMsgs;                 timers := [];                 engines := [mkPair executorCfg executorEnv];               }           | _ := none         }       | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#lockacquiredaction","title":"<code>lockAcquiredAction</code>","text":"<p>Action processing lock acquisition confirmation from shards.</p>\n\nState update\n\n<ul>\n<li>Adds lock to locks_acquired list<ul>\n<li>Updates seen_all_writes/reads counters if applicable</li>\n</ul>\n</li>\n</ul>\n\nMessages to be sent\n\n<ul>\n<li>UpdateSeenAll messages to shards when counters advance</li>\n</ul>\n\nEngines to be spawned\nNone\nTimer updates\nNo timers are set or cancelled.\n\n\n<pre><code><pre>allLocksAcquired  (keyToShard : KVSKey -&gt; EngineID)  (isWrite : Bool)  (tx : TransactionCandidate KVSKey KVSKey Executable)  (txNum : TxFingerprint)  (locks : List (Pair EngineID KVSLockAcquiredMsg))  : Bool :=  let    keys :=      case isWrite of        | true := TransactionLabel.write (TransactionCandidate.label tx)        | false := TransactionLabel.read (TransactionCandidate.label tx);    neededShards := Set.fromList (map keyToShard keys);    lockingShards :=      Set.fromList        (map          fst          (List.filter            \\{lock := KVSLockAcquiredMsg.timestamp (snd lock) == txNum}            locks));  in Set.isSubset neededShards lockingShards;</pre></code></pre>\n\n\n\n<pre><code><pre>--- Finds the highest transaction fingerprint N such that all transactions with fingerprints 1..N--- have acquired all their necessary locks of the specified type (read or write). This represents--- the \"safe point\" up to which shards can process transactions without worrying about missing locks.terminatingfindMaxConsecutiveLocked  (keyToShard : KVSKey -&gt; EngineID)  (isWrite : Bool)  (transactions : Map    TxFingerprint    (TransactionCandidate KVSKey KVSKey Executable))  (locks : List (Pair EngineID KVSLockAcquiredMsg))  (current : TxFingerprint)  (prev : TxFingerprint)  : TxFingerprint :=  case Map.lookup current transactions of    | none := prev    | some tx :=      case allLocksAcquired keyToShard isWrite tx current locks of        | true :=          findMaxConsecutiveLocked            keyToShard            isWrite            transactions            locks            (current + 1)            current        | false := prev;</pre></code></pre>\n\n\n\n<pre><code><pre>getAllShards  (keyToShard : KVSKey -&gt; EngineID)  (transactions : Map    TxFingerprint    (TransactionCandidate KVSKey KVSKey Executable))  : Set EngineID :=  let    getAllKeysFromLabel      (label : TransactionLabel KVSKey KVSKey) : List KVSKey :=      TransactionLabel.read label ++ TransactionLabel.write label;    allKeys :=      List.concatMap        \\{tx := getAllKeysFromLabel (TransactionCandidate.label tx)}        (Map.values transactions);  in Set.fromList (map keyToShard allKeys);</pre></code></pre>\n\n\n\n<pre><code><pre>lockAcquiredAction  (input : MempoolWorkerActionInput) : Option MempoolWorkerActionEffect :=  let    env := ActionInput.env input;    local := EngineEnv.localState env;    trigger := ActionInput.trigger input;    keyToShard :=      MempoolWorkerLocalCfg.keyToShard (EngineCfg.cfg (ActionInput.cfg input));  in case getEngineMsgFromTimestampedTrigger trigger of       | some emsg :=         case emsg of {           | EngineMsg.mk@{               msg := Anoma.Msg.Shard (ShardMsg.KVSLockAcquired lockMsg);               sender := sender;             } :=             let               timestamp := KVSLockAcquiredMsg.timestamp lockMsg;               newLocks :=                 mkPair sender lockMsg                   :: MempoolWorkerLocalState.locks_acquired local;               maxConsecutiveWrite :=                 findMaxConsecutiveLocked                   keyToShard                   true                   (MempoolWorkerLocalState.transactions local)                   newLocks                   1                   0;               maxConsecutiveRead :=                 findMaxConsecutiveLocked                   keyToShard                   false                   (MempoolWorkerLocalState.transactions local)                   newLocks                   1                   0;               newState :=                 local@MempoolWorkerLocalState{                   locks_acquired := newLocks;                   seen_all_writes := maxConsecutiveWrite;                   seen_all_reads := maxConsecutiveRead;                 };               newEnv := env@EngineEnv{localState := newState};               allShards :=                 getAllShards                   keyToShard                   (MempoolWorkerLocalState.transactions local);               makeUpdateMsg                 (target : EngineID)                 (isWrite : Bool)                 (timestamp : TxFingerprint)                 : EngineMsg Anoma.Msg :=                 EngineMsg.mk@{                   sender := getEngineIDFromEngineCfg (ActionInput.cfg input);                   target := target;                   mailbox := some 0;                   msg :=                     Anoma.Msg.Shard                       (ShardMsg.UpdateSeenAll                         UpdateSeenAllMsg.mkUpdateSeenAllMsg@{                           timestamp := timestamp;                           write := isWrite;                         });                 };               writeMessages :=                 map                   \\{shard := makeUpdateMsg shard true maxConsecutiveWrite}                   (Set.toList allShards);               readMessages :=                 map                   \\{shard := makeUpdateMsg shard false maxConsecutiveRead}                   (Set.toList allShards);             in some               ActionEffect.mk@{                 env := newEnv;                 msgs := writeMessages ++ readMessages;                 timers := [];                 engines := [];               }           | _ := none         }       | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#executorfinishedaction","title":"<code>executorFinishedAction</code>","text":"<p>Action processing execution completion notification from executor.</p>\n\nState update\nAdds execution summary to execution_summaries map\nMessages to be sent\nNone\nEngines to be spawned\nNone\nTimer updates\nNo timers are set or cancelled.\n\n\n<pre><code><pre>executorFinishedAction  (input : MempoolWorkerActionInput) : Option MempoolWorkerActionEffect :=  let    env := ActionInput.env input;    local := EngineEnv.localState env;    trigger := ActionInput.trigger input;  in case getEngineMsgFromTimestampedTrigger trigger of       | some emsg :=         case emsg of {           | EngineMsg.mk@{               msg := Anoma.Msg.Executor (ExecutorMsg.ExecutorFinished summary);               sender := sender;             } :=             case               Map.lookup                 sender                 (MempoolWorkerLocalState.transactionEngines local)             of {               | some tr :=                 let                   newState :=                     local@MempoolWorkerLocalState{execution_summaries := Map.insert                       tr                       summary                       (MempoolWorkerLocalState.execution_summaries local)};                   newEnv := env@EngineEnv{localState := newState};                 in some                   ActionEffect.mk@{                     env := newEnv;                     msgs := [];                     timers := [];                     engines := [];                   }               | _ := none             }           | _ := none         }       | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#action-labels","title":"Action Labels","text":"<pre><code><pre>transactionRequestActionLabel : MempoolWorkerActionExec :=  ActionExec.Seq [transactionRequestAction];lockAcquiredActionLabel : MempoolWorkerActionExec :=  ActionExec.Seq [lockAcquiredAction];executorFinishedActionLabel : MempoolWorkerActionExec :=  ActionExec.Seq [executorFinishedAction];</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code\n<p><pre><code><pre>MempoolWorkerGuard : Type :=  Guard    MempoolWorkerLocalCfg    MempoolWorkerLocalState    MempoolWorkerMailboxState    MempoolWorkerTimerHandle    MempoolWorkerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;MempoolWorkerGuardOutput : Type :=  GuardOutput    MempoolWorkerLocalCfg    MempoolWorkerLocalState    MempoolWorkerMailboxState    MempoolWorkerTimerHandle    MempoolWorkerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;MempoolWorkerGuardEval : Type :=  GuardEval    MempoolWorkerLocalCfg    MempoolWorkerLocalState    MempoolWorkerMailboxState    MempoolWorkerTimerHandle    MempoolWorkerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#transactionrequestguard","title":"<code>transactionRequestGuard</code>","text":"Condition\nMessage type is MempoolWorkerMsg.TransactionRequest\n\n\n<pre><code><pre>transactionRequestGuard  {{Runnable KVSKey KVSDatum Executable ProgramState}}  (trigger : TimestampedTrigger MempoolWorkerTimerHandle Anoma.Msg)  (cfg : MempoolWorkerCfg)  (env : MempoolWorkerEnv)  : Option MempoolWorkerGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{             msg := Anoma.Msg.MempoolWorker (MempoolWorkerMsg.TransactionRequest _);           } :=      some        GuardOutput.mk@{          action := transactionRequestActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#lockacquiredguard","title":"<code>lockAcquiredGuard</code>","text":"Condition\nMessage type is ShardMsgKVSLockAc","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#lockacquiredguard_1","title":"<code>lockAcquiredGuard</code>","text":"Condition\nMessage type is ShardMsg.KVSLockAcquired\n\n\n<pre><code><pre>lockAcquiredGuard  (trigger : TimestampedTrigger MempoolWorkerTimerHandle Anoma.Msg)  (cfg : MempoolWorkerCfg)  (env : MempoolWorkerEnv)  : Option MempoolWorkerGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{msg := Anoma.Msg.Shard (ShardMsg.KVSLockAcquired _)} :=      some        GuardOutput.mk@{          action := lockAcquiredActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#executorfinishedguard","title":"<code>executorFinishedGuard</code>","text":"Condition\nMessage type is ExecutorMsg.ExecutorFinished\n\n\n<pre><code><pre>executorFinishedGuard  (trigger : TimestampedTrigger MempoolWorkerTimerHandle Anoma.Msg)  (cfg : MempoolWorkerCfg)  (env : MempoolWorkerEnv)  : Option MempoolWorkerGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{             msg := Anoma.Msg.Executor (ExecutorMsg.ExecutorFinished _);           } :=      some        GuardOutput.mk@{          action := executorFinishedActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#the-mempool-worker-behaviour","title":"The Mempool Worker Behaviour","text":"","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#mempoolworkerbehaviour","title":"<code>MempoolWorkerBehaviour</code>","text":"<pre><code><pre>MempoolWorkerBehaviour : Type :=  EngineBehaviour    MempoolWorkerLocalCfg    MempoolWorkerLocalState    MempoolWorkerMailboxState    MempoolWorkerTimerHandle    MempoolWorkerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>mempoolWorkerBehaviour : MempoolWorkerBehaviour :=  EngineBehaviour.mk@{    guards :=      GuardEval.First        [transactionRequestGuard; lockAcquiredGuard; executorFinishedGuard];  };</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","behaviour"]},{"location":"arch/node/engines/mempool_worker_config.html","title":"Mempool Worker Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.mempool_worker_config;import prelude open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","configuration"]},{"location":"arch/node/engines/mempool_worker_config.html#mempool-worker-configuration","title":"Mempool Worker Configuration","text":"","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","configuration"]},{"location":"arch/node/engines/mempool_worker_config.html#overview","title":"Overview","text":"<p>The Mempool Worker engine configuration contains static information for Mempool Worker engine instances.</p>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","configuration"]},{"location":"arch/node/engines/mempool_worker_config.html#the-mempool-worker-local-configuration","title":"The Mempool Worker Local Configuration","text":"","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","configuration"]},{"location":"arch/node/engines/mempool_worker_config.html#mempoolworkerlocalcfg","title":"<code>MempoolWorkerLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type MempoolWorkerLocalCfg :=  mk@{    keyToShard : KVSKey -&gt; EngineID;  };</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","configuration"]},{"location":"arch/node/engines/mempool_worker_config.html#the-mempool-worker-configuration","title":"The Mempool Worker Configuration","text":"","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","configuration"]},{"location":"arch/node/engines/mempool_worker_config.html#mempoolworkercfg","title":"<code>MempoolWorkerCfg</code>","text":"<pre><code><pre>MempoolWorkerCfg : Type := EngineCfg MempoolWorkerLocalCfg;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","configuration"]},{"location":"arch/node/engines/mempool_worker_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>mempoolWorkerCfg : MempoolWorkerCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"mempool worker\";    cfg :=      MempoolWorkerLocalCfg.mk@{        keyToShard := \\{_ := mkPair none \"shard\"};      };  };</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","configuration"]},{"location":"arch/node/engines/mempool_worker_environment.html","title":"Mempool Worker Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.mempool_worker_environment;import prelude open;import arch.node.engines.shard_messages open;import arch.node.engines.executor_messages open;import arch.node.engines.mempool_worker_messages open;import arch.node.types.engine_environment open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","environment"]},{"location":"arch/node/engines/mempool_worker_environment.html#mempool-worker-environment","title":"Mempool Worker Environment","text":"","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","environment"]},{"location":"arch/node/engines/mempool_worker_environment.html#overview","title":"Overview","text":"<p>The Mempool Worker engine's environment maintains the state necessary for managing transaction requests, including information about batches, transaction candidates, and the state of lock acquisition and execution.</p>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","environment"]},{"location":"arch/node/engines/mempool_worker_environment.html#local-state","title":"Local State","text":"","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","environment"]},{"location":"arch/node/engines/mempool_worker_environment.html#mempoolworkerlocalstate","title":"<code>MempoolWorkerLocalState</code>","text":"<p>The local state of the Mempool Worker engine includes the following:</p> <pre><code><pre>type MempoolWorkerLocalState :=  mk@{    batch_number : BatchNumber;    transactions      : Map TxFingerprint (TransactionCandidate KVSKey KVSKey Executable);    transactionEngines : Map EngineID TxFingerprint;    locks_acquired : List (Pair EngineID KVSLockAcquiredMsg);    seen_all_writes : TxFingerprint;    seen_all_reads : TxFingerprint;    execution_summaries : Map TxFingerprint ExecutorFinishedMsg;    gensym : TxFingerprint;  };</pre></code></pre> Arguments <code>batch_number</code>: The current batch number. (Currently unused) <code>transactions</code>: A map of transaction fingerprints to their corresponding transaction candidates. <code>transactionEngines</code>: A map of engine ids for Executor Engines pointing to their transaction fingerprints. <code>locks_acquired</code>: A list of received <code>KVSLockAcquiredMsg</code>s, along with the ids of their shards. <code>seen_all_writes</code>: The highest transaction fingerprint for which all writes have been locked by the shards. <code>seen_all_reads</code>: The highest transaction fingerprint for which all reads have been locked by the shards. <code>execution_summaries</code>: A map of transaction fingerprints to their corresponding execution summaries, once received. <code>gensym</code>: A monotonically increasing number used to generate unique transaction numbers.","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","environment"]},{"location":"arch/node/engines/mempool_worker_environment.html#mailbox-state","title":"Mailbox State","text":"<p>The Mempool Worker engine does not require a complex mailbox state, so we define it as a unit type:</p>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","environment"]},{"location":"arch/node/engines/mempool_worker_environment.html#mempoolworkermailboxstate","title":"<code>MempoolWorkerMailboxState</code>","text":"<pre><code><pre>syntax alias MempoolWorkerMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","environment"]},{"location":"arch/node/engines/mempool_worker_environment.html#timer-handle","title":"Timer Handle","text":"<p>The Mempool Worker engine does not require a timer handle, so we define it as a unit type:</p>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","environment"]},{"location":"arch/node/engines/mempool_worker_environment.html#mempoolworkertimerhandle","title":"<code>MempoolWorkerTimerHandle</code>","text":"<pre><code><pre>syntax alias MempoolWorkerTimerHandle := Unit;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","environment"]},{"location":"arch/node/engines/mempool_worker_environment.html#the-mempool-worker-environment","title":"The Mempool Worker Environment","text":"","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","environment"]},{"location":"arch/node/engines/mempool_worker_environment.html#mempoolworkerenv","title":"<code>MempoolWorkerEnv</code>","text":"<pre><code><pre>MempoolWorkerEnv : Type :=  EngineEnv    MempoolWorkerLocalState    MempoolWorkerMailboxState    MempoolWorkerTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","environment"]},{"location":"arch/node/engines/mempool_worker_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>mempoolWorkerEnv : MempoolWorkerEnv :=  EngineEnv.mk@{    localState :=      MempoolWorkerLocalState.mk@{        batch_number := 0;        transactions := Map.empty;        transactionEngines := Map.empty;        locks_acquired := [];        seen_all_writes := 0;        seen_all_reads := 0;        execution_summaries := Map.empty;        gensym := 0;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","mempool-worker","environment"]},{"location":"arch/node/engines/mempool_worker_messages.html","title":"Mempool Worker Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.mempool_worker_messages;import prelude open;import arch.node.types.basics open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","ordering","engine","mempool-worker","message-types"]},{"location":"arch/node/engines/mempool_worker_messages.html#mempool-worker-messages","title":"Mempool Worker Messages","text":"<p>These are the specific messages that the Mempool Worker engine can receive/respond to.</p>","tags":["node-architecture","ordering","engine","mempool-worker","message-types"]},{"location":"arch/node/engines/mempool_worker_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type MempoolWorkerMsg Executable :=  | TransactionRequest (TransactionRequest KVSKey Executable)  | TransactionAck TransactionAck;</pre></code></pre>","tags":["node-architecture","ordering","engine","mempool-worker","message-types"]},{"location":"arch/node/engines/mempool_worker_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","ordering","engine","mempool-worker","message-types"]},{"location":"arch/node/engines/mempool_worker_messages.html#transaction-request-flow","title":"Transaction request flow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant MempoolWorker\n    participant Shard\n    participant Executor\n\n    User-&gt;&gt;MempoolWorker: MempoolWorkerMsgTransactionRequest\n    MempoolWorker-&gt;&gt;User: MempoolWorkerMsgTransactionAck\n    MempoolWorker-&gt;&gt;Shard: KVSAcquireLock\n    Shard-&gt;&gt;MempoolWorker: KVSLockAcquired\n    MempoolWorker-&gt;&gt;Executor: ExecutorPIDAssigned\n    Executor-&gt;&gt;MempoolWorker: ExecutorFinished</code></pre>  Sequence Diagram: Transaction Request Flow","tags":["node-architecture","ordering","engine","mempool-worker","message-types"]},{"location":"arch/node/engines/mempool_worker_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","ordering","engine","mempool-worker","message-types"]},{"location":"arch/node/engines/mempool_worker_messages.html#transactionrequest","title":"<code>TransactionRequest</code>","text":"<p>A request from a user or solver to order and execute a transaction candidate.</p> <pre><code><pre>type TransactionRequest KVSKey Executable :=  mkTransactionRequest@{    tx : TransactionCandidate KVSKey KVSKey Executable;    resubmission : Option TxFingerprint;  };</pre></code></pre> Arguments <code>tx</code> The transaction candidate to be ordered and executed. <code>resubmission</code> Optional reference to a previous occurrence of the same transaction candidate (currently unused).","tags":["node-architecture","ordering","engine","mempool-worker","message-types"]},{"location":"arch/node/engines/mempool_worker_messages.html#transactionack","title":"<code>TransactionAck</code>","text":"<p>Acknowledgment sent to the user or solver that a transaction request has been accepted.</p> <pre><code><pre>type TransactionAck :=  mkTransactionAck@{    tx_hash : Hash;    batch_number : BatchNumber;    batch_start : WallClockTime;    worker_id : EngineID;    signature : Signature;  };</pre></code></pre> Arguments <code>tx_hash</code> The hash of the acknowledged transaction candidate (Currently unused). <code>batch_number</code> The batch number assigned to the transaction (Currently unused). <code>batch_start</code> The wall clock time when the batch was opened (Currently unused). <code>worker_id</code> The external identity of the worker engine that processed the transaction. <code>signature</code> The signature of the worker engine over the above fields (Currently unused).","tags":["node-architecture","ordering","engine","mempool-worker","message-types"]},{"location":"arch/node/engines/mempool_worker_messages.html#mempoolworkermsg","title":"<code>MempoolWorkerMsg</code>","text":"<pre><code><pre>type MempoolWorkerMsg Executable :=  | TransactionRequest (TransactionRequest KVSKey Executable)  | TransactionAck TransactionAck;</pre></code></pre>","tags":["node-architecture","ordering","engine","mempool-worker","message-types"]},{"location":"arch/node/engines/mempool_worker_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Mempool Worker Configuration</li> <li>Mempool Worker Environment</li> <li>Mempool Worker Behaviour</li> </ul>","tags":["node-architecture","ordering","engine","mempool-worker","message-types"]},{"location":"arch/node/engines/naming.html","title":"Naming Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.naming;import prelude open;import arch.node.types.engine open;import arch.node.engines.naming_config open public;import arch.node.engines.naming_messages open public;import arch.node.engines.naming_environment open public;import arch.node.engines.naming_behaviour open public;import arch.node.types.anoma as Anoma open;open naming_config_example;open naming_environment_example;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","naming","engine-definition"]},{"location":"arch/node/engines/naming.html#naming-engine","title":"Naming Engine","text":"<p>The Naming Engine serves as the identity resolution system within Anoma, managing human-readable names (<code>IdentityName</code>) and their associations with cryptographic identities (<code>ExternalIdentity</code>). It can be compared to a decentralized DNS system that maintains verifiable connections between user-friendly names and their corresponding cryptographic identities, while requiring evidence to support these connections. The engine maintains an internal evidence store that tracks all verified name-identity associations.</p> <p>When users want to map names to identities, they interact with the engine in three main ways:</p> Name Resolution (<code>MsgNamingResolveNameRequest</code>) <p>Users provide a human-readable name and receive back any associated cryptographic identities (<code>ExternalIdentity</code>). This is like looking up who owns a domain name, but with cryptographic verification.</p> Evidence Submission (<code>MsgNamingSubmitNameEvidenceRequest</code>) <p>Users can submit evidence (<code>IdentityNameEvidence</code>) that proves the connection between a name and an identity. The engine verifies this evidence before storing it in its evidence store (<code>evidenceStore</code>). This is similar to domain name registration, but requiring cryptographic proof of the right to associate a name with an identity.</p> Evidence Querying (<code>MsgNamingQueryNameEvidenceRequest</code>) <p>Users can look up all the evidence associated with a particular cryptographic identity. This lets them verify the validity of name-to-identity mappings and understand the history of name claims.</p>","tags":["node-architecture","identity-subsystem","engine","naming","engine-definition"]},{"location":"arch/node/engines/naming.html#engine-components","title":"Engine components","text":"<ul> <li>Naming Messages</li> <li>Naming Configuration</li> <li>Naming Environment</li> <li>Naming Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","naming","engine-definition"]},{"location":"arch/node/engines/naming.html#type","title":"Type","text":"<pre><code><pre>NamingEngine : Type :=  Engine    NamingLocalCfg    NamingLocalState    NamingMailboxState    NamingTimerHandle    NamingActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","engine-definition"]},{"location":"arch/node/engines/naming.html#example-of-a-naming-engine","title":"Example of a naming engine","text":"<pre><code><pre>exampleNamingEngine : NamingEngine :=  Engine.mk@{    cfg := namingCfg;    env := namingEnv;    behaviour := namingBehaviour;  };</pre></code></pre> <p>where <code>namingCfg</code> is defined as follows:</p> <pre><code><pre>namingCfg : NamingCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"naming\";    cfg := NamingLocalCfg.mk;  };</pre></code></pre> <p>where <code>namingEnv</code> is defined as follows:</p> <pre><code><pre>namingEnv : NamingEnv :=  EngineEnv.mk@{    localState :=      NamingLocalState.mk@{        evidenceStore := Set.empty;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>namingBehaviour</code> is defined as follows:</p> <pre><code><pre>namingBehaviour : NamingBehaviour :=  EngineBehaviour.mk@{    guards :=      GuardEval.First        [resolveNameGuard; submitNameEvidenceGuard; queryNameEvidenceGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","engine-definition"]},{"location":"arch/node/engines/naming_behaviour.html","title":"Naming Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.naming_behaviour;import Stdlib.Data.Set as Set;import prelude open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.identities open;import arch.node.engines.naming_messages open;import arch.node.engines.naming_config open;import arch.node.engines.naming_environment open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#naming-behaviour","title":"Naming Behaviour","text":"","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#overview","title":"Overview","text":"<p>The behavior of the Naming Engine defines how it processes incoming messages and updates its state accordingly.</p>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#naming-action-flowcharts","title":"Naming Action Flowcharts","text":"","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#resolvenameaction-flowchart","title":"<code>resolveNameAction</code> flowchart","text":"<pre><code>flowchart TD\n    Start([Client Request]) --&gt; MsgReq[MsgNamingResolveNameRequest&lt;br/&gt;identityName: IdentityName]\n\n    subgraph Guard[\"resolveNameGuard\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br/&gt;ResolveNameRequest?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"resolveNameAction\"]\n        direction TB\n        Filter[Filter evidenceStore for&lt;br/&gt;matching identity name]\n        Filter --&gt; Extract[Extract external identities&lt;br/&gt;from matching evidence]\n        Extract --&gt; CreateResp[Create response with&lt;br/&gt;external identities]\n    end\n\n    CreateResp --&gt; Response[MsgNamingResolveNameReply&lt;br/&gt;externalIdentities: Set ExternalIdentity&lt;br/&gt;err: none]\n    Response --&gt; Client([Return to Client])</code></pre> <code>resolveNameAction</code> flowchart","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#explanation","title":"Explanation","text":"<ol> <li> <p>Initial Request</p> <ul> <li>A client sends a <code>MsgNamingResolveNameRequest</code> containing an identity name (<code>IdentityName</code>)</li> <li>The identity name is typically a human-readable identifier that the client wants to resolve to cryptographic identities</li> </ul> </li> <li> <p>Guard Phase (<code>resolveNameGuard</code>)</p> <ul> <li>Validates that the incoming message is a proper name resolution request</li> <li>Checks occur in the following order:<ul> <li>Verifies message type is <code>MsgNamingResolveNameRequest</code></li> <li>If validation fails, request is rejected without entering the action phase</li> <li>On success, passes control to <code>resolveNameActionLabel</code></li> </ul> </li> </ul> </li> <li> <p>Action Phase (<code>resolveNameAction</code>)</p> <ul> <li>Processes valid name resolution requests through these steps:<ul> <li>Retrieves the identity name from the request</li> <li>Scans the evidence store (<code>evidenceStore</code>) for any evidence matching this name</li> <li>Extracts all external identities from matching evidence records</li> <li>Constructs an appropriate response message</li> </ul> </li> </ul> </li> <li> <p>Response Generation</p> <ul> <li>Successful Case<ul> <li>Creates <code>MsgNamingResolveNameReply</code> with:<ul> <li><code>externalIdentities</code>: Set of all external identities associated with the name</li> <li><code>err</code>: None</li> </ul> </li> </ul> </li> <li>Empty Result Case<ul> <li>Still returns <code>MsgNamingResolveNameReply</code> with:<ul> <li><code>externalIdentities</code>: Empty set</li> <li><code>err</code>: None</li> </ul> </li> <li>Note: An empty result is not considered an error - it simply means no evidence exists for this name</li> </ul> </li> </ul> </li> <li> <p>Response Delivery</p> <ul> <li>Response is sent back to the original requester</li> <li>Response is sent to mailbox 0.</li> </ul> </li> </ol> <p>Important Notes</p> <ul> <li>The resolution process is read-only - it never modifies the evidence store</li> <li>Multiple external identities may be associated with a single name</li> </ul>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#submitnameevidenceaction-flowchart","title":"<code>submitNameEvidenceAction</code> flowchart","text":"<pre><code>flowchart TD\n    Start([Submit Request]) --&gt; MsgReq[MsgNamingSubmitNameEvidenceRequest&lt;br/&gt;evidence: IdentityNameEvidence]\n\n    subgraph Guard[\"submitNameEvidenceGuard\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br/&gt;SubmitNameEvidenceRequest?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"submitNameEvidenceAction\"]\n        direction TB\n        Valid{Evidence&lt;br/&gt;valid?}\n        Valid --&gt;|No| ErrInvalid[Create error response:&lt;br/&gt;'Invalid evidence']\n        Valid --&gt;|Yes| Exists{Evidence&lt;br/&gt;exists?}\n        Exists --&gt;|Yes| ErrExists[Create error response:&lt;br/&gt;'Evidence already exists']\n        Exists --&gt;|No| Store[Add to evidenceStore]\n        Store --&gt; Success[Create success response]\n    end\n\n    Success --&gt; Response[MsgNamingSubmitNameEvidenceReply&lt;br/&gt;err: none]\n    ErrInvalid &amp; ErrExists --&gt; ErrResponse[MsgNamingSubmitNameEvidenceReply&lt;br/&gt;err: Some error]\n    ErrResponse &amp; Response --&gt; Client([Return to Client])</code></pre> <code>submitNameEvidenceAction</code> flowchart","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#explanation_1","title":"Explanation","text":"<ol> <li> <p>Initial Request</p> <ul> <li>A client sends a <code>MsgNamingSubmitNameEvidenceRequest</code> containing:<ul> <li><code>evidence</code>: An <code>IdentityNameEvidence</code> that proves the connection between an <code>IdentityName</code> and an <code>ExternalIdentity</code></li> <li>An <code>IdentityNameEvidence</code> contains:<ul> <li><code>identityName</code>: The human-readable name being associated with an identity</li> <li><code>externalIdentity</code>: The cryptographic identity being associated with the name</li> <li><code>evidence</code>: The cryptographic evidence supporting this association</li> </ul> </li> <li>The evidence must be in a format that can be cryptographically verified</li> </ul> </li> </ul> </li> <li> <p>Guard Phase (<code>submitNameEvidenceGuard</code>)</p> <ul> <li>Validates that the incoming message is a proper evidence submission request</li> <li>Checks occur in the following order:<ul> <li>Verifies message type is <code>MsgNamingSubmitNameEvidenceRequest</code></li> <li>If validation fails, request is rejected without entering the action phase</li> <li>On success, passes control to <code>submitNameEvidenceActionLabel</code></li> </ul> </li> </ul> </li> <li> <p>Action Phase (<code>submitNameEvidenceAction</code>)</p> <ul> <li>Processes valid evidence submissions through these steps:<ul> <li>Validates the cryptographic evidence using <code>verifyEvidence</code></li> <li>Checks for duplicate evidence in the store</li> <li>Updates the evidence store if appropriate</li> <li>Constructs an appropriate response message</li> </ul> </li> </ul> </li> <li> <p>Response Generation</p> <ul> <li>Successful Case<ul> <li>Evidence is valid and new:<ul> <li>Adds evidence to the <code>evidenceStore</code></li> <li>Creates <code>MsgNamingSubmitNameEvidenceReply</code> with:<ul> <li><code>err</code>: None</li> </ul> </li> </ul> </li> </ul> </li> <li>Error Cases<ul> <li>Invalid evidence:<ul> <li>Returns error \"Invalid evidence\"</li> </ul> </li> <li>Duplicate evidence:<ul> <li>Returns error \"Evidence already exists\"</li> </ul> </li> <li>In all error cases, returns <code>MsgNamingSubmitNameEvidenceReply</code> with:<ul> <li><code>err</code>: Some(error message)</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Response Delivery</p> <ul> <li>Response is sent back to the original requester</li> <li>Response is sent to mailbox 0.</li> </ul> </li> </ol> <p>Important Notes</p> <ul> <li>The engine maintains an append-only evidence store, never removing or modifying existing evidence. The evidence store is the only mutable state in this flow and all state changes are performed only after complete validation.</li> <li>Evidence uniqueness is checked using exact matching</li> </ul>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#querynameevidenceaction-flowchart","title":"<code>queryNameEvidenceAction</code> flowchart","text":"<pre><code>flowchart TD\n    Start([Query Request]) --&gt; MsgReq[MsgNamingQueryNameEvidenceRequest&lt;br/&gt;externalIdentity: ExternalIdentity]\n\n    subgraph Guard[\"queryNameEvidenceGuard\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br/&gt;QueryNameEvidenceRequest?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"queryNameEvidenceAction\"]\n        direction TB\n        Filter[Filter evidenceStore for&lt;br/&gt;matching external identity]\n        Filter --&gt; CreateResp[Create response with&lt;br/&gt;relevant evidence]\n    end\n\n    CreateResp --&gt; Response[MsgNamingQueryNameEvidenceReply&lt;br/&gt;externalIdentity: ExternalIdentity&lt;br/&gt;evidence: Set IdentityNameEvidence&lt;br/&gt;err: none]\n    Response --&gt; Client([Return to Client])</code></pre> <code>queryNameEvidenceAction</code> flowchart","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#explanation_2","title":"Explanation","text":"<ol> <li> <p>Initial Request</p> <ul> <li>A client sends a <code>MsgNamingQueryNameEvidenceRequest</code> containing an external identity (<code>ExternalIdentity</code>)</li> <li>The external identity refers to the cryptographic identity for which all associated naming evidence should be retrieved</li> </ul> </li> <li> <p>Guard Phase (<code>queryNameEvidenceGuard</code>)</p> <ul> <li>Validates that the incoming message is a proper query request</li> <li>Checks occur in the following order:<ul> <li>Verifies message type is <code>MsgNamingQueryNameEvidenceRequest</code></li> <li>If validation fails, request is rejected without entering the action phase</li> <li>On success, passes control to <code>queryNameEvidenceActionLabel</code></li> </ul> </li> </ul> </li> <li> <p>Action Phase (<code>queryNameEvidenceAction</code>)</p> <ul> <li>Processes valid query requests through these steps:<ul> <li>Extracts the external identity from the request</li> <li>Filters the evidence store to find all evidence entries matching this identity</li> <li>Constructs an appropriate response message with the collected evidence</li> </ul> </li> </ul> </li> <li> <p>Response Generation</p> <ul> <li>Successful Case<ul> <li>Creates <code>MsgNamingQueryNameEvidenceReply</code> with:<ul> <li><code>externalIdentity</code>: The originally queried identity</li> <li><code>evidence</code>: Set of all matching <code>IdentityNameEvidence</code></li> <li><code>err</code>: None</li> </ul> </li> </ul> </li> <li>There are currently no implemented error cases.</li> </ul> </li> <li> <p>Response Delivery</p> <ul> <li>Response is sent back to the original requester</li> <li>Uses mailbox ID 0</li> </ul> </li> </ol> <p>Important Notes</p> <ul> <li>The query operation is read-only - it doesn't modify the evidence store</li> <li>Multiple pieces of evidence may exist for the same external identity</li> </ul>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#namingactionargumentreplyto-replyto","title":"<code>NamingActionArgumentReplyTo ReplyTo</code>","text":"<pre><code><pre>type ReplyTo :=  mkReplyTo@{    whoAsked : Option EngineID;    mailbox : Option MailboxID;  };</pre></code></pre> <p>This action argument contains the address and mailbox ID of where the response message should be sent.</p> <code>whoAsked</code>: is the address of the engine that sent the message. <code>mailbox</code>: is the mailbox ID where the response message should be sent.","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#namingactionargument","title":"<code>NamingActionArgument</code>","text":"<pre><code><pre>type NamingActionArgument := | NamingActionArgumentReplyTo ReplyTo;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#namingactionarguments","title":"<code>NamingActionArguments</code>","text":"<pre><code><pre>NamingActionArguments : Type := List NamingActionArgument;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#namingaction","title":"NamingAction","text":"<p><pre><code><pre>NamingAction : Type :=  Action    NamingLocalCfg    NamingLocalState    NamingMailboxState    NamingTimerHandle    NamingActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#namingactioninput","title":"NamingActionInput","text":"<p><pre><code><pre>NamingActionInput : Type :=  ActionInput    NamingLocalCfg    NamingLocalState    NamingMailboxState    NamingTimerHandle    NamingActionArguments    Anoma.Msg;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#namingactioneffect","title":"NamingActionEffect","text":"<p><pre><code><pre>NamingActionEffect : Type :=  ActionEffect    NamingLocalState    NamingMailboxState    NamingTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#namingactionexec","title":"NamingActionExec","text":"<p><pre><code><pre>NamingActionExec : Type :=  ActionExec    NamingLocalCfg    NamingLocalState    NamingMailboxState    NamingTimerHandle    NamingActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#resolvenameaction","title":"<code>resolveNameAction</code>","text":"<p>Resolve a name to associated external identities.</p> State update No change to the local state. Messages to be sent A <code>ReplyResolveName</code> message is sent to the requester, containing matching external identities. Engines to be spawned No engines are spawned by this action. Timer updates No timers are set or cancelled. <pre><code><pre>resolveNameAction (input : NamingActionInput) : Option NamingActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    tt := ActionInput.trigger input;    localState := EngineEnv.localState env;    identityName :=      case getEngineMsgFromTimestampedTrigger tt of        | some EngineMsg.mk@{                 msg := Anoma.Msg.Naming (NamingMsg.ResolveNameRequest req);               } := some (RequestResolveName.identityName req)        | _ := none;  in case identityName of       | some name :=         let           matchingEvidence :=             Set.filter               \\{evidence :=                 isEqual                   (Ord.compare                     (IdentityNameEvidence.identityName evidence)                     name)}               (NamingLocalState.evidenceStore localState);           identities :=             Set.fromList               (map                 \\{evidence := IdentityNameEvidence.externalIdentity evidence}                 (Set.toList matchingEvidence));           responseMsg :=             ReplyResolveName.mkReplyResolveName@{               externalIdentities := identities;               err := none;             };         in case getEngineMsgFromTimestampedTrigger tt of {              | some emsg :=                some                  ActionEffect.mk@{                    env := env;                    msgs :=                      [                        EngineMsg.mk@{                          sender := getEngineIDFromEngineCfg cfg;                          target := EngineMsg.sender emsg;                          mailbox := some 0;                          msg :=                            Anoma.Msg.Naming                              (NamingMsg.ResolveNameReply responseMsg);                        };                      ];                    timers := [];                    engines := [];                  }              | _ := none            }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#submitnameevidenceaction","title":"<code>submitNameEvidenceAction</code>","text":"<p>Submit new name evidence.</p> State update If the evidence doesn't already exist and is valid, it's added to the <code>evidenceStore</code>. Messages to be sent A response message is sent to the requester, confirming submission or indicating an error. Engines to be spawned No engines are spawned by this action. Timer updates No timers are set or cancelled. <pre><code><pre>submitNameEvidenceAction  (input : NamingActionInput) : Option NamingActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    tt := ActionInput.trigger input;    localState := EngineEnv.localState env;    evidence :=      case getEngineMsgFromTimestampedTrigger tt of        | some EngineMsg.mk@{                 msg := Anoma.Msg.Naming (NamingMsg.SubmitNameEvidenceRequest req);               } := some (RequestSubmitNameEvidence.evidence req)        | _ := none;  in case evidence of       | some ev :=         let           isValid := verifyEvidence ev;           alreadyExists :=             case isValid of               | true :=                 isElement                   \\{a b := a &amp;&amp; b}                   true                   (map                     \\{e := isEqual (Ord.compare e ev)}                     (Set.toList (NamingLocalState.evidenceStore localState)))               | false := false;           newEnv :=             case isValid &amp;&amp; not alreadyExists of               | true :=                 env@EngineEnv{localState := localState@NamingLocalState{evidenceStore := Set.insert                   ev                   (NamingLocalState.evidenceStore localState)}}               | false := env;           responseMsg :=             ReplySubmitNameEvidence.mkReplySubmitNameEvidence@{               err :=                 case isValid of                   | false := some \"Invalid evidence\"                   | true :=                     case alreadyExists of                       | true := some \"Evidence already exists\"                       | false := none;             };         in case getEngineMsgFromTimestampedTrigger tt of {              | some emsg :=                some                  ActionEffect.mk@{                    env := newEnv;                    msgs :=                      [                        EngineMsg.mk@{                          sender := getEngineIDFromEngineCfg cfg;                          target := EngineMsg.sender emsg;                          mailbox := some 0;                          msg :=                            Anoma.Msg.Naming                              (NamingMsg.SubmitNameEvidenceReply responseMsg);                        };                      ];                    timers := [];                    engines := [];                  }              | _ := none            }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#querynameevidenceaction","title":"<code>queryNameEvidenceAction</code>","text":"<p>Query name evidence for a specific external identity.</p> State update No change to the local state. Messages to be sent A <code>ReplyQueryNameEvidence</code> message is sent to the requester, containing relevant evidence. Engines to be spawned No engines are spawned by this action. Timer updates No timers are set or cancelled. <pre><code><pre>queryNameEvidenceAction  (input : NamingActionInput) : Option NamingActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    tt := ActionInput.trigger input;    localState := EngineEnv.localState env;    externalIdentity :=      case getEngineMsgFromTimestampedTrigger tt of        | some EngineMsg.mk@{                 msg := Anoma.Msg.Naming (NamingMsg.QueryNameEvidenceRequest req);               } := some (RequestQueryNameEvidence.externalIdentity req)        | _ := none;  in case externalIdentity of       | some extId :=         let           relevantEvidence :=             Set.filter               \\{evidence :=                 isEqual                   (Ord.compare                     (IdentityNameEvidence.externalIdentity evidence)                     extId)}               (NamingLocalState.evidenceStore localState);           responseMsg :=             ReplyQueryNameEvidence.mkReplyQueryNameEvidence@{               externalIdentity := extId;               evidence := relevantEvidence;               err := none;             };         in case getEngineMsgFromTimestampedTrigger tt of {              | some emsg :=                some                  ActionEffect.mk@{                    env := env;                    msgs :=                      [                        EngineMsg.mk@{                          sender := getEngineIDFromEngineCfg cfg;                          target := EngineMsg.sender emsg;                          mailbox := some 0;                          msg :=                            Anoma.Msg.Naming                              (NamingMsg.QueryNameEvidenceReply responseMsg);                        };                      ];                    timers := [];                    engines := [];                  }              | _ := none            }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#resolvenameactionlabel","title":"<code>resolveNameActionLabel</code>","text":"<pre><code><pre>resolveNameActionLabel : NamingActionExec := ActionExec.Seq [resolveNameAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#submitnameevidenceactionlabel","title":"<code>submitNameEvidenceActionLabel</code>","text":"<pre><code><pre>submitNameEvidenceActionLabel : NamingActionExec :=  ActionExec.Seq [submitNameEvidenceAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#querynameevidenceactionlabel","title":"<code>queryNameEvidenceActionLabel</code>","text":"<pre><code><pre>queryNameEvidenceActionLabel : NamingActionExec :=  ActionExec.Seq [queryNameEvidenceAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#namingguard","title":"<code>NamingGuard</code>","text":"<p> <pre><code><pre>NamingGuard : Type :=  Guard    NamingLocalCfg    NamingLocalState    NamingMailboxState    NamingTimerHandle    NamingActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#namingguardoutput","title":"<code>NamingGuardOutput</code>","text":"<p> <pre><code><pre>NamingGuardOutput : Type :=  GuardOutput    NamingLocalCfg    NamingLocalState    NamingMailboxState    NamingTimerHandle    NamingActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#namingguardeval","title":"<code>NamingGuardEval</code>","text":"<p> <pre><code><pre>NamingGuardEval : Type :=  GuardEval    NamingLocalCfg    NamingLocalState    NamingMailboxState    NamingTimerHandle    NamingActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#resolvenameguard","title":"<code>resolveNameGuard</code>","text":"Condition Message type is <code>MsgNamingResolveNameRequest</code>. <pre><code><pre>resolveNameGuard  (tt : TimestampedTrigger NamingTimerHandle Anoma.Msg)  (cfg : NamingCfg)  (env : NamingEnv)  : Option NamingGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some EngineMsg.mk@{             msg := Anoma.Msg.Naming (NamingMsg.ResolveNameRequest _);           } :=      some        GuardOutput.mk@{          action := resolveNameActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#submitnameevidenceguard","title":"<code>submitNameEvidenceGuard</code>","text":"Condition Message type is <code>MsgNamingSubmitNameEvidenceRequest</code>. <pre><code><pre>submitNameEvidenceGuard  (tt : TimestampedTrigger NamingTimerHandle Anoma.Msg)  (cfg : NamingCfg)  (env : NamingEnv)  : Option NamingGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some EngineMsg.mk@{             msg := Anoma.Msg.Naming (NamingMsg.SubmitNameEvidenceRequest _);           } :=      some        GuardOutput.mk@{          action := submitNameEvidenceActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#querynameevidenceguard","title":"<code>queryNameEvidenceGuard</code>","text":"Condition Message type is <code>MsgNamingQueryNameEvidenceRequest</code>. <pre><code><pre>queryNameEvidenceGuard  (tt : TimestampedTrigger NamingTimerHandle Anoma.Msg)  (cfg : NamingCfg)  (env : NamingEnv)  : Option NamingGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some EngineMsg.mk@{             msg := Anoma.Msg.Naming (NamingMsg.QueryNameEvidenceRequest _);           } :=      some        GuardOutput.mk@{          action := queryNameEvidenceActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#the-naming-behaviour","title":"The Naming Behaviour","text":"","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#namingbehaviour","title":"<code>NamingBehaviour</code>","text":"<pre><code><pre>NamingBehaviour : Type :=  EngineBehaviour    NamingLocalCfg    NamingLocalState    NamingMailboxState    NamingTimerHandle    NamingActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>namingBehaviour : NamingBehaviour :=  EngineBehaviour.mk@{    guards :=      GuardEval.First        [resolveNameGuard; submitNameEvidenceGuard; queryNameEvidenceGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","behaviour"]},{"location":"arch/node/engines/naming_config.html","title":"Naming Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.naming_config;import prelude open;import arch.node.engines.naming_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","naming","configuration"]},{"location":"arch/node/engines/naming_config.html#naming-configuration","title":"Naming Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","naming","configuration"]},{"location":"arch/node/engines/naming_config.html#overview","title":"Overview","text":"<p>The Naming engine configuration contains static information for Naming engine instances.</p>","tags":["node-architecture","identity-subsystem","engine","naming","configuration"]},{"location":"arch/node/engines/naming_config.html#the-naming-local-configuration","title":"The Naming Local Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","naming","configuration"]},{"location":"arch/node/engines/naming_config.html#naminglocalcfg","title":"<code>NamingLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type NamingLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","configuration"]},{"location":"arch/node/engines/naming_config.html#the-naming-configuration","title":"The Naming Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","naming","configuration"]},{"location":"arch/node/engines/naming_config.html#namingcfg","title":"<code>NamingCfg</code>","text":"<pre><code><pre>NamingCfg : Type := EngineCfg NamingLocalCfg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","configuration"]},{"location":"arch/node/engines/naming_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>namingCfg : NamingCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"naming\";    cfg := NamingLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","configuration"]},{"location":"arch/node/engines/naming_environment.html","title":"Naming Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.naming_environment;import prelude open;import arch.node.types.engine_environment open;import arch.node.types.identities open;import arch.node.engines.naming_messages open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","naming","environment"]},{"location":"arch/node/engines/naming_environment.html#naming-environment","title":"Naming Environment","text":"","tags":["node-architecture","identity-subsystem","engine","naming","environment"]},{"location":"arch/node/engines/naming_environment.html#overview","title":"Overview","text":"<p>The Naming Engine maintains the state necessary for managing associations between <code>IdentityName</code>s and <code>ExternalIdentity</code>s, including storing evidence submitted by clients.</p> Auxiliary Juvix code <p><pre><code><pre>axiom verifyEvidence : IdentityNameEvidence -&gt; Bool;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","naming","environment"]},{"location":"arch/node/engines/naming_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The Naming Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","naming","environment"]},{"location":"arch/node/engines/naming_environment.html#namingmailboxstate","title":"<code>NamingMailboxState</code>","text":"<pre><code><pre>syntax alias NamingMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","environment"]},{"location":"arch/node/engines/naming_environment.html#local-state","title":"Local state","text":"<p>The local state of the Naming Engine includes the evidence for name associations.</p>","tags":["node-architecture","identity-subsystem","engine","naming","environment"]},{"location":"arch/node/engines/naming_environment.html#naminglocalstate","title":"<code>NamingLocalState</code>","text":"<pre><code><pre>type NamingLocalState :=  mk@{    evidenceStore : Set IdentityNameEvidence;  };</pre></code></pre> Arguments <code>evidenceStore</code>: The pool of evidence which the engine uses for identity verification.","tags":["node-architecture","identity-subsystem","engine","naming","environment"]},{"location":"arch/node/engines/naming_environment.html#timer-handle","title":"Timer Handle","text":"<p>The Naming Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","naming","environment"]},{"location":"arch/node/engines/naming_environment.html#namingtimerhandle","title":"<code>NamingTimerHandle</code>","text":"<pre><code><pre>syntax alias NamingTimerHandle := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","environment"]},{"location":"arch/node/engines/naming_environment.html#the-naming-environment","title":"The Naming Environment","text":"","tags":["node-architecture","identity-subsystem","engine","naming","environment"]},{"location":"arch/node/engines/naming_environment.html#namingenv","title":"<code>NamingEnv</code>","text":"<pre><code><pre>NamingEnv : Type :=  EngineEnv NamingLocalState NamingMailboxState NamingTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","environment"]},{"location":"arch/node/engines/naming_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>namingEnv : NamingEnv :=  EngineEnv.mk@{    localState :=      NamingLocalState.mk@{        evidenceStore := Set.empty;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","environment"]},{"location":"arch/node/engines/naming_messages.html","title":"Naming Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.naming_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/naming_messages.html#naming-messages","title":"Naming Messages","text":"","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/naming_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type NamingMsg :=  | ResolveNameRequest RequestResolveName  | ResolveNameReply ReplyResolveName  | SubmitNameEvidenceRequest RequestSubmitNameEvidence  | SubmitNameEvidenceReply ReplySubmitNameEvidence  | QueryNameEvidenceRequest RequestQueryNameEvidence  | QueryNameEvidenceReply ReplyQueryNameEvidence;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/naming_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/naming_messages.html#resolving-a-name","title":"Resolving a name","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant NamingEngine\n\n    Client-&gt;&gt;NamingEngine: RequestResolveName (name)\n    Note over NamingEngine: Check stored evidence\n    NamingEngine-&gt;&gt;Client: ReplyResolveName</code></pre>  Resolving a name","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/naming_messages.html#submitting-name-evidence","title":"Submitting name evidence","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant NamingEngine\n\n    Client-&gt;&gt;NamingEngine: RequestSubmitNameEvidence\n    Note over NamingEngine: Verify and store evidence\n    NamingEngine-&gt;&gt;Client: ReplySubmitNameEvidence</code></pre>  Submitting name evidence","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/naming_messages.html#querying-name-evidence","title":"Querying name evidence","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant NamingEngine\n\n    Client-&gt;&gt;NamingEngine: RequestQueryNameEvidence (for ExternalIdentity)\n    Note over NamingEngine: Retrieve relevant evidence\n    NamingEngine-&gt;&gt;Client: ReplyQueryNameEvidence</code></pre>  Querying name evidence for an identity.","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/naming_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/naming_messages.html#requestresolvename","title":"<code>RequestResolveName</code>","text":"<pre><code><pre>type RequestResolveName :=  mkRequestResolveName@{    identityName : IdentityName;  };</pre></code></pre> <p>A <code>RequestResolveName</code> asks the Naming Engine which <code>ExternalIdentity</code>s are associated with a given <code>IdentityName</code>.</p> Arguments <code>identityName</code>: The name to resolve.","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/naming_messages.html#replyresolvename","title":"<code>ReplyResolveName</code>","text":"<pre><code><pre>type ReplyResolveName :=  mkReplyResolveName@{    externalIdentities : Set ExternalIdentity;    err : Option String;  };</pre></code></pre> <p>A <code>ReplyResolveName</code> is returned in response to a <code>RequestResolveName</code>.</p> Arguments <code>externalIdentities</code>: A set of <code>ExternalIdentity</code>s associated with the <code>IdentityName</code>. <code>err</code>: An error message if the resolution failed.","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/naming_messages.html#requestsubmitnameevidence","title":"<code>RequestSubmitNameEvidence</code>","text":"<pre><code><pre>type RequestSubmitNameEvidence :=  mkRequestSubmitNameEvidence@{    evidence : IdentityNameEvidence;  };</pre></code></pre> <p>A <code>RequestSubmitNameEvidence</code> instructs the Naming Engine to store a new piece of <code>IdentityNameEvidence</code>.</p> Arguments <code>evidence</code>: The evidence supporting the association between an <code>IdentityName</code> and an <code>ExternalIdentity</code>.","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/naming_messages.html#replysubmitnameevidence","title":"<code>ReplySubmitNameEvidence</code>","text":"<pre><code><pre>type ReplySubmitNameEvidence :=  mkReplySubmitNameEvidence@{    err : Option String;  };</pre></code></pre> <p>A <code>ReplySubmitNameEvidence</code> is sent in response to a <code>RequestSubmitNameEvidence</code>.</p> Arguments <code>err</code>: An error message if the submission failed.","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/naming_messages.html#requestquerynameevidence","title":"<code>RequestQueryNameEvidence</code>","text":"<pre><code><pre>type RequestQueryNameEvidence :=  mkRequestQueryNameEvidence@{    externalIdentity : ExternalIdentity;  };</pre></code></pre> <p>A <code>RequestQueryNameEvidence</code> instructs the Naming Engine to return any known <code>IdentityName</code>s and <code>IdentityNameEvidence</code> associated with a specific <code>ExternalIdentity</code>.</p> Arguments <code>externalIdentity</code>: The identity for which to retrieve evidence.","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/naming_messages.html#replyquerynameevidence","title":"<code>ReplyQueryNameEvidence</code>","text":"<pre><code><pre>type ReplyQueryNameEvidence :=  mkReplyQueryNameEvidence@{    externalIdentity : ExternalIdentity;    evidence : Set IdentityNameEvidence;    err : Option String;  };</pre></code></pre> <p>A <code>ReplyQueryNameEvidence</code> provides the requested evidence.</p> Arguments <code>externalIdentity</code>: The <code>ExternalIdentity</code> associated with the returned evidence. <code>evidence</code>: A set of <code>IdentityNameEvidence</code> related to the identity. <code>err</code>: An error message if the query failed.","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/naming_messages.html#namingmsg","title":"<code>NamingMsg</code>","text":"<pre><code><pre>type NamingMsg :=  | ResolveNameRequest RequestResolveName  | ResolveNameReply ReplyResolveName  | SubmitNameEvidenceRequest RequestSubmitNameEvidence  | SubmitNameEvidenceReply ReplySubmitNameEvidence  | QueryNameEvidenceRequest RequestQueryNameEvidence  | QueryNameEvidenceReply ReplyQueryNameEvidence;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/naming_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Naming Configuration</li> <li>Naming Environment</li> <li>Naming Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","naming","message-types"]},{"location":"arch/node/engines/net_registry.html","title":"Network Registry Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.net_registry;import arch.node.engines.net_registry_messages open public;import arch.node.engines.net_registry_config open public;import arch.node.engines.net_registry_environment open public;import arch.node.engines.net_registry_behaviour open public;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;open registry_config_example;open registry_environment_example;open registry_behaviour_example;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","registry","engine-definition"]},{"location":"arch/node/engines/net_registry.html#network-registry-engine","title":"Network Registry Engine","text":"","tags":["node-architecture","network-subsystem","engine","registry","engine-definition"]},{"location":"arch/node/engines/net_registry.html#purpose","title":"Purpose","text":"<p>The single Network Registry engine instance maintains a database of <code>NodeAdvert</code> and <code>TopicAdvert</code> messages that arrive from the network on each node. For each known node and topic it spawns a Router Engine or a Pub/Sub Topic Engine instance, respectively.</p>","tags":["node-architecture","network-subsystem","engine","registry","engine-definition"]},{"location":"arch/node/engines/net_registry.html#engine-components","title":"Engine components","text":"<ul> <li>Network Registry Messages</li> <li>Network Registry Configuration</li> <li>Network Registry Environment</li> <li>Network Registry Behaviour</li> </ul>","tags":["node-architecture","network-subsystem","engine","registry","engine-definition"]},{"location":"arch/node/engines/net_registry.html#the-type-for-a-network-registry-engine","title":"The type for a network registry engine","text":"<pre><code><pre>NetworkRegistryEngine : Type :=  Engine    NetworkRegistryLocalCfg    NetworkRegistryLocalState    NetworkRegistryMailboxState    NetworkRegistryTimerHandle    NetworkRegistryActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","engine-definition"]},{"location":"arch/node/engines/net_registry.html#example-instantiation","title":"Example instantiation","text":"<pre><code><pre>exNetworkRegistryEngine : NetworkRegistryEngine :=  Engine.mk@{    cfg := exNetworkRegistryCfg;    env := exNetworkRegistryEnv;    behaviour := exNetworkRegistryBehaviour;  };</pre></code></pre> <p>Where <code>exNetworkRegistryCfg</code> is defined as follows:</p> <pre><code><pre>exNetworkRegistryCfg : NetworkRegistryCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"net-registry\";    cfg := NetworkRegistryLocalCfg.mk;  };</pre></code></pre> <p><code>exNetworkRegistryEnv</code> is defined as follows:</p> <pre><code><pre>exNetworkRegistryEnv : NetworkRegistryEnv :=  EngineEnv.mk@{    localState := NetworkRegistryLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>exNetworkRegistryBehaviour</code> is defined as follows:</p> <pre><code><pre>module registry_behaviour_example;  exNetworkRegistryBehaviour : NetworkRegistryBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [exampleReplyGuard];    };end;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","engine-definition"]},{"location":"arch/node/engines/net_registry_behaviour.html","title":"Network Registry Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.net_registry_behaviour;import arch.node.engines.net_registry_messages open;import arch.node.engines.net_registry_config open;import arch.node.engines.net_registry_environment open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#network-registry-behaviour","title":"Network Registry Behaviour","text":"","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#overview","title":"Overview","text":"<p>A Network Registry engine acts in the ways described on this page. The action labels correspond to the actions that can be performed by the engine. Using the action labels, we describe the effects of the actions.</p>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#network-registry-action-flowchart","title":"Network Registry Action Flowchart","text":"","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#examplereply-flowchart","title":"<code>exampleReply</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;NetworkRegistryMsgExampleRequest&lt;br/&gt;from local engine]\n    CEnv[(exampleValue &lt; 10)]\n  end\n\n  G(exampleReplyGuard)\n  A(exampleReplyAction)\n\n  C --&gt; G -- *exampleReplyActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(exampleValue := exampleValue + 1)]\n    EMsg&gt;NetworkRegistryMsgExampleResponse&lt;br/&gt;argOne]\n  end</code></pre> <code>exampleReply</code> flowchart","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#action-arguments","title":"Action arguments","text":"<p>The action arguments are set by a guard and passed to the action function as part of the <code>GuardOutput</code>.</p>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#networkregistryactionarguments","title":"<code>NetworkRegistryActionArguments</code>","text":"<pre><code><pre>NetworkRegistryActionArguments : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#networkregistryaction","title":"<code>NetworkRegistryAction</code>","text":"<p> <pre><code><pre>NetworkRegistryAction : Type :=  Action    NetworkRegistryLocalCfg    NetworkRegistryLocalState    NetworkRegistryMailboxState    NetworkRegistryTimerHandle    NetworkRegistryActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#networkregistryactioninput","title":"<code>NetworkRegistryActionInput</code>","text":"<p> <pre><code><pre>NetworkRegistryActionInput : Type :=  ActionInput    NetworkRegistryLocalCfg    NetworkRegistryLocalState    NetworkRegistryMailboxState    NetworkRegistryTimerHandle    NetworkRegistryActionArguments    Anoma.Msg;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#networkregistryactioneffect","title":"<code>NetworkRegistryActionEffect</code>","text":"<p> <pre><code><pre>NetworkRegistryActionEffect : Type :=  ActionEffect    NetworkRegistryLocalState    NetworkRegistryMailboxState    NetworkRegistryTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#networkregistryactionexec","title":"<code>NetworkRegistryActionExec</code>","text":"<p> <pre><code><pre>NetworkRegistryActionExec : Type :=  ActionExec    NetworkRegistryLocalCfg    NetworkRegistryLocalState    NetworkRegistryMailboxState    NetworkRegistryTimerHandle    NetworkRegistryActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#examplereplyaction","title":"<code>exampleReplyAction</code>","text":"<p>Respond with a <code>NetworkRegistryMsgExampleResponse</code>.</p> State update The state remains unchanged. Messages to be sent A <code>NetworkRegistryMsgExampleReply</code> message with the data set by <code>exampleReplyGuard</code>. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>exampleReplyAction  (input : NetworkRegistryActionInput) : Option NetworkRegistryActionEffect :=  TODO;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#examplereplyactionlabel","title":"<code>exampleReplyActionLabel</code>","text":"<pre><code><pre>exampleReplyActionLabel : NetworkRegistryActionExec :=  ActionExec.Seq [exampleReplyAction];</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#networkregistryguard","title":"<code>NetworkRegistryGuard</code>","text":"<p> <pre><code><pre>NetworkRegistryGuard : Type :=  Guard    NetworkRegistryLocalCfg    NetworkRegistryLocalState    NetworkRegistryMailboxState    NetworkRegistryTimerHandle    NetworkRegistryActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#networkregistryguardoutput","title":"<code>NetworkRegistryGuardOutput</code>","text":"<p> <pre><code><pre>NetworkRegistryGuardOutput : Type :=  GuardOutput    NetworkRegistryLocalCfg    NetworkRegistryLocalState    NetworkRegistryMailboxState    NetworkRegistryTimerHandle    NetworkRegistryActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#networkregistryguardeval","title":"<code>NetworkRegistryGuardEval</code>","text":"<p> <pre><code><pre>NetworkRegistryGuardEval : Type :=  GuardEval    NetworkRegistryLocalCfg    NetworkRegistryLocalState    NetworkRegistryMailboxState    NetworkRegistryTimerHandle    NetworkRegistryActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#examplereplyguard","title":"<code>exampleReplyGuard</code>","text":"<p>Guard description (optional).</p> Condition Message type is <code>NetworkRegistryMsgExampleRequest</code>. <pre><code><pre>exampleReplyGuard  (trigger : NetworkRegistryTimestampedTrigger)  (cfg : NetworkRegistryCfg)  (env : NetworkRegistryEnv)  : Option NetworkRegistryGuardOutput := TODO;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#engine-behaviour","title":"Engine behaviour","text":"","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#networkregistrybehaviour","title":"<code>NetworkRegistryBehaviour</code>","text":"<pre><code><pre>NetworkRegistryBehaviour : Type :=  EngineBehaviour    NetworkRegistryLocalCfg    NetworkRegistryLocalState    NetworkRegistryMailboxState    NetworkRegistryTimerHandle    NetworkRegistryActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>module registry_behaviour_example;  exNetworkRegistryBehaviour : NetworkRegistryBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [exampleReplyGuard];    };end;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","behaviour"]},{"location":"arch/node/engines/net_registry_config.html","title":"Network Registry Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.net_registry_config;import arch.node.engines.net_registry_messages open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","registry","configuration"]},{"location":"arch/node/engines/net_registry_config.html#network-registry-configuration","title":"Network Registry Configuration","text":"","tags":["node-architecture","network-subsystem","engine","registry","configuration"]},{"location":"arch/node/engines/net_registry_config.html#overview","title":"Overview","text":"<p>The static configuration of the engine.</p>","tags":["node-architecture","network-subsystem","engine","registry","configuration"]},{"location":"arch/node/engines/net_registry_config.html#local-configuration","title":"Local Configuration","text":"","tags":["node-architecture","network-subsystem","engine","registry","configuration"]},{"location":"arch/node/engines/net_registry_config.html#networkregistrylocalcfg","title":"<code>NetworkRegistryLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type NetworkRegistryLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","configuration"]},{"location":"arch/node/engines/net_registry_config.html#engine-configuration","title":"Engine Configuration","text":"","tags":["node-architecture","network-subsystem","engine","registry","configuration"]},{"location":"arch/node/engines/net_registry_config.html#networkregistrycfg","title":"<code>NetworkRegistryCfg</code>","text":"<pre><code><pre>NetworkRegistryCfg : Type := EngineCfg NetworkRegistryLocalCfg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","configuration"]},{"location":"arch/node/engines/net_registry_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exNetworkRegistryCfg : NetworkRegistryCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"net-registry\";    cfg := NetworkRegistryLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","configuration"]},{"location":"arch/node/engines/net_registry_environment.html","title":"Network Registry Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.net_registry_environment;import arch.node.engines.net_registry_messages open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","registry","environment"]},{"location":"arch/node/engines/net_registry_environment.html#network-registry-environment","title":"Network Registry Environment","text":"","tags":["node-architecture","network-subsystem","registry","environment"]},{"location":"arch/node/engines/net_registry_environment.html#overview","title":"Overview","text":"<p>The Engine environment of the engine.</p>","tags":["node-architecture","network-subsystem","registry","environment"]},{"location":"arch/node/engines/net_registry_environment.html#mailbox-state","title":"Mailbox state","text":"","tags":["node-architecture","network-subsystem","registry","environment"]},{"location":"arch/node/engines/net_registry_environment.html#networkregistrymailboxstate","title":"<code>NetworkRegistryMailboxState</code>","text":"<pre><code><pre>NetworkRegistryMailboxState : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","registry","environment"]},{"location":"arch/node/engines/net_registry_environment.html#local-state","title":"Local state","text":"","tags":["node-architecture","network-subsystem","registry","environment"]},{"location":"arch/node/engines/net_registry_environment.html#networkregistrylocalstate","title":"<code>NetworkRegistryLocalState</code>","text":"<pre><code><pre>type NetworkRegistryLocalState := mk;</pre></code></pre>","tags":["node-architecture","network-subsystem","registry","environment"]},{"location":"arch/node/engines/net_registry_environment.html#timer-handles","title":"Timer handles","text":"","tags":["node-architecture","network-subsystem","registry","environment"]},{"location":"arch/node/engines/net_registry_environment.html#networkregistrytimerhandle","title":"<code>NetworkRegistryTimerHandle</code>","text":"<pre><code><pre>NetworkRegistryTimerHandle : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","registry","environment"]},{"location":"arch/node/engines/net_registry_environment.html#networkregistrytimestampedtrigger","title":"<code>NetworkRegistryTimestampedTrigger</code>","text":"<pre><code><pre>NetworkRegistryTimestampedTrigger : Type :=  TimestampedTrigger NetworkRegistryTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","network-subsystem","registry","environment"]},{"location":"arch/node/engines/net_registry_environment.html#engine-environment","title":"Engine Environment","text":"","tags":["node-architecture","network-subsystem","registry","environment"]},{"location":"arch/node/engines/net_registry_environment.html#networkregistryenv","title":"<code>NetworkRegistryEnv</code>","text":"<pre><code><pre>NetworkRegistryEnv : Type :=  EngineEnv    NetworkRegistryLocalState    NetworkRegistryMailboxState    NetworkRegistryTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","network-subsystem","registry","environment"]},{"location":"arch/node/engines/net_registry_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exNetworkRegistryEnv : NetworkRegistryEnv :=  EngineEnv.mk@{    localState := NetworkRegistryLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","network-subsystem","registry","environment"]},{"location":"arch/node/engines/net_registry_messages.html","title":"Network Registry Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.net_registry_messages;import arch.node.types.transport open;import arch.node.types.basics open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#network-registry-messages","title":"Network Registry Messages","text":"<p>These are the messages that the Network Registry engine can receive/respond to.</p>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type NetworkRegistryMsg :=  | NodeAdvert NodeAdvert  | TopicAdvert TopicAdvert  | GetNodeAdvertRequest NodeID  | GetNodeAdvertReply GetNodeAdvertReply  | GetTopicAdvertRequest TopicID  | GetTopicAdvertReply GetTopicAdvertReply;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#examplerequest-examplereply","title":"<code>ExampleRequest</code> &amp; <code>ExampleReply</code>","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ut purus eget sapien. Nulla facilisi.</p> <pre><code>sequenceDiagram\n    participant NetworkRegistryClient\n    participant NetworkRegistry\n\n    NetworkRegistryClient -&gt;&gt; NetworkRegistry: ExampleRequest\n    NetworkRegistry -&gt;&gt; NetworkRegistryClient: ExampleReplyOk\n\n    NetworkRegistryClient -&gt;&gt; NetworkRegistry: ExampleRequest\n    NetworkRegistry -&gt;&gt; NetworkRegistryClient: ExampleReplyErrorOne</code></pre>  Sequence Diagram: <code>ExampleRequest</code> &amp; <code>ExampleReply</code>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#networkregistrymsgnodeadvert","title":"<code>NetworkRegistryMsgNodeAdvert</code>","text":"<p>A <code>NodeAdvert</code> update from another node.</p>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#nodeadvert","title":"<code>NodeAdvert</code>","text":"<p>A self-signed node advertisement contains the node's cryptographic identity and transport addresses.</p> <pre><code><pre>type NodeAdvert :=  mkNodeAdvert@{    id : NodeID;    addrs : List TransportAddress;    version : Nat;    created : AbsTime;    sig : Commitment;  };</pre></code></pre> Arguments <code>id</code> Node identity. <code>addrs</code> Transport addresses with preferences expressed as weights. <code>version</code> Version number (incremented at every change). <code>created</code> Time of creation. <code>sig</code> Signature by <code>id</code>.","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#topicadvert","title":"<code>TopicAdvert</code>","text":"<p>A topic advertisement is signed by the topic creator, and contains the topic's cryptographic identity and the <code>NodeID</code> of a set of relay nodes that can be used to subscribe to the topic. These may be publishers, subscribers, or dedicated relay nodes for the topic.</p> <pre><code><pre>type TopicAdvert :=  mkTopicAdvert@{    id : TopicID;    relays : List NodeID;    tags : List String;    version : Nat;    created : AbsTime;    sig : Commitment;  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#getnodeadvertrequest","title":"<code>GetNodeAdvertRequest</code>","text":"<p>Get <code>NodeAdvert</code> for the given <code>NodeID</code>.</p> <p>Sender: any local engine.</p>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#getnodeadvertreply","title":"<code>GetNodeAdvertReply</code>","text":"<p>Reply to a <code>GetNodeAdvertRequest</code>.</p>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#getnodeadvertreplyok","title":"<code>GetNodeAdvertReplyOk</code>","text":"<p>Reply with locally available <code>NodeAdvert</code>.</p> <pre><code><pre>GetNodeAdvertReplyOk : Type := NodeAdvert;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#getnodeadvertreplyerror","title":"<code>GetNodeAdvertReplyError</code>","text":"<p>Error getting <code>NodeAdvert</code>.</p> <pre><code><pre>type GetNodeAdvertReplyError := | GetNodeAdvertReplyErrorNotFound;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#getnodeadvertreply_1","title":"<code>GetNodeAdvertReply</code>","text":"<pre><code><pre>GetNodeAdvertReply : Type := Result GetNodeAdvertReplyError GetNodeAdvertReplyOk;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#gettopicadvertrequest","title":"<code>GetTopicAdvertRequest</code>","text":"<p>Get <code>TopicAdvert</code> for the given <code>TopicID</code>.</p> <p>Sender: any local engine.</p>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#gettopicadvertreply","title":"<code>GetTopicAdvertReply</code>","text":"<p>Reply to a <code>GetTopicAdvertRequest</code>.</p>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#gettopicadvertreplyok","title":"<code>GetTopicAdvertReplyOk</code>","text":"<p>Reply with locally available <code>TopicAdvert</code>.</p> <pre><code><pre>GetTopicAdvertReplyOk : Type := TopicAdvert;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#gettopicadvertreplyerror","title":"<code>GetTopicAdvertReplyError</code>","text":"<p>Error getting <code>TopicAdvert</code>.</p> <pre><code><pre>type GetTopicAdvertReplyError := | GetTopicAdvertReplyErrorNotFound;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#gettopicadvertreply_1","title":"<code>GetTopicAdvertReply</code>","text":"<pre><code><pre>GetTopicAdvertReply : Type :=  Result GetTopicAdvertReplyError GetTopicAdvertReplyOk;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#networkregistrymsg","title":"<code>NetworkRegistryMsg</code>","text":"<pre><code><pre>type NetworkRegistryMsg :=  | NodeAdvert NodeAdvert  | TopicAdvert TopicAdvert  | GetNodeAdvertRequest NodeID  | GetNodeAdvertReply GetNodeAdvertReply  | GetTopicAdvertRequest TopicID  | GetTopicAdvertReply GetTopicAdvertReply;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/net_registry_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Network Registry Configuration</li> <li>Network Registry Environment</li> <li>Network Registry Behaviour</li> </ul>","tags":["node-architecture","network-subsystem","engine","registry","message-types"]},{"location":"arch/node/engines/pub_sub_topic.html","title":"Pub/Sub Topic Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.pub_sub_topic;import arch.node.engines.pub_sub_topic_messages open public;import arch.node.engines.pub_sub_topic_config open public;import arch.node.engines.pub_sub_topic_environment open public;import arch.node.engines.pub_sub_topic_behaviour open public;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;open pub_sub_topic_config_example;open pub_sub_topic_environment_example;open pub_sub_topic_behaviour_example;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","engine-definition"]},{"location":"arch/node/engines/pub_sub_topic.html#pubsub-topic-engine","title":"Pub/Sub Topic Engine","text":"","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","engine-definition"]},{"location":"arch/node/engines/pub_sub_topic.html#purpose","title":"Purpose","text":"<p>A Pub/Sub Topic engine is responsible for topic-based publish/subscribe (pub/sub) message dissemination for a single pub/sub topic.</p> <p>The protocol allows a set of authorized publishers to publish messages in the topic, as well as local and remote engines to subscribe to it. Published messages are disseminated to all subscribers.</p> <p>The engine instance name corresponds to the <code>TopicID</code>.</p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","engine-definition"]},{"location":"arch/node/engines/pub_sub_topic.html#engine-components","title":"Engine components","text":"<ul> <li>Pub/Sub Topic Messages</li> <li>Pub/Sub Topic Configuration</li> <li>Pub/Sub Topic Environment</li> <li>Pub/Sub Topic Behaviour</li> </ul>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","engine-definition"]},{"location":"arch/node/engines/pub_sub_topic.html#type","title":"Type","text":"<pre><code><pre>PubSubTopicEngine : Type :=  Engine    PubSubTopicLocalCfg    PubSubTopicLocalState    PubSubTopicMailboxState    PubSubTopicTimerHandle    PubSubTopicActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","engine-definition"]},{"location":"arch/node/engines/pub_sub_topic.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exPubSubTopicEngine : PubSubTopicEngine :=  Engine.mk@{    cfg := exPubSubTopicCfg;    env := exPubSubTopicEnv;    behaviour := exPubSubTopicBehaviour;  };</pre></code></pre> <p>Where <code>exPubSubTopicCfg</code> is defined as follows:</p> <pre><code><pre>exPubSubTopicCfg : PubSubTopicCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"pub-sub-topic\";    cfg := PubSubTopicLocalCfg.mk;  };</pre></code></pre> <p><code>exPubSubTopicEnv</code> is defined as follows:</p> <pre><code><pre>exPubSubTopicEnv : PubSubTopicEnv :=  EngineEnv.mk@{    localState := PubSubTopicLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>exPubSubTopicBehaviour</code> is defined as follows:</p> <pre><code><pre>module pub_sub_topic_behaviour_example;  exPubSubTopicBehaviour : PubSubTopicBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [exampleReplyGuard];    };end;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","engine-definition"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html","title":"Pub/Sub Topic Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.pub_sub_topic_behaviour;import arch.node.engines.pub_sub_topic_messages open;import arch.node.engines.pub_sub_topic_config open;import arch.node.engines.pub_sub_topic_environment open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#pubsub-topic-behaviour","title":"Pub/Sub Topic Behaviour","text":"","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#overview","title":"Overview","text":"<p>A Pub/Sub Topic engine acts in the ways described on this page. The action labels correspond to the actions that can be performed by the engine. Using the action labels, we describe the effects of the actions.</p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#pubsub-topic-action-flowchart","title":"Pub/Sub Topic Action Flowchart","text":"","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#examplereply-flowchart","title":"<code>exampleReply</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;PubSubTopicMsgExampleRequest&lt;br/&gt;from local engine]\n    CEnv[(exampleValue &lt; 10)]\n  end\n\n  G(exampleReplyGuard)\n  A(exampleReplyAction)\n\n  C --&gt; G -- *exampleReplyActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(exampleValue := exampleValue + 1)]\n    EMsg&gt;PubSubTopicMsgExampleResponse&lt;br/&gt;argOne]\n  end</code></pre> <code>exampleReply</code> flowchart","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#action-arguments","title":"Action arguments","text":"<p>The action arguments are set by a guard and passed to the action function as part of the <code>GuardOutput</code>.</p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#pubsubtopicactionarguments","title":"<code>PubSubTopicActionArguments</code>","text":"<pre><code><pre>PubSubTopicActionArguments : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#pubsubtopicaction","title":"<code>PubSubTopicAction</code>","text":"<p> <pre><code><pre>PubSubTopicAction : Type :=  Action    PubSubTopicLocalCfg    PubSubTopicLocalState    PubSubTopicMailboxState    PubSubTopicTimerHandle    PubSubTopicActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#pubsubtopicactioninput","title":"<code>PubSubTopicActionInput</code>","text":"<p> <pre><code><pre>PubSubTopicActionInput : Type :=  ActionInput    PubSubTopicLocalCfg    PubSubTopicLocalState    PubSubTopicMailboxState    PubSubTopicTimerHandle    PubSubTopicActionArguments    Anoma.Msg;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#pubsubtopicactioneffect","title":"<code>PubSubTopicActionEffect</code>","text":"<p> <pre><code><pre>PubSubTopicActionEffect : Type :=  ActionEffect    PubSubTopicLocalState    PubSubTopicMailboxState    PubSubTopicTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#pubsubtopicactionexec","title":"<code>PubSubTopicActionExec</code>","text":"<p> <pre><code><pre>PubSubTopicActionExec : Type :=  ActionExec    PubSubTopicLocalCfg    PubSubTopicLocalState    PubSubTopicMailboxState    PubSubTopicTimerHandle    PubSubTopicActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#examplereplyaction","title":"<code>exampleReplyAction</code>","text":"<p>Respond with a <code>PubSubTopicMsgExampleReply</code>. Respond with a <code>PubSubTopicMsgExampleReply</code>.</p> State update The state remains unchanged. Messages to be sent A <code>PubSubTopicMsgExampleReply</code> message with the data set by <code>exampleReplyGuard</code>. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>exampleReplyAction  (input : PubSubTopicActionInput) : Option PubSubTopicActionEffect := TODO;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#examplereplyactionlabel","title":"<code>exampleReplyActionLabel</code>","text":"<pre><code><pre>exampleReplyActionLabel : PubSubTopicActionExec :=  ActionExec.Seq [exampleReplyAction];</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#pubsubtopicguard","title":"<code>PubSubTopicGuard</code>","text":"<p> <pre><code><pre>PubSubTopicGuard : Type :=  Guard    PubSubTopicLocalCfg    PubSubTopicLocalState    PubSubTopicMailboxState    PubSubTopicTimerHandle    PubSubTopicActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#pubsubtopicguardoutput","title":"<code>PubSubTopicGuardOutput</code>","text":"<p> <pre><code><pre>PubSubTopicGuardOutput : Type :=  GuardOutput    PubSubTopicLocalCfg    PubSubTopicLocalState    PubSubTopicMailboxState    PubSubTopicTimerHandle    PubSubTopicActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#pubsubtopicguardeval","title":"<code>PubSubTopicGuardEval</code>","text":"<p> <pre><code><pre>PubSubTopicGuardEval : Type :=  GuardEval    PubSubTopicLocalCfg    PubSubTopicLocalState    PubSubTopicMailboxState    PubSubTopicTimerHandle    PubSubTopicActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#examplereplyguard","title":"<code>exampleReplyGuard</code>","text":"<p>Guard description (optional).</p> Condition Message type is <code>PubSubTopicMsgExampleRequest</code>. <pre><code><pre>exampleReplyGuard  (trigger : PubSubTopicTimestampedTrigger)  (cfg : PubSubTopicCfg)  (env : PubSubTopicEnv)  : Option PubSubTopicGuardOutput := TODO;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#engine-behaviour","title":"Engine behaviour","text":"","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#pubsubtopicbehaviour","title":"<code>PubSubTopicBehaviour</code>","text":"<pre><code><pre>PubSubTopicBehaviour : Type :=  EngineBehaviour    PubSubTopicLocalCfg    PubSubTopicLocalState    PubSubTopicMailboxState    PubSubTopicTimerHandle    PubSubTopicActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>module pub_sub_topic_behaviour_example;  exPubSubTopicBehaviour : PubSubTopicBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [exampleReplyGuard];    };end;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","behaviour"]},{"location":"arch/node/engines/pub_sub_topic_config.html","title":"Pub/Sub Topic Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.pub_sub_topic_config;import arch.node.engines.pub_sub_topic_messages open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","configuration"]},{"location":"arch/node/engines/pub_sub_topic_config.html#pubsub-topic-configuration","title":"Pub/Sub Topic Configuration","text":"","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","configuration"]},{"location":"arch/node/engines/pub_sub_topic_config.html#overview","title":"Overview","text":"<p>The static configuration of the engine.</p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","configuration"]},{"location":"arch/node/engines/pub_sub_topic_config.html#local-configuration","title":"Local Configuration","text":"","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","configuration"]},{"location":"arch/node/engines/pub_sub_topic_config.html#pubsubtopiclocalcfg","title":"<code>PubSubTopicLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type PubSubTopicLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","configuration"]},{"location":"arch/node/engines/pub_sub_topic_config.html#engine-configuration","title":"Engine Configuration","text":"","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","configuration"]},{"location":"arch/node/engines/pub_sub_topic_config.html#pubsubtopiccfg","title":"<code>PubSubTopicCfg</code>","text":"<pre><code><pre>PubSubTopicCfg : Type := EngineCfg PubSubTopicLocalCfg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","configuration"]},{"location":"arch/node/engines/pub_sub_topic_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exPubSubTopicCfg : PubSubTopicCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"pub-sub-topic\";    cfg := PubSubTopicLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","configuration"]},{"location":"arch/node/engines/pub_sub_topic_environment.html","title":"Pub/Sub Topic Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.pub_sub_topic_environment;import arch.node.engines.pub_sub_topic_messages open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","environment"]},{"location":"arch/node/engines/pub_sub_topic_environment.html#pubsub-topic-environment","title":"Pub/Sub Topic Environment","text":"","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","environment"]},{"location":"arch/node/engines/pub_sub_topic_environment.html#overview","title":"Overview","text":"<p>The Engine environment of the engine.</p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","environment"]},{"location":"arch/node/engines/pub_sub_topic_environment.html#mailbox-state","title":"Mailbox state","text":"","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","environment"]},{"location":"arch/node/engines/pub_sub_topic_environment.html#pubsubtopicmailboxstate","title":"<code>PubSubTopicMailboxState</code>","text":"<pre><code><pre>PubSubTopicMailboxState : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","environment"]},{"location":"arch/node/engines/pub_sub_topic_environment.html#local-state","title":"Local state","text":"","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","environment"]},{"location":"arch/node/engines/pub_sub_topic_environment.html#pubsubtopiclocalstate","title":"<code>PubSubTopicLocalState</code>","text":"<pre><code><pre>type PubSubTopicLocalState := mk;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","environment"]},{"location":"arch/node/engines/pub_sub_topic_environment.html#timer-handles","title":"Timer handles","text":"","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","environment"]},{"location":"arch/node/engines/pub_sub_topic_environment.html#pubsubtopictimerhandle","title":"<code>PubSubTopicTimerHandle</code>","text":"<pre><code><pre>PubSubTopicTimerHandle : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","environment"]},{"location":"arch/node/engines/pub_sub_topic_environment.html#pubsubtopictimestampedtrigger","title":"<code>PubSubTopicTimestampedTrigger</code>","text":"<pre><code><pre>PubSubTopicTimestampedTrigger : Type :=  TimestampedTrigger PubSubTopicTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","environment"]},{"location":"arch/node/engines/pub_sub_topic_environment.html#engine-environment","title":"Engine Environment","text":"","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","environment"]},{"location":"arch/node/engines/pub_sub_topic_environment.html#pubsubtopicenv","title":"<code>PubSubTopicEnv</code>","text":"<pre><code><pre>PubSubTopicEnv : Type :=  EngineEnv    PubSubTopicLocalState    PubSubTopicMailboxState    PubSubTopicTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","environment"]},{"location":"arch/node/engines/pub_sub_topic_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exPubSubTopicEnv : PubSubTopicEnv :=  EngineEnv.mk@{    localState := PubSubTopicLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","environment"]},{"location":"arch/node/engines/pub_sub_topic_messages.html","title":"Pub/Sub Topic Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.pub_sub_topic_messages;import arch.node.engines.net_registry_messages open;import arch.node.types.storage open;import arch.node.types.basics open;import arch.node.types.crypto open;import arch.node.types.identities open;import arch.node.types.messages open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#pubsub-topic-messages","title":"Pub/Sub Topic Messages","text":"<p>These are the messages that the Pub/Sub Topic engine can receive/respond to.</p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type PubSubTopicMsg :=  | Forward TopicMsg  | SubRequest TopicSubRequest  | SubReply TopicSubReply  | UnsubRequest TopicUnsubRequest  | UnsubReply TopicUnsubReply;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#topicmsg","title":"<code>TopicMsg</code>","text":"<p>A message published in a topic by an authorized publisher, forwarded to the local node.</p> Auxiliary type <pre><code><pre>type TopicMsg :=  mkTopicMsg@{    publisher : PublisherID;    seq : Nat;    deps : List TopicMsgID;    seen : List TopicMsgID;    content : TopicMsgContent;    sig : Commitment;  };</pre></code></pre> Arguments <code>publisher</code> Publisher identity. <code>seq</code> Per-publisher sequence number. <code>deps</code> Earlier messages this message depends on. <code>seen</code> Independent messages recently seen. <code>content</code>: Encrypted <code>TopicMsg</code>. <code>sig</code> Signature by <code>publisher</code> over the topic ID and the above fields.","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#topicmsgid","title":"<code>TopicMsgID</code>","text":"<p><pre><code><pre>syntax alias TopicMsgID := Digest;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#topicmsgcontent","title":"<code>TopicMsgContent</code>","text":"<pre><code><pre>type TopicMsgContent :=  | TopicMsgContentMsg ByteString  | TopicMsgContentChunk (Pair ByteString Chunk)  | TopicMsgContentChunkRef (Pair ByteString ChunkCommitment)  | TopicMsgContentAck TopicMsgAck;</pre></code></pre> TopicMsgContent constructors <code>TopicMsgContentMsg</code> Encrypted <code>TopicMsg</code>. <code>TopicMsgContentChunk</code> Chunk of an object. Pair of an encrypted <code>SecretKey</code> and a <code>Chunk</code>. <code>TopicMsgContentChunkRef</code> Reference to the root chunk of an object. Pair of an encrypted <code>SecretKey</code> and a <code>ChunkCommitment</code>. <code>TopicMsgContentAck</code> Acknowledgement of a <code>TopicMsg</code>.","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#topicmsgack","title":"<code>TopicMsgAck</code>","text":"<p>Acknowledgement of a <code>TopicMsg</code> with commitment to store it until the specified expiry date.</p> <pre><code><pre>type TopicMsgAck :=  mkTopicMsgAck@{    expiry : AbsTime;  };</pre></code></pre> Arguments <code>expiry</code> Expiry date and time until the node commits to store the event.","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#topicsubrequest","title":"<code>TopicSubRequest</code>","text":"<p>Pub/sub topic subscription request by a local engine or a remote node.</p> <pre><code><pre>type TopicSubRequest :=  mkTopicSubRequest@{    topic : TopicID;  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#topicsubreply","title":"<code>TopicSubReply</code>","text":"<p>Reply to a <code>TopicSubRequest</code>.</p> Auxiliary type <pre><code><pre>TopicSubReply : Type := Result TopicSubReplyOk TopicSubReplyError;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#topicsubreplyok","title":"<code>TopicSubReplyOk</code>","text":"<p>Subscription successful.</p> <p><pre><code><pre>type TopicSubReplyOk := | TopicSubReplyOkSuccess;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#topicsubreplyerror","title":"<code>TopicSubReplyError</code>","text":"<p>Subscription failed.</p> <p><pre><code><pre>type TopicSubReplyError := | TopicSubReplyErrorDenied;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#topicunsubrequest","title":"<code>TopicUnsubRequest</code>","text":"<p>Pub/sub topic unsubscription request by a local engine or a remote node.</p> <pre><code><pre>type TopicUnsubRequest :=  mkTopicUnsubRequest@{    topic : TopicID;  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#topicunsubreply","title":"<code>TopicUnsubReply</code>","text":"<p>Unsubscription successful.</p> Auxiliary type <pre><code><pre>TopicUnsubReply : Type := Result TopicUnsubReplyOk TopicUnsubReplyError;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#topicunsubreplyok","title":"<code>TopicUnsubReplyOk</code>","text":"<p><pre><code><pre>type TopicUnsubReplyOk := | TopicUnsubReplyOkSuccess;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#topicunsubreplyerror","title":"<code>TopicUnsubReplyError</code>","text":"<p>Unsubscription failed.</p> <p><pre><code><pre>type TopicUnsubReplyError := | TopicUnsubReplyErrorNotSubscribed;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#pubsubtopicmsg","title":"<code>PubSubTopicMsg</code>","text":"<p>All pub/sub topic  messages.</p> <pre><code><pre>type PubSubTopicMsg :=  | Forward TopicMsg  | SubRequest TopicSubRequest  | SubReply TopicSubReply  | UnsubRequest TopicUnsubRequest  | UnsubReply TopicUnsubReply;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/pub_sub_topic_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Pub/Sub Topic Configuration</li> <li>Pub/Sub Topic Environment</li> <li>Pub/Sub Topic Behaviour</li> </ul>","tags":["node-architecture","network-subsystem","engine","pub-sub-topic","message-types"]},{"location":"arch/node/engines/reads_for.html","title":"ReadsFor Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.reads_for;import prelude open;import arch.node.types.engine open;import arch.node.engines.reads_for_messages open public;import arch.node.engines.reads_for_environment open public;import arch.node.engines.reads_for_behaviour open public;import arch.node.engines.reads_for_config open public;import arch.node.engines.reads_for_messages open public;import arch.node.engines.reads_for_environment open public;import arch.node.engines.reads_for_behaviour open public;import arch.node.types.anoma as Anoma open;open reads_for_config_example;open reads_for_environment_example;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","readsfor","engine-definition"]},{"location":"arch/node/engines/reads_for.html#readfor-engine","title":"ReadFor Engine","text":"<p>The ReadFor Engine manages <code>reads_for</code> relationships between identities. A <code>reads_for</code> relationship indicates that one identity can read data encrypted for another identity.</p>","tags":["node-architecture","identity-subsystem","engine","readsfor","engine-definition"]},{"location":"arch/node/engines/reads_for.html#purpose","title":"Purpose","text":"<p>The ReadFor Engine maintains and manages the state of <code>reads_for</code> relationships between identities. It handles queries about these relationships, allows submission of new evidence, and provides information about existing relationships. This is useful in scenarios where data access needs to be delegated or shared.</p>","tags":["node-architecture","identity-subsystem","engine","readsfor","engine-definition"]},{"location":"arch/node/engines/reads_for.html#engine-components","title":"Engine components","text":"<ul> <li>ReadFor Messages</li> <li>ReadFor Configuration</li> <li>ReadFor Environment</li> <li>ReadFor Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","readsfor","engine-definition"]},{"location":"arch/node/engines/reads_for.html#type","title":"Type","text":"<pre><code><pre>ReadsForEngine : Type :=  Engine    ReadsForLocalCfg    ReadsForLocalState    ReadsForMailboxState    ReadsForTimerHandle    ReadsForActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","engine-definition"]},{"location":"arch/node/engines/reads_for.html#example-of-a-reads-for-engine","title":"Example of a reads for engine","text":"<pre><code><pre>exampleReadsForEngine : ReadsForEngine :=  Engine.mk@{    cfg := readsForCfg;    env := readsForEnv;    behaviour := readsForBehaviour;  };</pre></code></pre> <p>where <code>readsForCfg</code> is defined as follows:</p> <pre><code><pre>readsForCfg : ReadsForCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"reads for\";    cfg := ReadsForLocalCfg.mk;  };</pre></code></pre> <p><code>readsForEnv</code> is defined as follows:</p> <pre><code><pre>readsForEnv : ReadsForEnv :=  EngineEnv.mk@{    localState :=      ReadsForLocalState.mk@{        evidenceStore := Set.empty;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>readsForBehaviour</code> is defined as follows:</p> <pre><code><pre>readsForBehaviour : ReadsForBehaviour :=  EngineBehaviour.mk@{    guards :=      GuardEval.First        [readsForQueryGuard; submitEvidenceGuard; queryEvidenceGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","engine-definition"]},{"location":"arch/node/engines/reads_for_behaviour.html","title":"ReadsFor Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.reads_for_behaviour;import prelude open;import Stdlib.Data.Set as Set;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.identities open;import arch.node.engines.reads_for_messages open;import arch.node.engines.reads_for_config open;import arch.node.engines.reads_for_environment open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readfor-behaviour","title":"ReadFor Behaviour","text":"","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#overview","title":"Overview","text":"<p>The behavior of the ReadFor Engine defines how it processes incoming messages and updates its state accordingly.</p>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readsforactionargumentreplyto-replyto","title":"<code>ReadsForActionArgumentReplyTo ReplyTo</code>","text":"<pre><code><pre>type ReplyTo :=  mkReplyTo@{    whoAsked : Option EngineID;    mailbox : Option MailboxID;  };</pre></code></pre> <p>This action argument contains the address and mailbox ID of where the response message should be sent.</p> Argument description   <code>whoAsked</code>: is the address of the engine that sent the message. <code>mailbox</code>: is the mailbox ID where the response should be sent.","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readsforactionargument","title":"<code>ReadsForActionArgument</code>","text":"<pre><code><pre>type ReadsForActionArgument := | ReadsForActionArgumentReplyTo ReplyTo;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readsforactionarguments","title":"<code>ReadsForActionArguments</code>","text":"<pre><code><pre>ReadsForActionArguments : Type := List ReadsForActionArgument;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readsforaction","title":"ReadsForAction","text":"<p><pre><code><pre>ReadsForAction : Type :=  Action    ReadsForLocalCfg    ReadsForLocalState    ReadsForMailboxState    ReadsForTimerHandle    ReadsForActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readsforactioninput","title":"ReadsForActionInput","text":"<p><pre><code><pre>ReadsForActionInput : Type :=  ActionInput    ReadsForLocalCfg    ReadsForLocalState    ReadsForMailboxState    ReadsForTimerHandle    ReadsForActionArguments    Anoma.Msg;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readsforactioneffect","title":"ReadsForActionEffect","text":"<p><pre><code><pre>ReadsForActionEffect : Type :=  ActionEffect    ReadsForLocalState    ReadsForMailboxState    ReadsForTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readsforactionexec","title":"ReadsForActionExec","text":"<p><pre><code><pre>ReadsForActionExec : Type :=  ActionExec    ReadsForLocalCfg    ReadsForLocalState    ReadsForMailboxState    ReadsForTimerHandle    ReadsForActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readsforqueryaction","title":"<code>readsForQueryAction</code>","text":"<p>Process a reads for query and respond with whether the relationship exists.</p> State update The state remains unchanged. Messages to be sent A <code>ReplyReadsFor</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>readsForQueryAction  (input : ReadsForActionInput) : Option ReadsForActionEffect :=  let    env := ActionInput.env input;    tt := ActionInput.trigger input;    cfg := ActionInput.cfg input;    localState := EngineEnv.localState env;  in case getEngineMsgFromTimestampedTrigger tt of       | some emsg :=         case emsg of {           | EngineMsg.mk@{               msg := Anoma.Msg.ReadsFor (ReadsForMsg.Request (RequestReadsFor.mkRequestReadsFor identityA identityB));             } :=             let               hasEvidence :=                 isElement                   \\{a b := a &amp;&amp; b}                   true                   (map                     \\{evidence :=                       isEqual                           (Ord.compare                             (ReadsForEvidence.fromIdentity evidence)                             identityA)                         &amp;&amp; isEqual                           (Ord.compare                             (ReadsForEvidence.toIdentity evidence)                             identityB)}                     (Set.toList                       (ReadsForLocalState.evidenceStore localState)));               responseMsg :=                 ReplyReadsFor.mkReplyReadsFor@{                   readsFor := hasEvidence;                   err := none;                 };             in some               ActionEffect.mk@{                 env := env;                 msgs :=                   [                     EngineMsg.mk@{                       sender := getEngineIDFromEngineCfg cfg;                       target := EngineMsg.sender emsg;                       mailbox := some 0;                       msg :=                         Anoma.Msg.ReadsFor (ReadsForMsg.Reply responseMsg);                     };                   ];                 timers := [];                 engines := [];               }           | _ := none         }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#submitevidenceaction","title":"<code>submitEvidenceAction</code>","text":"<p>Process submission of new reads for evidence.</p> State update If the evidence is valid and doesn't exist, it's added to the evidence store. Messages to be sent A <code>ReplySubmitReadsForEvidence</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>submitEvidenceAction  (input : ReadsForActionInput) : Option ReadsForActionEffect :=  let    env := ActionInput.env input;    tt := ActionInput.trigger input;    cfg := ActionInput.cfg input;    localState := EngineEnv.localState env;  in case getEngineMsgFromTimestampedTrigger tt of       | some emsg :=         case emsg of {           | EngineMsg.mk@{               msg := Anoma.Msg.ReadsFor (ReadsForMsg.SubmitReadsForEvidenceRequest (RequestSubmitReadsForEvidence.mkRequestSubmitReadsForEvidence evidence));             } :=             case verifyEvidence evidence of {               | true :=                 case                   isElement                     \\{a b := a &amp;&amp; b}                     true                     (map                       \\{e := isEqual (Ord.compare e evidence)}                       (Set.toList                         (ReadsForLocalState.evidenceStore localState)))                 of {                   | true :=                     some                       ActionEffect.mk@{                         env := env;                         msgs :=                           [                             EngineMsg.mk@{                               sender := getEngineIDFromEngineCfg cfg;                               target := EngineMsg.sender emsg;                               mailbox := some 0;                               msg :=                                 Anoma.Msg.ReadsFor                                   (ReadsForMsg.SubmitReadsForEvidenceReply                                     (ReplySubmitReadsForEvidence.mkReplySubmitReadsForEvidence                                       (some \"Evidence already exists.\")));                             };                           ];                         timers := [];                         engines := [];                       }                   | false :=                     let                       newEvidenceStore :=                         Set.insert                           evidence                           (ReadsForLocalState.evidenceStore localState);                       updatedLocalState :=                         localState@ReadsForLocalState{evidenceStore := newEvidenceStore};                       newEnv := env@EngineEnv{localState := updatedLocalState};                     in some                       ActionEffect.mk@{                         env := newEnv;                         msgs :=                           [                             EngineMsg.mk@{                               sender := getEngineIDFromEngineCfg cfg;                               target := EngineMsg.sender emsg;                               mailbox := some 0;                               msg :=                                 Anoma.Msg.ReadsFor                                   (ReadsForMsg.SubmitReadsForEvidenceReply                                     (ReplySubmitReadsForEvidence.mkReplySubmitReadsForEvidence                                       none));                             };                           ];                         timers := [];                         engines := [];                       }                 }               | false :=                 some                   ActionEffect.mk@{                     env := env;                     msgs :=                       [                         EngineMsg.mk@{                           sender := getEngineIDFromEngineCfg cfg;                           target := EngineMsg.sender emsg;                           mailbox := some 0;                           msg :=                             Anoma.Msg.ReadsFor                               (ReadsForMsg.SubmitReadsForEvidenceReply                                 (ReplySubmitReadsForEvidence.mkReplySubmitReadsForEvidence                                   (some \"Invalid evidence provided.\")));                         };                       ];                     timers := [];                     engines := [];                   }             }           | _ := none         }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#queryevidenceaction","title":"<code>queryEvidenceAction</code>","text":"<p>Query all evidence related to a specific identity.</p> State update The state remains unchanged. Messages to be sent A <code>ReplyQueryReadsForEvidence</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>queryEvidenceAction  (input : ReadsForActionInput) : Option ReadsForActionEffect :=  let    env := ActionInput.env input;    tt := ActionInput.trigger input;    cfg := ActionInput.cfg input;    localState := EngineEnv.localState env;  in case getEngineMsgFromTimestampedTrigger tt of       | some emsg :=         case emsg of {           | EngineMsg.mk@{               msg := Anoma.Msg.ReadsFor (ReadsForMsg.QueryReadsForEvidenceRequest (RequestQueryReadsForEvidence.mkRequestQueryReadsForEvidence identity));             } :=             let               relevantEvidence :=                 Set.filter                   \\{evidence :=                     isEqual                         (Ord.compare                           (ReadsForEvidence.fromIdentity evidence)                           identity)                       || isEqual                         (Ord.compare                           (ReadsForEvidence.toIdentity evidence)                           identity)}                   (ReadsForLocalState.evidenceStore localState);               responseMsg :=                 ReplyQueryReadsForEvidence.mkReplyQueryReadsForEvidence@{                   externalIdentity := identity;                   evidence := relevantEvidence;                   err := none;                 };             in some               ActionEffect.mk@{                 env := env;                 msgs :=                   [                     EngineMsg.mk@{                       sender := getEngineIDFromEngineCfg cfg;                       target := EngineMsg.sender emsg;                       mailbox := some 0;                       msg :=                         Anoma.Msg.ReadsFor                           (ReadsForMsg.QueryReadsForEvidenceReply responseMsg);                     };                   ];                 timers := [];                 engines := [];               }           | _ := none         }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readsforqueryactionlabel","title":"<code>readsForQueryActionLabel</code>","text":"<pre><code><pre>readsForQueryActionLabel : ReadsForActionExec :=  ActionExec.Seq [readsForQueryAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#submitevidenceactionlabel","title":"<code>submitEvidenceActionLabel</code>","text":"<pre><code><pre>submitEvidenceActionLabel : ReadsForActionExec :=  ActionExec.Seq [submitEvidenceAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#queryevidenceactionlabel","title":"<code>queryEvidenceActionLabel</code>","text":"<pre><code><pre>queryEvidenceActionLabel : ReadsForActionExec :=  ActionExec.Seq [queryEvidenceAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readsforguard","title":"<code>ReadsForGuard</code>","text":"<p> <pre><code><pre>ReadsForGuard : Type :=  Guard    ReadsForLocalCfg    ReadsForLocalState    ReadsForMailboxState    ReadsForTimerHandle    ReadsForActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readsforguardoutput","title":"<code>ReadsForGuardOutput</code>","text":"<p> <pre><code><pre>ReadsForGuardOutput : Type :=  GuardOutput    ReadsForLocalCfg    ReadsForLocalState    ReadsForMailboxState    ReadsForTimerHandle    ReadsForActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readsforguardeval","title":"<code>ReadsForGuardEval</code>","text":"<p> <pre><code><pre>ReadsForGuardEval : Type :=  GuardEval    ReadsForLocalCfg    ReadsForLocalState    ReadsForMailboxState    ReadsForTimerHandle    ReadsForActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readsforqueryguard","title":"<code>readsForQueryGuard</code>","text":"Condition Message type is <code>MsgReadsForRequest</code>. <pre><code><pre>readsForQueryGuard  (tt : TimestampedTrigger ReadsForTimerHandle Anoma.Msg)  (cfg : ReadsForCfg)  (env : ReadsForEnv)  : Option ReadsForGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some EngineMsg.mk@{msg := Anoma.Msg.ReadsFor (ReadsForMsg.Request _)} :=      some        GuardOutput.mk@{          action := readsForQueryActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#submitevidenceguard","title":"<code>submitEvidenceGuard</code>","text":"Condition Message type is <code>MsgSubmitReadsForEvidenceRequest</code>. <pre><code><pre>submitEvidenceGuard  (tt : TimestampedTrigger ReadsForTimerHandle Anoma.Msg)  (cfg : ReadsForCfg)  (env : ReadsForEnv)  : Option ReadsForGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some EngineMsg.mk@{             msg := Anoma.Msg.ReadsFor (ReadsForMsg.SubmitReadsForEvidenceRequest _);           } :=      some        GuardOutput.mk@{          action := submitEvidenceActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#queryevidenceguard","title":"<code>queryEvidenceGuard</code>","text":"Condition Message type is <code>MsgQueryReadsForEvidenceRequest</code>. <pre><code><pre>queryEvidenceGuard  (tt : TimestampedTrigger ReadsForTimerHandle Anoma.Msg)  (cfg : ReadsForCfg)  (env : ReadsForEnv)  : Option ReadsForGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some EngineMsg.mk@{             msg := Anoma.Msg.ReadsFor (ReadsForMsg.QueryReadsForEvidenceRequest _);           } :=      some        GuardOutput.mk@{          action := queryEvidenceActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#the-readfor-behaviour","title":"The ReadFor Behaviour","text":"","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readsforbehaviour","title":"<code>ReadsForBehaviour</code>","text":"<pre><code><pre>ReadsForBehaviour : Type :=  EngineBehaviour    ReadsForLocalCfg    ReadsForLocalState    ReadsForMailboxState    ReadsForTimerHandle    ReadsForActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>readsForBehaviour : ReadsForBehaviour :=  EngineBehaviour.mk@{    guards :=      GuardEval.First        [readsForQueryGuard; submitEvidenceGuard; queryEvidenceGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readfor-action-flowcharts","title":"ReadFor Action Flowcharts","text":"","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#readsforqueryaction-flowchart","title":"<code>readsForQueryAction</code> flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;MsgReadsForRequest]\n  end\n\n  G(readsForQueryGuard)\n  A(readsForQueryAction)\n\n  C --&gt; G -- *readsForQueryActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EMsg&gt;ReplyReadsFor&lt;br/&gt;readsFor]\n  end</code></pre> <code>readsForQueryAction</code> flowchart","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#submitevidenceaction-flowchart","title":"<code>submitEvidenceAction</code> flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;MsgSubmitReadsForEvidenceRequest]\n  end\n\n  G(submitEvidenceGuard)\n  A(submitEvidenceAction)\n\n  C --&gt; G -- *submitEvidenceActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(evidenceStore update)]\n    EMsg&gt;ReplySubmitReadsForEvidence&lt;br/&gt;error]\n  end</code></pre> <code>submitEvidenceAction</code> flowchart","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_behaviour.html#queryevidenceaction-flowchart","title":"<code>queryEvidenceAction</code> flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;MsgQueryReadsForEvidenceRequest]\n  end\n\n  G(queryEvidenceGuard)\n  A(queryEvidenceAction)\n\n  C --&gt; G -- *queryEvidenceActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EMsg&gt;ReplyQueryReadsForEvidence&lt;br/&gt;evidence list]\n  end</code></pre> <code>queryEvidenceAction</code> flowchart","tags":["node-architecture","identity-subsystem","engine","readsfor","behaviour"]},{"location":"arch/node/engines/reads_for_config.html","title":"ReadsFor Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.reads_for_config;import prelude open;import arch.node.engines.reads_for_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","readsfor","configuration"]},{"location":"arch/node/engines/reads_for_config.html#readfor-configuration","title":"ReadFor Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","readsfor","configuration"]},{"location":"arch/node/engines/reads_for_config.html#overview","title":"Overview","text":"<p>The ReadFor engine configuration contains static information for ReadFor engine instances.</p>","tags":["node-architecture","identity-subsystem","engine","readsfor","configuration"]},{"location":"arch/node/engines/reads_for_config.html#the-readfor-local-configuration","title":"The ReadFor Local Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","readsfor","configuration"]},{"location":"arch/node/engines/reads_for_config.html#readsforlocalcfg","title":"<code>ReadsForLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type ReadsForLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","configuration"]},{"location":"arch/node/engines/reads_for_config.html#the-readfor-configuration","title":"The ReadFor Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","readsfor","configuration"]},{"location":"arch/node/engines/reads_for_config.html#readsforcfg","title":"<code>ReadsForCfg</code>","text":"<pre><code><pre>ReadsForCfg : Type := EngineCfg ReadsForLocalCfg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","configuration"]},{"location":"arch/node/engines/reads_for_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>readsForCfg : ReadsForCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"reads for\";    cfg := ReadsForLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","configuration"]},{"location":"arch/node/engines/reads_for_environment.html","title":"ReadsFor Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.reads_for_environment;import prelude open;import arch.node.types.engine_environment open;import arch.node.types.identities open;import arch.node.engines.reads_for_messages open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","readsfor","environment"]},{"location":"arch/node/engines/reads_for_environment.html#readfor-environment","title":"ReadFor Environment","text":"","tags":["node-architecture","identity-subsystem","engine","readsfor","environment"]},{"location":"arch/node/engines/reads_for_environment.html#overview","title":"Overview","text":"<p>The ReadFor Engine environment maintains the state necessary for managing <code>reads_for</code> relationships between identities, including storing evidence submitted by clients.</p> Auxiliary Juvix code <p><pre><code><pre>axiom verifyEvidence : ReadsForEvidence -&gt; Bool;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","readsfor","environment"]},{"location":"arch/node/engines/reads_for_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The ReadFor Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","readsfor","environment"]},{"location":"arch/node/engines/reads_for_environment.html#readsformailboxstate","title":"<code>ReadsForMailboxState</code>","text":"<pre><code><pre>syntax alias ReadsForMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","environment"]},{"location":"arch/node/engines/reads_for_environment.html#local-state","title":"Local state","text":"<p>The local state of the ReadFor Engine includes the evidence for reads_for relationships.</p>","tags":["node-architecture","identity-subsystem","engine","readsfor","environment"]},{"location":"arch/node/engines/reads_for_environment.html#readsforlocalstate","title":"<code>ReadsForLocalState</code>","text":"<pre><code><pre>type ReadsForLocalState :=  mk@{    evidenceStore : Set ReadsForEvidence;  };</pre></code></pre> Arguments <code>evidenceStore</code>: The collection of validated <code>ReadsForEvidence</code> which has been submitted to the engine.","tags":["node-architecture","identity-subsystem","engine","readsfor","environment"]},{"location":"arch/node/engines/reads_for_environment.html#timer-handle","title":"Timer Handle","text":"<p>The ReadFor Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","readsfor","environment"]},{"location":"arch/node/engines/reads_for_environment.html#readsfortimerhandle","title":"<code>ReadsForTimerHandle</code>","text":"<pre><code><pre>syntax alias ReadsForTimerHandle := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","environment"]},{"location":"arch/node/engines/reads_for_environment.html#the-readfor-environment","title":"The ReadFor Environment","text":"","tags":["node-architecture","identity-subsystem","engine","readsfor","environment"]},{"location":"arch/node/engines/reads_for_environment.html#readsforenv","title":"<code>ReadsForEnv</code>","text":"<pre><code><pre>ReadsForEnv : Type :=  EngineEnv    ReadsForLocalState    ReadsForMailboxState    ReadsForTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","environment"]},{"location":"arch/node/engines/reads_for_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>readsForEnv : ReadsForEnv :=  EngineEnv.mk@{    localState :=      ReadsForLocalState.mk@{        evidenceStore := Set.empty;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","environment"]},{"location":"arch/node/engines/reads_for_messages.html","title":"ReadsFor Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.reads_for_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/reads_for_messages.html#readsfor-messages","title":"ReadsFor Messages","text":"","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/reads_for_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type ReadsForMsg :=  | Request RequestReadsFor  | Reply ReplyReadsFor  | SubmitReadsForEvidenceRequest RequestSubmitReadsForEvidence  | SubmitReadsForEvidenceReply ReplySubmitReadsForEvidence  | QueryReadsForEvidenceRequest RequestQueryReadsForEvidence  | QueryReadsForEvidenceReply ReplyQueryReadsForEvidence;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/reads_for_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/reads_for_messages.html#submitting-reads_for-evidence","title":"Submitting <code>reads_for</code> evidence","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant ReadsForEngine\n\n    Client-&gt;&gt;ReadsForEngine: RequestSubmitReadsForEvidence\n    Note over ReadsForEngine: Verify and store evidence\n    ReadsForEngine-&gt;&gt;Client: ReplySubmitReadsForEvidence</code></pre>  Submitting <code>reads_for</code> evidence","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/reads_for_messages.html#querying-a-reads_for-relationship","title":"Querying a <code>reads_for</code> relationship","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant ReadsForEngine\n\n    Client-&gt;&gt;ReadsForEngine: RequestReadsFor (A reads for B?)\n    Note over ReadsForEngine: Check stored evidence\n    ReadsForEngine-&gt;&gt;Client: ReplyReadsFor</code></pre>  Querying a reads_for relationship","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/reads_for_messages.html#querying-reads_for-evidence","title":"Querying <code>reads_for</code> evidence","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant ReadsForEngine\n\n    Client-&gt;&gt;ReadsForEngine: RequestQueryReadsForEvidence (for X)\n    Note over ReadsForEngine: Retrieve relevant evidence\n    ReadsForEngine-&gt;&gt;Client: ReplyQueryReadsForEvidence</code></pre>  Querying reads_for evidence for an identity","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/reads_for_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/reads_for_messages.html#requestreadsfor","title":"<code>RequestReadsFor</code>","text":"<pre><code><pre>type RequestReadsFor :=  mkRequestReadsFor@{    externalIdentityA : ExternalIdentity;    externalIdentityB : ExternalIdentity;  };</pre></code></pre> <p>A request to query whether <code>externalIdentityA</code> can read data encrypted to <code>externalIdentityB</code>.</p> Arguments <code>externalIdentityA</code>: The identity doing the reading. <code>externalIdentityB</code>: The identity being read for.","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/reads_for_messages.html#replyreadsfor","title":"<code>ReplyReadsFor</code>","text":"<pre><code><pre>type ReplyReadsFor :=  mkReplyReadsFor@{    readsFor : Bool;    err : Option String;  };</pre></code></pre> <p>Reply indicating whether the <code>reads_for</code> relationship exists.</p> Arguments <code>readsFor</code>: True if <code>externalIdentityA</code> can read for <code>externalIdentityB</code>, False otherwise. <code>err</code>: An error message if the query failed.","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/reads_for_messages.html#requestsubmitreadsforevidence","title":"<code>RequestSubmitReadsForEvidence</code>","text":"<pre><code><pre>type RequestSubmitReadsForEvidence :=  mkRequestSubmitReadsForEvidence@{    evidence : ReadsForEvidence;  };</pre></code></pre> <p>Request to submit evidence of a <code>reads_for</code> relationship.</p> Arguments <code>evidence</code>: The evidence supporting the <code>reads_for</code> relationship.","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/reads_for_messages.html#replysubmitreadsforevidence","title":"<code>ReplySubmitReadsForEvidence</code>","text":"<pre><code><pre>type ReplySubmitReadsForEvidence :=  mkReplySubmitReadsForEvidence@{    err : Option String;  };</pre></code></pre> <p>Reply acknowledging the submission of evidence.</p> Arguments <code>err</code>: An error message if the submission failed.","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/reads_for_messages.html#requestqueryreadsforevidence","title":"<code>RequestQueryReadsForEvidence</code>","text":"<pre><code><pre>type RequestQueryReadsForEvidence :=  mkRequestQueryReadsForEvidence@{    externalIdentity : ExternalIdentity;  };</pre></code></pre> <p>Request to query all <code>reads_for</code> evidence related to an identity.</p> Arguments <code>externalIdentity</code>: The identity for which to retrieve evidence.","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/reads_for_messages.html#replyqueryreadsforevidence","title":"<code>ReplyQueryReadsForEvidence</code>","text":"<pre><code><pre>type ReplyQueryReadsForEvidence :=  mkReplyQueryReadsForEvidence@{    externalIdentity : ExternalIdentity;    evidence : Set ReadsForEvidence;    err : Option String;  };</pre></code></pre> <p>Reply providing the requested evidence.</p> Arguments <code>externalIdentity</code>: The identity for which evidence was requested. <code>evidence</code>: A set of <code>ReadsForEvidence</code> related to the identity. <code>err</code>: An error message if the query failed.","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/reads_for_messages.html#readsformsg","title":"<code>ReadsForMsg</code>","text":"<pre><code><pre>type ReadsForMsg :=  | Request RequestReadsFor  | Reply ReplyReadsFor  | SubmitReadsForEvidenceRequest RequestSubmitReadsForEvidence  | SubmitReadsForEvidenceReply ReplySubmitReadsForEvidence  | QueryReadsForEvidenceRequest RequestQueryReadsForEvidence  | QueryReadsForEvidenceReply ReplyQueryReadsForEvidence;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/reads_for_messages.html#engine-components","title":"Engine components","text":"<ul> <li>ReadsFor Configuration</li> <li>ReadsFor Environment</li> <li>ReadsFor Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","readsfor","message-types"]},{"location":"arch/node/engines/router.html","title":"Router Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.router;import arch.node.engines.router_messages open;import arch.node.engines.router_config open;import arch.node.engines.router_environment open;import arch.node.engines.router_behaviour open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;open router_config_example;open router_environment_example;open router_behaviour_example;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","router","engine-definition"]},{"location":"arch/node/engines/router.html#router-engine","title":"Router Engine","text":"","tags":["node-architecture","network-subsystem","engine","router","engine-definition"]},{"location":"arch/node/engines/router.html#purpose","title":"Purpose","text":"<p>The Router engine is responsible for routing messages between local engines and remote nodes.</p>","tags":["node-architecture","network-subsystem","engine","router","engine-definition"]},{"location":"arch/node/engines/router.html#operation","title":"Operation","text":"<p>The Router may operate in different modes depending on requirements and constraints of the implementation:</p> Centralized A single Router engine instance forwards messages to &amp; from local engines.   It may integrate the functionality of Pub/Sub Topic engines as well. Decentralized A separate Router engine instance is spawned for each destination node,   each of which forward messages for a single node only.   The engine instance name is derived from <code>NodeID</code> of the destination,   which allows local engines to forward outgoing messages   via the router engine instance responsible for the destination. <p>Spawning of Router and Pub/Sub Topic engines may be implemented either manually when the first message is sent to the node or when the topic is subscribed, or automatically as soon as a <code>NodeAdvert</code> or <code>TopicAdvert</code> is known for the destination.</p> <p>In the following we assume decentralized operation with automatic spawning for simplicity.</p>","tags":["node-architecture","network-subsystem","engine","router","engine-definition"]},{"location":"arch/node/engines/router.html#engine-components","title":"Engine components","text":"<ul> <li>Router Messages</li> <li>Router Configuration</li> <li>Router Environment</li> <li>Router Behaviour</li> </ul>","tags":["node-architecture","network-subsystem","engine","router","engine-definition"]},{"location":"arch/node/engines/router.html#the-type-for-a-router-engine","title":"The type for a router engine","text":"<pre><code><pre>RouterEngine : Type :=  Engine    RouterLocalCfg    RouterLocalState    RouterMailboxState    RouterTimerHandle    RouterActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","engine-definition"]},{"location":"arch/node/engines/router.html#example-of-a-router-engine","title":"Example of a router engine","text":"<pre><code><pre>exRouterEngine : RouterEngine :=  Engine.mk@{    cfg := exRouterCfg;    env := exRouterEnv;    behaviour := exRouterBehaviour;  };</pre></code></pre> <p>Where <code>exRouterCfg</code> is defined as follows:</p> <pre><code><pre>exRouterCfg : RouterCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"router-0xab12cd34\";    cfg := RouterLocalCfg.mk;  };</pre></code></pre> <p><code>exRouterEnv</code> is defined as follows:</p> <pre><code><pre>exRouterEnv : RouterEnv :=  EngineEnv.mk@{    localState := RouterLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>exRouterBehaviour</code> is defined as follows:</p> <pre><code><pre>module router_behaviour_example;  exRouterBehaviour : RouterBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [exampleReplyGuard];    };end;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","engine-definition"]},{"location":"arch/node/engines/router_behaviour.html","title":"Router Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.router_behaviour;import arch.node.engines.router_messages open;import arch.node.engines.router_config open;import arch.node.engines.router_environment open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#router-behaviour","title":"Router Behaviour","text":"","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#overview","title":"Overview","text":"<p>A router engine acts in the ways described on this page. The action labels correspond to the actions that can be performed by the engine. Using the action labels, we describe the effects of the actions.</p>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#router-action-flowchart","title":"Router Action Flowchart","text":"","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#examplereply-flowchart","title":"<code>exampleReply</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;RouterMsgExampleRequest&lt;br/&gt;from local engine]\n    CEnv[(exampleValue &lt; 10)]\n  end\n\n  G(exampleReplyGuard)\n  A(exampleReplyAction)\n\n  C --&gt; G -- *exampleReplyActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(exampleValue := exampleValue + 1)]\n    EMsg&gt;RouterMsgExampleResponse&lt;br/&gt;argOne]\n  end</code></pre> <code>exampleReply</code> flowchart","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#action-arguments","title":"Action arguments","text":"<p>The action arguments are set by a guard and passed to the action function as part of the <code>GuardOutput</code>.</p>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#routeractionarguments","title":"<code>RouterActionArguments</code>","text":"<pre><code><pre>RouterActionArguments : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#routeraction","title":"<code>RouterAction</code>","text":"<p> <pre><code><pre>RouterAction : Type :=  Action    RouterLocalCfg    RouterLocalState    RouterMailboxState    RouterTimerHandle    RouterActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#routeractioninput","title":"<code>RouterActionInput</code>","text":"<p> <pre><code><pre>RouterActionInput : Type :=  ActionInput    RouterLocalCfg    RouterLocalState    RouterMailboxState    RouterTimerHandle    RouterActionArguments    Anoma.Msg;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#routeractioneffect","title":"<code>RouterActionEffect</code>","text":"<p> <pre><code><pre>RouterActionEffect : Type :=  ActionEffect    RouterLocalState    RouterMailboxState    RouterTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#routeractionexec","title":"<code>RouterActionExec</code>","text":"<p> <pre><code><pre>RouterActionExec : Type :=  ActionExec    RouterLocalCfg    RouterLocalState    RouterMailboxState    RouterTimerHandle    RouterActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#examplereplyaction","title":"<code>exampleReplyAction</code>","text":"<p>Respond with a <code>RouterMsgExampleReply</code>.</p> State update The state remains unchanged. Messages to be sent A <code>RouterMsgExampleReply</code> message with the data set by <code>exampleReplyGuard</code>. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>exampleReplyAction (input : RouterActionInput) : Option RouterActionEffect :=  TODO;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#examplereplyactionlabel","title":"<code>exampleReplyActionLabel</code>","text":"<pre><code><pre>exampleReplyActionLabel : RouterActionExec :=  ActionExec.Seq [exampleReplyAction];</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#routerguard","title":"<code>RouterGuard</code>","text":"<p> <pre><code><pre>RouterGuard : Type :=  Guard    RouterLocalCfg    RouterLocalState    RouterMailboxState    RouterTimerHandle    RouterActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#routerguardoutput","title":"<code>RouterGuardOutput</code>","text":"<p> <pre><code><pre>RouterGuardOutput : Type :=  GuardOutput    RouterLocalCfg    RouterLocalState    RouterMailboxState    RouterTimerHandle    RouterActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#routerguardeval","title":"<code>RouterGuardEval</code>","text":"<p> <pre><code><pre>RouterGuardEval : Type :=  GuardEval    RouterLocalCfg    RouterLocalState    RouterMailboxState    RouterTimerHandle    RouterActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#examplereplyguard","title":"<code>exampleReplyGuard</code>","text":"<p>Guard description (optional).</p> Condition Message type is <code>RouterMsgExampleRequest</code>. <pre><code><pre>exampleReplyGuard  (trigger : RouterTimestampedTrigger)  (cfg : RouterCfg)  (env : RouterEnv)  : Option RouterGuardOutput := TODO;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#the-router-behaviour","title":"The Router behaviour","text":"","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#routerbehaviour","title":"<code>RouterBehaviour</code>","text":"<pre><code><pre>RouterBehaviour : Type :=  EngineBehaviour    RouterLocalCfg    RouterLocalState    RouterMailboxState    RouterTimerHandle    RouterActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>module router_behaviour_example;  exRouterBehaviour : RouterBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [exampleReplyGuard];    };end;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","behaviour"]},{"location":"arch/node/engines/router_config.html","title":"Router Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.router_config;import arch.node.engines.router_messages open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","router","configuration"]},{"location":"arch/node/engines/router_config.html#router-configuration","title":"Router Configuration","text":"","tags":["node-architecture","network-subsystem","engine","router","configuration"]},{"location":"arch/node/engines/router_config.html#overview","title":"Overview","text":"<p>The static configuration of the engine.</p>","tags":["node-architecture","network-subsystem","engine","router","configuration"]},{"location":"arch/node/engines/router_config.html#the-router-local-configuration","title":"The Router Local Configuration","text":"","tags":["node-architecture","network-subsystem","engine","router","configuration"]},{"location":"arch/node/engines/router_config.html#routerlocalcfg","title":"<code>RouterLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type RouterLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","configuration"]},{"location":"arch/node/engines/router_config.html#the-router-configuration","title":"The Router Configuration","text":"","tags":["node-architecture","network-subsystem","engine","router","configuration"]},{"location":"arch/node/engines/router_config.html#routercfg","title":"<code>RouterCfg</code>","text":"<pre><code><pre>RouterCfg : Type := EngineCfg RouterLocalCfg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","configuration"]},{"location":"arch/node/engines/router_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exRouterCfg : RouterCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"router-0xab12cd34\";    cfg := RouterLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","configuration"]},{"location":"arch/node/engines/router_environment.html","title":"Router Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.router_environment;import arch.node.engines.router_messages open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","router","environment"]},{"location":"arch/node/engines/router_environment.html#router-environment","title":"Router Environment","text":"","tags":["node-architecture","network-subsystem","engine","router","environment"]},{"location":"arch/node/engines/router_environment.html#overview","title":"Overview","text":"<p>The Engine environment of the engine.</p>","tags":["node-architecture","network-subsystem","engine","router","environment"]},{"location":"arch/node/engines/router_environment.html#mailbox-state","title":"Mailbox state","text":"<pre><code><pre>RouterMailboxState : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","environment"]},{"location":"arch/node/engines/router_environment.html#local-state","title":"Local state","text":"<pre><code><pre>type RouterLocalState := mk;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","environment"]},{"location":"arch/node/engines/router_environment.html#timer-handles","title":"Timer handles","text":"<pre><code><pre>RouterTimerHandle : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","environment"]},{"location":"arch/node/engines/router_environment.html#timestamped-trigger","title":"Timestamped Trigger","text":"<pre><code><pre>RouterTimestampedTrigger : Type :=  TimestampedTrigger RouterTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","environment"]},{"location":"arch/node/engines/router_environment.html#the-router-environment","title":"The Router Environment","text":"","tags":["node-architecture","network-subsystem","engine","router","environment"]},{"location":"arch/node/engines/router_environment.html#routerenv","title":"<code>RouterEnv</code>","text":"<pre><code><pre>RouterEnv : Type :=  EngineEnv RouterLocalState RouterMailboxState RouterTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","environment"]},{"location":"arch/node/engines/router_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exRouterEnv : RouterEnv :=  EngineEnv.mk@{    localState := RouterLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","environment"]},{"location":"arch/node/engines/router_messages.html","title":"Router Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.router_messages;import arch.node.engines.net_registry_messages open;import arch.node.types.transport open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/router_messages.html#router-messages","title":"Router Messages","text":"","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/router_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type RouterMsg M :=  | NodeAdvert NodeAdvert  | Send (NodeOutMsg M)  | Recv NodeMsg  | ConnectRequest ConnectRequest  | ConnectReply ConnectReply  | SetPermanence ConnectionPermanence;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/router_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/router_messages.html#routermsgsend","title":"<code>RouterMsgSend</code>","text":"<p>Send an <code>EngineMsg</code> to the remote node with the given transport preferences and expiry time for send retries.</p> <p>Expected sender: any local engine.</p>","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/router_messages.html#nodeoutmsg","title":"<code>NodeOutMsg</code>","text":"<p>Outgoing message to a remote node.</p> <p>Expected sender: any local engine.</p> <pre><code><pre>type NodeOutMsg M :=  mkNodeOutMsg@{    prefs : TransportPrefs;    expiry : Time;    msg : EngineMsg M;  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/router_messages.html#routermsgrecv","title":"<code>RouterMsgRecv</code>","text":"<p>Receive a message from the remote node.</p> <p>Expected sender: local Transport Connection engine.</p>","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/router_messages.html#nodemsg","title":"<code>NodeMsg</code>","text":"<p>A message sent between nodes.</p> <p>Sender: local Transport Connection engine.</p> <pre><code><pre>type NodeMsg :=  mkNodeMsg@{    seq : Nat;    msg : EncryptedMsg;  };</pre></code></pre> Arguments <code>seq</code> Message sequence number of the sender. <code>msg</code> Encrypted <code>SerializedMsg</code> message that contains an <code>EngineMsg</code>.","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/router_messages.html#connectrequest","title":"<code>ConnectRequest</code>","text":"<p>Request a connection to a remote node.</p> <p>The responder may accept or deny the request. As part of the connection establishment, first a protocol version negotiation takes place. the highest common supported protocol version is chosen, or else the connection fails.</p> <p>Nodes let each other know about their own latest <code>NodeAdvert</code> version, and the version they know of from the other party, and if necessary, send each other an updated <code>NodeAdvert</code> after the connection is established.</p> <p>Expected sender: remote Router engine.</p> <pre><code><pre>type ConnectRequest :=  mkConnectRequest@{    proto_ver_min : Nat;    proto_ver_max : Nat;    src_node_id : NodeID;    dst_node_id : NodeID;    src_node_advert_ver : Nat;    dst_node_advert_ver : Nat;  };</pre></code></pre> Arguments <code>proto_ver_min</code> Min. supported protocol version range. <code>proto_ver_max</code> Max. supported protocol version range. <code>src_node_id</code> Source node ID. <code>dst_node_id</code> Destination node ID. <code>src_node_advert_ver</code> Latest <code>NodeAdvert</code> version of the source node. <code>dst_node_advert_ver</code> Latest known <code>NodeAdvert</code> version of the destination node.","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/router_messages.html#connectreply","title":"<code>ConnectReply</code>","text":"<p>Reply to a <code>ConnectRequest</code>.</p>","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/router_messages.html#connectreplyok","title":"<code>ConnectReplyOk</code>","text":"<p>Accept a connection from a node.</p> <pre><code><pre>type ConnectReplyOk :=  mkConnectReplyOk@{    proto_ver : Nat;    node_advert_ver : Pair Nat Nat;  };</pre></code></pre> Arguments <code>proto_ver</code> Protocol version to use. <code>node_advert_ver</code> Latest local <code>NodeAdvert</code> version.","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/router_messages.html#connectreplyerror","title":"<code>ConnectReplyError</code>","text":"<p>Refuse a connection from a node.</p> <pre><code><pre>type ConnectReplyError :=  | ConnectReplyErrorOverCapacity  | ConnectReplyErrorIncompatible  | ConnectReplyErrorDenied;</pre></code></pre> ConnectReplyError constructors <code>NodeConnectReplyErrorOverCapacity</code> Node over capacity. Temporary failure. <code>NodeConnectReplyErrorIncompatible</code> Incompatible protocol versions. <code>NodeConnectReplyErrorDenied</code> Connection denied by local policy.","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/router_messages.html#connectreply_1","title":"<code>ConnectReply</code>","text":"<pre><code><pre>ConnectReply : Type := Result ConnectReplyOk ConnectReplyError;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/router_messages.html#setpermanence","title":"<code>SetPermanence</code>","text":"<p>Set connection permanence of the destination node to either ephemeral or permanent.</p> <p>Permanent connections are automatically reconnected on node start and when the connection is lost.</p> <pre><code><pre>type ConnectionPermanence :=  | RouterMsgConnectionEphemeral  | RouterMsgConnectionPermanent;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/router_messages.html#routermsg","title":"<code>RouterMsg</code>","text":"<p>All Router engine messages.</p> <pre><code><pre>type RouterMsg M :=  | NodeAdvert NodeAdvert  | Send (NodeOutMsg M)  | Recv NodeMsg  | ConnectRequest ConnectRequest  | ConnectReply ConnectReply  | SetPermanence ConnectionPermanence;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/router_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Router Configuration</li> <li>Router Environment</li> <li>Router Behaviour</li> </ul>","tags":["node-architecture","network-subsystem","engine","router","message-types"]},{"location":"arch/node/engines/shard.html","title":"Shard Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.shard;import prelude open;import arch.node.types.engine open;import arch.node.engines.shard_config open public;import arch.node.engines.shard_messages open public;import arch.node.engines.shard_environment open public;import arch.node.engines.shard_behaviour open public;import arch.node.types.anoma as Anoma open;open shard_config_example;open shard_environment_example;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard.html#shard","title":"Shard","text":"<p>The Shard Engine functions as a specialized multi-version concurrent database that manages state access for Anoma's distributed execution system. Think of each Shard as a guardian of a specific subset of the system's key-value pairs, maintaining not just the current values, but a complete timeline of how those values change through different transactions. This timeline-based approach allows multiple transactions to read and write state concurrently while maintaining consistency, similar to how Git allows multiple developers to work with different versions of code.</p> <p>At the heart of the Shard Engine is a sophisticated locking system that coordinates state access between transactions. Rather than using simple read/write locks, it employs a more nuanced approach using a DAG (Directed Acyclic Graph) structure. This structure tracks both the values stored at each key and, crucially, the relationships between different transactions' access requests. The Shard receives lock acquisition requests (<code>ShardMsgKVSAcquireLock</code>) from Mempool Workers, which specify exactly how a transaction intends to interact with state through several categories: eager reads (keys that will definitely be read), lazy reads (keys that might be read), definite writes (keys that will be written), and potential writes (keys that might be written).</p> <p>When a transaction needs to read a value, it can happen in two ways. With eager reads, the Shard automatically sends the value (<code>ShardMsgKVSRead</code>) as soon as it's known to be the correct version for that transaction's timestamp. With lazy reads, the transaction must explicitly request the value (<code>ShardMsgKVSReadRequest</code>). This dual approach allows for optimization - transactions can get values they definitely need right away while avoiding unnecessary data transfer for values they might not use.</p> <p>The Shard maintains ordering through two important timestamps: <code>heardAllWrites</code> and <code>heardAllReads</code>. These act like watermarks in the system - the Shard knows it won't receive any new write operations before <code>heardAllWrites</code> or any new read operations before <code>heardAllReads</code>. These watermarks, updated through <code>ShardMsgUpdateSeenAll</code> messages from Mempool Workers, allow the Shard to make important decisions about when it's safe to execute reads and when it can clean up old state versions that are no longer needed.</p> <p>The interface of the Shard Engine revolves around these key message types: <code>KVSAcquireLock</code> for securing access rights, <code>KVSReadRequest</code> for requesting values, <code>KVSWrite</code> for updating values, and <code>UpdateSeenAll</code> for maintaining order. Each write operation (<code>ShardMsgKVSWrite</code>) adds a new version to a key's timeline, while read operations need to carefully select the correct version based on transaction timestamps. When locks are successfully acquired, the Shard responds with <code>KVSLockAcquired</code> messages, allowing the Mempool Worker to track transaction progress.</p>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard.html#purpose","title":"Purpose","text":"<p>The Shards together store and update the  state of the replicated state machine and   together are a component of the Execution Engines. They provide Executors with input data and update the state  according to the results of Executors' computations.</p> <p>Different shards may be on different physical machines.   </p> <p>Each shard is responsible for a set of KVSKeys and these sets are disjoint for different shards. For each of the keys that a shard is responsible for, the shard maintains a  (partially-ordered) timeline of Timestamps of  transaction candidates that may read or write to keys. Shards also keep a history of data written by each  TransactionCandidate to each key. This is multi-version concurrent storage.</p>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard.html#state-of-the-shard","title":"State (of the shard)","text":"<p>For each Mempool Worker Engine, the Shard maintains:</p> <ul> <li>A Timestamp, such that all    write lock requests[^1] for    transaction candidates with earlier timestamps that this worker curates    have already been received.   Together, these timestamps represent <code>heardAllWrites</code>.</li> <li>Another Timestamp, before which    the Shard will receive no further read requests from this    Mempool Worker Engine.   For Mempool Worker Engine, this cannot be after the corresponding    write Timestamps.   We will also maintain these from each Read Backend worker.   Together, these represent <code>heardAllReads</code>.</li> </ul> <p>For each key (assigned to this Shard):</p> <ul> <li>A set of time\u200dstamps of known    transaction candidates that read and/or write that key, and for    each, some subset of:<ul> <li>A value written to that key at that time\u200dstamps    by that TransactionCandidate using a KVSWrite message</li> <li>A marker indicating that this TransactionCandidate may    (or will) write to this key, but this Shard has not yet received    a corresponding KVSWrite message.</li> <li>A marker indicating that this TransactionCandidate will read    this value, and an ExternalIdentity corresponding to the    relevant Executor.   This marker is only stored so long as the Shard doesn't know the    value.   When this value is determined, this Shard must remove this marker    and send a KVSRead message to the Executor.</li> <li>A marker indicating that this TransactionCandidate may read    this value, and an ExternalIdentity corresponding to the    relevant Executor.   If the Executor sends a KVSReadRequest for this key, the    Shard updates this marker to a \"will read\" marker.</li> </ul> </li> <li>If a Timestamp has no corresponding markers or    values written, we don't have to store it.</li> <li>If a value written is before <code>heardAllReads</code>, and there are no pending    reads or writes before it, then we can remove all earlier values    written.</li> </ul> <p>Additionally, the Shard maintains:</p> <ul> <li>A complete copy of the DAG structure produced by the    Mempool Engines.   This includes a set of all NarwhalBlockHeaders.   For Timestamps before <code>SeenAllRead</code>, if there are    no keys with a pending read or write before that    Timestamp, we can delete old DAG structure.</li> <li>A complete copy of the sequence of Anchors chosen    by Consensus Engine.   This is a sequence of consensus decisions.   For Timestamps before <code>heardAllReads</code>, if there are    no keys with a pending read or write before that    Timestamp, we can delete old anchors.</li> </ul>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard.html#shard-optimizations","title":"Shard Optimizations","text":"<p>We want to execute each TransactionCandidate (evaluate the executor function in order to compute the data written) using the idea of serializability: each TransactionCandidate's reads and writes should be as if they were executed in the total order determined by the mempool (and consensus, from V2 onward). In fact, the simplest correct implementation amounts to executing all transaction candidates sequentially, repeatedly applying the executor function in a loop. However, we want to compute concurrently as possible, for minimum latency. We do this using a set of optimizations.</p>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard.html#optimization-per-key-ordering","title":"Optimization: Per-Key Ordering","text":"<p>Mempool  and  consensus provides ordering  information for  the time\u200dstamps. Thus, relative to each key, transaction candidates can be totally ordered by the  Happens Before  relationship. With a total ordering of transaction candidates, Shards can send  read information (KVSReads) to Executors as soon as the  previous TransactionCandidate is complete. However, transaction candidates that access on disjoint sets of  keys can be run in parallel. In the diagram above, for example, transaction candidates <code>c</code> and  <code>d</code> can run concurrently, as can transaction candidates <code>e</code> and  <code>f</code>, and transaction candidates <code>h</code> and <code>j</code>.</p>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard.html#optimization-order-with-respect-to-writes","title":"Optimization: Order With Respect To Writes","text":"<p>In fact, Shards can send read information to an Executor as soon  as the previous write's TransactionCandidate has completed  (sent a KVSWrite). All Shards really need to keep track of is a total order of writes,  and how each read is ordered with respect to writes (which write it  precedes and which write preceded it). As soon as the preceding write is complete (the Shard has received a  KVSWrite), the reads that depend on it can run concurrently. There are no \"read/read\" conflicts. In the diagram above, for example, transaction candidates <code>a</code> and <code>b</code> can run  concurrently.</p>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard.html#optimization-only-wait-to-read","title":"Optimization: Only Wait to Read","text":"<p>Because we store each version written  (multi-version concurrent storage),  we do not have to execute writes in order. A Shard does not have to wait to write a later data version to a key  just because previous reads have not finished executing yet. In the diagram above, for example, only green happens-before arrows  require waiting. transaction candidates <code>a</code>, <code>b</code>, <code>c</code>, and <code>j</code> can all be executed  concurrently, as can transaction candidates <code>d</code>, <code>e</code>, and <code>i</code>.</p>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard.html#optimization-execute-with-partial-order","title":"Optimization: Execute With Partial Order","text":"<p>Some mempools, including Narwhal, can provide partial order information on transactions even before consensus has determined a total order. This allows the Ordering Machine to execute some transactions before a total ordering is known. In general, for a given key, a shard can send read information to an executor when it knows precisely which write happens most recently before the read, and that write has executed.</p>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard.html#heardallwrites","title":"<code>heardAllWrites</code>","text":"<p>In order to know which write happens most recently before a given  read, the Shard must know that no further writes will be added to  the timeline before the read. Mempool and consensus should  communicate a lower bound on timestamps to the Shards, called  <code>heardAllWrites</code>. The Shard is guaranteed to never receive another KVSAcquireLock  with a write operation and   Timestamp before  <code>heardAllWrites</code>. In general, a Shard cannot send a KVSRead for  a Timestamp unless   the Timestamp is before <code>heardAllWrites</code>. <code>heardAllWrites</code> consists of a TxFingerprint from each  worker engine such that the worker engine is certain  (based on KVSLockAcquireds) that the Shard has already seen all  the KVSAcquireLocks it will ever send at or before that  TxFingerprint.</p> <p>This can be on a per-key basis or simply a global lower bound. Occasionally, <code>heardAllWrites</code> should be updated with later timestamps. Each round of consensus should produce a lower bound for <code>heardAllWrites</code>, but the mempool may already have sent better bounds. Each Shard must keep track of <code>heardAllWrites</code> on each key's multi-version timeline.</p> <p>Transactions (like transaction <code>j</code> in the diagram below) containing only write operations can execute with a timestamp after <code>heardAllWrites</code>, but this simply means calculating the data they will write. Since that does not depend on state, this can of course be done at any time.</p>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard.html#heardallreads","title":"<code>heardAllReads</code>","text":"<p>We want to allow Typhon to eventually garbage-collect old state. mempool and consensus should communicate a lower bound timestamp to the execution engine, called <code>heardAllReads</code>, before which there will be no more read transactions send to the execution engine. Occasionally, <code>heardAllReads</code> should be updated with later timestamps. Each Shard must keep track of <code>heardAllReads</code> on each key's multi-version timeline, so it can garbage-collect old values.</p> <p></p> <p>In the example above, our happens-before arrows have been replaced with may-happen-before arrows, representing partial ordering information from the mempool. Note that not all transactions can be executed with this partial order information.</p>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard.html#conflicts","title":"Conflicts","text":"<p>There are three types of conflicts that can prevent a transaction from being executable without more ordering information.</p> <ul> <li>Write/Write Conflicts   occur when a shard cannot identify the most recent write before a given read.   In the diagram above,   transaction <code>e</code> cannot execute because it is not clear whether   transaction <code>b</code> or transaction <code>c</code> wrote most recently to the yellow key.</li> </ul> <ul> <li>Read/Write Conflicts   occur when shard cannot identify whether a read operation occurs before or   after a write,   so it is not clear if it should read the value from that write or   from a previous write.   In the diagram above,   transaction <code>g</code> cannot execute because it is not clear whether   it would read the data written to the blue key by transaction <code>d</code> or   transaction <code>i</code>.</li> </ul> <ul> <li>Transitive Conflicts   occur when a shard cannot get the data for a read because   the relevant write is conflicted.   In the diagram above,   transaction <code>h</code> cannot execute because   it cannot read the data written to the yellow key by transaction <code>g</code>, since   transaction <code>g</code> is conflicted.</li> </ul> <p>As the mempool and consensus provide the execution engine with more and more ordering information, and the partial order of timestamps is refined, all conflicts eventually resolve. In the diagram above, suppose consensus orders transaction <code>g</code> before transaction <code>i</code>. The Read/Write conflict is resolved: transaction <code>g</code> reads the data transaction <code>d</code> writes to the blue key. Then the transitive conflict is also resolved: transaction <code>h</code> will be able to execute. --&gt;</p>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard.html#optimization-client-reads-as-read-only-transactions","title":"Optimization: Client Reads as Read-Only Transactions","text":"<p>With the above optimizations, transactions containing only read operations do not affect other transactions (or scheduling) at all. Therefore, they can bypass mempool and consensus altogether. Clients can simply send read-only transactions directly to the execution engine (with a label and a timestamp), and if the timestamp is after <code>heardAllReads</code>, the execution engine can simply place the transaction in the timeline of the relevant shards and execute it when possible. In the diagram above, transaction <code>f</code> is read-only.</p> <p>If client reads produce signed responses, then signed responses from a weak quorum of validators would form a light client proof.</p>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard.html#engine-components","title":"Engine components","text":"<ul> <li>Shard Messages</li> <li>Shard Configuration</li> <li>Shard Environment</li> <li>Shard Behaviour</li> </ul>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard.html#type","title":"Type","text":"<pre><code><pre>ShardEngine : Type :=  Engine    ShardLocalCfg    ShardLocalState    ShardMailboxState    ShardTimerHandle    ShardActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard.html#example-of-a-shard-engine","title":"Example of a shard engine","text":"<pre><code><pre>exampleShardEngine : ShardEngine :=  Engine.mk@{    cfg := shardCfg;    env := shardEnv;    behaviour := shardBehaviour;  };</pre></code></pre> <p>where <code>shardCfg</code> is defined as follows:</p> <pre><code><pre>shardCfg : ShardCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"shard\";    cfg := ShardLocalCfg.mk;  };</pre></code></pre> <p>where <code>shardEnv</code> is defined as follows:</p> <pre><code><pre>shardEnv : ShardEnv :=  EngineEnv.mk@{    localState :=      ShardLocalState.mk@{        dagStructure :=          DAGStructure.mkDAGStructure@{            keyAccesses := Map.empty;            heardAllReads := 0;            heardAllWrites := 0;          };        anchors := [];      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>shardBehaviour</code> is defined as follows:</p> <pre><code><pre>shardBehaviour : ShardBehaviour :=  EngineBehaviour.mk@{    guards :=      GuardEval.First        [          acquireLockGuard;          processWriteGuard;          processReadRequestGuard;          updateSeenAllGuard;        ];  };</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","engine-definition"]},{"location":"arch/node/engines/shard_behaviour.html","title":"Shard Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.shard_behaviour;import arch.node.engines.shard_messages open;import arch.node.engines.shard_config open;import arch.node.engines.shard_environment open;import Stdlib.Data.Nat open;import Stdlib.Data.List as List;import Stdlib.Data.Set as Set;import prelude open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#shard-behaviour","title":"Shard Behaviour","text":"","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#shard-action-flowchart","title":"Shard Action Flowchart","text":"","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#acquirelock-flowchart","title":"<code>acquireLock</code> Flowchart","text":"<pre><code>flowchart TD\n    Start([Worker Request]) --&gt; MsgReq[ShardMsgKVSAcquireLock&lt;br/&gt;keys, worker, executor, timestamp]\n\n    subgraph Guard[\"acquireLockGuard\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br/&gt;KVSAcquireLock?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"acquireLockAction\"]\n        direction TB\n        AddReads[Add read accesses to DAG&lt;br/&gt;eager and lazy]\n        AddReads --&gt; AddWrites[Add write accesses to DAG&lt;br/&gt;definite and potential]\n        AddWrites --&gt; CheckEager{Any eager reads&lt;br/&gt;ready to execute?}\n        CheckEager --&gt;|Yes| PrepReadMsgs[Create read messages&lt;br/&gt;for eligible keys]\n        CheckEager --&gt;|No| SkipReads[Skip read messages]\n        PrepReadMsgs &amp; SkipReads --&gt; PrepareLockAck[Create lock acquired&lt;br/&gt;response]\n    end\n\n    PrepareLockAck --&gt; Msgs[Send Messages]\n\n    subgraph Msgs[\"Messages Sent\"]\n        LockAck[KVSLockAcquired to Worker]\n        ReadMsgs[KVSRead messages to Executor&lt;br/&gt;for eligible eager reads]\n    end</code></pre> <code>acquireLock</code> flowchart","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#explanation","title":"Explanation","text":"<ol> <li> <p>Initial Request</p> <ul> <li>A Mempool Worker sends a <code>ShardMsgKVSAcquireLock</code> containing:<ul> <li><code>lazy_read_keys</code>: Keys that might be read during execution.</li> <li><code>eager_read_keys</code>: Keys that will definitely be read.</li> <li><code>will_write_keys</code>: Keys that will definitely be written.</li> <li><code>may_write_keys</code>: Keys that might be written.</li> <li><code>worker</code>: ID of the requesting worker engine.</li> <li><code>executor</code>: ID of the executor that will process this transaction.</li> <li><code>timestamp</code>: Logical timestamp for transaction ordering.</li> </ul> </li> </ul> </li> <li> <p>Guard Phase (<code>acquireLockGuard</code>)</p> <ul> <li>Verifies message type is <code>ShardMsgKVSAcquireLock</code>.</li> <li>If validation fails, request is rejected immediately.</li> <li>On success, passes control to <code>acquireLockActionLabel</code>.</li> </ul> </li> <li> <p>Action Phase (<code>acquireLockAction</code>)</p> <ul> <li>Processes valid lock requests through these steps:<ul> <li>Adds read accesses to DAG for both eager and lazy reads.</li> <li>Adds write accesses to DAG for both definite and potential writes.</li> <li>Checks for any eager reads that are immediately eligible for execution.</li> <li>Creates read messages for eligible eager reads.</li> <li>Prepares lock acquisition acknowledgment.</li> <li>Records all lock information in DAG structure.</li> </ul> </li> </ul> </li> <li> <p>Reply Generation</p> <ul> <li>Always Sends:<ul> <li><code>KVSLockAcquired</code> message back to worker containing:<ul> <li><code>timestamp</code>: Same timestamp as request.</li> </ul> </li> </ul> </li> <li>Conditionally Sends:<ul> <li>If eligible eager reads found:<ul> <li><code>KVSRead</code> messages to executor containing:<ul> <li><code>timestamp</code>: Transaction timestamp.</li> <li><code>key</code>: Key that was read.</li> <li><code>data</code>: Value at that timestamp.</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Reply Delivery</p> <ul> <li>Lock acknowledgment sent to original worker.</li> <li>Any read messages sent to specified executor.</li> <li>Uses mailbox 0 (the standard mailbox for responses).</li> </ul> </li> </ol>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#processwrite-flowchart","title":"<code>processWrite</code> Flowchart","text":"<pre><code>flowchart TD\n    Start([Executor Request]) --&gt; MsgReq[ShardMsgKVSWrite&lt;br/&gt;key, timestamp, data]\n\n    subgraph Guard[\"processWriteGuard\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br/&gt;KVSWrite?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"processWriteAction\"]\n        direction TB\n        CheckLock{Write lock&lt;br/&gt;exists for timestamp?}\n        CheckLock --&gt;|No| FailNoLock[Fail - No Lock]\n        CheckLock --&gt;|Yes| ValidateWrite{Valid write for&lt;br/&gt;lock type?}\n        ValidateWrite --&gt;|No| FailInvalid[Fail - Invalid Write]\n        ValidateWrite --&gt;|Yes| UpdateDAG[Update DAG with&lt;br/&gt;write data]\n        UpdateDAG --&gt; CheckReads{Eager reads&lt;br/&gt;now eligible?}\n        CheckReads --&gt;|Yes| PrepReadMsgs[Create read messages&lt;br/&gt;for eligible keys]\n        CheckReads --&gt;|No| NoReads[No messages needed]\n    end\n\n    PrepReadMsgs --&gt; SendReads[Send KVSRead messages&lt;br/&gt;to eligible executors]\n    NoReads --&gt; Complete([Complete])\n    FailNoLock &amp; FailInvalid --&gt; Fail([Fail - No Reply])</code></pre> <code>processWrite</code> flowchart","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#explanation_1","title":"Explanation","text":"<ol> <li> <p>Initial Request</p> <ul> <li>A client sends a <code>ShardMsgKVSWrite</code> containing:<ul> <li><code>key</code>: The state key to write to.</li> <li><code>timestamp</code>: The transaction's logical timestamp.</li> <li><code>datum</code>: The value to write (or None for null writes).</li> </ul> </li> <li>This request comes from an Executor Engine that previously acquired write locks.</li> </ul> </li> <li> <p>Guard Phase (<code>processWriteGuard</code>)</p> <ul> <li>Verifies message type is <code>ShardMsgKVSWrite</code>.</li> <li>If validation fails, request is rejected immediately.</li> <li>On success, passes control to <code>processWriteActionLabel</code>.</li> </ul> </li> <li> <p>Action Phase (<code>processWriteAction</code>)</p> <ul> <li>Processes valid write requests through these steps:<ul> <li>Checks if write lock exists for the key at given timestamp.</li> <li>Validates write against lock type (null writes only valid for <code>mayWrite</code> locks).</li> <li>Updates DAG structure with new write data.</li> <li>Checks for eligible eager reads that can now proceed.</li> <li>Constructs appropriate read messages for any newly eligible reads.</li> </ul> </li> </ul> </li> <li> <p>Error Cases</p> <ul> <li>No Lock Case: Returns none if:<ul> <li>No write access exists for the timestamp.</li> <li>Write access exists but no <code>writeStatus</code> (no write lock).</li> </ul> </li> <li>Invalid Write Case: Returns none if:<ul> <li>Attempting null write on definite write lock.</li> <li>Lock exists but write is invalid for lock type.</li> </ul> </li> </ul> </li> <li> <p>Reply Delivery</p> <ul> <li>On success, sends <code>KVSRead</code> messages to Executors for any eligible eager reads.</li> <li>The original write request does not receive a direct response.</li> <li>All messages use mailbox 0 (the standard mailbox for responses).</li> </ul> </li> </ol>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#processreadrequest-flowchart","title":"<code>processReadRequest</code> Flowchart","text":"<pre><code>flowchart TD\n    Start([Executor Request]) --&gt; MsgReq[ShardMsgKVSReadRequest&lt;br/&gt;key, timestamp, actual]\n\n    subgraph Guard[\"processReadRequestGuard\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br/&gt;KVSReadRequest?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"processReadRequestAction\"]\n        direction TB\n        CheckBarrier{timestamp &gt;=&lt;br/&gt;heardAllReads?}\n        CheckBarrier --&gt;|No| FailTooEarly[Fail - Too Early]\n        CheckBarrier --&gt;|Yes| CheckLock{Read lock&lt;br/&gt;exists?}\n        CheckLock --&gt;|No| FailNoLock[Fail - No Lock]\n        CheckLock --&gt;|Yes| MarkRead[Mark read as completed&lt;br/&gt;in DAG]\n        MarkRead --&gt; CheckActual{actual flag&lt;br/&gt;true?}\n        CheckActual --&gt;|No| NoReply[No response needed]\n        CheckActual --&gt;|Yes| FindValue[Find most recent&lt;br/&gt;write before timestamp]\n        FindValue --&gt; HasValue{Value found?}\n        HasValue --&gt;|No| FailNoValue[Fail - No Value]\n        HasValue --&gt;|Yes| PrepReply[Create read response&lt;br/&gt;with found value]\n    end\n\n    PrepReply --&gt; SendRead[Send KVSRead message&lt;br/&gt;to executor]\n    NoReply --&gt; Complete([Complete])\n    FailTooEarly &amp; FailNoLock &amp; FailNoValue --&gt; Fail([Fail - No Reply])\n\n    style Guard fill:#f0f7ff,stroke:#333,stroke-width:2px\n    style Action fill:#fff7f0,stroke:#333,stroke-width:2px</code></pre> <code>processReadRequest</code> flowchart","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#explanation_2","title":"Explanation","text":"<ol> <li> <p>Initial Request</p> <ul> <li>An executor sends a <code>ShardMsgKVSReadRequest</code> containing:<ul> <li><code>key</code>: The state key to read.</li> <li><code>timestamp</code>: The logical timestamp of the requesting transaction.</li> <li><code>actual</code>: Boolean flag indicating if this is a real read or just cleanup.</li> </ul> </li> <li>The key must be one that this shard is responsible for managing.</li> </ul> </li> <li> <p>Guard Phase (<code>processReadRequestGuard</code>)</p> <ul> <li>Verifies message type is <code>ShardMsgKVSReadRequest</code>.</li> <li>If validation fails, request is rejected immediately.</li> <li>On success, passes control to <code>processReadRequestActionLabel</code>.</li> </ul> </li> <li> <p>Action Phase (<code>processReadRequestAction</code>)</p> <ul> <li>Processes valid read requests through these steps:<ul> <li>Checks if timestamp is at or after the <code>heardAllReads</code> barrier.</li> <li>Verifies a read lock exists for this key at this timestamp.</li> <li>Marks the read as completed in the DAG structure.</li> <li>If <code>actual</code> flag is true, finds the most recent write value.</li> <li>Constructs appropriate response based on result.</li> </ul> </li> </ul> </li> <li> <p>Reply Generation</p> <ul> <li>Successful Case (actual = true)<ul> <li>Creates <code>ShardMsgKVSRead</code> with:<ul> <li><code>timestamp</code>: Original request timestamp.</li> <li><code>key</code>: Original request key.</li> <li><code>data</code>: Found historical value.</li> </ul> </li> </ul> </li> <li>Successful Case (actual = false)<ul> <li>No response message generated.</li> <li>Only updates internal state.</li> </ul> </li> <li>Error Cases<ul> <li>No response sent if:<ul> <li>Timestamp is before <code>heardAllReads</code>.</li> <li>No valid read lock exists.</li> <li>No historical value found.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Reply Delivery</p> <ul> <li>Success response sent directly to requesting executor.</li> <li>Uses mailbox 0 (the standard mailbox for responses).</li> </ul> </li> </ol>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#updateseenall-flowchart","title":"<code>updateSeenAll</code> Flowchart","text":"<pre><code>flowchart TD\n    Start([Worker Request]) --&gt; MsgReq[ShardMsgUpdateSeenAll&lt;br/&gt;timestamp, write]\n\n    subgraph Guard[\"updateSeenAllGuard\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br/&gt;UpdateSeenAll?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"updateSeenAllAction\"]\n        direction TB\n        CheckType{What kind&lt;br/&gt;of barrier?}\n        CheckType --&gt;|write| UpdateWrites[Update heardAllWrites&lt;br/&gt;barrier]\n        CheckType --&gt;|read| UpdateReads[Update heardAllReads&lt;br/&gt;barrier]\n        UpdateWrites --&gt; CheckEager{Eager reads&lt;br/&gt;now eligible?}\n        UpdateReads --&gt; NoReads[No reads to process]\n        CheckEager --&gt;|Yes| PrepReadMsgs[Create read messages&lt;br/&gt;for eligible keys]\n        CheckEager --&gt;|No| NoNewReads[No new reads eligible]\n    end\n\n    PrepReadMsgs --&gt; SendReads[Send KVSRead messages&lt;br/&gt;to eligible executors]\n    NoReads &amp; NoNewReads --&gt; Complete([Complete])</code></pre> <code>updateSeenAll</code> flowchart","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#explanation_3","title":"Explanation","text":"<ol> <li> <p>Initial Request</p> <ul> <li>A worker sends a <code>ShardMsgUpdateSeenAll</code> containing:<ul> <li><code>timestamp</code>: The new barrier position in the transaction timeline.</li> <li><code>write</code>: Boolean flag indicating if this updates the write barrier or read barrier.</li> </ul> </li> <li>This represents a guarantee from the worker about transaction ordering.</li> </ul> </li> <li> <p>Guard Phase (<code>updateSeenAllGuard</code>)</p> <ul> <li>Verifies message type is <code>ShardMsgUpdateSeenAll</code>.</li> <li>If validation fails, request is rejected immediately.</li> <li>On success, passes control to <code>updateSeenAllActionLabel</code>.</li> </ul> </li> <li> <p>Action Phase (<code>updateSeenAllAction</code>)</p> <ul> <li>Processes valid update requests through these steps:<ul> <li>Determines barrier type (write vs read) from message.</li> <li>For write barriers:<ul> <li>Updates <code>heardAllWrites</code> to new timestamp.</li> <li>Checks for eager reads that can now execute.</li> <li>Prepares read messages for eligible reads.</li> </ul> </li> <li>For read barriers:<ul> <li>Updates <code>heardAllReads</code> to new timestamp.</li> <li>No immediate read processing needed.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Reply Generation</p> <ul> <li>For write barrier updates:<ul> <li>If eligible eager reads found:<ul> <li>Creates <code>KVSRead</code> messages for each eligible read.</li> <li>Includes value and timestamp for each read.</li> </ul> </li> <li>If no eligible reads, completes with no messages.</li> </ul> </li> <li>For read barrier updates:<ul> <li>Always completes with no messages.</li> <li>Read barrier updates are used for garbage collection, not triggering reads.</li> </ul> </li> </ul> </li> <li> <p>Message Delivery</p> <ul> <li>Any generated read messages are sent to their respective executors.</li> <li>No acknowledgment is sent back to the worker.</li> </ul> </li> </ol>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#shardactionargument","title":"<code>ShardActionArgument</code>","text":"<pre><code><pre>type ShardActionArgument := | ShardActionArgumentReplyTo EngineID;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#shardactionarguments","title":"<code>ShardActionArguments</code>","text":"<pre><code><pre>ShardActionArguments : Type := List ShardActionArgument;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#helper-functions","title":"Helper Functions","text":"<pre><code><pre>findMostRecentWrite  (dag : DAGStructure)  (key : KVSKey)  (timestamp : TxFingerprint)  : Option KVSDatum :=  case Map.lookup key (DAGStructure.keyAccesses dag) of    | none := none    | some timestampMap :=      let        validEntries :=          List.filter            \\{entry :=              fst entry &lt; timestamp                &amp;&amp; case KeyAccess.writeStatus (snd entry) of {                     | some writeStatus :=                       not                         (WriteStatus.mayWrite writeStatus                           &amp;&amp; isNone (WriteStatus.data writeStatus))                     | none := false                   }}            (Map.toList timestampMap);      in case maximumBy \\{entry := fst entry} validEntries of           | some (mkPair _ access) :=             case KeyAccess.writeStatus access of {               | some writeStatus := WriteStatus.data writeStatus               | none := none             }           | none := none;</pre></code></pre> <p>-- add read without prior lock</p> <pre><code><pre>addReadAccess  (dag : DAGStructure)  (key : KVSKey)  (timestamp : TxFingerprint)  (readStatus : ReadStatus)  : DAGStructure :=  let    keyMap :=      case Map.lookup key (DAGStructure.keyAccesses dag) of        | none := Map.empty        | some m := m;    existingAccess :=      case Map.lookup timestamp keyMap of        | none :=          KeyAccess.mkKeyAccess@{            readStatus := none;            writeStatus := none;          }        | some access := access;    newAccess := existingAccess@KeyAccess{readStatus := some readStatus};    newKeyMap := Map.insert timestamp newAccess keyMap;    newKeyAccesses := Map.insert key newKeyMap (DAGStructure.keyAccesses dag);  in dag@DAGStructure{keyAccesses := newKeyAccesses};</pre></code></pre> <p>-- add write without prior lock</p> <pre><code><pre>addWriteAccess  (dag : DAGStructure)  (key : KVSKey)  (timestamp : TxFingerprint)  (writeStatus : WriteStatus)  : DAGStructure :=  let    keyMap :=      case Map.lookup key (DAGStructure.keyAccesses dag) of        | none := Map.empty        | some m := m;    existingAccess :=      case Map.lookup timestamp keyMap of        | none :=          KeyAccess.mkKeyAccess@{            readStatus := none;            writeStatus := none;          }        | some access := access;    newAccess := existingAccess@KeyAccess{writeStatus := some writeStatus};    newKeyMap := Map.insert timestamp newAccess keyMap;    newKeyAccesses := Map.insert key newKeyMap (DAGStructure.keyAccesses dag);  in dag@DAGStructure{keyAccesses := newKeyAccesses};</pre></code></pre> <p>-- Replaces if read lock exists</p> <pre><code><pre>replaceReadAccess  (dag : DAGStructure)  (key : KVSKey)  (timestamp : TxFingerprint)  : Option DAGStructure :=  let    keyMap :=      case Map.lookup key (DAGStructure.keyAccesses dag) of        | none := Map.empty        | some m := m;    access :=      case Map.lookup timestamp keyMap of        | none := none        | some a := some a;  in case access of       | some a :=         case KeyAccess.readStatus a of {           | none := none           | some rs :=             let               updatedReadStatus := rs@ReadStatus{hasBeenRead := true};               updatedAccess :=                 a@KeyAccess{readStatus := some updatedReadStatus};               updatedKeyMap := Map.insert timestamp updatedAccess keyMap;               updatedKeyAccesses :=                 Map.insert key updatedKeyMap (DAGStructure.keyAccesses dag);             in some dag@DAGStructure{keyAccesses := updatedKeyAccesses}         }       | none := none;</pre></code></pre> <p>-- Replaces if write lock exists</p> <pre><code><pre>replaceWriteAccess  (dag : DAGStructure)  (key : KVSKey)  (timestamp : TxFingerprint)  (newData : Option KVSDatum)  : Option DAGStructure :=  let    keyMap :=      case Map.lookup key (DAGStructure.keyAccesses dag) of        | none := Map.empty        | some m := m;  in case Map.lookup timestamp keyMap of       | some a :=         case KeyAccess.writeStatus a of {           | none := none           | some ws :=             case isNone newData &amp;&amp; not (WriteStatus.mayWrite ws) of {               | true := none               | false :=                 let                   data :=                     case newData of                       | none := WriteStatus.data ws                       | some dat := some dat;                   updatedAccess :=                     a@KeyAccess{writeStatus := some                       ws@WriteStatus{data := data}};                   updatedKeyMap := Map.insert timestamp updatedAccess keyMap;                   updatedKeyAccesses :=                     Map.insert                       key                       updatedKeyMap                       (DAGStructure.keyAccesses dag);                 in some dag@DAGStructure{keyAccesses := updatedKeyAccesses}             }         }       | none := none;</pre></code></pre> <pre><code><pre>generateReadMsg  (sender : EngineID)  (key : KVSKey)  (timestamp : TxFingerprint)  (data : KVSDatum)  (executor : EngineID)  : EngineMsg Msg :=  EngineMsg.mk@{    sender := sender;    target := executor;    mailbox := some 0;    msg :=      Anoma.Msg.Shard        (ShardMsg.KVSRead          KVSReadMsg.mkKVSReadMsg@{            timestamp := timestamp;            key := key;            data := data;          });  };</pre></code></pre> <pre><code><pre>execEagerReadsAtTime  (sender : EngineID)  (dag : DAGStructure)  (key : KVSKey)  (timestamp : TxFingerprint)  (access : KeyAccess)  : Option (Pair DAGStructure (EngineMsg Anoma.Msg)) :=  case KeyAccess.readStatus access of    | some readStatus :=      case        ReadStatus.isEager readStatus &amp;&amp; not (ReadStatus.hasBeenRead readStatus)      of {        | true :=          case            timestamp &lt; DAGStructure.heardAllWrites dag              &amp;&amp; timestamp &gt;= DAGStructure.heardAllReads dag          of {            | true :=              case findMostRecentWrite dag key timestamp of {                | some data :=                  let                    newReadStatus := readStatus@ReadStatus{hasBeenRead := true};                    newDag := addReadAccess dag key timestamp newReadStatus;                    msg :=                      generateReadMsg                        sender                        key                        timestamp                        data                        (ReadStatus.executor readStatus);                  in some (mkPair newDag msg)                | none := none              }            | false := none          }        | false := none      }    | none := none;</pre></code></pre> <pre><code><pre>execEagerReadsAtKey  (sender : EngineID)  (dag : DAGStructure)  (key : KVSKey)  (timestampMap : Map TxFingerprint KeyAccess)  : Pair DAGStructure (List (EngineMsg Anoma.Msg)) :=  let    processTimestamp :=      \\{k v acc :=        case acc of          | mkPair currDag msgs :=            case execEagerReadsAtTime sender currDag key k v of              | some processed := mkPair (fst processed) (snd processed :: msgs)              | none := acc};  in Map.foldr processTimestamp (mkPair dag []) timestampMap;</pre></code></pre> <pre><code><pre>execEagerReads  (sender : EngineID)  (dag : DAGStructure)  : Pair DAGStructure (List (EngineMsg Anoma.Msg)) :=  let    processKey :=      \\{k v acc :=        case acc of          | mkPair currDag msgs :=            let              processed := execEagerReadsAtKey sender currDag k v;            in mkPair (fst processed) (msgs ++ snd processed)};  in Map.foldr processKey (mkPair dag []) (DAGStructure.keyAccesses dag);</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#shardaction","title":"<code>ShardAction</code>","text":"<p><pre><code><pre>ShardAction : Type :=  Action    ShardLocalCfg    ShardLocalState    ShardMailboxState    ShardTimerHandle    ShardActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#shardactioninput","title":"<code>ShardActionInput</code>","text":"<p><pre><code><pre>ShardActionInput : Type :=  ActionInput    ShardLocalCfg    ShardLocalState    ShardMailboxState    ShardTimerHandle    ShardActionArguments    Anoma.Msg;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#shardactioneffect","title":"<code>ShardActionEffect</code>","text":"<p><pre><code><pre>ShardActionEffect : Type :=  ActionEffect    ShardLocalState    ShardMailboxState    ShardTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#shardactionexec","title":"<code>ShardActionExec</code>","text":"<p><pre><code><pre>ShardActionExec : Type :=  ActionExec    ShardLocalCfg    ShardLocalState    ShardMailboxState    ShardTimerHandle    ShardActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#acquirelockaction","title":"<code>acquireLockAction</code>","text":"<p>Process lock acquisition request and send confirmation.</p> State update Update DAG with new read/write accesses. Messages to be sent KVSLockAcquired message to worker. <pre><code><pre>acquireLockAction (input : ShardActionInput) : Option ShardActionEffect :=  let    cfg := ActionInput.cfg input;    env := ActionInput.env input;    local := EngineEnv.localState env;    trigger := ActionInput.trigger input;  in case getEngineMsgFromTimestampedTrigger trigger of       | some EngineMsg.mk@{                msg := Anoma.Msg.Shard (ShardMsg.KVSAcquireLock lockMsg);              } :=         let           addEagerReadAccesses :=             \\{key dag :=               let                 readStatus :=                   ReadStatus.mkReadStatus@{                     hasBeenRead := false;                     isEager := true;                     executor := KVSAcquireLockMsg.executor lockMsg;                   };               in addReadAccess                 dag                 key                 (KVSAcquireLockMsg.timestamp lockMsg)                 readStatus};           addLazyReadAccesses :=             \\{key dag :=               let                 readStatus :=                   ReadStatus.mkReadStatus@{                     hasBeenRead := false;                     isEager := false;                     executor := KVSAcquireLockMsg.executor lockMsg;                   };               in addReadAccess                 dag                 key                 (KVSAcquireLockMsg.timestamp lockMsg)                 readStatus};           addWillWriteAccesses :=             \\{key dag :=               let                 writeStatus :=                   WriteStatus.mkWriteStatus@{                     data := none;                     mayWrite := false;                   };               in addWriteAccess                 dag                 key                 (KVSAcquireLockMsg.timestamp lockMsg)                 writeStatus};           addMayWriteAccesses :=             \\{key dag :=               let                 writeStatus :=                   WriteStatus.mkWriteStatus@{                     data := none;                     mayWrite := true;                   };               in addWriteAccess                 dag                 key                 (KVSAcquireLockMsg.timestamp lockMsg)                 writeStatus};           dagWithEagerReads :=             Set.foldr               addEagerReadAccesses               (ShardLocalState.dagStructure local)               (KVSAcquireLockMsg.eager_read_keys lockMsg);           dagWithAllReads :=             Set.foldr               addLazyReadAccesses               dagWithEagerReads               (KVSAcquireLockMsg.lazy_read_keys lockMsg);           dagWithWillWrites :=             Set.foldr               addWillWriteAccesses               dagWithAllReads               (KVSAcquireLockMsg.will_write_keys lockMsg);           dagWithAllWrites :=             Set.foldr               addMayWriteAccesses               dagWithWillWrites               (KVSAcquireLockMsg.may_write_keys lockMsg);           propagationResult :=             execEagerReads (getEngineIDFromEngineCfg cfg) dagWithAllWrites;           newLocal :=             local@ShardLocalState{dagStructure := fst propagationResult};           newEnv := env@EngineEnv{localState := newLocal};         in some           ActionEffect.mk@{             env := newEnv;             msgs :=               EngineMsg.mk@{                 sender := getEngineIDFromEngineCfg (ActionInput.cfg input);                 target := KVSAcquireLockMsg.worker lockMsg;                 mailbox := some 0;                 msg :=                   Anoma.Msg.Shard                     (ShardMsg.KVSLockAcquired                       KVSLockAcquiredMsg.mkKVSLockAcquiredMsg@{                         timestamp := KVSAcquireLockMsg.timestamp lockMsg;                       });               }                 :: snd propagationResult;             timers := [];             engines := [];           }       | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#processwriteaction","title":"<code>processWriteAction</code>","text":"<p>Process write request and potentially trigger eager reads.</p> State update Update DAG with write data and trigger eager reads. Messages to be sent KVSRead messages if eligible eager reads are found. <pre><code><pre>processWriteAction (input : ShardActionInput) : Option ShardActionEffect :=  let    cfg := ActionInput.cfg input;    env := ActionInput.env input;    local := EngineEnv.localState env;    trigger := ActionInput.trigger input;  in case getEngineMsgFromTimestampedTrigger trigger of       | some EngineMsg.mk@{                msg := Anoma.Msg.Shard (ShardMsg.KVSWrite writeMsg);              } :=         let           dag := ShardLocalState.dagStructure local;           key := KVSWriteMsg.key writeMsg;           timestamp := KVSWriteMsg.timestamp writeMsg;         in case              replaceWriteAccess dag key timestamp (KVSWriteMsg.datum writeMsg)            of {              | some updatedDag :=                let                  propagationResult :=                    execEagerReads (getEngineIDFromEngineCfg cfg) updatedDag;                  newLocal :=                    local@ShardLocalState{dagStructure := fst                      propagationResult};                  newEnv := env@EngineEnv{localState := newLocal};                  readMsgs := snd propagationResult;                in some                  ActionEffect.mk@{                    env := newEnv;                    msgs := readMsgs;                    timers := [];                    engines := [];                  }              | none := none            }       | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#processreadrequestaction","title":"<code>processReadRequestAction</code>","text":"<p>Process read request and potentially send read response.</p> State update Update DAG with read request status. Messages to be sent KVSRead message if read data is available. <pre><code><pre>processReadRequestAction  (input : ShardActionInput) : Option ShardActionEffect :=  let    cfg := ActionInput.cfg input;    env := ActionInput.env input;    local := EngineEnv.localState env;    trigger := ActionInput.trigger input;  in case getEngineMsgFromTimestampedTrigger trigger of       | some EngineMsg.mk@{                sender := sender;                msg := Anoma.Msg.Shard (ShardMsg.KVSReadRequest readReqMsg);              } :=         let           dag := ShardLocalState.dagStructure local;           key := KVSReadRequestMsg.key readReqMsg;           timestamp := KVSReadRequestMsg.timestamp readReqMsg;           actual := KVSReadRequestMsg.actual readReqMsg;         in case timestamp &gt;= DAGStructure.heardAllReads dag of {              | false := none              | true :=                case replaceReadAccess dag key timestamp of {                  | none := none                  | some updatedDag :=                    case actual of {                      | false :=                        let                          newLocal :=                            local@ShardLocalState{dagStructure := updatedDag};                          newEnv := env@EngineEnv{localState := newLocal};                        in some                          ActionEffect.mk@{                            env := newEnv;                            msgs := [];                            timers := [];                            engines := [];                          }                      | true :=                        case findMostRecentWrite updatedDag key timestamp of {                          | none := none                          | some data :=                            let                              readMsg :=                                EngineMsg.mk@{                                  sender := getEngineIDFromEngineCfg cfg;                                  target := sender;                                  mailbox := some 0;                                  msg :=                                    Anoma.Msg.Shard                                      (ShardMsg.KVSRead                                        KVSReadMsg.mkKVSReadMsg@{                                          timestamp := timestamp;                                          key := key;                                          data := data;                                        });                                };                              newLocal :=                                local@ShardLocalState{dagStructure := updatedDag};                              newEnv := env@EngineEnv{localState := newLocal};                            in some                              ActionEffect.mk@{                                env := newEnv;                                msgs := [readMsg];                                timers := [];                                engines := [];                              }                        }                    }                }            }       | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#updateseenallaction","title":"<code>updateSeenAllAction</code>","text":"<p>Process seen-all update and potentially trigger eager reads.</p> State update Update DAG barriers and trigger eager reads. Messages to be sent KVSRead messages if eligible eager reads are found. <pre><code><pre>updateSeenAllAction (input : ShardActionInput) : Option ShardActionEffect :=  let    cfg := ActionInput.cfg input;    env := ActionInput.env input;    local := EngineEnv.localState env;    trigger := ActionInput.trigger input;  in case getEngineMsgFromTimestampedTrigger trigger of       | some EngineMsg.mk@{                msg := Anoma.Msg.Shard (ShardMsg.UpdateSeenAll updateMsg);              } :=         let           oldDag := ShardLocalState.dagStructure local;           newDag :=             case UpdateSeenAllMsg.write updateMsg of               | true :=                 oldDag@DAGStructure{heardAllWrites := UpdateSeenAllMsg.timestamp                   updateMsg}               | false :=                 oldDag@DAGStructure{heardAllReads := UpdateSeenAllMsg.timestamp                   updateMsg};           propagationResult :=             case UpdateSeenAllMsg.write updateMsg of               | true := execEagerReads (getEngineIDFromEngineCfg cfg) newDag               | false := mkPair newDag [];           newLocal :=             local@ShardLocalState{dagStructure := fst propagationResult};           newEnv := env@EngineEnv{localState := newLocal};           readMsgs := snd propagationResult;         in some           ActionEffect.mk@{             env := newEnv;             msgs := readMsgs;             timers := [];             engines := [];           }       | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#acquirelockactionlabel","title":"<code>acquireLockActionLabel</code>","text":"<pre><code><pre>acquireLockActionLabel : ShardActionExec := ActionExec.Seq [acquireLockAction];</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#processwriteactionlabel","title":"<code>processWriteActionLabel</code>","text":"<pre><code><pre>processWriteActionLabel : ShardActionExec := ActionExec.Seq [processWriteAction];</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#processreadrequestactionlabel","title":"<code>processReadRequestActionLabel</code>","text":"<pre><code><pre>processReadRequestActionLabel : ShardActionExec :=  ActionExec.Seq [processReadRequestAction];</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#updateseenallactionlabel","title":"<code>updateSeenAllActionLabel</code>","text":"<pre><code><pre>updateSeenAllActionLabel : ShardActionExec :=  ActionExec.Seq [updateSeenAllAction];</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#shardguard","title":"<code>ShardGuard</code>","text":"<p><pre><code><pre>ShardGuard : Type :=  Guard    ShardLocalCfg    ShardLocalState    ShardMailboxState    ShardTimerHandle    ShardActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#shardguardoutput","title":"<code>ShardGuardOutput</code>","text":"<p><pre><code><pre>ShardGuardOutput : Type :=  GuardOutput    ShardLocalCfg    ShardLocalState    ShardMailboxState    ShardTimerHandle    ShardActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#shardguardeval","title":"<code>ShardGuardEval</code>","text":"<p><pre><code><pre>ShardGuardEval : Type :=  GuardEval    ShardLocalCfg    ShardLocalState    ShardMailboxState    ShardTimerHandle    ShardActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#acquirelockguard","title":"<code>acquireLockGuard</code>","text":"Condition Message type is ShardMsgKVSAcquireLock. <pre><code><pre>acquireLockGuard  (trigger : TimestampedTrigger ShardTimerHandle Anoma.Msg)  (cfg : ShardCfg)  (env : ShardEnv)  : Option ShardGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{msg := Anoma.Msg.Shard (ShardMsg.KVSAcquireLock _)} :=      some        GuardOutput.mk@{          action := acquireLockActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#processwriteguard","title":"<code>processWriteGuard</code>","text":"Condition Message type is ShardMsgKVSWrite. <pre><code><pre>processWriteGuard  (trigger : TimestampedTrigger ShardTimerHandle Anoma.Msg)  (cfg : ShardCfg)  (env : ShardEnv)  : Option ShardGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{msg := Anoma.Msg.Shard (ShardMsg.KVSWrite _)} :=      some        GuardOutput.mk@{          action := processWriteActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#processreadrequestguard","title":"<code>processReadRequestGuard</code>","text":"Condition Message type is ShardMsgKVSReadRequest. <pre><code><pre>processReadRequestGuard  (trigger : TimestampedTrigger ShardTimerHandle Anoma.Msg)  (cfg : ShardCfg)  (env : ShardEnv)  : Option ShardGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{msg := Anoma.Msg.Shard (ShardMsg.KVSReadRequest _)} :=      some        GuardOutput.mk@{          action := processReadRequestActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#updateseenallguard","title":"<code>updateSeenAllGuard</code>","text":"Condition Message type is ShardMsgUpdateSeenAll. <pre><code><pre>updateSeenAllGuard  (trigger : TimestampedTrigger ShardTimerHandle Anoma.Msg)  (cfg : ShardCfg)  (env : ShardEnv)  : Option ShardGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{msg := Anoma.Msg.Shard (ShardMsg.UpdateSeenAll _)} :=      some        GuardOutput.mk@{          action := updateSeenAllActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#the-shard-behaviour","title":"The Shard Behaviour","text":"","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#shardbehaviour","title":"<code>ShardBehaviour</code>","text":"<pre><code><pre>ShardBehaviour : Type :=  EngineBehaviour    ShardLocalCfg    ShardLocalState    ShardMailboxState    ShardTimerHandle    ShardActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>shardBehaviour : ShardBehaviour :=  EngineBehaviour.mk@{    guards :=      GuardEval.First        [          acquireLockGuard;          processWriteGuard;          processReadRequestGuard;          updateSeenAllGuard;        ];  };</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","behaviour"]},{"location":"arch/node/engines/shard_config.html","title":"Shard Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.shard_config;import prelude open;import arch.node.engines.shard_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","shard","configuration"]},{"location":"arch/node/engines/shard_config.html#shard-configuration","title":"Shard Configuration","text":"","tags":["node-architecture","ordering-subsystem","engine","shard","configuration"]},{"location":"arch/node/engines/shard_config.html#overview","title":"Overview","text":"<p>The shard configuration contains static information for shard engine instances.</p>","tags":["node-architecture","ordering-subsystem","engine","shard","configuration"]},{"location":"arch/node/engines/shard_config.html#the-shard-local-configuration","title":"The Shard Local Configuration","text":"","tags":["node-architecture","ordering-subsystem","engine","shard","configuration"]},{"location":"arch/node/engines/shard_config.html#shardlocalcfg","title":"<code>ShardLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type ShardLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","configuration"]},{"location":"arch/node/engines/shard_config.html#the-shard-configuration","title":"The Shard Configuration","text":"","tags":["node-architecture","ordering-subsystem","engine","shard","configuration"]},{"location":"arch/node/engines/shard_config.html#shardcfg","title":"<code>ShardCfg</code>","text":"<pre><code><pre>ShardCfg : Type := EngineCfg ShardLocalCfg;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","configuration"]},{"location":"arch/node/engines/shard_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>shardCfg : ShardCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"shard\";    cfg := ShardLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","configuration"]},{"location":"arch/node/engines/shard_environment.html","title":"Shard Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.shard_environment;import prelude open;import arch.node.engines.shard_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","shard","environment"]},{"location":"arch/node/engines/shard_environment.html#shard-environment","title":"Shard Environment","text":"","tags":["node-architecture","ordering-subsystem","engine","shard","environment"]},{"location":"arch/node/engines/shard_environment.html#overview","title":"Overview","text":"<p>The shard environment maintains state about key-value pairs, tracking read and write accesses for each key across different transaction timestamps. It provides multi-version concurrent storage capabilities.</p>","tags":["node-architecture","ordering-subsystem","engine","shard","environment"]},{"location":"arch/node/engines/shard_environment.html#mailbox-states","title":"Mailbox states","text":"<pre><code><pre>syntax alias ShardMailboxState := Unit;</pre></code></pre> <p>The shard engine does not require complex mailbox states. Therefore, we define the mailbox state type as <code>Unit</code>.</p>","tags":["node-architecture","ordering-subsystem","engine","shard","environment"]},{"location":"arch/node/engines/shard_environment.html#local-state","title":"Local state","text":"Auxiliary Juvix code <p> <pre><code><pre>type ReadStatus :=  mkReadStatus@{    hasBeenRead : Bool;    isEager : Bool;    executor : EngineID;  };type WriteStatus :=  mkWriteStatus@{    data : Option KVSDatum;    mayWrite : Bool;  };type KeyAccess :=  mkKeyAccess@{    readStatus : Option ReadStatus;    writeStatus : Option WriteStatus;  };type DAGStructure :=  mkDAGStructure@{    keyAccesses : Map KVSKey (Map TxFingerprint KeyAccess);    heardAllReads : TxFingerprint;    heardAllWrites : TxFingerprint;  };</pre></code></pre> </p>","tags":["node-architecture","ordering-subsystem","engine","shard","environment"]},{"location":"arch/node/engines/shard_environment.html#shardlocalstate","title":"<code>ShardLocalState</code>","text":"<pre><code><pre>type ShardLocalState :=  mk@{    dagStructure : DAGStructure;    anchors : List NarwhalBlock;  };</pre></code></pre> Arguments <code>dagStructure</code> Structure tracking all key accesses across transactions, including read/write status and <code>heardAll</code> points <code>anchors</code> Sequence of consensus decisions (Currently unused)","tags":["node-architecture","ordering-subsystem","engine","shard","environment"]},{"location":"arch/node/engines/shard_environment.html#timer-handles","title":"Timer handles","text":"<pre><code><pre>syntax alias ShardTimerHandle := Unit;</pre></code></pre> <p>The shard engine does not require timers. Therefore, we define the timer handle type as <code>Unit</code>.</p>","tags":["node-architecture","ordering-subsystem","engine","shard","environment"]},{"location":"arch/node/engines/shard_environment.html#the-shard-environment","title":"The Shard Environment","text":"","tags":["node-architecture","ordering-subsystem","engine","shard","environment"]},{"location":"arch/node/engines/shard_environment.html#shardenv","title":"<code>ShardEnv</code>","text":"<pre><code><pre>ShardEnv : Type :=  EngineEnv ShardLocalState ShardMailboxState ShardTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","environment"]},{"location":"arch/node/engines/shard_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>shardEnv : ShardEnv :=  EngineEnv.mk@{    localState :=      ShardLocalState.mk@{        dagStructure :=          DAGStructure.mkDAGStructure@{            keyAccesses := Map.empty;            heardAllReads := 0;            heardAllWrites := 0;          };        anchors := [];      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","environment"]},{"location":"arch/node/engines/shard_messages.html","title":"Shard Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.shard_messages;import prelude open;import arch.node.types.basics open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","ordering-subsystem","engine","shard","message-types"]},{"location":"arch/node/engines/shard_messages.html#shard-messages","title":"Shard Messages","text":"<p>These are the messages that the Shard engine can receive/respond to.</p>","tags":["node-architecture","ordering-subsystem","engine","shard","message-types"]},{"location":"arch/node/engines/shard_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type ShardMsg :=  | KVSReadRequest KVSReadRequestMsg  | KVSWrite KVSWriteMsg  | KVSAcquireLock KVSAcquireLockMsg  | KVSLockAcquired KVSLockAcquiredMsg  | KVSRead KVSReadMsg  | UpdateSeenAll UpdateSeenAllMsg;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","message-types"]},{"location":"arch/node/engines/shard_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","ordering-subsystem","engine","shard","message-types"]},{"location":"arch/node/engines/shard_messages.html#transaction-lock-and-read-flow","title":"Transaction lock and read flow","text":"<pre><code>sequenceDiagram\n    participant WorkerEngine\n    participant Shard\n    participant Executor\n    participant Mempool\n    participant Consensus\n\n    WorkerEngine-&gt;&gt;Shard: KVSAcquireLock\n    Shard-&gt;&gt;WorkerEngine: KVSLockAcquired\n    Executor-&gt;&gt;Shard: KVSReadRequest\n    Mempool-&gt;&gt;Shard: UpdateSeenAll\n    Consensus-&gt;&gt;Shard: AnchorChosen\n    Shard-&gt;&gt;Executor: KVSRead\n    Executor-&gt;&gt;Shard: KVSWrite</code></pre>  Sequence Diagram: Transaction Lock and Read Flow","tags":["node-architecture","ordering-subsystem","engine","shard","message-types"]},{"location":"arch/node/engines/shard_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","ordering-subsystem","engine","shard","message-types"]},{"location":"arch/node/engines/shard_messages.html#kvsreadrequestmsg","title":"<code>KVSReadRequestMsg</code>","text":"<p>Read request from an Executor Engine.</p> <pre><code><pre>type KVSReadRequestMsg :=  mkKVSReadRequestMsg@{    timestamp : TxFingerprint;    key : KVSKey;    actual : Bool;  };</pre></code></pre> Arguments <code>timestamp</code> The logical timestamp identifying the transaction at which to read <code>key</code> The key to read <code>actual</code> True if value is actually needed, false if just cleaning up a lazy read","tags":["node-architecture","ordering-subsystem","engine","shard","message-types"]},{"location":"arch/node/engines/shard_messages.html#kvswritemsg","title":"<code>KVSWriteMsg</code>","text":"<p>Write request from an Executor Engine.</p> <pre><code><pre>type KVSWriteMsg :=  mkKVSWriteMsg@{    timestamp : TxFingerprint;    key : KVSKey;    datum : Option KVSDatum;  };</pre></code></pre> Arguments <code>timestamp</code> The logical timestamp identifying the transaction in which to write <code>key</code> The key to write to <code>datum</code> The data to write, or <code>none</code> to indicate no write","tags":["node-architecture","ordering-subsystem","engine","shard","message-types"]},{"location":"arch/node/engines/shard_messages.html#updateseenallmsg","title":"<code>UpdateSeenAllMsg</code>","text":"<p>Update about seen transactions from a Mempool Worker Engine.</p> <pre><code><pre>type UpdateSeenAllMsg :=  mkUpdateSeenAllMsg@{    timestamp : TxFingerprint;    write : Bool;  };</pre></code></pre> Arguments <code>timestamp</code> The logical timestamp at which to push the SeenAll value. <code>write</code> Whether it is the <code>SeenAllReads</code> or <code>SeenAllWrites</code> to update.","tags":["node-architecture","ordering-subsystem","engine","shard","message-types"]},{"location":"arch/node/engines/shard_messages.html#kvsacquirelockmsg","title":"<code>KVSAcquireLockMsg</code>","text":"<p>Request to acquire locks for transaction execution.</p> <pre><code><pre>type KVSAcquireLockMsg :=  mkKVSAcquireLockMsg@{    lazy_read_keys : Set KVSKey;    eager_read_keys : Set KVSKey;    will_write_keys : Set KVSKey;    may_write_keys : Set KVSKey;    worker : EngineID;    executor : EngineID;    timestamp : TxFingerprint;  };</pre></code></pre> Arguments <code>lazy_read_keys</code> Keys this transaction may read (only send values read in response to <code>KVSReadRequest</code>s) <code>eager_read_keys</code> Keys this transaction will read (send values read as soon as possible) <code>will_write_keys</code> Keys this transaction will write <code>may_write_keys</code> Keys this transaction may write <code>worker</code> The Worker Engine in charge of the transaction <code>executor</code> The Executor for this transaction <code>timestamp</code> Specifies the transaction affiliated with these locks","tags":["node-architecture","ordering-subsystem","engine","shard","message-types"]},{"location":"arch/node/engines/shard_messages.html#kvslockacquiredmsg","title":"<code>KVSLockAcquiredMsg</code>","text":"<p>Confirmation that locks were acquired.</p> <pre><code><pre>type KVSLockAcquiredMsg :=  mkKVSLockAcquiredMsg@{    timestamp : TxFingerprint;  };</pre></code></pre> Arguments <code>timestamp</code> The timestamp of the transaction which was locked.","tags":["node-architecture","ordering-subsystem","engine","shard","message-types"]},{"location":"arch/node/engines/shard_messages.html#kvsreadmsg","title":"<code>KVSReadMsg</code>","text":"<p>Value read response to executor.</p> <pre><code><pre>type KVSReadMsg :=  mkKVSReadMsg@{    timestamp : TxFingerprint;    key : KVSKey;    data : KVSDatum;  };</pre></code></pre> Arguments <code>timestamp</code> The timestamp of the transaction which was read. <code>key</code> The key which was read. <code>data</code> The the data read.","tags":["node-architecture","ordering-subsystem","engine","shard","message-types"]},{"location":"arch/node/engines/shard_messages.html#shardmsg","title":"<code>ShardMsg</code>","text":"<pre><code><pre>type ShardMsg :=  | KVSReadRequest KVSReadRequestMsg  | KVSWrite KVSWriteMsg  | KVSAcquireLock KVSAcquireLockMsg  | KVSLockAcquired KVSLockAcquiredMsg  | KVSRead KVSReadMsg  | UpdateSeenAll UpdateSeenAllMsg;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","engine","shard","message-types"]},{"location":"arch/node/engines/shard_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Shard Configuration</li> <li>Shard Environment</li> <li>Shard Behaviour</li> </ul>","tags":["node-architecture","ordering-subsystem","engine","shard","message-types"]},{"location":"arch/node/engines/signs_for.html","title":"SignsFor Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.signs_for;import prelude open;import arch.node.types.engine open;import arch.node.engines.signs_for_config open public;import arch.node.engines.signs_for_messages open public;import arch.node.engines.signs_for_environment open public;import arch.node.engines.signs_for_behaviour open public;import arch.node.types.anoma as Anoma open;open signs_for_config_example;open signs_for_environment_example;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","signsfor"]},{"location":"arch/node/engines/signs_for.html#signsfor-engine","title":"SignsFor Engine","text":"<p>The SignsFor Engine manages signs for relationships between identities. A \"signs for\" relationship indicates that one identity can produce signatures (commitments) on behalf of another identity.</p>","tags":["node-architecture","identity-subsystem","engine","signsfor"]},{"location":"arch/node/engines/signs_for.html#purpose","title":"Purpose","text":"<p>The SignsFor Engine maintains and manages the state of sings for relationships between identities. It handles queries about these relationships, allows submission of new evidence, and provides information about existing relationships. This is useful in scenarios where signature delegation or proxy signing is required.</p>","tags":["node-architecture","identity-subsystem","engine","signsfor"]},{"location":"arch/node/engines/signs_for.html#engine-components","title":"Engine components","text":"<ul> <li>SignsFor Messages</li> <li>SignsFor Configuration</li> <li>SignsFor Environment</li> <li>SignsFor Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","signsfor"]},{"location":"arch/node/engines/signs_for.html#type","title":"Type","text":"<pre><code><pre>SignsForEngine : Type :=  Engine    SignsForLocalCfg    SignsForLocalState    SignsForMailboxState    SignsForTimerHandle    SignsForActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor"]},{"location":"arch/node/engines/signs_for.html#example-of-a-signsfor-engine","title":"Example of a signsFor engine","text":"<pre><code><pre>exampleSignsForEngine : SignsForEngine :=  Engine.mk@{    cfg := signsForCfg;    env := signsForEnv;    behaviour := signsForBehaviour;  };</pre></code></pre> <p>where <code>signsForCfg</code> is defined as follows:</p> <pre><code><pre>signsForCfg : SignsForCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"signs for\";    cfg := SignsForLocalCfg.mk;  };</pre></code></pre> <p><code>signsForEnv</code> is defined as follows:</p> <pre><code><pre>signsForEnv : SignsForEnv :=  EngineEnv.mk@{    localState :=      SignsForLocalState.mk@{        evidenceStore := Set.empty;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>signsForBehaviour</code> is defined as follows:</p> <pre><code><pre>signsForBehaviour : SignsForBehaviour :=  EngineBehaviour.mk@{    guards :=      GuardEval.First        [signsForQueryGuard; submitEvidenceGuard; queryEvidenceGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor"]},{"location":"arch/node/engines/signs_for_behaviour.html","title":"SignsFor Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.signs_for_behaviour;import prelude open;import Stdlib.Data.Set as Set;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.identities open;import arch.node.engines.signs_for_environment open;import arch.node.engines.signs_for_messages open;import arch.node.engines.signs_for_config open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsfor-behaviour","title":"SignsFor Behaviour","text":"","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#overview","title":"Overview","text":"<p>The behavior of the SignsFor Engine defines how it processes incoming messages and updates its state accordingly.</p>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsforactionargumentreplyto-replyto","title":"<code>SignsForActionArgumentReplyTo ReplyTo</code>","text":"<pre><code><pre>type ReplyTo :=  mkReplyTo@{    whoAsked : Option EngineID;    mailbox : Option MailboxID;  };</pre></code></pre> <p>This action argument contains the address and mailbox ID of where the response message should be sent.</p> <code>whoAsked</code>: The engine ID of the requester. <code>mailbox</code>: The mailbox ID where the response should be sent.","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsforactionargument","title":"<code>SignsForActionArgument</code>","text":"<pre><code><pre>type SignsForActionArgument := | SignsForActionArgumentReplyTo ReplyTo;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsforactionarguments","title":"<code>SignsForActionArguments</code>","text":"<pre><code><pre>SignsForActionArguments : Type := List SignsForActionArgument;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsforaction","title":"SignsForAction","text":"<p><pre><code><pre>SignsForAction : Type :=  Action    SignsForLocalCfg    SignsForLocalState    SignsForMailboxState    SignsForTimerHandle    SignsForActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsforactioninput","title":"SignsForActionInput","text":"<p><pre><code><pre>SignsForActionInput : Type :=  ActionInput    SignsForLocalCfg    SignsForLocalState    SignsForMailboxState    SignsForTimerHandle    SignsForActionArguments    Anoma.Msg;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsforactioneffect","title":"SignsForActionEffect","text":"<p><pre><code><pre>SignsForActionEffect : Type :=  ActionEffect    SignsForLocalState    SignsForMailboxState    SignsForTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsforactionexec","title":"SignsForActionExec","text":"<p><pre><code><pre>SignsForActionExec : Type :=  ActionExec    SignsForLocalCfg    SignsForLocalState    SignsForMailboxState    SignsForTimerHandle    SignsForActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsforqueryaction","title":"<code>signsForQueryAction</code>","text":"<p>Respond to a signs_for query.</p> State update The state remains unchanged. Messages to be sent A <code>ReplySignsFor</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>signsForQueryAction  (input : SignsForActionInput) : Option SignsForActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    tt := ActionInput.trigger input;    localState := EngineEnv.localState env;  in case getEngineMsgFromTimestampedTrigger tt of       | some EngineMsg.mk@{                msg := Anoma.Msg.SignsFor (SignsForMsg.SignsForRequest (RequestSignsFor.mkRequestSignsFor externalIdentityA externalIdentityB));                sender := msgSender;              } :=         let           hasEvidence :=             isElement               \\{a b := a &amp;&amp; b}               true               (map                 \\{evidence :=                   isEqual                       (Ord.compare                         (SignsForEvidence.fromIdentity evidence)                         externalIdentityA)                     &amp;&amp; isEqual                       (Ord.compare                         (SignsForEvidence.toIdentity evidence)                         externalIdentityB)}                 (Set.toList (SignsForLocalState.evidenceStore localState)));           responseMsg :=             ReplySignsFor.mkReplySignsFor@{               signsFor := hasEvidence;               err := none;             };         in some           ActionEffect.mk@{             env := env;             msgs :=               [                 EngineMsg.mk@{                   sender := getEngineIDFromEngineCfg cfg;                   target := msgSender;                   mailbox := some 0;                   msg :=                     Anoma.Msg.SignsFor (SignsForMsg.SignsForReply responseMsg);                 };               ];             timers := [];             engines := [];           }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#submitevidenceaction","title":"<code>submitEvidenceAction</code>","text":"<p>Submit new signs_for evidence.</p> State update If the evidence doesn't already exist and is valid, it's added to the <code>evidenceStore</code> in the local state. Messages to be sent A <code>ReplySubmitSignsForEvidence</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>submitEvidenceAction  (input : SignsForActionInput) : Option SignsForActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    tt := ActionInput.trigger input;    localState := EngineEnv.localState env;  in case getEngineMsgFromTimestampedTrigger tt of       | some EngineMsg.mk@{                msg := Anoma.Msg.SignsFor (SignsForMsg.SubmitSignsForEvidenceRequest (RequestSubmitSignsForEvidence.mkRequestSubmitSignsForEvidence evidence));                sender := msgSender;              } :=         case verifyEvidence evidence of {           | true :=             let               alreadyExists :=                 isElement                   \\{a b := a &amp;&amp; b}                   true                   (map                     \\{e := isEqual (Ord.compare e evidence)}                     (Set.toList                       (SignsForLocalState.evidenceStore localState)));             in case alreadyExists of {                  | true :=                    let                      responseMsg :=                        ReplySubmitSignsForEvidence.mkReplySubmitSignsForEvidence@{                          err := some \"Evidence already exists.\";                        };                    in some                      ActionEffect.mk@{                        env := env;                        msgs :=                          [                            EngineMsg.mk@{                              sender := getEngineIDFromEngineCfg cfg;                              target := msgSender;                              mailbox := some 0;                              msg :=                                Anoma.Msg.SignsFor                                  (SignsForMsg.SubmitSignsForEvidenceReply                                    responseMsg);                            };                          ];                        timers := [];                        engines := [];                      }                  | false :=                    let                      newEvidenceStore :=                        Set.insert                          evidence                          (SignsForLocalState.evidenceStore localState);                      updatedLocalState :=                        localState@SignsForLocalState{evidenceStore := newEvidenceStore};                      newEnv := env@EngineEnv{localState := updatedLocalState};                      responseMsg :=                        ReplySubmitSignsForEvidence.mkReplySubmitSignsForEvidence@{                          err := none;                        };                    in some                      ActionEffect.mk@{                        env := newEnv;                        msgs :=                          [                            EngineMsg.mk@{                              sender := getEngineIDFromEngineCfg cfg;                              target := msgSender;                              mailbox := some 0;                              msg :=                                Anoma.Msg.SignsFor                                  (SignsForMsg.SubmitSignsForEvidenceReply                                    responseMsg);                            };                          ];                        timers := [];                        engines := [];                      }                }           | false :=             let               responseMsg :=                 ReplySubmitSignsForEvidence.mkReplySubmitSignsForEvidence@{                   err := some \"Invalid evidence provided.\";                 };             in some               ActionEffect.mk@{                 env := env;                 msgs :=                   [                     EngineMsg.mk@{                       sender := getEngineIDFromEngineCfg cfg;                       target := msgSender;                       mailbox := some 0;                       msg :=                         Anoma.Msg.SignsFor                           (SignsForMsg.SubmitSignsForEvidenceReply                             responseMsg);                     };                   ];                 timers := [];                 engines := [];               }         }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#queryevidenceaction","title":"<code>queryEvidenceAction</code>","text":"<p>Query signs_for evidence for a specific identity.</p> State update The state remains unchanged. Messages to be sent A <code>ReplyQuerySignsForEvidence</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>queryEvidenceAction  (input : SignsForActionInput) : Option SignsForActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    tt := ActionInput.trigger input;    localState := EngineEnv.localState env;  in case getEngineMsgFromTimestampedTrigger tt of       | some EngineMsg.mk@{                msg := Anoma.Msg.SignsFor (SignsForMsg.QuerySignsForEvidenceRequest (RequestQuerySignsForEvidence.mkRequestQuerySignsForEvidence externalIdentity));                sender := msgSender;              } :=         let           relevantEvidence :=             Set.filter               \\{evidence :=                 isEqual                     (Ord.compare                       (SignsForEvidence.fromIdentity evidence)                       externalIdentity)                   || isEqual                     (Ord.compare                       (SignsForEvidence.toIdentity evidence)                       externalIdentity)}               (SignsForLocalState.evidenceStore localState);           responseMsg :=             ReplyQuerySignsForEvidence.mkReplyQuerySignsForEvidence@{               externalIdentity := externalIdentity;               evidence := relevantEvidence;               err := none;             };         in some           ActionEffect.mk@{             env := env;             msgs :=               [                 EngineMsg.mk@{                   sender := getEngineIDFromEngineCfg cfg;                   target := msgSender;                   mailbox := some 0;                   msg :=                     Anoma.Msg.SignsFor                       (SignsForMsg.QuerySignsForEvidenceReply responseMsg);                 };               ];             timers := [];             engines := [];           }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsforqueryactionlabel","title":"<code>signsForQueryActionLabel</code>","text":"<pre><code><pre>signsForQueryActionLabel : SignsForActionExec :=  ActionExec.Seq [signsForQueryAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#submitevidenceactionlabel","title":"<code>submitEvidenceActionLabel</code>","text":"<pre><code><pre>submitEvidenceActionLabel : SignsForActionExec :=  ActionExec.Seq [submitEvidenceAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#queryevidenceactionlabel","title":"<code>queryEvidenceActionLabel</code>","text":"<pre><code><pre>queryEvidenceActionLabel : SignsForActionExec :=  ActionExec.Seq [queryEvidenceAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsforguard","title":"<code>SignsForGuard</code>","text":"<p> <pre><code><pre>SignsForGuard : Type :=  Guard    SignsForLocalCfg    SignsForLocalState    SignsForMailboxState    SignsForTimerHandle    SignsForActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsforguardoutput","title":"<code>SignsForGuardOutput</code>","text":"<p> <pre><code><pre>SignsForGuardOutput : Type :=  GuardOutput    SignsForLocalCfg    SignsForLocalState    SignsForMailboxState    SignsForTimerHandle    SignsForActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsforguardeval","title":"<code>SignsForGuardEval</code>","text":"<p> <pre><code><pre>SignsForGuardEval : Type :=  GuardEval    SignsForLocalCfg    SignsForLocalState    SignsForMailboxState    SignsForTimerHandle    SignsForActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsforqueryguard","title":"<code>signsForQueryGuard</code>","text":"Condition Message type is <code>MsgSignsForRequest</code>. <pre><code><pre>signsForQueryGuard  (tt : TimestampedTrigger SignsForTimerHandle Anoma.Msg)  (cfg : SignsForCfg)  (env : SignsForEnv)  : Option SignsForGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some EngineMsg.mk@{             msg := Anoma.Msg.SignsFor (SignsForMsg.SignsForRequest _);           } :=      some        GuardOutput.mk@{          action := signsForQueryActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#submitevidenceguard","title":"<code>submitEvidenceGuard</code>","text":"Condition Message type is <code>MsgSubmitSignsForEvidenceRequest</code>. <pre><code><pre>submitEvidenceGuard  (tt : TimestampedTrigger SignsForTimerHandle Anoma.Msg)  (cfg : SignsForCfg)  (env : SignsForEnv)  : Option SignsForGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some EngineMsg.mk@{             msg := Anoma.Msg.SignsFor (SignsForMsg.SubmitSignsForEvidenceRequest _);           } :=      some        GuardOutput.mk@{          action := submitEvidenceActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#queryevidenceguard","title":"<code>queryEvidenceGuard</code>","text":"Condition Message type is <code>MsgQuerySignsForEvidenceRequest</code>. <pre><code><pre>queryEvidenceGuard  (tt : TimestampedTrigger SignsForTimerHandle Anoma.Msg)  (cfg : SignsForCfg)  (env : SignsForEnv)  : Option SignsForGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some EngineMsg.mk@{             msg := Anoma.Msg.SignsFor (SignsForMsg.QuerySignsForEvidenceRequest _);           } :=      some        GuardOutput.mk@{          action := queryEvidenceActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#the-signsfor-behaviour","title":"The SignsFor Behaviour","text":"","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsforbehaviour","title":"<code>SignsForBehaviour</code>","text":"<pre><code><pre>SignsForBehaviour : Type :=  EngineBehaviour    SignsForLocalCfg    SignsForLocalState    SignsForMailboxState    SignsForTimerHandle    SignsForActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>signsForBehaviour : SignsForBehaviour :=  EngineBehaviour.mk@{    guards :=      GuardEval.First        [signsForQueryGuard; submitEvidenceGuard; queryEvidenceGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsfor-action-flowcharts","title":"SignsFor Action Flowcharts","text":"","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#signsforqueryaction-flowchart","title":"<code>signsForQueryAction</code> flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;MsgSignsForRequest]\n  end\n\n  G(signsForQueryGuard)\n  A(signsForQueryAction)\n\n  C --&gt; G -- *signsForQueryActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EMsg&gt;MsgSignsForReply&lt;br/&gt;signsFor result]\n  end</code></pre>  signsForQueryAction flowchart","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#submitevidenceaction-flowchart","title":"<code>submitEvidenceAction</code> flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;MsgSubmitSignsForEvidenceRequest]\n  end\n\n  G(submitEvidenceGuard)\n  A(submitEvidenceAction)\n\n  C --&gt; G -- *submitEvidenceActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(evidenceStore update)]\n    EMsg&gt;MsgSubmitSignsForEvidenceReply]\n  end</code></pre>  submitEvidenceAction flowchart","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_behaviour.html#queryevidenceaction-flowchart","title":"<code>queryEvidenceAction</code> flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;MsgQuerySignsForEvidenceRequest]\n  end\n\n  G(queryEvidenceGuard)\n  A(queryEvidenceAction)\n\n  C --&gt; G -- *queryEvidenceActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EMsg&gt;MsgQuerySignsForEvidenceReply&lt;br/&gt;matching evidence]\n  end</code></pre>  queryEvidenceAction flowchart","tags":["node-architecture","identity-subsystem","engine","signsfor","behaviour"]},{"location":"arch/node/engines/signs_for_config.html","title":"SignsFor Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.signs_for_config;import prelude open;import arch.node.engines.signs_for_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","signsfor","configuration"]},{"location":"arch/node/engines/signs_for_config.html#signsfor-configuration","title":"SignsFor Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","signsfor","configuration"]},{"location":"arch/node/engines/signs_for_config.html#overview","title":"Overview","text":"<p>The SignsFor engine configuration contains static information for SignsFor engine instances.</p>","tags":["node-architecture","identity-subsystem","engine","signsfor","configuration"]},{"location":"arch/node/engines/signs_for_config.html#the-signsfor-local-configuration","title":"The SignsFor Local Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","signsfor","configuration"]},{"location":"arch/node/engines/signs_for_config.html#signsforlocalcfg","title":"<code>SignsForLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type SignsForLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","configuration"]},{"location":"arch/node/engines/signs_for_config.html#the-signsfor-configuration","title":"The SignsFor Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","signsfor","configuration"]},{"location":"arch/node/engines/signs_for_config.html#signsforcfg","title":"<code>SignsForCfg</code>","text":"<pre><code><pre>SignsForCfg : Type := EngineCfg SignsForLocalCfg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","configuration"]},{"location":"arch/node/engines/signs_for_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>signsForCfg : SignsForCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"signs for\";    cfg := SignsForLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","configuration"]},{"location":"arch/node/engines/signs_for_environment.html","title":"SignsFor Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.signs_for_environment;import prelude open;import arch.node.types.messages open;import arch.node.types.engine_environment open;import arch.node.types.identities open;import arch.node.engines.signs_for_messages open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","signsfor","environment"]},{"location":"arch/node/engines/signs_for_environment.html#signsfor-environment","title":"SignsFor Environment","text":"","tags":["node-architecture","identity-subsystem","engine","signsfor","environment"]},{"location":"arch/node/engines/signs_for_environment.html#overview","title":"Overview","text":"<p>The SignsFor Engine environment maintains the state necessary for managing <code>signs_for</code> relationships between identities, including storing evidence submitted by clients.</p> Auxiliary Juvix code <p><pre><code><pre>axiom verifyEvidence : SignsForEvidence -&gt; Bool;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","signsfor","environment"]},{"location":"arch/node/engines/signs_for_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The SignsFor Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","signsfor","environment"]},{"location":"arch/node/engines/signs_for_environment.html#signsformailboxstate","title":"<code>SignsForMailboxState</code>","text":"<pre><code><pre>syntax alias SignsForMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","environment"]},{"location":"arch/node/engines/signs_for_environment.html#local-state","title":"Local state","text":"<p>The local state of the SignsFor Engine includes the evidence for signs_for relationships.</p>","tags":["node-architecture","identity-subsystem","engine","signsfor","environment"]},{"location":"arch/node/engines/signs_for_environment.html#signsforlocalstate","title":"<code>SignsForLocalState</code>","text":"<pre><code><pre>type SignsForLocalState :=  mk@{    evidenceStore : Set SignsForEvidence;  };</pre></code></pre> Arguments <code>evidenceStore</code>: The collection of validated <code>SignsForEvidence</code> which has been submitted to the engine.","tags":["node-architecture","identity-subsystem","engine","signsfor","environment"]},{"location":"arch/node/engines/signs_for_environment.html#timer-handle","title":"Timer Handle","text":"<p>The SignsFor Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","signsfor","environment"]},{"location":"arch/node/engines/signs_for_environment.html#signsfortimerhandle","title":"<code>SignsForTimerHandle</code>","text":"<pre><code><pre>syntax alias SignsForTimerHandle := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","environment"]},{"location":"arch/node/engines/signs_for_environment.html#the-signsfor-environment","title":"The SignsFor Environment","text":"","tags":["node-architecture","identity-subsystem","engine","signsfor","environment"]},{"location":"arch/node/engines/signs_for_environment.html#signsforenv","title":"<code>SignsForEnv</code>","text":"<pre><code><pre>SignsForEnv : Type :=  EngineEnv    SignsForLocalState    SignsForMailboxState    SignsForTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","environment"]},{"location":"arch/node/engines/signs_for_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>signsForEnv : SignsForEnv :=  EngineEnv.mk@{    localState :=      SignsForLocalState.mk@{        evidenceStore := Set.empty;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","environment"]},{"location":"arch/node/engines/signs_for_messages.html","title":"SignsFor Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.signs_for_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/signs_for_messages.html#signsfor-messages","title":"SignsFor Messages","text":"","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/signs_for_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type SignsForMsg :=  | SignsForRequest RequestSignsFor  | SignsForReply ReplySignsFor  | SubmitSignsForEvidenceRequest RequestSubmitSignsForEvidence  | SubmitSignsForEvidenceReply ReplySubmitSignsForEvidence  | QuerySignsForEvidenceRequest RequestQuerySignsForEvidence  | QuerySignsForEvidenceReply ReplyQuerySignsForEvidence;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/signs_for_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/signs_for_messages.html#submitting-signs_for-evidence","title":"Submitting <code>signs_for</code> evidence","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant SignsForEngine\n\n    Client-&gt;&gt;SignsForEngine: RequestSubmitSignsForEvidence\n    Note over SignsForEngine: Process and store evidence\n    SignsForEngine-&gt;&gt;Client: ReplySubmitSignsForEvidence</code></pre>  Submitting evidence of a signs_for relationship","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/signs_for_messages.html#querying-signs_for-relationship","title":"Querying <code>signs_for</code> relationship","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant SignsForEngine\n\n    Client-&gt;&gt;SignsForEngine: RequestSignsFor (X signs for Y?)\n    Note over SignsForEngine: Check stored evidence\n    SignsForEngine-&gt;&gt;Client: ReplySignsFor</code></pre>  Querying whether a specific signs_for relationship exists","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/signs_for_messages.html#retrieving-signs_for-evidence","title":"Retrieving <code>signs_for</code> evidence","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant SignsForEngine\n\n    Client-&gt;&gt;SignsForEngine: RequestQuerySignsForEvidence (for X)\n    Note over SignsForEngine: Retrieve relevant evidence\n    SignsForEngine-&gt;&gt;Client: ReplyQuerySignsForEvidence</code></pre>  Retrieving all signs_for evidence related to a particular identity","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/signs_for_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/signs_for_messages.html#requestsignsfor","title":"<code>RequestSignsFor</code>","text":"<pre><code><pre>type RequestSignsFor :=  mkRequestSignsFor@{    externalIdentityA : ExternalIdentity;    externalIdentityB : ExternalIdentity;  };</pre></code></pre> <p>A <code>RequestSignsFor</code> queries whether <code>externalIdentityA</code> can sign on behalf of <code>externalIdentityB</code>.</p> Arguments <code>externalIdentityA</code>: The identity attempting to sign. <code>externalIdentityB</code>: The identity on whose behalf the signature is made.","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/signs_for_messages.html#msgsignsforreply-replysignsfor","title":"<code>MsgSignsForReply ReplySignsFor</code>","text":"<pre><code><pre>type ReplySignsFor :=  mkReplySignsFor@{    signsFor : Bool;    err : Option String;  };</pre></code></pre> <p>A <code>ReplySignsFor</code> indicates whether the <code>signs_for</code> relationship exists.</p> Arguments <code>signsFor</code>: True if <code>externalIdentityA</code> can sign for <code>externalIdentityB</code>, False otherwise. <code>err</code>: An error message if the query failed.","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/signs_for_messages.html#requestsubmitsignsforevidence","title":"<code>RequestSubmitSignsForEvidence</code>","text":"<pre><code><pre>type RequestSubmitSignsForEvidence :=  mkRequestSubmitSignsForEvidence@{    evidence : SignsForEvidence;  };</pre></code></pre> <p>A <code>RequestSubmitSignsForEvidence</code> submits evidence of a <code>signs_for</code> relationship.</p> Arguments <code>evidence</code>: The evidence supporting the <code>signs_for</code> relationship.","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/signs_for_messages.html#replysubmitsignsforevidence","title":"<code>ReplySubmitSignsForEvidence</code>","text":"<pre><code><pre>type ReplySubmitSignsForEvidence :=  mkReplySubmitSignsForEvidence@{    err : Option String;  };</pre></code></pre> <p>A <code>ReplySubmitSignsForEvidence</code> acknowledges the submission of evidence.</p> Arguments <code>err</code>: An error message if the submission failed.","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/signs_for_messages.html#requestquerysignsforevidence","title":"<code>RequestQuerySignsForEvidence</code>","text":"<pre><code><pre>type RequestQuerySignsForEvidence :=  mkRequestQuerySignsForEvidence@{    externalIdentity : ExternalIdentity;  };</pre></code></pre> <p>A <code>RequestQuerySignsForEvidence</code> queries all <code>signs_for</code> evidence related to an identity.</p> Arguments <code>externalIdentity</code>: The identity for which to retrieve evidence.","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/signs_for_messages.html#replyquerysignsforevidence","title":"<code>ReplyQuerySignsForEvidence</code>","text":"<pre><code><pre>type ReplyQuerySignsForEvidence :=  mkReplyQuerySignsForEvidence@{    externalIdentity : ExternalIdentity;    evidence : Set SignsForEvidence;    err : Option String;  };</pre></code></pre> <p>A <code>ReplyQuerySignsForEvidence</code> provides the requested evidence.</p> Arguments <code>externalIdentity</code>: The identity for which to retrieve evidence. <code>evidence</code>: A set of <code>SignsForEvidence</code> related to the identity. <code>err</code>: An error message if the query failed.","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/signs_for_messages.html#signsformsg","title":"<code>SignsForMsg</code>","text":"<pre><code><pre>type SignsForMsg :=  | SignsForRequest RequestSignsFor  | SignsForReply ReplySignsFor  | SubmitSignsForEvidenceRequest RequestSubmitSignsForEvidence  | SubmitSignsForEvidenceReply ReplySubmitSignsForEvidence  | QuerySignsForEvidenceRequest RequestQuerySignsForEvidence  | QuerySignsForEvidenceReply ReplyQuerySignsForEvidence;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/signs_for_messages.html#engine-components","title":"Engine components","text":"<ul> <li>SignsFor Configuration</li> <li>SignsFor Environment</li> <li>SignsFor Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","signsfor","message-types"]},{"location":"arch/node/engines/storage.html","title":"Storage Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.storage;import arch.node.engines.storage_messages open public;import arch.node.engines.storage_config open public;import arch.node.engines.storage_environment open public;import arch.node.engines.storage_behaviour open public;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;open storage_config_example;open storage_environment_example;open storage_behaviour_example;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","storage","engine-definition"]},{"location":"arch/node/engines/storage.html#storage-engine","title":"Storage Engine","text":"","tags":["node-architecture","network-subsystem","engine","storage","engine-definition"]},{"location":"arch/node/engines/storage.html#purpose","title":"Purpose","text":"<p>The Storage engine implements distributed object storage. Each stored object is encrypted using convergent encryption with a key derived from the hash of the content and a secret key, then the ciphertext is split into equal-sized parts, and organized in a Merkle-tree.</p> <p>A <code>Chunk</code> is a Merkle-tree node that is stored by nodes in the network. An associated access control list may limit access to the chunk to a set of nodes, e.g. publisher or subscribers of a Topic.</p> <p>Nodes may commit to store a <code>Chunk</code> via a <code>ChunkCommitment</code> sent to a pub/sub Topic or shared directly with certain nodes, and keep track of known commitments by other nodes. This allows nodes to respond to chunk requests with either the chunk itself if available locally, or with a <code>ChunkCommitment</code> by a node that stores the requested chunk.</p>","tags":["node-architecture","network-subsystem","engine","storage","engine-definition"]},{"location":"arch/node/engines/storage.html#engine-components","title":"Engine components","text":"<ul> <li>Storage Messages</li> <li>Storage Configuration</li> <li>Storage Environment</li> <li>Storage Behaviour</li> </ul>","tags":["node-architecture","network-subsystem","engine","storage","engine-definition"]},{"location":"arch/node/engines/storage.html#the-type-for-a-storage-engine","title":"The type for a storage engine","text":"<pre><code><pre>StorageEngine : Type :=  Engine    StorageLocalCfg    StorageLocalState    StorageMailboxState    StorageTimerHandle    StorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","engine-definition"]},{"location":"arch/node/engines/storage.html#example-of-a-storage-engine","title":"Example of a storage engine","text":"<pre><code><pre>exStorageEngine : StorageEngine :=  Engine.mk@{    cfg := exStorageCfg;    env := exStorageEnv;    behaviour := exStorageBehaviour;  };</pre></code></pre> <p>Where <code>exStorageCfg</code> is defined as follows:</p> <pre><code><pre>exStorageCfg : StorageCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"storage\";    cfg := StorageLocalCfg.mk;  };</pre></code></pre> <p><code>exStorageEnv</code> is defined as follows:</p> <pre><code><pre>exStorageEnv : StorageEnv :=  EngineEnv.mk@{    localState := StorageLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>exStorageBehaviour</code> is defined as follows:</p> <pre><code><pre>module storage_behaviour_example;  exStorageBehaviour : StorageBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [exampleReplyGuard];    };end;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","engine-definition"]},{"location":"arch/node/engines/storage_behaviour.html","title":"Storage Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.storage_behaviour;import arch.node.engines.storage_messages open;import arch.node.engines.storage_config open;import arch.node.engines.storage_environment open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#storage-behaviour","title":"Storage Behaviour","text":"","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#overview","title":"Overview","text":"<p>A Storage engine acts in the ways described on this page. The action labels correspond to the actions that can be performed by the engine. Using the action labels, we describe the effects of the actions.</p>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#storage-action-flowchart","title":"Storage Action Flowchart","text":"","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#examplereply-flowchart","title":"<code>exampleReply</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;StorageMsgExampleRequest&lt;br/&gt;from local engine]\n    CEnv[(exampleValue &lt; 10)]\n  end\n\n  G(exampleReplyGuard)\n  A(exampleReplyAction)\n\n  C --&gt; G -- *exampleReplyActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(exampleValue := exampleValue + 1)]\n    EMsg&gt;StorageMsgExampleResponse&lt;br/&gt;argOne]\n  end</code></pre> <code>exampleReply</code> flowchart","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#action-arguments","title":"Action arguments","text":"<p>The action arguments are set by a guard and passed to the action function as part of the <code>GuardOutput</code>.</p>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#storageactionarguments","title":"<code>StorageActionArguments</code>","text":"<pre><code><pre>StorageActionArguments : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#storageaction","title":"<code>StorageAction</code>","text":"<p> <pre><code><pre>StorageAction : Type :=  Action    StorageLocalCfg    StorageLocalState    StorageMailboxState    StorageTimerHandle    StorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#storageactioninput","title":"<code>StorageActionInput</code>","text":"<p> <pre><code><pre>StorageActionInput : Type :=  ActionInput    StorageLocalCfg    StorageLocalState    StorageMailboxState    StorageTimerHandle    StorageActionArguments    Anoma.Msg;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#storageactioneffect","title":"<code>StorageActionEffect</code>","text":"<p> <pre><code><pre>StorageActionEffect : Type :=  ActionEffect    StorageLocalState    StorageMailboxState    StorageTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#storageactionexec","title":"<code>StorageActionExec</code>","text":"<p> <pre><code><pre>StorageActionExec : Type :=  ActionExec    StorageLocalCfg    StorageLocalState    StorageMailboxState    StorageTimerHandle    StorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#examplereplyaction","title":"<code>exampleReplyAction</code>","text":"<p>Respond with a <code>StorageMsgExampleReply</code>.</p> State update The state remains unchanged. Messages to be sent A <code>StorageMsgExampleReply</code> message with the data set by <code>exampleReplyGuard</code>. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>exampleReplyAction (input : StorageActionInput) : Option StorageActionEffect :=  TODO;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#examplereplyactionlabel","title":"<code>exampleReplyActionLabel</code>","text":"<pre><code><pre>exampleReplyActionLabel : StorageActionExec :=  ActionExec.Seq [exampleReplyAction];</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#storageguard","title":"<code>StorageGuard</code>","text":"<p> <pre><code><pre>StorageGuard : Type :=  Guard    StorageLocalCfg    StorageLocalState    StorageMailboxState    StorageTimerHandle    StorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#storageguardoutput","title":"<code>StorageGuardOutput</code>","text":"<p> <pre><code><pre>StorageGuardOutput : Type :=  GuardOutput    StorageLocalCfg    StorageLocalState    StorageMailboxState    StorageTimerHandle    StorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#storageguardeval","title":"<code>StorageGuardEval</code>","text":"<p> <pre><code><pre>StorageGuardEval : Type :=  GuardEval    StorageLocalCfg    StorageLocalState    StorageMailboxState    StorageTimerHandle    StorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#examplereplyguard","title":"<code>exampleReplyGuard</code>","text":"<p>Guard description (optional).</p> Condition Message type is <code>StorageMsgExampleRequest</code>. <pre><code><pre>exampleReplyGuard  (trigger : StorageTimestampedTrigger)  (cfg : StorageCfg)  (env : StorageEnv)  : Option StorageGuardOutput := TODO;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#engine-behaviour","title":"Engine behaviour","text":"","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#storagebehaviour","title":"<code>StorageBehaviour</code>","text":"<pre><code><pre>StorageBehaviour : Type :=  EngineBehaviour    StorageLocalCfg    StorageLocalState    StorageMailboxState    StorageTimerHandle    StorageActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>module storage_behaviour_example;  exStorageBehaviour : StorageBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [exampleReplyGuard];    };end;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","behaviour"]},{"location":"arch/node/engines/storage_config.html","title":"Storage Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.storage_config;import arch.node.engines.storage_messages open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","storage","configuration"]},{"location":"arch/node/engines/storage_config.html#storage-configuration","title":"Storage Configuration","text":"","tags":["node-architecture","network-subsystem","engine","storage","configuration"]},{"location":"arch/node/engines/storage_config.html#overview","title":"Overview","text":"<p>The static configuration of the engine.</p>","tags":["node-architecture","network-subsystem","engine","storage","configuration"]},{"location":"arch/node/engines/storage_config.html#local-configuration","title":"Local Configuration","text":"","tags":["node-architecture","network-subsystem","engine","storage","configuration"]},{"location":"arch/node/engines/storage_config.html#storagelocalcfg","title":"<code>StorageLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type StorageLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","configuration"]},{"location":"arch/node/engines/storage_config.html#engine-configuration","title":"Engine Configuration","text":"","tags":["node-architecture","network-subsystem","engine","storage","configuration"]},{"location":"arch/node/engines/storage_config.html#storagecfg","title":"<code>StorageCfg</code>","text":"<pre><code><pre>StorageCfg : Type := EngineCfg StorageLocalCfg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","configuration"]},{"location":"arch/node/engines/storage_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exStorageCfg : StorageCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"storage\";    cfg := StorageLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","configuration"]},{"location":"arch/node/engines/storage_environment.html","title":"Storage Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.storage_environment;import arch.node.engines.storage_messages open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","storage","environment"]},{"location":"arch/node/engines/storage_environment.html#storage-environment","title":"Storage Environment","text":"","tags":["node-architecture","network-subsystem","engine","storage","environment"]},{"location":"arch/node/engines/storage_environment.html#overview","title":"Overview","text":"<p>The Engine environment of the engine.</p>","tags":["node-architecture","network-subsystem","engine","storage","environment"]},{"location":"arch/node/engines/storage_environment.html#mailbox-state","title":"Mailbox state","text":"","tags":["node-architecture","network-subsystem","engine","storage","environment"]},{"location":"arch/node/engines/storage_environment.html#storagemailboxstate","title":"<code>StorageMailboxState</code>","text":"<pre><code><pre>StorageMailboxState : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","environment"]},{"location":"arch/node/engines/storage_environment.html#local-state","title":"Local state","text":"","tags":["node-architecture","network-subsystem","engine","storage","environment"]},{"location":"arch/node/engines/storage_environment.html#storagelocalstate","title":"<code>StorageLocalState</code>","text":"<pre><code><pre>type StorageLocalState := mk;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","environment"]},{"location":"arch/node/engines/storage_environment.html#timer-handles","title":"Timer handles","text":"","tags":["node-architecture","network-subsystem","engine","storage","environment"]},{"location":"arch/node/engines/storage_environment.html#storagetimerhandle","title":"<code>StorageTimerHandle</code>","text":"<pre><code><pre>StorageTimerHandle : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","environment"]},{"location":"arch/node/engines/storage_environment.html#storagetimestampedtrigger","title":"<code>StorageTimestampedTrigger</code>","text":"<pre><code><pre>StorageTimestampedTrigger : Type :=  TimestampedTrigger StorageTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","environment"]},{"location":"arch/node/engines/storage_environment.html#engine-environment","title":"Engine Environment","text":"","tags":["node-architecture","network-subsystem","engine","storage","environment"]},{"location":"arch/node/engines/storage_environment.html#storageenv","title":"<code>StorageEnv</code>","text":"<pre><code><pre>StorageEnv : Type :=  EngineEnv StorageLocalState StorageMailboxState StorageTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","environment"]},{"location":"arch/node/engines/storage_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exStorageEnv : StorageEnv :=  EngineEnv.mk@{    localState := StorageLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","environment"]},{"location":"arch/node/engines/storage_messages.html","title":"Storage Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.storage_messages;import arch.node.types.storage open;import arch.node.types.basics open;import arch.node.types.crypto open;import arch.node.types.identities open;import arch.node.types.messages open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/storage_messages.html#storage-engine","title":"Storage Engine","text":"","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/storage_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type StorageMsg :=  | ChunkGetRequest ChunkGetRequest  | ChunkGetReply ChunkGetReply  | ChunkPutRequest Chunk  | ChunkPutReply ChunkPutReply;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/storage_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/storage_messages.html#storage-message-sequence-diagram","title":"Storage message sequence diagram","text":"<pre><code>sequenceDiagram</code></pre>  Chunk request &amp; response.","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/storage_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/storage_messages.html#chunkgetrequest","title":"<code>ChunkGetRequest</code>","text":"<p>Request for a chunk of an object.</p> <p>Source: any local engine or remote Storage engine.</p> <pre><code><pre>type ChunkGetRequest :=  mkChunkRequest@{    chunk : ChunkID;    children : Either Bool Nat;  };</pre></code></pre> Arguments <code>chunk</code> Chunk ID <code>children</code> Request children recursively: <p>- <code>False</code>: none,   - <code>True</code>: all,   - <code>Nat</code>: up to nth level.</p>","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/storage_messages.html#chunkgetreply","title":"<code>ChunkGetReply</code>","text":"<p>Reply to a <code>ChunkGetRequest</code>.</p> Auxiliary type <pre><code><pre>ChunkGetReply : Type := Result ChunkGetReplyOk ChunkGetReplyError;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/storage_messages.html#chunkgetreplyok","title":"<code>ChunkGetReplyOk</code>","text":"<p>Chunk found.</p> <p>When available, the chunk contents are returned, otherwise a list of commitments by nodes that store the chunk.</p> <p><pre><code><pre>type ChunkGetReplyOk :=  | ChunkGetReplyOkContent Chunk  | ChunkGetReplyOkCommitment (Set ChunkCommitment);</pre></code></pre></p> <code>ChunkGetReplyOk</code> constructors <code>ChunkGetReplyOkContent</code> Reply with chunk content. <code>ChunkGetReplyOkCommitment</code> Reply with a set of known storage commitments. Each such commitment contains a <code>NodeID</code> that stores the chunk until the time specified. To retrieve the chunk, the requestor should issue another <code>ChunkGetRequest</code> to one of these nodes, trying them in the order of most recently successfully contacted.","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/storage_messages.html#chunkgetreplyerror","title":"<code>ChunkGetReplyError</code>","text":"<p>Chunk not found.</p> <p><pre><code><pre>type ChunkGetReplyError := | ChunkGetReplyErrorNotFound;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/storage_messages.html#chunkputrequest","title":"<code>ChunkPutRequest</code>","text":"<p>Request to store a chunk. May be restricted to local engines.</p> Auxiliary type <pre><code><pre>ChunkPutReply : Type := Result ChunkPutReplyOk ChunkPutReplyError;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/storage_messages.html#chunkputrequestok","title":"<code>ChunkPutRequestOk</code>","text":"<p>Request to store a chunk.</p> <p><pre><code><pre>type ChunkPutRequestOk := | ChunkPutRequestOkSuccess;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/storage_messages.html#chunkputreplyok","title":"<code>ChunkPutReplyOk</code>","text":"<p>Chunk stored successfully or already exists.</p> <p><pre><code><pre>type ChunkPutReplyOk :=  | ChunkPutReplyOkStored  | ChunkPutReplyOkExists;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/storage_messages.html#chunkputreplyerror","title":"<code>ChunkPutReplyError</code>","text":"<p>Failed to store chunk.</p> <p><pre><code><pre>type ChunkPutReplyError := | ChunkPutReplyErrorFailed;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/storage_messages.html#storagemsg","title":"<code>StorageMsg</code>","text":"<p>All storage protocol messages.</p> <pre><code><pre>type StorageMsg :=  | ChunkGetRequest ChunkGetRequest  | ChunkGetReply ChunkGetReply  | ChunkPutRequest Chunk  | ChunkPutReply ChunkPutReply;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/storage_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Storage Configuration</li> <li>Storage Environment</li> <li>Storage Behaviour</li> </ul>","tags":["node-architecture","network-subsystem","engine","storage","message-types"]},{"location":"arch/node/engines/ticker.html","title":"Ticker Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.ticker;import prelude open;import arch.node.types.engine_environment open;import arch.node.types.engine_behaviour open;import arch.node.types.engine open;import arch.node.engines.ticker_config open public;import arch.node.engines.ticker_messages open public;import arch.node.engines.ticker_environment open public;import arch.node.engines.ticker_behaviour open public;import arch.node.types.anoma as Anoma open;open ticker_config_example;open ticker_environment_example;</pre></code></pre></p>","tags":["node-architecture","example","engine","ticker","engine-definition"]},{"location":"arch/node/engines/ticker.html#ticker-engine","title":"Ticker Engine","text":"<p>The Ticker engine provides a simple counter functionality, allowing clients to increment a counter and retrieve its current value.</p>","tags":["node-architecture","example","engine","ticker","engine-definition"]},{"location":"arch/node/engines/ticker.html#purpose","title":"Purpose","text":"<p>A ticker engine maintains a counter in its local state. It increases the counter when it receives an <code>Increment</code> message and provides the updated result upon receiving a <code>Count</code> message. The initial state initializes the counter.</p>","tags":["node-architecture","example","engine","ticker","engine-definition"]},{"location":"arch/node/engines/ticker.html#engine-components","title":"Engine components","text":"<ul> <li>Ticker Messages</li> <li>Ticker Configuration</li> <li>Ticker Environment</li> <li>Ticker Behaviour</li> </ul>","tags":["node-architecture","example","engine","ticker","engine-definition"]},{"location":"arch/node/engines/ticker.html#useful-links","title":"Useful links","text":"<ul> <li>Composable Semantic Models for Actor Theories</li> </ul>","tags":["node-architecture","example","engine","ticker","engine-definition"]},{"location":"arch/node/engines/ticker.html#type","title":"Type","text":"<pre><code><pre>TickerEngine : Type :=  Engine    TickerLocalCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","example","engine","ticker","engine-definition"]},{"location":"arch/node/engines/ticker.html#example-of-a-ticker-engine","title":"Example of a ticker engine","text":"<pre><code><pre>exampleTickerEngine : TickerEngine :=  Engine.mk@{    cfg := tickerCfg;    env := tickerEnv;    behaviour := tickerBehaviour;  };</pre></code></pre> <p>where <code>tickerCfg</code> is defined as follows:</p> <pre><code><pre>tickerCfg : TickerCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"ticker\";    cfg := TickerLocalCfg.mk;  };</pre></code></pre> <p><code>tickerEnv</code> is defined as follows:</p> <pre><code><pre>tickerEnv : TickerEnv :=  EngineEnv.mk@{    localState :=      TickerLocalState.mk@{        counter := 0;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>tickerBehaviour</code> is defined as follows:</p> <pre><code><pre>tickerBehaviour : TickerBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [incrementGuard; countReplyGuard];  };</pre></code></pre>","tags":["node-architecture","example","engine","ticker","engine-definition"]},{"location":"arch/node/engines/ticker_behaviour.html","title":"Ticker Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.ticker_behaviour;import arch.node.engines.ticker_messages open;import arch.node.engines.ticker_config open;import arch.node.engines.ticker_environment open;import prelude open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#ticker-behaviour","title":"Ticker Behaviour","text":"","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#overview","title":"Overview","text":"<p>The Ticker engine maintains a counter as local state and allows two actions: incrementing the counter and sending the current counter value.</p>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickeractionargumentreplyto-replyto","title":"<code>TickerActionArgumentReplyTo ReplyTo</code>","text":"<pre><code><pre>type ReplyTo :=  mkReplyTo@{    whoAsked : Option EngineID;    mailbox : Option MailboxID;  };</pre></code></pre> <p>This action argument contains the address and mailbox ID of where the response message should be sent.</p> Arguments <code>whoAsked</code>: is the address of the engine that sent the message. <code>mailbox</code>: is the mailbox ID where the response message should be sent.","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickeractionargument","title":"<code>TickerActionArgument</code>","text":"<pre><code><pre>type TickerActionArgument := | TickerActionArgumentReplyTo ReplyTo;</pre></code></pre>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickeractionarguments","title":"<code>TickerActionArguments</code>","text":"<pre><code><pre>TickerActionArguments : Type := List TickerActionArgument;</pre></code></pre>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickeraction","title":"<code>TickerAction</code>","text":"<p><pre><code><pre>TickerAction : Type :=  Action    TickerLocalCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickeractioninput","title":"<code>TickerActionInput</code>","text":"<p><pre><code><pre>TickerActionInput : Type :=  ActionInput    TickerLocalCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg;</pre></code></pre></p>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickeractioneffect","title":"<code>TickerActionEffect</code>","text":"<p><pre><code><pre>TickerActionEffect : Type :=  ActionEffect    TickerLocalState    TickerMailboxState    TickerTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickeractionexec","title":"<code>TickerActionExec</code>","text":"<p><pre><code><pre>TickerActionExec : Type :=  ActionExec    TickerLocalCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#incrementaction","title":"<code>incrementAction</code>","text":"<p>Increment the counter.</p> State update The counter value is increased by one. Messages to be sent No messages are added to the send queue. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>incrementAction (input : TickerActionInput) : Option TickerActionEffect :=  let    env := ActionInput.env input;    counterValue := TickerLocalState.counter (EngineEnv.localState env);  in some    ActionEffect.mk@{      env :=        env@EngineEnv{localState := TickerLocalState.mk@{                                      counter := counterValue + 1;                                    }};      msgs := [];      timers := [];      engines := [];    };</pre></code></pre>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#countreplyaction","title":"<code>countReplyAction</code>","text":"<p>Respond with the counter value.</p> State update The state remains unchanged. Messages to be sent A message with the current counter value is sent to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>countReplyAction (input : TickerActionInput) : Option TickerActionEffect :=  let    cfg := ActionInput.cfg input;    env := ActionInput.env input;    trigger := ActionInput.trigger input;    counterValue := TickerLocalState.counter (EngineEnv.localState env);  in case getEngineMsgFromTimestampedTrigger trigger of       | some emsg :=         some           ActionEffect.mk@{             env := env;             msgs :=               [                 EngineMsg.mk@{                   sender := getEngineIDFromEngineCfg cfg;                   target := EngineMsg.sender emsg;                   mailbox := some 0;                   msg :=                     Anoma.Msg.Ticker                       (TickerMsg.CountReply                         CountReply.mkCountReply@{                           counter := counterValue;                         });                 };               ];             timers := [];             engines := [];           }       | _ := none;</pre></code></pre>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#incrementactionlabel","title":"<code>incrementActionLabel</code>","text":"<pre><code><pre>incrementActionLabel : TickerActionExec := ActionExec.Seq [incrementAction];</pre></code></pre>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#countreplyactionlabel","title":"<code>countReplyActionLabel</code>","text":"<pre><code><pre>countReplyActionLabel : TickerActionExec := ActionExec.Seq [countReplyAction];</pre></code></pre>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickerguard","title":"<code>TickerGuard</code>","text":"<p> <pre><code><pre>TickerGuard : Type :=  Guard    TickerLocalCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickerguardoutput","title":"<code>TickerGuardOutput</code>","text":"<p> <pre><code><pre>TickerGuardOutput : Type :=  GuardOutput    TickerLocalCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickerguardeval","title":"<code>TickerGuardEval</code>","text":"<p> <pre><code><pre>TickerGuardEval : Type :=  GuardEval    TickerLocalCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#incrementguard","title":"<code>incrementGuard</code>","text":"Condition Message type is <code>TickerMsgIncrement</code>. <pre><code><pre>incrementGuard  (trigger : TimestampedTrigger TickerTimerHandle Anoma.Msg)  (cfg : TickerCfg)  (env : TickerEnv)  : Option TickerGuardOutput :=  let    emsg := getEngineMsgFromTimestampedTrigger trigger;  in case emsg of       | some EngineMsg.mk@{msg := Anoma.Msg.Ticker TickerMsg.Increment} :=         some           GuardOutput.mk@{             action := incrementActionLabel;             args := [];           }       | _ := none;</pre></code></pre>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#countreplyguard","title":"<code>countReplyGuard</code>","text":"Condition Message type is <code>TickerMsgCountRequest</code>. <pre><code><pre>countReplyGuard  (trigger : TimestampedTrigger TickerTimerHandle Anoma.Msg)  (cfg : TickerCfg)  (env : TickerEnv)  : Option TickerGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{msg := Anoma.Msg.Ticker TickerMsg.CountRequest} :=      some        GuardOutput.mk@{          action := countReplyActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#the-ticker-behaviour","title":"The Ticker behaviour","text":"","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickerbehaviour","title":"<code>TickerBehaviour</code>","text":"<pre><code><pre>TickerBehaviour : Type :=  EngineBehaviour    TickerLocalCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>tickerBehaviour : TickerBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [incrementGuard; countReplyGuard];  };</pre></code></pre>","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#ticker-action-flowchart","title":"Ticker Action Flowchart","text":"","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#incrementaction-flowchart","title":"<code>incrementAction</code> flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;TickerMsgIncrement]\n  end\n\n  G(incrementGuard)\n  A(incrementAction)\n\n  C --&gt; G -- *incrementActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(counter := counter + 1)]\n  end</code></pre> <code>incrementAction</code> flowchart","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#countreplyaction-flowchart","title":"<code>countReplyAction</code> flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;TickerMsgCountRequest]\n  end\n\n  G(countReplyGuard)\n  A(countReplyAction)\n\n  C --&gt; G -- *countReplyActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EMsg&gt;TickerMsgCountReply&lt;br/&gt;counter]\n  end</code></pre> <code>countReplyAction</code> flowchart","tags":["node-architecture","example","engine","ticker","behaviour"]},{"location":"arch/node/engines/ticker_config.html","title":"Ticker Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.ticker_config;import prelude open;import arch.node.engines.ticker_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","example","engine","ticker","configuration"]},{"location":"arch/node/engines/ticker_config.html#ticker-configuration","title":"Ticker Configuration","text":"","tags":["node-architecture","example","engine","ticker","configuration"]},{"location":"arch/node/engines/ticker_config.html#overview","title":"Overview","text":"<p>The static configuration of the engine.</p>","tags":["node-architecture","example","engine","ticker","configuration"]},{"location":"arch/node/engines/ticker_config.html#the-ticker-local-configuration","title":"The Ticker Local Configuration","text":"","tags":["node-architecture","example","engine","ticker","configuration"]},{"location":"arch/node/engines/ticker_config.html#tickerlocalcfg","title":"<code>TickerLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type TickerLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","example","engine","ticker","configuration"]},{"location":"arch/node/engines/ticker_config.html#the-ticker-configuration","title":"The Ticker Configuration","text":"","tags":["node-architecture","example","engine","ticker","configuration"]},{"location":"arch/node/engines/ticker_config.html#tickercfg","title":"<code>TickerCfg</code>","text":"<pre><code><pre>TickerCfg : Type := EngineCfg TickerLocalCfg;</pre></code></pre>","tags":["node-architecture","example","engine","ticker","configuration"]},{"location":"arch/node/engines/ticker_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>tickerCfg : TickerCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"ticker\";    cfg := TickerLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","example","engine","ticker","configuration"]},{"location":"arch/node/engines/ticker_environment.html","title":"Ticker Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.ticker_environment;import prelude open;import arch.node.types.basics open;import arch.node.engines.ticker_messages open;import arch.node.types.engine_environment open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","example","engine","ticker","environment"]},{"location":"arch/node/engines/ticker_environment.html#overview","title":"Overview","text":"<p>The sole data item of the ticker environment that deserves mention is the counter; we do not need timers, or mailbox state.</p>","tags":["node-architecture","example","engine","ticker","environment"]},{"location":"arch/node/engines/ticker_environment.html#mailbox-states","title":"Mailbox states","text":"<pre><code><pre>syntax alias TickerMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","example","engine","ticker","environment"]},{"location":"arch/node/engines/ticker_environment.html#local-state","title":"Local state","text":"<pre><code><pre>type TickerLocalState :=  mk@{    counter : Nat;  };</pre></code></pre> Arguments <code>counter</code>: The counter value.","tags":["node-architecture","example","engine","ticker","environment"]},{"location":"arch/node/engines/ticker_environment.html#timer-handle","title":"Timer Handle","text":"<pre><code><pre>syntax alias TickerTimerHandle := Unit;</pre></code></pre> <p>The ticker does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>","tags":["node-architecture","example","engine","ticker","environment"]},{"location":"arch/node/engines/ticker_environment.html#timestamped-trigger","title":"Timestamped Trigger","text":"<pre><code><pre>TickerTimestampedTrigger : Type :=  TimestampedTrigger TickerTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","example","engine","ticker","environment"]},{"location":"arch/node/engines/ticker_environment.html#the-ticker-environment","title":"The Ticker Environment","text":"","tags":["node-architecture","example","engine","ticker","environment"]},{"location":"arch/node/engines/ticker_environment.html#tickerenv","title":"<code>TickerEnv</code>","text":"<pre><code><pre>TickerEnv : Type :=  EngineEnv TickerLocalState TickerMailboxState TickerTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","example","engine","ticker","environment"]},{"location":"arch/node/engines/ticker_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>tickerEnv : TickerEnv :=  EngineEnv.mk@{    localState :=      TickerLocalState.mk@{        counter := 0;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","example","engine","ticker","environment"]},{"location":"arch/node/engines/ticker_messages.html","title":"Ticker Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.ticker_messages;import prelude open;</pre></code></pre></p>","tags":["node-architecture","example","engine","ticker","message-types"]},{"location":"arch/node/engines/ticker_messages.html#ticker-messages","title":"Ticker Messages","text":"","tags":["node-architecture","example","engine","ticker","message-types"]},{"location":"arch/node/engines/ticker_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type TickerMsg :=  | Increment  | CountRequest  | CountReply CountReply;</pre></code></pre>","tags":["node-architecture","example","engine","ticker","message-types"]},{"location":"arch/node/engines/ticker_messages.html#message-sequence-diagram","title":"Message sequence diagram","text":"","tags":["node-architecture","example","engine","ticker","message-types"]},{"location":"arch/node/engines/ticker_messages.html#requesting-a-counter-value","title":"Requesting a counter value","text":"<pre><code>sequenceDiagram\n    participant Ticker\n    participant EngineTickerClient\n\n    EngineTickerClient -&gt;&gt; Ticker: Send TickerMsgIncrement\n    Note over Ticker: Counter = 1\n\n    EngineTickerClient -&gt;&gt; Ticker: Send TickerMsgIncrement\n    Note over Ticker: Counter = 2\n\n    EngineTickerClient -&gt;&gt; Ticker: Send TickerMsgCount\n    Ticker -&gt;&gt; EngineTickerClient: Respond with Counter (2)</code></pre>  A client interacts with the <code>Ticker</code> engine, which increments and responds with the counter value.","tags":["node-architecture","example","engine","ticker","message-types"]},{"location":"arch/node/engines/ticker_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","example","engine","ticker","message-types"]},{"location":"arch/node/engines/ticker_messages.html#tickermsgincrement","title":"<code>TickerMsgIncrement</code>","text":"<p>A <code>TickerMsgIncrement</code> message instructs the engine to increase the counter. This message doesn't require any arguments.</p>","tags":["node-architecture","example","engine","ticker","message-types"]},{"location":"arch/node/engines/ticker_messages.html#tickermsgcountrequest","title":"<code>TickerMsgCountRequest</code>","text":"<p>A <code>TickerMsgCountRequest</code> message requests the engine to send the current counter value back to the requester. This message doesn't require any arguments.</p>","tags":["node-architecture","example","engine","ticker","message-types"]},{"location":"arch/node/engines/ticker_messages.html#countreply","title":"<code>CountReply</code>","text":"<p>The <code>CountReply</code> payload contains the counter value.</p> <pre><code><pre>type CountReply : Type :=  mkCountReply@{    counter : Nat;  };</pre></code></pre> Arguments <code>counter</code> The counter value.","tags":["node-architecture","example","engine","ticker","message-types"]},{"location":"arch/node/engines/ticker_messages.html#tickermsg","title":"<code>TickerMsg</code>","text":"<pre><code><pre>type TickerMsg :=  | Increment  | CountRequest  | CountReply CountReply;</pre></code></pre>","tags":["node-architecture","example","engine","ticker","message-types"]},{"location":"arch/node/engines/ticker_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Ticker Configuration</li> <li>Ticker Environment</li> <li>Ticker Behaviour</li> </ul>","tags":["node-architecture","example","engine","ticker","message-types"]},{"location":"arch/node/engines/transport.html","title":"Transport","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.transport;import arch.node.engines.transport_messages open;import arch.node.engines.transport_config open;import arch.node.engines.transport_environment open;import arch.node.engines.transport_behaviour open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;open transport_config_example;open transport_environment_example;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","transport","engine-definition"]},{"location":"arch/node/engines/transport.html#transport-engine","title":"Transport Engine","text":"","tags":["node-architecture","network-subsystem","engine","transport","engine-definition"]},{"location":"arch/node/engines/transport.html#purpose","title":"Purpose","text":"<p>The Transport engine is responsible for establishing and accepting transport connections via one of the Transport Protocol engines, each of which responsible for a specific transport protocol, such as QUIC or TLS.</p>","tags":["node-architecture","network-subsystem","engine","transport","engine-definition"]},{"location":"arch/node/engines/transport.html#engine-components","title":"Engine components","text":"<ul> <li>Transport Messages</li> <li>Transport Config</li> <li>Transport Environment</li> <li>Transport Behaviour</li> </ul>","tags":["node-architecture","network-subsystem","engine","transport","engine-definition"]},{"location":"arch/node/engines/transport.html#the-type-for-a-transport-engine","title":"The type for a transport engine","text":"<pre><code><pre>TransportEngine : Type :=  Engine    TransportLocalCfg    TransportLocalState    TransportMailboxState    TransportTimerHandle    TransportActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","engine-definition"]},{"location":"arch/node/engines/transport.html#instantiation","title":"Instantiation","text":"<pre><code><pre>transportEngine : TransportEngine :=  Engine.mk@{    cfg := transportCfg;    env := transportEnv;    behaviour := transportBehaviour;  };</pre></code></pre> <p>Where <code>transportCfg</code> is defined as follows:</p> <pre><code><pre>transportCfg : TransportCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"transport\";    cfg := TransportLocalCfg.mk;  };</pre></code></pre> <p><code>transportEnv</code> is defined as follows:</p> <pre><code><pre>transportEnv : TransportEnv :=  EngineEnv.mk@{    localState := TransportLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>transportBehaviour</code> is defined as follows:</p> <pre><code><pre>transportBehaviour : TransportBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [exampleReplyGuard];  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","engine-definition"]},{"location":"arch/node/engines/transport_behaviour.html","title":"Transport behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.transport_behaviour;import arch.node.engines.transport_messages open;import arch.node.engines.transport_config open;import arch.node.engines.transport_environment open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#transport-behaviour","title":"Transport Behaviour","text":"","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#overview","title":"Overview","text":"<p>A transport engine acts in the ways described on this page. The action labels correspond to the actions that can be performed by the engine. Using the action labels, we describe the effects of the actions.</p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#transport-action-flowchart","title":"Transport Action Flowchart","text":"","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#examplereply-flowchart","title":"<code>exampleReply</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;TransportMsgExampleRequest&lt;br/&gt;from local engine]\n    CEnv[(exampleValue &lt; 10)]\n  end\n\n  G(exampleReplyGuard)\n  A(exampleReplyAction)\n\n  C --&gt; G -- *exampleReplyActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(exampleValue := exampleValue + 1)]\n    EMsg&gt;TransportMsgExampleResponse&lt;br/&gt;argOne]\n  end</code></pre> <code>exampleReply</code> flowchart","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#action-arguments","title":"Action arguments","text":"<p>The action arguments are set by a guard and passed to the action function as part of the <code>GuardOutput</code>.</p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#transportactionarguments","title":"<code>TransportActionArguments</code>","text":"<pre><code><pre>TransportActionArguments : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#transportaction","title":"<code>TransportAction</code>","text":"<p> <pre><code><pre>TransportAction : Type :=  Action    TransportLocalCfg    TransportLocalState    TransportMailboxState    TransportTimerHandle    TransportActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#transportactioninput","title":"<code>TransportActionInput</code>","text":"<p> <pre><code><pre>TransportActionInput : Type :=  ActionInput    TransportLocalCfg    TransportLocalState    TransportMailboxState    TransportTimerHandle    TransportActionArguments    Anoma.Msg;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#transportactioneffect","title":"<code>TransportActionEffect</code>","text":"<p> <pre><code><pre>TransportActionEffect : Type :=  ActionEffect    TransportLocalState    TransportMailboxState    TransportTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#transportactionexec","title":"<code>TransportActionExec</code>","text":"<p> <pre><code><pre>TransportActionExec : Type :=  ActionExec    TransportLocalCfg    TransportLocalState    TransportMailboxState    TransportTimerHandle    TransportActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#examplereplyaction","title":"<code>exampleReplyAction</code>","text":"<p>Respond with a <code>TransportMsgExampleReply</code>.</p> State update The state remains unchanged. Messages to be sent A <code>TransportMsgExampleReply</code> message with the data set by <code>exampleReplyGuard</code>. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>exampleReplyAction  (input : TransportActionInput) : Option TransportActionEffect := TODO;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#examplereplyactionlabel","title":"<code>exampleReplyActionLabel</code>","text":"<pre><code><pre>exampleReplyActionLabel : TransportActionExec :=  ActionExec.Seq [exampleReplyAction];</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#transportguard","title":"<code>TransportGuard</code>","text":"<p> <pre><code><pre>TransportGuard : Type :=  Guard    TransportLocalCfg    TransportLocalState    TransportMailboxState    TransportTimerHandle    TransportActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#transportguardoutput","title":"<code>TransportGuardOutput</code>","text":"<p> <pre><code><pre>TransportGuardOutput : Type :=  GuardOutput    TransportLocalCfg    TransportLocalState    TransportMailboxState    TransportTimerHandle    TransportActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#transportguardeval","title":"<code>TransportGuardEval</code>","text":"<p> <pre><code><pre>TransportGuardEval : Type :=  GuardEval    TransportLocalCfg    TransportLocalState    TransportMailboxState    TransportTimerHandle    TransportActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#examplereplyguard","title":"<code>exampleReplyGuard</code>","text":"<p>Guard description (optional).</p> Condition Message type is <code>TransportMsgExampleRequest</code>. <pre><code><pre>exampleReplyGuard  (trigger : TransportTimestampedTrigger)  (cfg : TransportCfg)  (env : TransportEnv)  : Option TransportGuardOutput := TODO;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#the-transport-behaviour","title":"The Transport behaviour","text":"","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#transportbehaviour","title":"<code>TransportBehaviour</code>","text":"<pre><code><pre>TransportBehaviour : Type :=  EngineBehaviour    TransportLocalCfg    TransportLocalState    TransportMailboxState    TransportTimerHandle    TransportActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>transportBehaviour : TransportBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [exampleReplyGuard];  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_config.html","title":"Transport config","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.transport_config;import arch.node.engines.transport_messages open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_config.html#transport-configuration","title":"Transport Configuration","text":"","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_config.html#overview","title":"Overview","text":"<p>The static configuration of the engine.</p>","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_config.html#the-transport-local-configuration","title":"The Transport Local Configuration","text":"","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_config.html#transportlocalcfg","title":"<code>TransportLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type TransportLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_config.html#the-transport-configuration","title":"The Transport Configuration","text":"","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_config.html#transportcfg","title":"<code>TransportCfg</code>","text":"<pre><code><pre>TransportCfg : Type := EngineCfg TransportLocalCfg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>transportCfg : TransportCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"transport\";    cfg := TransportLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_connection.html","title":"Transport Connection Engine","text":"<p>icon: octicons/gear-24 search:   exclude: false tags:   - node-architecture   - network-subsystem   - engine   - transport   - engine-definition</p> Juvix imports <p><pre><code><pre>module arch.node.engines.transport_connection;import arch.node.engines.transport_connection_messages open;import arch.node.engines.transport_connection_config open;import arch.node.engines.transport_connection_environment open;import arch.node.engines.transport_connection_behaviour open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;open transport_connection_config_example;open transport_connection_environment_example;open transport_connection_behaviour_example;</pre></code></pre></p>"},{"location":"arch/node/engines/transport_connection.html#transport-connection-engine","title":"Transport Connection Engine","text":""},{"location":"arch/node/engines/transport_connection.html#purpose","title":"Purpose","text":"<p>A Transport Protocol engine is responsible for accepting and initiating transport connections for one specific transport protocol, such as QUIC or TLS.</p>"},{"location":"arch/node/engines/transport_connection.html#engine-components","title":"Engine components","text":"<ul> <li>Transport Connection Messages</li> <li>Transport Connection Configuration</li> <li>Transport Connection Environment</li> <li>Transport Connection Behaviour</li> </ul>"},{"location":"arch/node/engines/transport_connection.html#the-type-for-a-transport-connection-engine","title":"The type for a transport connection engine","text":"<pre><code><pre>TransportConnectionEngine : Type :=  Engine    TransportConnectionLocalCfg    TransportConnectionLocalState    TransportConnectionMailboxState    TransportConnectionTimerHandle    TransportConnectionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>"},{"location":"arch/node/engines/transport_connection.html#example-of-a-transport-connection-engine","title":"Example of a transport connection engine","text":"<pre><code><pre>exTransportConnectionEngine : TransportConnectionEngine :=  Engine.mk@{    cfg := exTransportConnectionCfg;    env := exTransportConnectionEnv;    behaviour := exTransportConnectionBehaviour;  };</pre></code></pre> <p>Where <code>exTransportConnectionCfg</code> is defined as follows:</p> <pre><code><pre>exTransportConnectionCfg : TransportConnectionCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"transport-connection\";    cfg := TransportConnectionLocalCfg.mk;  };</pre></code></pre> <p><code>exTransportConnectionEnv</code> is defined as follows:</p> <pre><code><pre>exTransportConnectionEnv : TransportConnectionEnv :=  EngineEnv.mk@{    localState := TransportConnectionLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>exTransportConnectionBehaviour</code> is defined as follows:</p> <pre><code><pre>module transport_connection_behaviour_example;  exTransportConnectionBehaviour : TransportConnectionBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [exampleReplyGuard];    };end;</pre></code></pre>"},{"location":"arch/node/engines/transport_connection_behaviour.html","title":"Transport Connection Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.transport_connection_behaviour;import arch.node.engines.transport_connection_messages open;import arch.node.engines.transport_connection_config open;import arch.node.engines.transport_connection_environment open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#transport-connection-behaviour","title":"Transport Connection Behaviour","text":"","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#overview","title":"Overview","text":"<p>A Transport Connection engine acts in the ways described on this page. The action labels correspond to the actions that can be performed by the engine. Using the action labels, we describe the effects of the actions.</p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#transport-connection-action-flowchart","title":"Transport Connection Action Flowchart","text":"","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#examplereply-flowchart","title":"<code>exampleReply</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;TransportConnectionMsgExampleRequest&lt;br/&gt;from local engine]\n    CEnv[(exampleValue &lt; 10)]\n  end\n\n  G(exampleReplyGuard)\n  A(exampleReplyAction)\n\n  C --&gt; G -- *exampleReplyActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(exampleValue := exampleValue + 1)]\n    EMsg&gt;TransportConnectionMsgExampleResponse&lt;br/&gt;argOne]\n  end</code></pre> <code>exampleReply</code> flowchart","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#action-arguments","title":"Action arguments","text":"<p>The action arguments are set by a guard and passed to the action function as part of the <code>GuardOutput</code>.</p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#transportconnectionactionarguments","title":"<code>TransportConnectionActionArguments</code>","text":"<pre><code><pre>TransportConnectionActionArguments : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#transportconnectionaction","title":"<code>TransportConnectionAction</code>","text":"<p> <pre><code><pre>TransportConnectionAction : Type :=  Action    TransportConnectionLocalCfg    TransportConnectionLocalState    TransportConnectionMailboxState    TransportConnectionTimerHandle    TransportConnectionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#transportconnectionactioninput","title":"<code>TransportConnectionActionInput</code>","text":"<p> <pre><code><pre>TransportConnectionActionInput : Type :=  ActionInput    TransportConnectionLocalCfg    TransportConnectionLocalState    TransportConnectionMailboxState    TransportConnectionTimerHandle    TransportConnectionActionArguments    Anoma.Msg;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#transportconnectionactioneffect","title":"<code>TransportConnectionActionEffect</code>","text":"<p> <pre><code><pre>TransportConnectionActionEffect : Type :=  ActionEffect    TransportConnectionLocalState    TransportConnectionMailboxState    TransportConnectionTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#transportconnectionactionexec","title":"<code>TransportConnectionActionExec</code>","text":"<p> <pre><code><pre>TransportConnectionActionExec : Type :=  ActionExec    TransportConnectionLocalCfg    TransportConnectionLocalState    TransportConnectionMailboxState    TransportConnectionTimerHandle    TransportConnectionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#examplereplyaction","title":"<code>exampleReplyAction</code>","text":"<p>Respond with a <code>TransportConnectionMsgExampleReply</code>.</p> State update The state remains unchanged. Messages to be sent A <code>TransportConnectionMsgExampleReply</code> message with the data set by <code>exampleReplyGuard</code>. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>exampleReplyAction  (input : TransportConnectionActionInput)  : Option TransportConnectionActionEffect := TODO;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#examplereplyactionlabel","title":"<code>exampleReplyActionLabel</code>","text":"<pre><code><pre>exampleReplyActionLabel : TransportConnectionActionExec :=  ActionExec.Seq [exampleReplyAction];</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#transportconnectionguard","title":"<code>TransportConnectionGuard</code>","text":"<p> <pre><code><pre>TransportConnectionGuard : Type :=  Guard    TransportConnectionLocalCfg    TransportConnectionLocalState    TransportConnectionMailboxState    TransportConnectionTimerHandle    TransportConnectionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#transportconnectionguardoutput","title":"<code>TransportConnectionGuardOutput</code>","text":"<p> <pre><code><pre>TransportConnectionGuardOutput : Type :=  GuardOutput    TransportConnectionLocalCfg    TransportConnectionLocalState    TransportConnectionMailboxState    TransportConnectionTimerHandle    TransportConnectionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#transportconnectionguardeval","title":"<code>TransportConnectionGuardEval</code>","text":"<p> <pre><code><pre>TransportConnectionGuardEval : Type :=  GuardEval    TransportConnectionLocalCfg    TransportConnectionLocalState    TransportConnectionMailboxState    TransportConnectionTimerHandle    TransportConnectionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#examplereplyguard","title":"<code>exampleReplyGuard</code>","text":"<p>Guard description (optional).</p> Condition Message type is <code>TransportConnectionMsgExampleRequest</code>. <pre><code><pre>exampleReplyGuard  (trigger : TransportConnectionTimestampedTrigger)  (cfg : TransportConnectionCfg)  (env : TransportConnectionEnv)  : Option TransportConnectionGuardOutput := TODO;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#the-transport-connection-behaviour","title":"The Transport Connection behaviour","text":"","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#transportconnectionbehaviour","title":"<code>TransportConnectionBehaviour</code>","text":"<pre><code><pre>TransportConnectionBehaviour : Type :=  EngineBehaviour    TransportConnectionLocalCfg    TransportConnectionLocalState    TransportConnectionMailboxState    TransportConnectionTimerHandle    TransportConnectionActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>module transport_connection_behaviour_example;  exTransportConnectionBehaviour : TransportConnectionBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [exampleReplyGuard];    };end;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_connection_config.html","title":"Transport Connection Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.transport_connection_config;import arch.node.engines.transport_connection_messages open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_connection_config.html#transport-connection-configuration","title":"Transport Connection Configuration","text":"","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_connection_config.html#overview","title":"Overview","text":"<p>The static configuration of the engine.</p>","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_connection_config.html#the-transport-connection-local-configuration","title":"The Transport Connection Local Configuration","text":"","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_connection_config.html#transportconnectionlocalcfg","title":"<code>TransportConnectionLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type TransportConnectionLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_connection_config.html#the-transport-connection-configuration","title":"The Transport Connection Configuration","text":"","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_connection_config.html#transportconnectioncfg","title":"<code>TransportConnectionCfg</code>","text":"<pre><code><pre>TransportConnectionCfg : Type := EngineCfg TransportConnectionLocalCfg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_connection_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exTransportConnectionCfg : TransportConnectionCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"transport-connection\";    cfg := TransportConnectionLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_connection_environment.html","title":"Transport Connection Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.transport_connection_environment;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_connection_environment.html#transport-connection-environment","title":"Transport Connection Environment","text":"","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_connection_environment.html#overview","title":"Overview","text":"<p>The Engine environment of the engine.</p>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_connection_environment.html#mailbox-states","title":"Mailbox states","text":"<pre><code><pre>syntax alias TransportConnectionMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_connection_environment.html#local-state","title":"Local state","text":"<pre><code><pre>type TransportConnectionLocalState := mk;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_connection_environment.html#timer-handle","title":"Timer Handle","text":"<pre><code><pre>TransportConnectionTimerHandle : Type := Unit;</pre></code></pre> <p>The TransportConnection does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_connection_environment.html#timestamped-trigger","title":"Timestamped Trigger","text":"<pre><code><pre>TransportConnectionTimestampedTrigger : Type :=  TimestampedTrigger TransportConnectionTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_connection_environment.html#the-transport-connection-environment","title":"The Transport Connection Environment","text":"","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_connection_environment.html#transportconnectionenv","title":"<code>TransportConnectionEnv</code>","text":"<pre><code><pre>TransportConnectionEnv : Type :=  EngineEnv    TransportConnectionLocalState    TransportConnectionMailboxState    TransportConnectionTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_connection_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exTransportConnectionEnv : TransportConnectionEnv :=  EngineEnv.mk@{    localState := TransportConnectionLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_connection_messages.html","title":"Transport Connection Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.transport_connection_messages;import arch.node.engines.router_messages open;import arch.node.types.transport open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_connection_messages.html#transport-connection-messages","title":"Transport Connection Messages","text":"<p>These are the messages that the Transport Connection engine can receive.</p>","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_connection_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type TransportConnectionMsg := | Send TransportConnectionOutMsg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_connection_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_connection_messages.html#transportconnectionoutmsg","title":"<code>TransportConnectionOutMsg</code>","text":"<p>Send a message to the remote node via the established connection.</p> <pre><code><pre>type TransportConnectionOutMsg :=  mkTransportConnectionOutMsg@{    expiry : Time;    msg : NodeMsg;  };</pre></code></pre> Arguments <code>expiry</code>: Time after which the message expires. <code>msg</code>: The message to send.","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_connection_messages.html#transportconnectionmsg","title":"<code>TransportConnectionMsg</code>","text":"<pre><code><pre>type TransportConnectionMsg := | Send TransportConnectionOutMsg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_connection_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Transport Connection Configuration</li> <li>Transport Connection Environment</li> <li>Transport Connection Behaviour</li> </ul>","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_environment.html","title":"Transport environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.transport_environment;import arch.node.engines.transport_messages open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_environment.html#transport-environment","title":"Transport Environment","text":"","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_environment.html#overview","title":"Overview","text":"<p>The Engine environment of the engine.</p>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_environment.html#mailbox-state","title":"Mailbox state","text":"","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_environment.html#transportmailboxstate","title":"<code>TransportMailboxState</code>","text":"<pre><code><pre>TransportMailboxState : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_environment.html#local-state","title":"Local state","text":"","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_environment.html#transportlocalstate","title":"<code>TransportLocalState</code>","text":"<pre><code><pre>type TransportLocalState := mk;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_environment.html#timer-handles","title":"Timer handles","text":"","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_environment.html#transporttimerhandle","title":"<code>TransportTimerHandle</code>","text":"<pre><code><pre>TransportTimerHandle : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_environment.html#transporttimestampedtrigger","title":"<code>TransportTimestampedTrigger</code>","text":"<pre><code><pre>TransportTimestampedTrigger : Type :=  TimestampedTrigger TransportTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_environment.html#the-transport-environment","title":"The Transport Environment","text":"","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_environment.html#transportenv","title":"<code>TransportEnv</code>","text":"<pre><code><pre>TransportEnv : Type :=  EngineEnv    TransportLocalState    TransportMailboxState    TransportTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>transportEnv : TransportEnv :=  EngineEnv.mk@{    localState := TransportLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_messages.html","title":"Transport messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.transport_messages;import arch.node.types.transport open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_messages.html#transport-messages","title":"Transport Messages","text":"<p>These are the messages that the Transport engine can receive.</p>","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type TransportMsg := | Send TransportOutMsg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_messages.html#transportoutmsg","title":"<code>TransportOutMsg</code>","text":"<p>Send a message to a remote node via the given transport address.</p> <p>The Transport Protocol engine forwards the given message to the Transport Protocol engine responsible for the protocol of the given transport address.</p> <pre><code><pre>type TransportOutMsg :=  mkTransportOutMsg@{    addr : TransportAddress;    msg : ByteString;  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_messages.html#transportmsg","title":"<code>TransportMsg</code>","text":"<pre><code><pre>type TransportMsg := | Send TransportOutMsg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_protocol.html","title":"Transport Protocol Engine","text":"<p>icon: octicons/gear-24 search:   exclude: false tags:   - node-architecture   - network-subsystem   - engine   - transport   - engine-definition</p> Juvix imports <p><pre><code><pre>module arch.node.engines.transport_protocol;import arch.node.engines.transport_protocol_messages open;import arch.node.engines.transport_protocol_config open;import arch.node.engines.transport_protocol_environment open;import arch.node.engines.transport_protocol_behaviour open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;open transport_protocol_config_example;open transport_protocol_environment_example;open transport_protocol_behaviour_example;</pre></code></pre></p>"},{"location":"arch/node/engines/transport_protocol.html#transport-protocol-engine","title":"Transport Protocol Engine","text":""},{"location":"arch/node/engines/transport_protocol.html#purpose","title":"Purpose","text":"<p>A Transport Protocol engine is responsible for accepting and initiating transport connections for one specific transport protocol, such as QUIC or TLS.</p>"},{"location":"arch/node/engines/transport_protocol.html#engine-components","title":"Engine components","text":"<ul> <li>Transport Protocol Messages</li> <li>Transport Protocol Configuration</li> <li>Transport Protocol Environment</li> <li>Transport Protocol Behaviour</li> </ul>"},{"location":"arch/node/engines/transport_protocol.html#the-type-for-a-transport-protocol-engine","title":"The type for a transport protocol engine","text":"<pre><code><pre>TransportProtocolEngine : Type :=  Engine    TransportProtocolLocalCfg    TransportProtocolLocalState    TransportProtocolMailboxState    TransportProtocolTimerHandle    TransportProtocolActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>"},{"location":"arch/node/engines/transport_protocol.html#example-of-a-transport-protocol-engine","title":"Example of a transport protocol engine","text":"<pre><code><pre>exTransportProtocolEngine : TransportProtocolEngine :=  Engine.mk@{    cfg := exTransportProtocolCfg;    env := exTransportProtocolEnv;    behaviour := exTransportProtocolBehaviour;  };</pre></code></pre> <p>Where <code>exTransportProtocolCfg</code> is defined as follows:</p> <pre><code><pre>exTransportProtocolCfg : TransportProtocolCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"transport-protocol\";    cfg := TransportProtocolLocalCfg.mk;  };</pre></code></pre> <p><code>exTransportProtocolEnv</code> is defined as follows:</p> <pre><code><pre>exTransportProtocolEnv : TransportProtocolEnv :=  EngineEnv.mk@{    localState := TransportProtocolLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>exTransportProtocolBehaviour</code> is defined as follows:</p> <pre><code><pre>module transport_protocol_behaviour_example;  exTransportProtocolBehaviour : TransportProtocolBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [exampleReplyGuard];    };end;</pre></code></pre>"},{"location":"arch/node/engines/transport_protocol_behaviour.html","title":"Transport Protocol Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.transport_protocol_behaviour;import arch.node.engines.transport_protocol_messages open;import arch.node.engines.transport_protocol_config open;import arch.node.engines.transport_protocol_environment open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#transport-protocol-behaviour","title":"Transport Protocol Behaviour","text":"","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#overview","title":"Overview","text":"<p>A Transport Protocol engine acts in the ways described on this page. The action labels correspond to the actions that can be performed by the engine. Using the action labels, we describe the effects of the actions.</p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#transport-protocol-action-flowchart","title":"Transport Protocol Action Flowchart","text":"","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#examplereply-flowchart","title":"<code>exampleReply</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;TransportProtocolMsgExampleRequest&lt;br/&gt;from local engine]\n    CEnv[(exampleValue &lt; 10)]\n  end\n\n  G(exampleReplyGuard)\n  A(exampleReplyAction)\n\n  C --&gt; G -- *exampleReplyActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(exampleValue := exampleValue + 1)]\n    EMsg&gt;TransportProtocolMsgExampleResponse&lt;br/&gt;argOne]\n  end</code></pre> <code>exampleReply</code> flowchart","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#action-arguments","title":"Action arguments","text":"<p>The action arguments are set by a guard and passed to the action function as part of the <code>GuardOutput</code>.</p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#transportprotocolactionarguments","title":"<code>TransportProtocolActionArguments</code>","text":"<pre><code><pre>TransportProtocolActionArguments : Type := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#transportprotocolaction","title":"<code>TransportProtocolAction</code>","text":"<p> <pre><code><pre>TransportProtocolAction : Type :=  Action    TransportProtocolLocalCfg    TransportProtocolLocalState    TransportProtocolMailboxState    TransportProtocolTimerHandle    TransportProtocolActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#transportprotocolactioninput","title":"<code>TransportProtocolActionInput</code>","text":"<p> <pre><code><pre>TransportProtocolActionInput : Type :=  ActionInput    TransportProtocolLocalCfg    TransportProtocolLocalState    TransportProtocolMailboxState    TransportProtocolTimerHandle    TransportProtocolActionArguments    Anoma.Msg;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#transportprotocolactioneffect","title":"<code>TransportProtocolActionEffect</code>","text":"<p> <pre><code><pre>TransportProtocolActionEffect : Type :=  ActionEffect    TransportProtocolLocalState    TransportProtocolMailboxState    TransportProtocolTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#transportprotocolactionexec","title":"<code>TransportProtocolActionExec</code>","text":"<p> <pre><code><pre>TransportProtocolActionExec : Type :=  ActionExec    TransportProtocolLocalCfg    TransportProtocolLocalState    TransportProtocolMailboxState    TransportProtocolTimerHandle    TransportProtocolActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#examplereplyaction","title":"<code>exampleReplyAction</code>","text":"<p>Respond with a <code>TransportProtocolMsgExampleReply</code>.</p> State update The state remains unchanged. Messages to be sent A <code>TransportProtocolMsgExampleReply</code> message with the data set by <code>exampleReplyGuard</code>. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>exampleReplyAction  (input : TransportProtocolActionInput)  : Option TransportProtocolActionEffect := TODO;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#examplereplyactionlabel","title":"<code>exampleReplyActionLabel</code>","text":"<pre><code><pre>exampleReplyActionLabel : TransportProtocolActionExec :=  ActionExec.Seq [exampleReplyAction];</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#transportprotocolguard","title":"<code>TransportProtocolGuard</code>","text":"<p> <pre><code><pre>TransportProtocolGuard : Type :=  Guard    TransportProtocolLocalCfg    TransportProtocolLocalState    TransportProtocolMailboxState    TransportProtocolTimerHandle    TransportProtocolActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#transportprotocolguardoutput","title":"<code>TransportProtocolGuardOutput</code>","text":"<p> <pre><code><pre>TransportProtocolGuardOutput : Type :=  GuardOutput    TransportProtocolLocalCfg    TransportProtocolLocalState    TransportProtocolMailboxState    TransportProtocolTimerHandle    TransportProtocolActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#transportprotocolguardeval","title":"<code>TransportProtocolGuardEval</code>","text":"<p> <pre><code><pre>TransportProtocolGuardEval : Type :=  GuardEval    TransportProtocolLocalCfg    TransportProtocolLocalState    TransportProtocolMailboxState    TransportProtocolTimerHandle    TransportProtocolActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#examplereplyguard","title":"<code>exampleReplyGuard</code>","text":"<p>Guard description (optional).</p> Condition Message type is <code>TransportProtocolMsgExampleRequest</code>. <pre><code><pre>exampleReplyGuard  (trigger : TransportProtocolTimestampedTrigger)  (cfg : TransportProtocolCfg)  (env : TransportProtocolEnv)  : Option TransportProtocolGuardOutput := TODO;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#the-transport-protocol-behaviour","title":"The Transport Protocol behaviour","text":"","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#transportprotocolbehaviour","title":"<code>TransportProtocolBehaviour</code>","text":"<pre><code><pre>TransportProtocolBehaviour : Type :=  EngineBehaviour    TransportProtocolLocalCfg    TransportProtocolLocalState    TransportProtocolMailboxState    TransportProtocolTimerHandle    TransportProtocolActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>module transport_protocol_behaviour_example;  exTransportProtocolBehaviour : TransportProtocolBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [exampleReplyGuard];    };end;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","behaviour"]},{"location":"arch/node/engines/transport_protocol_config.html","title":"Transport Protocol Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.transport_protocol_config;import arch.node.types.basics open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_protocol_config.html#transport-protocol-configuration","title":"Transport Protocol Configuration","text":"","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_protocol_config.html#overview","title":"Overview","text":"<p>The static configuration of the engine.</p>","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_protocol_config.html#the-transport-protocol-local-configuration","title":"The Transport Protocol Local Configuration","text":"","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_protocol_config.html#transportprotocollocalcfg","title":"<code>TransportProtocolLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type TransportProtocolLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_protocol_config.html#the-transport-protocol-configuration","title":"The Transport Protocol Configuration","text":"","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_protocol_config.html#transportprotocolcfg","title":"<code>TransportProtocolCfg</code>","text":"<pre><code><pre>TransportProtocolCfg : Type := EngineCfg TransportProtocolLocalCfg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_protocol_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exTransportProtocolCfg : TransportProtocolCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"transport-protocol\";    cfg := TransportProtocolLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","configuration"]},{"location":"arch/node/engines/transport_protocol_environment.html","title":"Transport Protocol Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.transport_protocol_environment;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_protocol_environment.html#transport-protocol-environment","title":"Transport Protocol Environment","text":"","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_protocol_environment.html#overview","title":"Overview","text":"<p>The Engine environment of the engine.</p>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_protocol_environment.html#mailbox-states","title":"Mailbox states","text":"<pre><code><pre>syntax alias TransportProtocolMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_protocol_environment.html#local-state","title":"Local state","text":"<pre><code><pre>type TransportProtocolLocalState := mk;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_protocol_environment.html#timer-handle","title":"Timer Handle","text":"<pre><code><pre>TransportProtocolTimerHandle : Type := Unit;</pre></code></pre> <p>The TransportProtocol does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_protocol_environment.html#timestamped-trigger","title":"Timestamped Trigger","text":"<pre><code><pre>TransportProtocolTimestampedTrigger : Type :=  TimestampedTrigger TransportProtocolTimerHandle Anoma.Msg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_protocol_environment.html#the-transport-protocol-environment","title":"The Transport Protocol Environment","text":"","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_protocol_environment.html#transportprotocolenv","title":"<code>TransportProtocolEnv</code>","text":"<pre><code><pre>TransportProtocolEnv : Type :=  EngineEnv    TransportProtocolLocalState    TransportProtocolMailboxState    TransportProtocolTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_protocol_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exTransportProtocolEnv : TransportProtocolEnv :=  EngineEnv.mk@{    localState := TransportProtocolLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","environment"]},{"location":"arch/node/engines/transport_protocol_messages.html","title":"Transport Protocol Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.transport_protocol_messages;import arch.node.types.transport open;import arch.node.engines.router_messages open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_protocol_messages.html#transport-protocol-messages","title":"Transport Protocol Messages","text":"<p>These are the messages that the Transport Protocol engine can receive.</p>","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_protocol_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type TransportProtocolMsg := | Send TransportOutMsg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_protocol_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_protocol_messages.html#transportoutmsg","title":"<code>TransportOutMsg</code>","text":"<p>Send a message to a remote node via the given transport address.</p> <p>The Transport Protocol engine spawns a new Transport Connection engine instance for the connection if it does not exist yet, and forwards the given message to it.</p> <pre><code><pre>type TransportOutMsg :=  mkTransportOutMsg@{    addr : TransportAddress;    prefs : TransportPrefs;    expiry : Time;    msg : NodeMsg;  };</pre></code></pre> Arguments <code>addr</code> Transport address. <code>prefs</code> Transport preferences. <code>expiry</code> Expiry time for send retries. <code>msg</code> Node message.","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_protocol_messages.html#transportprotocolmsg","title":"<code>TransportProtocolMsg</code>","text":"<pre><code><pre>type TransportProtocolMsg := | Send TransportOutMsg;</pre></code></pre>","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/transport_protocol_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Transport Protocol Configuration</li> <li>Transport Protocol Environment</li> <li>Transport Protocol Behaviour</li> </ul>","tags":["node-architecture","network-subsystem","engine","transport","message-types"]},{"location":"arch/node/engines/verification.html","title":"Verification Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.verification;import prelude open;import arch.node.types.engine open;import arch.node.engines.verification_config open public;import arch.node.engines.verification_messages open public;import arch.node.engines.verification_environment open public;import arch.node.engines.verification_behaviour open public;import arch.node.types.anoma as Anoma open;open verification_config_example;open verification_environment_example;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","verification","engine-definition"]},{"location":"arch/node/engines/verification.html#verification-engine","title":"Verification Engine","text":"<p>The Verification Engine provides signature verification services within Anoma. It can check cryptographic signatures/commitments (a <code>Commitment</code>) against data (a <code>Signable</code>) in two modes: direct verification against a specified identity, or verification that takes into account \"signs_for\" relationships through integration with a SignsFor Engine (specified via <code>signsForEngineAddress</code> in its configuration) which allows some identities to sign on behalf of other identities. One may compare the verification service to how a notary might verify not just a signature, but also check if the signer had proper authority to sign on behalf of another party.</p> <p>When users submit a verification request (via a <code>MsgVerificationRequest</code> message), they provide the data, the commitment/signature to verify, the supposed external identity that made the commitment, and whether to use signs-for relationships (via the <code>useSignsFor</code> flag). If signs-for checking is disabled, the engine directly verifies the signature using the configured verifier. If signs-for checking is enabled, the engine first queries the SignsFor Engine for evidence of signing relationships, then uses this additional context during verification. The engine returns a boolean result (via a <code>MsgVerificationReply</code> message) indicating whether the signature is valid.</p> <p>The verification process is atomic - each request either succeeds with a clear yes/no answer or fails with an error message. The engine's state only keeps track of pending requests when signs-for relationships need to be checked. Requests are added to a queue associated with the request, and this queue is cleared once information is provided by the SignsFor Engine.</p>","tags":["node-architecture","identity-subsystem","engine","verification","engine-definition"]},{"location":"arch/node/engines/verification.html#engine-components","title":"Engine components","text":"<ul> <li>Verification Messages</li> <li>Verification Configuration</li> <li>Verification Environment</li> <li>Verification Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","verification","engine-definition"]},{"location":"arch/node/engines/verification.html#type","title":"Type","text":"<pre><code><pre>VerificationEngine : Type :=  Engine    VerificationLocalCfg    VerificationLocalState    VerificationMailboxState    VerificationTimerHandle    VerificationActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","engine-definition"]},{"location":"arch/node/engines/verification.html#example-of-a-verification-engine","title":"Example of a verification engine","text":"<pre><code><pre>exampleVerificationEngine : VerificationEngine :=  Engine.mk@{    cfg := verificationCfg;    env := verificationEnv;    behaviour := verificationBehaviour;  };</pre></code></pre> <p>where <code>verificationCfg</code> is defined as follows:</p> <pre><code><pre>verificationCfg : VerificationCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"verification\";    cfg :=      VerificationLocalCfg.mk@{        verifier :=          \\{_ _ :=            Verifier.mkVerifier@{              verify := \\{_ _ _ := true};              verifierHash :=                HASH.mkHASH@{                  ordKey :=                    OrdKey.mkOrdKey@{                      compare := Ord.compare;                    };                  hash := \\{x := \"0x1234abcd\"};                };            }};        backend := Backend.LocalMemory;        signsForEngineAddress := mkPair none \"Blah\";      };  };</pre></code></pre> <p><code>verificationEnv</code> is defined as follows:</p> <pre><code><pre>verificationEnv : VerificationEnv :=  EngineEnv.mk@{    localState :=      VerificationLocalState.mk@{        pendingRequests := Map.empty;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>verificationBehaviour</code> is defined as follows:</p> <pre><code><pre>verificationBehaviour : VerificationBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [verifyGuard; signsForReplyGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","engine-definition"]},{"location":"arch/node/engines/verification_behaviour.html","title":"Verification Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.verification_behaviour;import prelude open;import arch.node.types.messages open;import arch.system.identity.identity open hiding {ExternalIdentity};import arch.node.types.engine open;import arch.node.engines.verification_config open;import arch.node.engines.verification_environment open;import arch.node.engines.verification_messages open;import arch.node.engines.signs_for_messages open;import arch.node.types.crypto open;import arch.node.types.identities open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verification-behaviour","title":"Verification Behaviour","text":"","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#overview","title":"Overview","text":"<p>The behavior of the Verification Engine defines how it processes incoming verification requests and produces the corresponding responses.</p>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verification-action-flowchart","title":"Verification Action Flowchart","text":"","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verifyaction-flowchart","title":"<code>verifyAction</code> flowchart","text":"<pre><code>flowchart TD\n    Start([Client Request]) --&gt; MsgReq[MsgVerificationRequest&lt;br/&gt;data: Signable&lt;br/&gt;commitment: Commitment&lt;br/&gt;externalIdentity: ExternalIdentity&lt;br/&gt;useSignsFor: Bool]\n\n    subgraph Guard[\"verifyGuard\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br/&gt;VerificationRequest?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"verifyAction\"]\n        direction TB\n        SignsFor{useSignsFor&lt;br/&gt;flag?}\n        SignsFor --&gt;|No| DirectVerify[Verify using configured&lt;br/&gt;verifier]\n        SignsFor --&gt;|Yes| CheckPending{Existing requests&lt;br/&gt;for this identity?}\n\n        CheckPending --&gt;|Yes| StorePending[Add to pending&lt;br/&gt;request list only]\n        CheckPending --&gt;|No| SendAndStore[Send SignsFor request&lt;br/&gt;and store in pending]\n\n        DirectVerify --&gt; Response1[Prepare immediate response]\n    end\n\n    Response1 --&gt; MsgResp1[MsgVerificationReply&lt;br/&gt;result: Bool&lt;br/&gt;err: none]\n    SendAndStore --&gt; SignsForQuery[MsgQuerySignsForEvidenceRequest&lt;br/&gt;to SignsFor Engine]\n    MsgResp1 --&gt; Client([Return to Client])</code></pre> <code>verifyAction</code> flowchart","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#explanation","title":"Explanation","text":"<ol> <li> <p>Initial Request</p> <ul> <li>A client sends a <code>MsgVerificationRequest</code> containing:<ul> <li><code>data</code>: The original data (<code>Signable</code>) that was allegedly signed</li> <li><code>commitment</code>: The signature (<code>Commitment</code>) to verify</li> <li><code>externalIdentity</code>: The identity that supposedly made the signature</li> <li><code>useSignsFor</code>: Flag indicating whether to check signs-for relationships</li> </ul> </li> </ul> </li> <li> <p>Guard Phase (<code>verifyGuard</code>)</p> <ul> <li>Validates that the incoming message is a proper verification request</li> <li>Checks occur in the following order:<ul> <li>Verifies message type is <code>MsgVerificationRequest</code></li> <li>If validation fails, request is rejected without entering the action phase</li> <li>On success, passes control to <code>verifyActionLabel</code></li> </ul> </li> </ul> </li> <li> <p>Action Phase (<code>verifyAction</code>)</p> <ul> <li>Processing branches based on the <code>useSignsFor</code> flag:</li> </ul> <ul> <li> <p>Direct Verification Path (useSignsFor = false)</p> <ul> <li>Directly verifies the commitment using the configured verifier</li> <li>Creates <code>MsgVerificationReply</code> with:<ul> <li><code>result</code>: Boolean indicating if verification succeeded</li> <li><code>err</code>: None (or Some error message if verification failed)</li> </ul> </li> <li>Sends response immediately back to requester</li> </ul> </li> </ul> <ul> <li> <p>SignsFor Path (useSignsFor = true)</p> <ul> <li>Checks if there are existing pending requests for this identity</li> <li>If this is the first request:<ul> <li>Stores request in pending requests map</li> <li>Sends <code>MsgQuerySignsForEvidenceRequest</code> to SignsFor Engine</li> </ul> </li> <li>If there are existing requests:<ul> <li>Only stores new request in pending requests map</li> </ul> </li> <li>No immediate response is sent to client</li> </ul> </li> </ul> </li> <li> <p>State Management</p> <ul> <li>For direct verification: No state changes</li> <li>For signs-for verification:<ul> <li>Updates pendingRequests map in VerificationLocalState</li> <li>Stores:<ul> <li>The requester's engine ID</li> <li>The data to verify</li> <li>The commitment to verify</li> </ul> </li> <li>Maintains these until signs-for evidence is received</li> </ul> </li> </ul> </li> </ol> <p>Important Notes</p> <ul> <li>Multiple requests for the same identity are batched to avoid duplicate signs-for queries</li> <li>The engine ensures exactly one signs-for query per identity is in flight at any time</li> </ul>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#signsforreplyaction-flowchart","title":"<code>signsForReplyAction</code> flowchart","text":"<pre><code>flowchart TD\n    Start([Client Request]) --&gt; MsgReq[MsgVerificationRequest&lt;br/&gt;data: Signable&lt;br/&gt;commitment: Commitment&lt;br/&gt;externalIdentity: ExternalIdentity&lt;br/&gt;useSignsFor: Bool]\n\n    subgraph Guard[\"verifyGuard\"]\n        MsgReq --&gt; ValidType{Is message type&lt;br/&gt;VerificationRequest?}\n        ValidType --&gt;|No| Reject([Reject Request])\n        ValidType --&gt;|Yes| ActionEntry[Enter Action Phase]\n    end\n\n    ActionEntry --&gt; Action\n\n    subgraph Action[\"verifyAction\"]\n        direction TB\n        SignsFor{useSignsFor&lt;br/&gt;flag?}\n        SignsFor --&gt;|No| DirectVerify[Verify using configured&lt;br/&gt;verifier]\n        SignsFor --&gt;|Yes| CheckPending{Existing requests&lt;br/&gt;for this identity?}\n\n        CheckPending --&gt;|Yes| StorePending[Add to pending&lt;br/&gt;request list]\n        CheckPending --&gt;|No| RequestSF[Send SignsFor&lt;br/&gt;evidence request]\n\n        StorePending &amp; RequestSF --&gt; UpdateState[Update state with&lt;br/&gt;pending request]\n        DirectVerify --&gt; Response1[Prepare immediate response]\n        UpdateState --&gt; Response2[Prepare pending response]\n    end\n\n    Response1 --&gt; MsgResp1[MsgVerificationReply&lt;br/&gt;result: Bool&lt;br/&gt;err: none]\n    Response2 --&gt; MsgResp2[MsgQuerySignsForEvidenceRequest&lt;br/&gt;to SignsFor Engine]\n\n    MsgResp1 &amp; MsgResp2 --&gt; Client([Return to Client])</code></pre> <code>signsForReplyAction</code> flowchart","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#explanation_1","title":"Explanation","text":"<p>Let me provide a detailed explanation of the SignsFor Reply flow chart, following the style used for previous engines:</p>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#signsfor-reply-flow","title":"SignsFor Reply Flow","text":"<ol> <li> <p>Initial Request</p> <ul> <li>A message arrives from the SignsFor Engine containing:<ul> <li><code>externalIdentity</code>: The identity the evidence relates to</li> <li><code>evidence</code>: The signs-for relationships evidence</li> <li><code>err</code>: Any error that occurred during evidence gathering</li> </ul> </li> </ul> </li> <li> <p>Guard Phase (<code>signsForReplyGuard</code>)</p> <ul> <li>Validates incoming messages through these checks:<ul> <li>Verifies message type is <code>MsgQuerySignsForEvidenceReply</code></li> <li>Verifies the message sender is the known SignsFor Engine address</li> <li>If validation fails, request is rejected without entering action phase</li> <li>On success, passes control to <code>signsForReplyActionLabel</code></li> </ul> </li> </ul> </li> <li> <p>Action Phase (<code>signsForReplyAction</code>)</p> <ul> <li>Processes the SignsFor evidence reply through these steps:<ul> <li>Checks map of pending requests for the given external identity</li> <li>If no pending requests exist:<ul> <li>No action needed</li> <li>No responses are generated</li> </ul> </li> <li>If pending requests exist:<ul> <li>Processes each pending request using the received evidence</li> <li>For each request, verifies the commitment using both the verifier and the signs-for evidence</li> <li>Generates verification responses for all pending requesters</li> <li>Clears all pending requests for this identity from the state</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Response Generation</p> <ul> <li>For each pending requester:<ul> <li>Creates <code>MsgVerificationReply</code> containing:<ul> <li><code>result</code>: Boolean indicating if verification succeeded</li> <li><code>err</code>: None (or Some error if verification failed)</li> </ul> </li> </ul> </li> <li>All responses are sent back to their original requesters</li> <li>Each response uses mailbox ID 0</li> </ul> </li> </ol> <p>Important Notes</p> <ul> <li>The engine processes all pending requests for an identity at once when evidence arrives</li> <li>The state is cleaned up (pending requests removed) regardless of verification results</li> <li>Each original requester gets their own individual response</li> </ul>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#replyto","title":"<code>ReplyTo</code>","text":"<pre><code><pre>type ReplyTo :=  mkReplyTo@{    whoAsked : Option EngineID;    mailbox : Option MailboxID;  };</pre></code></pre> <p>This action argument contains the address and mailbox ID of where the response message should be sent.</p> Arguments <code>whoAsked</code>: The engine ID of the requester. <code>mailbox</code>: The mailbox ID where the response should be sent.","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verificationactionargument","title":"<code>VerificationActionArgument</code>","text":"<pre><code><pre>type VerificationActionArgument := | VerificationActionArgumentReplyTo ReplyTo;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verificationactionarguments","title":"<code>VerificationActionArguments</code>","text":"<pre><code><pre>VerificationActionArguments : Type := List VerificationActionArgument;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verificationaction","title":"<code>VerificationAction</code>","text":"<p><pre><code><pre>VerificationAction : Type :=  Action    VerificationLocalCfg    VerificationLocalState    VerificationMailboxState    VerificationTimerHandle    VerificationActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verificationactioninput","title":"<code>VerificationActionInput</code>","text":"<p><pre><code><pre>VerificationActionInput : Type :=  ActionInput    VerificationLocalCfg    VerificationLocalState    VerificationMailboxState    VerificationTimerHandle    VerificationActionArguments    Anoma.Msg;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verificationactioneffect","title":"<code>VerificationActionEffect</code>","text":"<p><pre><code><pre>VerificationActionEffect : Type :=  ActionEffect    VerificationLocalState    VerificationMailboxState    VerificationTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verificationactionexec","title":"<code>VerificationActionExec</code>","text":"<p><pre><code><pre>VerificationActionExec : Type :=  ActionExec    VerificationLocalCfg    VerificationLocalState    VerificationMailboxState    VerificationTimerHandle    VerificationActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verifyaction","title":"<code>verifyAction</code>","text":"<p>Verify a commitment.</p> State update If <code>useSignsFor</code> is true, the state is updated to store pending requests. Otherwise, the state remains unchanged. Messages to be sent If <code>useSignsFor</code> is false, a <code>ReplyVerification</code> message is sent back to the requester. If <code>useSignsFor</code> is true and it's the first request for this identity, a <code>QuerySignsForEvidenceRequest</code> is sent to the SignsFor Engine. Engines to be spawned No engines are created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>verifyAction  (input : VerificationActionInput) : Option VerificationActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    tt := ActionInput.trigger input;    localState := EngineEnv.localState env;  in case getEngineMsgFromTimestampedTrigger tt of       | some emsg :=         case emsg of {           | EngineMsg.mk@{               msg := Anoma.Msg.Verification (VerificationMsg.Request (RequestVerification.mkRequestVerification data commitment externalIdentity useSignsFor));             } :=             case useSignsFor of {               | false :=                 some                   ActionEffect.mk@{                     env := env;                     msgs :=                       [                         EngineMsg.mk@{                           sender := getEngineIDFromEngineCfg cfg;                           target := EngineMsg.sender emsg;                           mailbox := some 0;                           msg :=                             Anoma.Msg.Verification                               (VerificationMsg.Reply                                 (ReplyVerification.mkReplyVerification                                   (Verifier.verify                                     (VerificationLocalCfg.verifier                                       (EngineCfg.cfg cfg)                                       Set.empty                                       externalIdentity)                                     (VerificationLocalCfg.backend                                       (EngineCfg.cfg cfg))                                     data                                     commitment)                                   none));                         };                       ];                     timers := [];                     engines := [];                   }               | true :=                 let                   existingRequests :=                     Map.lookup                       externalIdentity                       (VerificationLocalState.pendingRequests localState);                   newPendingList :=                     case existingRequests of                       | some reqs :=                         reqs                           ++ [                                mkPair                                  (EngineMsg.sender emsg)                                  (mkPair data commitment);                              ]                       | none :=                         [                           mkPair                             (EngineMsg.sender emsg)                             (mkPair data commitment);                         ];                   newPendingRequests :=                     Map.insert                       externalIdentity                       newPendingList                       (VerificationLocalState.pendingRequests localState);                   newLocalState :=                     localState@VerificationLocalState{pendingRequests := newPendingRequests};                   newEnv := env@EngineEnv{localState := newLocalState};                 in some                   ActionEffect.mk@{                     env := newEnv;                     msgs :=                       case existingRequests of                         | some _ := []                         | none :=                           [                             EngineMsg.mk@{                               sender := getEngineIDFromEngineCfg cfg;                               target :=                                 VerificationLocalCfg.signsForEngineAddress                                   (EngineCfg.cfg cfg);                               mailbox := some 0;                               msg :=                                 Anoma.Msg.SignsFor                                   (SignsForMsg.QuerySignsForEvidenceRequest                                     (RequestQuerySignsForEvidence.mkRequestQuerySignsForEvidence                                       externalIdentity));                             };                           ];                     timers := [];                     engines := [];                   }             }           | _ := none         }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#signsforreplyaction","title":"<code>signsForReplyAction</code>","text":"<p>Process a signs-for response and handle pending requests.</p> State update The state is updated to remove the processed pending requests for the given external identity. Messages to be sent <code>ReplyVerification</code> messages are sent to all requesters who were waiting for this SignsFor evidence. Engines to be spawned No engines are created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>signsForReplyAction  (input : VerificationActionInput) : Option VerificationActionEffect :=  let    env := ActionInput.env input;    cfg := ActionInput.cfg input;    tt := ActionInput.trigger input;    localState := EngineEnv.localState env;  in case getEngineMsgFromTimestampedTrigger tt of       | some emsg :=         case emsg of {           | EngineMsg.mk@{               msg := Anoma.Msg.SignsFor (SignsForMsg.QuerySignsForEvidenceReply (ReplyQuerySignsForEvidence.mkReplyQuerySignsForEvidence externalIdentity evidence err));             } :=             case               Map.lookup                 externalIdentity                 (VerificationLocalState.pendingRequests localState)             of {               | some reqs :=                 let                   newPendingRequests :=                     Map.delete                       externalIdentity                       (VerificationLocalState.pendingRequests localState);                   newLocalState :=                     localState@VerificationLocalState{pendingRequests := newPendingRequests};                   newEnv := env@EngineEnv{localState := newLocalState};                 in some                   ActionEffect.mk@{                     env := newEnv;                     msgs :=                       map                         \\{req :=                           let                             whoAsked := fst req;                             data := fst (snd req);                             commitment := snd (snd req);                           in EngineMsg.mk@{                                sender := getEngineIDFromEngineCfg cfg;                                target := whoAsked;                                mailbox := some 0;                                msg :=                                  Anoma.Msg.Verification                                    (VerificationMsg.Reply                                      (ReplyVerification.mkReplyVerification                                        (Verifier.verify                                          (VerificationLocalCfg.verifier                                            (EngineCfg.cfg cfg)                                            evidence                                            externalIdentity)                                          (VerificationLocalCfg.backend                                            (EngineCfg.cfg cfg))                                          data                                          commitment)                                        none));                              }}                         reqs;                     timers := [];                     engines := [];                   }               | none :=                 some                   ActionEffect.mk@{                     env := env;                     msgs := [];                     timers := [];                     engines := [];                   }             }           | _ := none         }       | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verifyactionlabel","title":"<code>verifyActionLabel</code>","text":"<pre><code><pre>verifyActionLabel : VerificationActionExec := ActionExec.Seq [verifyAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#signsforreplyactionlabel","title":"<code>signsForReplyActionLabel</code>","text":"<pre><code><pre>signsForReplyActionLabel : VerificationActionExec :=  ActionExec.Seq [signsForReplyAction];</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verificationguard","title":"<code>VerificationGuard</code>","text":"<p> <pre><code><pre>VerificationGuard : Type :=  Guard    VerificationLocalCfg    VerificationLocalState    VerificationMailboxState    VerificationTimerHandle    VerificationActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verificationguardoutput","title":"<code>VerificationGuardOutput</code>","text":"<p> <pre><code><pre>VerificationGuardOutput : Type :=  GuardOutput    VerificationLocalCfg    VerificationLocalState    VerificationMailboxState    VerificationTimerHandle    VerificationActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verificationguardeval","title":"<code>VerificationGuardEval</code>","text":"<p> <pre><code><pre>VerificationGuardEval : Type :=  GuardEval    VerificationLocalCfg    VerificationLocalState    VerificationMailboxState    VerificationTimerHandle    VerificationActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verifyguard","title":"<code>verifyGuard</code>","text":"Condition Message type is <code>VerificationRequest</code>. <pre><code><pre>verifyGuard  (tt : TimestampedTrigger VerificationTimerHandle Anoma.Msg)  (cfg : VerificationCfg)  (env : VerificationEnv)  : Option VerificationGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some EngineMsg.mk@{             msg := Anoma.Msg.Verification (VerificationMsg.Request _);           } :=      some        GuardOutput.mk@{          action := verifyActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#signsforreplyguard","title":"<code>signsForReplyGuard</code>","text":"Condition Message is a signs-for response from the SignsFor engine. <pre><code><pre>signsForReplyGuard  (tt : TimestampedTrigger VerificationTimerHandle Anoma.Msg)  (cfg : VerificationCfg)  (env : VerificationEnv)  : Option VerificationGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some emsg :=      case emsg of {        | EngineMsg.mk@{            msg := Anoma.Msg.SignsFor (SignsForMsg.QuerySignsForEvidenceReply _);            sender := sender;          } :=          case            isEqual              (Ord.compare                sender                (VerificationLocalCfg.signsForEngineAddress                  (EngineCfg.cfg cfg)))          of {            | true :=              some                GuardOutput.mk@{                  action := signsForReplyActionLabel;                  args := [];                }            | false := none          }        | _ := none      }    | none := none;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#the-verification-behaviour","title":"The Verification Behaviour","text":"","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#verificationbehaviour","title":"<code>VerificationBehaviour</code>","text":"<pre><code><pre>VerificationBehaviour : Type :=  EngineBehaviour    VerificationLocalCfg    VerificationLocalState    VerificationMailboxState    VerificationTimerHandle    VerificationActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>verificationBehaviour : VerificationBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [verifyGuard; signsForReplyGuard];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","behaviour"]},{"location":"arch/node/engines/verification_config.html","title":"Verification Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.verification_config;import prelude open;import arch.node.engines.verification_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.system.identity.identity open hiding {ExternalIdentity};</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","verification","configuration"]},{"location":"arch/node/engines/verification_config.html#verification-configuration","title":"Verification Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","verification","configuration"]},{"location":"arch/node/engines/verification_config.html#overview","title":"Overview","text":"<p>The Verification engine configuration contains static information for Verification engine instances.</p>","tags":["node-architecture","identity-subsystem","engine","verification","configuration"]},{"location":"arch/node/engines/verification_config.html#the-verification-local-configuration","title":"The Verification Local Configuration","text":"<p>The configuration of a Verification Engine instance includes the identity's verification capabilities, the address of an associated <code>SignsFor</code> engine, and a specific backend.</p>","tags":["node-architecture","identity-subsystem","engine","verification","configuration"]},{"location":"arch/node/engines/verification_config.html#verificationlocalcfg","title":"<code>VerificationLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type VerificationLocalCfg :=  mk@{    verifier      : Set SignsForEvidence        -&gt; ExternalIdentity        -&gt; Verifier ByteString Backend Signable Commitment;    backend : Backend;    signsForEngineAddress : EngineID;  };</pre></code></pre> Arguments <code>verifier</code>: Function to generate verifier for a set of evidence and an identity. It takes a set of evidence, an identity, and returns a verifier. <code>backend</code>: The backend to use for verification. <code>signsForEngineAddress</code>: The address of the associated SignsFor engine.","tags":["node-architecture","identity-subsystem","engine","verification","configuration"]},{"location":"arch/node/engines/verification_config.html#the-verification-configuration","title":"The Verification Configuration","text":"","tags":["node-architecture","identity-subsystem","engine","verification","configuration"]},{"location":"arch/node/engines/verification_config.html#verificationcfg","title":"<code>VerificationCfg</code>","text":"<pre><code><pre>VerificationCfg : Type := EngineCfg VerificationLocalCfg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","configuration"]},{"location":"arch/node/engines/verification_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>verificationCfg : VerificationCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"verification\";    cfg :=      VerificationLocalCfg.mk@{        verifier :=          \\{_ _ :=            Verifier.mkVerifier@{              verify := \\{_ _ _ := true};              verifierHash :=                HASH.mkHASH@{                  ordKey :=                    OrdKey.mkOrdKey@{                      compare := Ord.compare;                    };                  hash := \\{x := \"0x1234abcd\"};                };            }};        backend := Backend.LocalMemory;        signsForEngineAddress := mkPair none \"Blah\";      };  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","configuration"]},{"location":"arch/node/engines/verification_environment.html","title":"Verification Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.verification_environment;import prelude open;import arch.node.types.messages open;import arch.node.types.engine_environment open;import arch.node.types.identities open;import arch.node.engines.verification_messages open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","verification","environment"]},{"location":"arch/node/engines/verification_environment.html#verification-environment","title":"Verification Environment","text":"","tags":["node-architecture","identity-subsystem","engine","verification","environment"]},{"location":"arch/node/engines/verification_environment.html#overview","title":"Overview","text":"<p>The Verification Engine is stateless and does not maintain any internal state between requests. It relies on external information (like the <code>signs_for</code> relationships) for its operations.</p>","tags":["node-architecture","identity-subsystem","engine","verification","environment"]},{"location":"arch/node/engines/verification_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The Verification Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","verification","environment"]},{"location":"arch/node/engines/verification_environment.html#verificationmailboxstate","title":"<code>VerificationMailboxState</code>","text":"<pre><code><pre>syntax alias VerificationMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","environment"]},{"location":"arch/node/engines/verification_environment.html#local-state","title":"Local state","text":"<p>The local state of a Verification Engine instance contains a map to a list of pending requests which require <code>SignsFor</code> information which is requested from the associated <code>SignsFor</code> engine.</p>","tags":["node-architecture","identity-subsystem","engine","verification","environment"]},{"location":"arch/node/engines/verification_environment.html#verificationlocalstate","title":"<code>VerificationLocalState</code>","text":"<pre><code><pre>type VerificationLocalState :=  mk@{    pendingRequests      : Map ExternalIdentity (List (Pair EngineID (Pair Signable Commitment)));  };</pre></code></pre> Arguments <code>pendingRequests</code>: The backlog of verification requests still in processing.","tags":["node-architecture","identity-subsystem","engine","verification","environment"]},{"location":"arch/node/engines/verification_environment.html#timer-handle","title":"Timer Handle","text":"<p>The Verification Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>","tags":["node-architecture","identity-subsystem","engine","verification","environment"]},{"location":"arch/node/engines/verification_environment.html#verificationtimerhandle","title":"<code>VerificationTimerHandle</code>","text":"<pre><code><pre>syntax alias VerificationTimerHandle := Unit;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","environment"]},{"location":"arch/node/engines/verification_environment.html#the-verification-environment","title":"The Verification Environment","text":"","tags":["node-architecture","identity-subsystem","engine","verification","environment"]},{"location":"arch/node/engines/verification_environment.html#verificationenv","title":"<code>VerificationEnv</code>","text":"<pre><code><pre>VerificationEnv : Type :=  EngineEnv    VerificationLocalState    VerificationMailboxState    VerificationTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","environment"]},{"location":"arch/node/engines/verification_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>verificationEnv : VerificationEnv :=  EngineEnv.mk@{    localState :=      VerificationLocalState.mk@{        pendingRequests := Map.empty;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","environment"]},{"location":"arch/node/engines/verification_messages.html","title":"Verification Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.verification_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","engine","verification","message-types"]},{"location":"arch/node/engines/verification_messages.html#verification-messages","title":"Verification Messages","text":"","tags":["node-architecture","identity-subsystem","engine","verification","message-types"]},{"location":"arch/node/engines/verification_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type VerificationMsg :=  | Request RequestVerification  | Reply ReplyVerification;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","message-types"]},{"location":"arch/node/engines/verification_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","identity-subsystem","engine","verification","message-types"]},{"location":"arch/node/engines/verification_messages.html#verification-sequence-without-signs_for-evidence","title":"Verification sequence (without <code>signs_for</code> evidence)","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant VE as Verification Engine\n\n    C-&gt;&gt;VE: RequestVerification(useSignsFor=false)\n    Note over VE: Verify commitment directly for external identity\n    VE--&gt;&gt;C: ReplyVerification</code></pre>  Sequence diagram for verification (no <code>signs_for</code> evidence).","tags":["node-architecture","identity-subsystem","engine","verification","message-types"]},{"location":"arch/node/engines/verification_messages.html#verification-sequence-with-signs_for-evidence","title":"Verification sequence (with <code>signs_for</code> evidence)","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant VE as Verification Engine\n    participant SF as SignsFor Engine\n\n    C-&gt;&gt;VE: RequestVerification(useSignsFor=true)\n    VE-&gt;&gt;SF: QuerySignsForEvidenceRequest\n    Note over SF: Retrieve signs_for evidence\n    SF--&gt;&gt;VE: QuerySignsForEvidenceReply\n    Note over VE: Verify commitment using SignsFor evidence\n    VE--&gt;&gt;C: ReplyVerification</code></pre>  Sequence diagram for verification (with <code>signs_for</code> evidence).","tags":["node-architecture","identity-subsystem","engine","verification","message-types"]},{"location":"arch/node/engines/verification_messages.html#message-types","title":"Message types","text":"","tags":["node-architecture","identity-subsystem","engine","verification","message-types"]},{"location":"arch/node/engines/verification_messages.html#requestverification","title":"<code>RequestVerification</code>","text":"<pre><code><pre>type RequestVerification :=  mkRequestVerification@{    data : Signable;    commitment : Commitment;    externalIdentity : ExternalIdentity;    useSignsFor : Bool;  };</pre></code></pre> <p>A <code>RequestVerification</code> instructs the Verification Engine to verify a commitment (signature) from a particular external identity, possibly using known <code>signs_for</code> relationships.</p> Arguments <code>data</code>: The data that was signed. <code>commitment</code>: The commitment (signature) to verify. <code>externalIdentity</code>: The external identity that supposedly made the commitment. <code>useSignsFor</code>: Whether or not to use known <code>signs_for</code> relationships.","tags":["node-architecture","identity-subsystem","engine","verification","message-types"]},{"location":"arch/node/engines/verification_messages.html#replyverification","title":"<code>ReplyVerification</code>","text":"<pre><code><pre>type ReplyVerification :=  mkReplyVerification@{    result : Bool;    err : Option String;  };</pre></code></pre> <p>A <code>ReplyVerification</code> contains the result of verifying a commitment in response to a <code>RequestVerification</code>.</p> Arguments <code>result</code>: True if the verification succeeded, False otherwise. <code>err</code>: An error message if verification failed.","tags":["node-architecture","identity-subsystem","engine","verification","message-types"]},{"location":"arch/node/engines/verification_messages.html#verificationmsg","title":"<code>VerificationMsg</code>","text":"<pre><code><pre>type VerificationMsg :=  | Request RequestVerification  | Reply ReplyVerification;</pre></code></pre>","tags":["node-architecture","identity-subsystem","engine","verification","message-types"]},{"location":"arch/node/engines/verification_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Verification Configuration</li> <li>Verification Environment</li> <li>Verification Behaviour</li> </ul>","tags":["node-architecture","identity-subsystem","engine","verification","message-types"]},{"location":"arch/node/engines/wall_clock.html","title":"Wall Clock Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.wall_clock;import prelude open;import arch.node.types.engine_environment open;import arch.node.types.engine_behaviour open;import arch.node.types.engine open;import arch.node.engines.wall_clock_config open public;import arch.node.engines.wall_clock_messages open public;import arch.node.engines.wall_clock_environment open public;import arch.node.engines.wall_clock_behaviour open public;import arch.node.types.anoma as Anoma open;open wall_clock_config_example;open wall_clock_environment_example;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","engine-definition"]},{"location":"arch/node/engines/wall_clock.html#wall-clock-engine","title":"Wall Clock Engine","text":"","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","engine-definition"]},{"location":"arch/node/engines/wall_clock.html#purpose","title":"Purpose","text":"<p>The Wall Clock Engine provides a mechanism for tracking and managing time locally on the physical machine that the Anoma node is running. It abstracts away the details of the underlying hardware and provides an interface for getting real-time clock functionality.</p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","engine-definition"]},{"location":"arch/node/engines/wall_clock.html#engine-components","title":"Engine components","text":"<ul> <li>Wall Clock Messages</li> <li>Wall Clock Configuration</li> <li>Wall Clock Environment</li> <li>Wall Clock Behaviour</li> </ul>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","engine-definition"]},{"location":"arch/node/engines/wall_clock.html#type","title":"Type","text":"<pre><code><pre>WallClockEngine : Type :=  Engine    WallClockLocalCfg    WallClockLocalState    WallClockMailboxState    WallClockTimerHandle    WallClockActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","engine-definition"]},{"location":"arch/node/engines/wall_clock.html#example-of-a-wall-clock-engine","title":"Example of a wall clock engine","text":"<pre><code><pre>exampleWallClockEngine : WallClockEngine :=  Engine.mk@{    cfg := wallClockCfg;    env := wallClockEnv;    behaviour := wallClockBehaviour;  };</pre></code></pre> <p>where <code>wallClockCfg</code> is defined as follows:</p> <pre><code><pre>wallClockCfg : WallClockCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"wall clock\";    cfg := WallClockLocalCfg.mk;  };</pre></code></pre> <p><code>wallClockEnv</code> is defined as follows:</p> <pre><code><pre>wallClockEnv : WallClockEnv :=  EngineEnv.mk@{    localState :=      WallClockLocalState.mk@{        currentTime := 0;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>wallClockBehaviour</code> is defined as follows:</p> <pre><code><pre>wallClockBehaviour : WallClockBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [getTimeGuard];  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","engine-definition"]},{"location":"arch/node/engines/wall_clock_behaviour.html","title":"Wall Clock Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.wall_clock_behaviour;import arch.node.engines.wall_clock_messages open;import arch.node.engines.wall_clock_config open;import arch.node.engines.wall_clock_environment open;import prelude open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#wall-clock-behaviour","title":"Wall Clock Behaviour","text":"","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#overview","title":"Overview","text":"<p>The behavior of the Wall Clock Engine defines how it processes get time requests and produces time results using the current wall clock time.</p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#messagefrom","title":"<code>MessageFrom</code>","text":"<pre><code><pre>type MessageFrom :=  mkMessageFrom@{    whoAsked : Option EngineID;    mailbox : Option MailboxID;  };</pre></code></pre> Arguments <code>whoAsked</code>: The engine ID of the requester. <code>mailbox</code>: The mailbox ID where the response message should be sent.","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#wallclockactionargument","title":"<code>WallClockActionArgument</code>","text":"<pre><code><pre>type WallClockActionArgument := | WallClockActionArgumentFrom MessageFrom;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#wallclockactionarguments","title":"<code>WallClockActionArguments</code>","text":"<pre><code><pre>WallClockActionArguments : Type := List WallClockActionArgument;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#wallclockaction","title":"WallClockAction","text":"<p> <pre><code><pre>WallClockAction : Type :=  Action    WallClockLocalCfg    WallClockLocalState    WallClockMailboxState    WallClockTimerHandle    WallClockActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#wallclockactioninput","title":"WallClockActionInput","text":"<p> <pre><code><pre>WallClockActionInput : Type :=  ActionInput    WallClockLocalCfg    WallClockLocalState    WallClockMailboxState    WallClockTimerHandle    WallClockActionArguments    Anoma.Msg;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#wallclockactioneffect","title":"<code>WallClockActionEffect</code>","text":"<p> <pre><code><pre>WallClockActionEffect : Type :=  ActionEffect    WallClockLocalState    WallClockMailboxState    WallClockTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#wallclockactionexec","title":"<code>WallClockActionExec</code>","text":"<p> <pre><code><pre>WallClockActionExec : Type :=  ActionExec    WallClockLocalCfg    WallClockLocalState    WallClockMailboxState    WallClockTimerHandle    WallClockActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#gettimeaction","title":"<code>getTimeAction</code>","text":"<p>Return the current wall clock time.</p> State update Time will have advanced. Messages to be sent A <code>WallClockGetTimeResult</code> message with the current time. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>getTimeAction (input : WallClockActionInput) : Option WallClockActionEffect :=  let    cfg := ActionInput.cfg input;    env := ActionInput.env input;    trigger := ActionInput.trigger input;    currentTime := WallClockLocalState.currentTime (EngineEnv.localState env);    newTime := advanceTime currentTime;  in case getEngineMsgFromTimestampedTrigger trigger of       | some emsg :=         some           ActionEffect.mk@{             env :=               env@EngineEnv{localState := WallClockLocalState.mk@{                                             currentTime := newTime;                                           }};             msgs :=               [                 EngineMsg.mk@{                   sender := getEngineIDFromEngineCfg cfg;                   target := EngineMsg.sender emsg;                   mailbox := some 0;                   msg :=                     Anoma.Msg.WallClock                       (WallClockMsg.GetTimeResult                         TimeResult.mk@{                           epochTime := newTime;                         });                 };               ];             timers := [];             engines := [];           }       | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#gettimeactionlabel","title":"<code>getTimeActionLabel</code>","text":"<pre><code><pre>getTimeActionLabel : WallClockActionExec := ActionExec.Seq [getTimeAction];</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#wallclockguard","title":"<code>WallClockGuard</code>","text":"<p> <pre><code><pre>WallClockGuard : Type :=  Guard    WallClockLocalCfg    WallClockLocalState    WallClockMailboxState    WallClockTimerHandle    WallClockActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#wallclockguardoutput","title":"<code>WallClockGuardOutput</code>","text":"<p> <pre><code><pre>WallClockGuardOutput : Type :=  GuardOutput    WallClockLocalCfg    WallClockLocalState    WallClockMailboxState    WallClockTimerHandle    WallClockActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#wallclockguardeval","title":"<code>WallClockGuardEval</code>","text":"<p> <pre><code><pre>WallClockGuardEval : Type :=  GuardEval    WallClockLocalCfg    WallClockLocalState    WallClockMailboxState    WallClockTimerHandle    WallClockActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#gettimeguard","title":"<code>getTimeGuard</code>","text":"Condition Message type is <code>WallClockGetTime</code>. <pre><code><pre>getTimeGuard  (trigger : TimestampedTrigger WallClockTimerHandle Anoma.Msg)  (cfg : WallClockCfg)  (env : WallClockEnv)  : Option WallClockGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{msg := Anoma.Msg.WallClock WallClockMsg.GetTime} :=      some        GuardOutput.mk@{          action := getTimeActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#the-wall-clock-behaviour","title":"The Wall Clock behaviour","text":"","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#wallclockbehaviour","title":"<code>WallClockBehaviour</code>","text":"<pre><code><pre>WallClockBehaviour : Type :=  EngineBehaviour    WallClockLocalCfg    WallClockLocalState    WallClockMailboxState    WallClockTimerHandle    WallClockActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>wallClockBehaviour : WallClockBehaviour :=  EngineBehaviour.mk@{    guards := GuardEval.First [getTimeGuard];  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#wall-clock-action-flowchart","title":"Wall Clock Action Flowchart","text":"","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_behaviour.html#gettime-flowchart","title":"<code>getTime</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;WallClockGetTime]\n  end\n\n  G(getTimeGuard)\n  A(getTimeAction)\n\n  C --&gt; G -- *getTimeActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(time := advanceTime time)]\n    EMsg&gt;WallClockGetTimeResult&lt;br/&gt;epochTime]\n  end</code></pre> <code>getTime</code> flowchart","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","behaviour"]},{"location":"arch/node/engines/wall_clock_config.html","title":"Wall Clock Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.wall_clock_config;import prelude open;import arch.node.engines.wall_clock_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","configuration"]},{"location":"arch/node/engines/wall_clock_config.html#wall-clock-configuration","title":"Wall Clock Configuration","text":"","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","configuration"]},{"location":"arch/node/engines/wall_clock_config.html#overview","title":"Overview","text":"<p>The wall clock engine configuration contains the static configuration needed for the wall clock engine to function.</p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","configuration"]},{"location":"arch/node/engines/wall_clock_config.html#the-wall-clock-local-configuration","title":"The Wall Clock Local Configuration","text":"","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","configuration"]},{"location":"arch/node/engines/wall_clock_config.html#wallclocklocalcfg","title":"<code>WallClockLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type WallClockLocalCfg := mk;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","configuration"]},{"location":"arch/node/engines/wall_clock_config.html#the-wall-clock-configuration","title":"The Wall Clock Configuration","text":"","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","configuration"]},{"location":"arch/node/engines/wall_clock_config.html#wallclockcfg","title":"<code>WallClockCfg</code>","text":"<pre><code><pre>WallClockCfg : Type := EngineCfg WallClockLocalCfg;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","configuration"]},{"location":"arch/node/engines/wall_clock_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>wallClockCfg : WallClockCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"wall clock\";    cfg := WallClockLocalCfg.mk;  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","configuration"]},{"location":"arch/node/engines/wall_clock_environment.html","title":"Wall Clock Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.wall_clock_environment;import prelude open;import arch.node.engines.wall_clock_messages open;import arch.node.types.engine_environment open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","environment"]},{"location":"arch/node/engines/wall_clock_environment.html#wall-clock-environment","title":"Wall Clock Environment","text":"","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","environment"]},{"location":"arch/node/engines/wall_clock_environment.html#overview","title":"Overview","text":"<p>The Local Wall Clock Engine provides and keeps track of a local time.</p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","environment"]},{"location":"arch/node/engines/wall_clock_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The wall clock engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p> <pre><code><pre>syntax alias WallClockMailboxState := Unit;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","environment"]},{"location":"arch/node/engines/wall_clock_environment.html#local-state","title":"Local state","text":"<pre><code><pre>type WallClockLocalState :=  mk@{    currentTime : EpochTimestamp;  };</pre></code></pre> Arguments <code>currentTime</code> The current epoch time value","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","environment"]},{"location":"arch/node/engines/wall_clock_environment.html#timer-handle","title":"Timer Handle","text":"<p>The wall clock engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p> <pre><code><pre>syntax alias WallClockTimerHandle := Unit;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","environment"]},{"location":"arch/node/engines/wall_clock_environment.html#the-wall-clock-environment","title":"The Wall Clock Environment","text":"","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","environment"]},{"location":"arch/node/engines/wall_clock_environment.html#auxiliary-abstraction-functions","title":"Auxiliary abstraction Functions","text":"<pre><code><pre>axiom advanceTime : EpochTimestamp -&gt; EpochTimestamp;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","environment"]},{"location":"arch/node/engines/wall_clock_environment.html#wallclockenv","title":"<code>WallClockEnv</code>","text":"<pre><code><pre>WallClockEnv : Type :=  EngineEnv    WallClockLocalState    WallClockMailboxState    WallClockTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","environment"]},{"location":"arch/node/engines/wall_clock_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>wallClockEnv : WallClockEnv :=  EngineEnv.mk@{    localState :=      WallClockLocalState.mk@{        currentTime := 0;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","environment"]},{"location":"arch/node/engines/wall_clock_messages.html","title":"Wall Clock Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.wall_clock_messages;import prelude open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","message-types"]},{"location":"arch/node/engines/wall_clock_messages.html#wall-clock-messages","title":"Wall Clock Messages","text":"<p>These are the messages that the Wall Clock engine can receive/respond to.</p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","message-types"]},{"location":"arch/node/engines/wall_clock_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type WallClockMsg :=  | GetTime  | GetTimeResult TimeResult;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","message-types"]},{"location":"arch/node/engines/wall_clock_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","message-types"]},{"location":"arch/node/engines/wall_clock_messages.html#wall-clock-request-and-response","title":"Wall Clock request and response","text":"<pre><code>sequenceDiagram\n    participant WallClockClient\n    participant WallClock\n\n    WallClockClient -&gt;&gt; WallClock: WallClockGetTime\n    WallClock -&gt;&gt; WallClockClient: WallClockGetTimeResult</code></pre>  Sequence diagram: Wall Clock time request &amp; response","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","message-types"]},{"location":"arch/node/engines/wall_clock_messages.html#message-types","title":"Message types","text":"Auxiliary Juvix code <p><pre><code><pre>syntax alias StorageKey := String;syntax alias StorageValue := String;syntax alias EpochTimestamp := Nat;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","message-types"]},{"location":"arch/node/engines/wall_clock_messages.html#wallclockgettime","title":"<code>WallClockGetTime</code>","text":"<p>A <code>WallClockGetTime</code> message tracks and manages time within the local computing environment. This message doesn't require any arguments.</p>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","message-types"]},{"location":"arch/node/engines/wall_clock_messages.html#timeresult","title":"<code>TimeResult</code>","text":"<p>Reply to a <code>WallClockGetTime</code> request.</p> <pre><code><pre>type TimeResult :=  mk@{    epochTime : EpochTimestamp;  };</pre></code></pre> Arguments <code>epochTime</code> The current time in epoch format (seconds/milliseconds since epoch)","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","message-types"]},{"location":"arch/node/engines/wall_clock_messages.html#wallclockmsg","title":"<code>WallClockMsg</code>","text":"<pre><code><pre>type WallClockMsg :=  | GetTime  | GetTimeResult TimeResult;</pre></code></pre>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","message-types"]},{"location":"arch/node/engines/wall_clock_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Wall Clock Configuration</li> <li>Wall Clock Environment</li> <li>Wall Clock Behaviour</li> </ul>","tags":["node-architecture","hardware-subsystem","engine","wall-clock-engine","message-types"]},{"location":"arch/node/integration/simulator.html","title":"Engine Simulator","text":"","tags":["work-in-progress","simulator","engine"],"boost":2},{"location":"arch/node/integration/simulator.html#module-setup-and-core-types","title":"Module Setup and Core Types","text":"<p>The main simulator module with essential imports and the message selection strategy type definition.</p> Juvix imports <p><pre><code><pre>module arch.node.integration.simulator;import prelude open;open OMap;import arch.node.types.basics open public;import arch.node.types.messages open public;import arch.node.types.identities open;import arch.node.types.engine_config open public;import arch.node.types.engine_environment open;import arch.node.types.engine_behaviour open;import arch.node.types.engine open public;import arch.node.types.anoma_engines open;import arch.node.types.anoma_message open;import arch.node.types.anoma_config open;import arch.node.types.anoma_environment open;</pre></code></pre></p> <pre><code><pre>MessageSelector : Type :=  (messages : List (EngineMsg Msg))    -&gt; Option (Pair (EngineMsg Msg) (List (EngineMsg Msg)));</pre></code></pre> <pre><code><pre>selectFirstMessage  (messages : List (EngineMsg Msg))  : Option (Pair (EngineMsg Msg) (List (EngineMsg Msg))) :=  case messages of    | [] := none    | msg :: rest := some (mkPair msg rest);</pre></code></pre>","tags":["work-in-progress","simulator","engine"],"boost":2},{"location":"arch/node/integration/simulator.html#network-and-node-state-types","title":"Network and Node State Types","text":"<p>Data structures for representing nodes, network state, and the overall simulation environment.</p> <pre><code><pre>type Node :=  mkNode@{    engines : OMap EngineName Eng;  };</pre></code></pre> <pre><code><pre>type NetworkState :=  mkNetworkState@{    nodes : OMap NodeID Node;    messages : List (EngineMsg Msg);    currentTime : Time;    incrementId : NodeID -&gt; NodeID;    nextId : NodeID;  };</pre></code></pre>","tags":["work-in-progress","simulator","engine"],"boost":2},{"location":"arch/node/integration/simulator.html#guard-execution-and-action-processing","title":"Guard Execution and Action Processing","text":"<p>Core logic for executing guard outputs and processing engine actions based on triggers.</p> <pre><code><pre>executeGuardOutput  {C S B H A AM AC AE : Type}  (output : GuardOutput C S B H A AM AC AE)  (eng : Engine C S B H A AM AC AE)  (trigger : TimestampedTrigger H AM)  : Option (ActionEffect S B H AM AC AE) :=  case output of    | GuardOutput.mk@{action := ActionExec.Seq actions; args := args} :=      let        terminating        executeAction          (acts : List (Action C S B H A AM AC AE))          (currentEnv : EngineEnv S B H AM)          : Option (ActionEffect S B H AM AC AE) :=          case acts of            | [] := none            | act :: rest :=              case                act                  ActionInput.mk@{                    args := args;                    cfg := Engine.cfg eng;                    env := currentEnv;                    trigger := trigger;                  }              of                | none := executeAction rest currentEnv                | some effect :=                  case executeAction rest (ActionEffect.env effect) of                    | none := some effect                    | some nextEffect :=                      some                        ActionEffect.mk@{                          env := ActionEffect.env nextEffect;                          msgs :=                            ActionEffect.msgs effect                              ++ ActionEffect.msgs nextEffect;                          timers :=                            ActionEffect.timers effect                              ++ ActionEffect.timers nextEffect;                          engines :=                            ActionEffect.engines effect                              ++ ActionEffect.engines nextEffect;                        };      in executeAction actions (Engine.env eng);</pre></code></pre>","tags":["work-in-progress","simulator","engine"],"boost":2},{"location":"arch/node/integration/simulator.html#engine-evaluation-and-execution","title":"Engine Evaluation and Execution","text":"<p>Functions for evaluating guards and executing actions for specific engines, including both typed and untyped variants.</p> <pre><code><pre>terminatingevaluateAndExecute  {C S B H A AM AC AE : Type}  (eng : Engine C S B H A AM AC AE)  (msg : EngineMsg AM)  : Option    (Pair      (List (EngineMsg AM))      (Pair (List (Pair AC AE)) (Engine C S B H A AM AC AE))) :=  let    trigger :=      TimestampedTrigger.mkTimestampedTrigger@{        time := right 0;        trigger :=          Trigger.MessageArrived@{            msg := msg;          };      };    behaviour := Engine.behaviour eng;    guardResult :=      case EngineBehaviour.guards behaviour of        | GuardEval.First guards :=          let            terminating            tryGuard              (gs : List (Guard C S B H A AM AC AE))              : Option (GuardOutput C S B H A AM AC AE) :=              case gs of                | [] := none                | g :: rest :=                  case g trigger (Engine.cfg eng) (Engine.env eng) of                    | none := tryGuard rest                    | some output := some output;          in tryGuard guards        | GuardEval.Any guards :=          let            terminating            tryGuard              (gs : List (Guard C S B H A AM AC AE))              : Option (GuardOutput C S B H A AM AC AE) :=              case gs of                | [] := none                | g :: rest :=                  case g trigger (Engine.cfg eng) (Engine.env eng) of                    | none := tryGuard rest                    | some output := some output;          in tryGuard guards;    actionResult :=      case guardResult of        | none := none        | some output := executeGuardOutput output eng trigger;    updatedEngine :=      case actionResult of        | none := none        | some effect := some eng@Engine{env := ActionEffect.env effect};  in case updatedEngine of       | none := none       | some newEng :=         case actionResult of           | none := none           | some effect :=             some               (mkPair                 (ActionEffect.msgs effect)                 (mkPair (ActionEffect.engines effect) newEng));</pre></code></pre>","tags":["work-in-progress","simulator","engine"],"boost":2},{"location":"arch/node/integration/simulator.html#engine-dispatcher","title":"Engine Dispatcher","text":"<p>The large dispatcher function that handles evaluation and execution for all engine types in the system.</p> <pre><code><pre>evaluateAndExecuteEng  (eng : Eng)  (msg : EngineMsg Msg)  : Option (Pair (List (EngineMsg Msg)) (Pair (List (Pair Cfg Env)) Eng)) :=  case eng of    | Eng.IdentityManagement e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some            (mkPair msgs (mkPair cfgEnvPairs (Eng.IdentityManagement newEng)))      }    | Eng.Decryption e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.Decryption newEng)))      }    | Eng.Encryption e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.Encryption newEng)))      }    | Eng.Commitment e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.Commitment newEng)))      }    | Eng.Verification e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.Verification newEng)))      }    | Eng.ReadsFor e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.ReadsFor newEng)))      }    | Eng.SignsFor e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.SignsFor newEng)))      }    | Eng.Naming e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.Naming newEng)))      }    | Eng.LocalKeyValueStorage e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some            (mkPair msgs (mkPair cfgEnvPairs (Eng.LocalKeyValueStorage newEng)))      }    | Eng.Logging e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.Logging newEng)))      }    | Eng.WallClock e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.WallClock newEng)))      }    | Eng.LocalTSeries e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.LocalTSeries newEng)))      }    | Eng.Router e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.Router newEng)))      }    | Eng.TransportProtocol e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.TransportProtocol newEng)))      }    | Eng.TransportConnection e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some            (mkPair msgs (mkPair cfgEnvPairs (Eng.TransportConnection newEng)))      }    | Eng.PubSubTopic e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.PubSubTopic newEng)))      }    | Eng.Storage e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.Storage newEng)))      }    | Eng.MempoolWorker e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.MempoolWorker newEng)))      }    | Eng.Executor e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.Executor newEng)))      }    | Eng.Shard e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.Shard newEng)))      }    | Eng.Ticker e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.Ticker newEng)))      }    | Eng.Template e :=      case evaluateAndExecute e msg of {        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.Template newEng)))      }    | Eng.TemplateMinimum e :=      case evaluateAndExecute e msg of        | none := none        | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=          some (mkPair msgs (mkPair cfgEnvPairs (Eng.TemplateMinimum newEng)));</pre></code></pre>","tags":["work-in-progress","simulator","engine"],"boost":2},{"location":"arch/node/integration/simulator.html#network-state-management","title":"Network State Management","text":"<p>Functions for managing network state updates, including adding new engines and updating existing ones.</p> <pre><code><pre>addNewEngine  (state : NetworkState)  (nodeId : NodeID)  (cfg : Cfg)  (env : Env)  : NetworkState :=  case OMap.lookup nodeId (NetworkState.nodes state) of    | none := state    | some node :=      case mkEng nodeId (mkPair cfg env) of        | none := state        | some (mkPair newEng newEngineId) :=          let            engineName := snd newEngineId;            updatedNode :=              node@Node{engines := OMap.insert                engineName                newEng                (Node.engines node)};          in state@NetworkState{nodes := OMap.insert            nodeId            updatedNode            (NetworkState.nodes state)};</pre></code></pre> <pre><code><pre>updateNetworkState  (state : NetworkState)  (target : EngineID)  (eng : Eng)  (msgs : List (EngineMsg Msg))  (cfgEnvPairs : List (Pair Cfg Env))  : NetworkState :=  let    nodeId :=      case target of        | mkPair none _ := none        | mkPair (some nid) _ := some nid;    engineName := snd target;    state' :=      case nodeId of        | none := state        | some nid :=          case OMap.lookup nid (NetworkState.nodes state) of            | none := state            | some n :=              state@NetworkState{nodes := OMap.insert                nid                n@Node{engines := OMap.insert engineName eng (Node.engines n)}                (NetworkState.nodes state)};    stateWithMessages :=      state'@NetworkState{messages := NetworkState.messages state ++ msgs};    finalState :=      foldl        \\{s (mkPair cfg env) :=          case nodeId of            | none := s            | some nid := addNewEngine s nid cfg env}        stateWithMessages        cfgEnvPairs;  in finalState;</pre></code></pre>","tags":["work-in-progress","simulator","engine"],"boost":2},{"location":"arch/node/integration/simulator.html#core-simulation-logic","title":"Core Simulation Logic","text":"<p>The main step function and simulation loops for processing messages and running the simulation.</p> <pre><code><pre>step  (selector : MessageSelector)  (state : NetworkState)  : Pair NetworkState (Option (EngineMsg Msg)) :=  let    selected := selector (NetworkState.messages state);  in case selected of       | none := mkPair state none       | some (mkPair msg rest) :=         let           state' := state@NetworkState{messages := rest};           target := EngineMsg.target msg;           nodeId :=             case target of               | mkPair none _ := none               | mkPair (some nid) _ := some nid;           engineName := snd target;           engine :=             case nodeId of               | none := none               | some nid :=                 case OMap.lookup nid (NetworkState.nodes state) of                   | none := none                   | some n := OMap.lookup engineName (Node.engines n);         in case engine of              | none := mkPair state' none              | some eng :=                let                  result := evaluateAndExecuteEng eng msg;                in case result of                     | none := mkPair state' none                     | some (mkPair msgs (mkPair cfgEnvPairs newEng)) :=                       mkPair                         (updateNetworkState                           state'                           target                           newEng                           msgs                           cfgEnvPairs)                         (some msg);</pre></code></pre> <pre><code><pre>terminatingsimulate  (selector : MessageSelector)  (state : NetworkState)  (steps : Nat)  : List (EngineMsg Msg) :=  case steps of    | zero := []    | suc n :=      let        nextPair := step selector state;        newState := fst nextPair;        processedMsgOpt := snd nextPair;        restMsgs := simulate selector newState n;      in case processedMsgOpt of           | none := restMsgs           | some processedMsg := processedMsg :: restMsgs;</pre></code></pre> <pre><code><pre>terminatingsimulateWithFailures  (selector : MessageSelector)  (state : NetworkState)  (steps : Nat)  : Pair (List (EngineMsg Msg)) (List (EngineMsg Msg)) :=  case steps of    | zero := mkPair [] []    | suc n :=      let        selected := selector (NetworkState.messages state);      in case selected of           | none :=             let               recursiveResult := simulateWithFailures selector state n;             in recursiveResult           | some (mkPair msg rest) :=             let               state' := state@NetworkState{messages := rest};               nextPair := step selector state;               newState := fst nextPair;               processedMsgOpt := snd nextPair;               recursiveResult := simulateWithFailures selector newState n;               successMsgs := fst recursiveResult;               failedMsgs := snd recursiveResult;             in case processedMsgOpt of                  | none := mkPair successMsgs (msg :: failedMsgs)                  | some processedMsg :=                    mkPair (processedMsg :: successMsgs) failedMsgs;</pre></code></pre>","tags":["work-in-progress","simulator","engine"],"boost":2},{"location":"arch/node/integration/visualizer.html","title":"Simulation Message Visualizer","text":"<p>This module provides functions to generate Mermaid sequence diagrams from a list of engine messages, allowing for visualization of simulation traces.</p> Juvix Code <p><pre><code><pre>module arch.node.integration.visualizer;import prelude open;import Stdlib.Data.Set as Set;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message open;import arch.system.state.resource_machine.notes.nockma open;import arch.node.types.basics open;import arch.node.types.transport open;import arch.node.engines.identity_management_messages open;import arch.node.engines.decryption_messages open;import arch.node.engines.encryption_messages open;import arch.node.engines.commitment_messages open;import arch.node.engines.verification_messages open;import arch.node.engines.reads_for_messages open;import arch.node.engines.signs_for_messages open;import arch.node.engines.naming_messages open;import arch.node.engines.local_key_value_storage_messages open;import arch.node.engines.logging_messages open;import arch.node.engines.wall_clock_messages open;import arch.node.engines.local_time_series_storage_messages open;import arch.node.engines.net_registry_messages open;import arch.node.engines.router_messages open;import arch.node.engines.transport_protocol_messages open;import arch.node.engines.transport_connection_messages open;import arch.node.engines.pub_sub_topic_messages open;import arch.node.engines.storage_messages open;import arch.node.engines.mempool_worker_messages open;import arch.node.engines.executor_messages open;import arch.node.engines.shard_messages open;import arch.node.engines.ticker_messages open;import tutorial.engines.template_messages open;import tutorial.engines.template_minimum_messages as TemplateMinimum;</pre></code></pre></p>","tags":["simulator","visualizer","mermaid"]},{"location":"arch/node/integration/visualizer.html#helper-functions","title":"Helper Functions","text":"<p>Utility functions for string conversion, participant management, and basic data manipulation needed for diagram generation.</p> <pre><code><pre>engineIdToString (eid : EngineID) : String :=  let    nodeStr :=      case fst eid of        | none := \"Client\"        | some (PublicKey.Curve25519PubKey pk) := pk;    engineNameStr := snd eid;  in nodeStr ++str \"/\" ++str engineNameStr;</pre></code></pre> <pre><code><pre>nodeIdToString (nodeId : NodeID) : String :=  case nodeId of | PublicKey.Curve25519PubKey pk := pk;</pre></code></pre> <pre><code><pre>terminatingstringJoin (separator : String) (strings : List String) : String :=  case strings of    | [] := \"\"    | s :: [] := s    | s :: rest := s ++str separator ++str stringJoin separator rest;</pre></code></pre> <pre><code><pre>getParticipants (messages : List (EngineMsg Msg)) : Set String :=  let    addParticipantIds (msg : EngineMsg Msg) (acc : Set String) : Set String :=      let        senderStr := engineIdToString (EngineMsg.sender msg);        targetStr := engineIdToString (EngineMsg.target msg);      in insert senderStr (insert targetStr acc);  in foldr addParticipantIds Set.empty messages;</pre></code></pre> <pre><code><pre>boolToString (b : Bool) : String :=  if     | b := \"true\"    | else := \"false\";</pre></code></pre>","tags":["simulator","visualizer","mermaid"]},{"location":"arch/node/integration/visualizer.html#basic-type-converters","title":"Basic Type Converters","text":"<p>Conversion functions for fundamental data types used throughout the system.</p> <pre><code><pre>hashToString (h : Hash) : String := \"&lt;hash&gt;\";</pre></code></pre> <pre><code><pre>terminatingnounToString (n : Noun) : String :=  case n of    | Noun.Atom a := natToString a    | Noun.Cell l r :=      \"[\" ++str nounToString l ++str \" \" ++str nounToString r ++str \"]\";</pre></code></pre> <pre><code><pre>kvsKeyToString (key : KVSKey) : String := \"&lt;KVSKeyPlaceholder&gt;\";</pre></code></pre> <pre><code><pre>kvsDatumToString (datum : KVSDatum) : String := \"&lt;KVSDatumPlaceholder&gt;\";</pre></code></pre> <pre><code><pre>signableToString (s : Signable) : String := \"&lt;Signable&gt;\";commitmentToString (c : Commitment) : String := \"&lt;Commitment&gt;\";ciphertextToString (c : Ciphertext) : String := \"&lt;Ciphertext&gt;\";plaintextToString (p : Plaintext) : String := \"&lt;Plaintext&gt;\";readsForEvidenceToString (rfe : ReadsForEvidence) : String :=  \"&lt;ReadsForEvidence&gt;\";signsForEvidenceToString (sfe : SignsForEvidence) : String :=  \"&lt;SignsForEvidence&gt;\";backendToString (b : Backend) : String := \"&lt;Backend&gt;\";idParamsToString (p : IDParams) : String := \"&lt;IDParams&gt;\";capabilitiesToString (c : Capabilities) : String := \"&lt;Capabilities&gt;\";routerMsgInnerToString (r : RouterMsg Msg) : String := \"&lt;RouterMsgInner&gt;\";transportAddressToString (t : TransportAddress) : String := \"&lt;TransportAddress&gt;\";byteStringToString (b : ByteString) : String := \"&lt;ByteString&gt;\";chunkIdToString (c : ChunkID) : String := \"&lt;ChunkID&gt;\";topicIdToString (t : TopicID) : String := \"&lt;TopicID&gt;\";epochTimestampToString (et : Nat) : String := natToString et;tsStorageDBQueryToString (q : TSStorageDBQuery) : String := \"&lt;TSQuery&gt;\";tsStorageDBDataToString (d : TSStorageDBData) : String := \"&lt;TSData&gt;\";storageKeyToString (k : String) : String := k;storageValueToString (v : String) : String := v;encryptedMsgToString (em : EncryptedMsg) : String := \"&lt;EncryptedMsg&gt;\";</pre></code></pre> <pre><code><pre>transactionLabelToString (label : TransactionLabel KVSKey KVSKey) : String :=  let    readKeysStr :=      stringJoin \",\" (map kvsKeyToString (TransactionLabel.read label));    writeKeysStr :=      stringJoin \",\" (map kvsKeyToString (TransactionLabel.write label));  in \"R:[\" ++str readKeysStr ++str \"]W:[\" ++str writeKeysStr ++str \"]\";</pre></code></pre>","tags":["simulator","visualizer","mermaid"]},{"location":"arch/node/integration/visualizer.html#core-engine-message-converters","title":"Core Engine Message Converters","text":"<p>Functions to convert core engine messages (Mempool, Shard, Executor, Logging) into readable string representations.</p> <pre><code><pre>terminatingmempoolWorkerMsgToString (mwMsg : MempoolWorkerMsg Noun) : String :=  case mwMsg of    | MempoolWorkerMsg.TransactionRequest tr :=      \"TxReq(label: \"        ++str transactionLabelToString          (TransactionCandidate.label (TransactionRequest.tx tr))        ++str \")\"    | MempoolWorkerMsg.TransactionAck ack :=      \"TxAck(hash: \"        ++str hashToString (TransactionAck.tx_hash ack)        ++str \", batch: \"        ++str natToString (TransactionAck.batch_number ack)        ++str \")\";</pre></code></pre> <pre><code><pre>terminatingshardMsgToString (sMsg : ShardMsg) : String :=  case sMsg of    | ShardMsg.KVSReadRequest req :=      \"KVSReadReq(key:\"        ++str kvsKeyToString (KVSReadRequestMsg.key req)        ++str \",ts:\"        ++str natToString (KVSReadRequestMsg.timestamp req)        ++str \",act:\"        ++str boolToString (KVSReadRequestMsg.actual req)        ++str \")\"    | ShardMsg.KVSWrite write :=      let        datumStr :=          case KVSWriteMsg.datum write of            | none := \"&lt;none&gt;\"            | some d := kvsDatumToString d;      in \"KVSWrite(key:\"        ++str kvsKeyToString (KVSWriteMsg.key write)        ++str \",ts:\"        ++str natToString (KVSWriteMsg.timestamp write)        ++str \",data:\"        ++str datumStr        ++str \")\"    | ShardMsg.KVSAcquireLock acquireLock :=      \"KVSAcquireLock(ts:\"        ++str natToString (KVSAcquireLockMsg.timestamp acquireLock)        ++str \")\"    | ShardMsg.KVSLockAcquired lockAcquired :=      \"KVSLockAcquired(ts:\"        ++str natToString (KVSLockAcquiredMsg.timestamp lockAcquired)        ++str \")\"    | ShardMsg.KVSRead readReply :=      \"KVSRead(key:\"        ++str kvsKeyToString (KVSReadMsg.key readReply)        ++str \",ts:\"        ++str natToString (KVSReadMsg.timestamp readReply)        ++str \",data:\"        ++str kvsDatumToString (KVSReadMsg.data readReply)        ++str \")\"    | ShardMsg.UpdateSeenAll updateSeenAll :=      \"UpdateSeenAll(ts: \"        ++str natToString (UpdateSeenAllMsg.timestamp updateSeenAll)        ++str \", write: \"        ++str boolToString (UpdateSeenAllMsg.write updateSeenAll)        ++str \")\";</pre></code></pre> <pre><code><pre>terminatingexecutorMsgToString (execMsg : ExecutorMsg) : String :=  case execMsg of    | ExecutorMsg.ExecutorFinished fin :=      \"ExecFinished(ok: \"        ++str boolToString (ExecutorFinishedMsg.success fin)        ++str \")\";</pre></code></pre> <pre><code><pre>terminatingloggingMsgToString (logMsg : LoggingMsg) : String :=  case logMsg of    | LoggingMsg.Append appendVal :=      \"LogAppend(val: \\\"\" ++str AppendValue.value appendVal ++str \"\\\")\";</pre></code></pre>","tags":["simulator","visualizer","mermaid"]},{"location":"arch/node/integration/visualizer.html#identity-and-cryptographic-message-converters","title":"Identity and Cryptographic Message Converters","text":"<p>Converters for identity management, naming, and cryptographic operations (encryption, decryption, verification, etc.).</p> <pre><code><pre>identityNameToString (idName : IdentityName) : String := \"&lt;IdentityName&gt;\";externalIdentityToString (extId : ExternalIdentity) : String :=  \"&lt;ExternalIdentity&gt;\";identityNameEvidenceToString (evidence : IdentityNameEvidence) : String :=  \"&lt;IdentityNameEvidence&gt;\";</pre></code></pre> <pre><code><pre>terminatingnamingMsgToString (nMsg : NamingMsg) : String :=  case nMsg of    | NamingMsg.ResolveNameRequest req :=      \"ResolveNameReq(name:\"        ++str identityNameToString (RequestResolveName.identityName req)        ++str \")\"    | NamingMsg.ResolveNameReply reply :=      let        count :=          length (Set.toList (ReplyResolveName.externalIdentities reply));      in \"ResolveNameReply(count:\"        ++str natToString count        ++str \", err:\"        ++str option (ReplyResolveName.err reply) \"None\" id        ++str \")\"    | NamingMsg.SubmitNameEvidenceRequest req :=      \"SubmitEvidenceReq(ev:\"        ++str identityNameEvidenceToString          (RequestSubmitNameEvidence.evidence req)        ++str \")\"    | NamingMsg.SubmitNameEvidenceReply reply :=      \"SubmitEvidenceReply(err:\"        ++str option (ReplySubmitNameEvidence.err reply) \"None\" id        ++str \")\"    | NamingMsg.QueryNameEvidenceRequest req :=      \"QueryEvidenceReq(id:\"        ++str externalIdentityToString          (RequestQueryNameEvidence.externalIdentity req)        ++str \")\"    | NamingMsg.QueryNameEvidenceReply reply :=      let        evCount := length (Set.toList (ReplyQueryNameEvidence.evidence reply));      in \"QueryEvidenceReply(id:\"        ++str externalIdentityToString          (ReplyQueryNameEvidence.externalIdentity reply)        ++str \", evCount:\"        ++str natToString evCount        ++str \", err:\"        ++str option (ReplyQueryNameEvidence.err reply) \"None\" id        ++str \")\";</pre></code></pre> <pre><code><pre>identityManagementMsgToString (imMsg : IdentityManagementMsg) : String :=  case imMsg of    | IdentityManagementMsg.GenerateIdentityRequest req :=      \"GenerateIdReq(be:\"        ++str backendToString (RequestGenerateIdentity.backend req)        ++str \",cap:\"        ++str capabilitiesToString (RequestGenerateIdentity.capabilities req)        ++str \")\"    | IdentityManagementMsg.GenerateIdentityReply reply :=      \"GenerateIdReply(extId:\"        ++str engineIdToString (ReplyGenerateIdentity.externalIdentity reply)        ++str \",err:\"        ++str option (ReplyGenerateIdentity.err reply) \"None\" id        ++str \")\"    | IdentityManagementMsg.ConnectIdentityRequest req :=      \"ConnectIdReq(id:\"        ++str engineIdToString (RequestConnectIdentity.externalIdentity req)        ++str \",be:\"        ++str backendToString (RequestConnectIdentity.backend req)        ++str \")\"    | IdentityManagementMsg.ConnectIdentityReply reply :=      \"ConnectIdReply(err:\"        ++str option (ReplyConnectIdentity.err reply) \"None\" id        ++str \")\"    | IdentityManagementMsg.DeleteIdentityRequest req :=      \"DeleteIdReq(id:\"        ++str engineIdToString (RequestDeleteIdentity.externalIdentity req)        ++str \",be:\"        ++str backendToString (RequestDeleteIdentity.backend req)        ++str \")\"    | IdentityManagementMsg.DeleteIdentityReply reply :=      \"DeleteIdReply(err:\"        ++str option (ReplyDeleteIdentity.err reply) \"None\" id        ++str \")\";</pre></code></pre> <pre><code><pre>decryptionMsgToString (decMsg : DecryptionMsg) : String :=  case decMsg of    | DecryptionMsg.Request req :=      \"DecryptReq(data:\"        ++str ciphertextToString (RequestDecryption.data req)        ++str \")\"    | DecryptionMsg.Reply reply :=      \"DecryptReply(data:\"        ++str plaintextToString (ReplyDecryption.data reply)        ++str \",err:\"        ++str option (ReplyDecryption.err reply) \"None\" id        ++str \")\";</pre></code></pre> <pre><code><pre>encryptionMsgToString (encMsg : EncryptionMsg) : String :=  case encMsg of    | EncryptionMsg.Request req :=      \"EncryptReq(id:\"        ++str externalIdentityToString (RequestEncrypt.externalIdentity req)        ++str \",readsFor:\"        ++str boolToString (RequestEncrypt.useReadsFor req)        ++str \")\"    | EncryptionMsg.Reply reply :=      \"EncryptReply(data:\"        ++str ciphertextToString (ReplyEncrypt.ciphertext reply)        ++str \",err:\"        ++str option (ReplyEncrypt.err reply) \"None\" id        ++str \")\";</pre></code></pre> <pre><code><pre>commitmentMsgToString (comMsg : CommitmentMsg) : String :=  case comMsg of    | CommitmentMsg.Request req :=      \"CommitReq(data:\"        ++str signableToString (RequestCommitment.data req)        ++str \")\"    | CommitmentMsg.Reply reply :=      \"CommitReply(commit:\"        ++str commitmentToString (ReplyCommitment.commitment reply)        ++str \",err:\"        ++str option (ReplyCommitment.err reply) \"None\" id        ++str \")\";verificationMsgToString (verMsg : VerificationMsg) : String :=  case verMsg of    | VerificationMsg.Request req :=      \"VerifyReq(id:\"        ++str externalIdentityToString          (RequestVerification.externalIdentity req)        ++str \",useSf:\"        ++str boolToString (RequestVerification.useSignsFor req)        ++str \")\"    | VerificationMsg.Reply reply :=      \"VerifyReply(ok:\"        ++str boolToString (ReplyVerification.result reply)        ++str \",err:\"        ++str option (ReplyVerification.err reply) \"None\" id        ++str \")\";</pre></code></pre> <pre><code><pre>readsForMsgToString (rfMsg : ReadsForMsg) : String :=  case rfMsg of    | ReadsForMsg.Request req :=      \"ReadsForReq(A:\"        ++str externalIdentityToString (RequestReadsFor.externalIdentityA req)        ++str \",B:\"        ++str externalIdentityToString (RequestReadsFor.externalIdentityB req)        ++str \")\"    | ReadsForMsg.Reply reply :=      \"ReadsForReply(ok:\"        ++str boolToString (ReplyReadsFor.readsFor reply)        ++str \",err:\"        ++str option (ReplyReadsFor.err reply) \"None\" id        ++str \")\"    | ReadsForMsg.SubmitReadsForEvidenceRequest req :=      \"SubmitReadsForEvReq(ev:\"        ++str readsForEvidenceToString          (RequestSubmitReadsForEvidence.evidence req)        ++str \")\"    | ReadsForMsg.SubmitReadsForEvidenceReply reply :=      \"SubmitReadsForEvReply(err:\"        ++str option (ReplySubmitReadsForEvidence.err reply) \"None\" id        ++str \")\"    | ReadsForMsg.QueryReadsForEvidenceRequest req :=      \"QueryReadsForEvReq(id:\"        ++str externalIdentityToString          (RequestQueryReadsForEvidence.externalIdentity req)        ++str \")\"    | ReadsForMsg.QueryReadsForEvidenceReply reply :=      \"QueryReadsForEvReply(id:\"        ++str externalIdentityToString          (ReplyQueryReadsForEvidence.externalIdentity reply)        ++str \",err:\"        ++str option (ReplyQueryReadsForEvidence.err reply) \"None\" id        ++str \")\";</pre></code></pre> <pre><code><pre>signsForMsgToString (sfMsg : SignsForMsg) : String :=  case sfMsg of    | SignsForMsg.SignsForRequest req :=      \"SignsForReq(A:\"        ++str externalIdentityToString (RequestSignsFor.externalIdentityA req)        ++str \",B:\"        ++str externalIdentityToString (RequestSignsFor.externalIdentityB req)        ++str \")\"    | SignsForMsg.SignsForReply reply :=      \"SignsForReply(ok:\"        ++str boolToString (ReplySignsFor.signsFor reply)        ++str \",err:\"        ++str option (ReplySignsFor.err reply) \"None\" id        ++str \")\"    | SignsForMsg.SubmitSignsForEvidenceRequest req :=      \"SubmitSignsForEvReq(ev:\"        ++str signsForEvidenceToString          (RequestSubmitSignsForEvidence.evidence req)        ++str \")\"    | SignsForMsg.SubmitSignsForEvidenceReply reply :=      \"SubmitSignsForEvReply(err:\"        ++str option (ReplySubmitSignsForEvidence.err reply) \"None\" id        ++str \")\"    | SignsForMsg.QuerySignsForEvidenceRequest req :=      \"QuerySignsForEvReq(id:\"        ++str externalIdentityToString          (RequestQuerySignsForEvidence.externalIdentity req)        ++str \")\"    | SignsForMsg.QuerySignsForEvidenceReply reply :=      \"QuerySignsForEvReply(id:\"        ++str externalIdentityToString          (ReplyQuerySignsForEvidence.externalIdentity reply)        ++str \",err:\"        ++str option (ReplyQuerySignsForEvidence.err reply) \"None\" id        ++str \")\";</pre></code></pre>","tags":["simulator","visualizer","mermaid"]},{"location":"arch/node/integration/visualizer.html#storage-and-system-message-converters","title":"Storage and System Message Converters","text":"<p>Converters for various storage systems (Local KV, Time Series) and system services (Wall Clock, etc.).</p> <pre><code><pre>localKVStorageMsgToString (kvMsg : LocalKVStorageMsg) : String :=  case kvMsg of    | LocalKVStorageMsg.GetValueRequest req :=      \"KVGetReq(key:\"        ++str storageKeyToString (GetValueKVStoreRequest.key req)        ++str \")\"    | LocalKVStorageMsg.GetValueReply reply :=      \"KVGetReply(key:\"        ++str storageKeyToString (GetValueKVStoreReply.key reply)        ++str \",val:\"        ++str storageValueToString (GetValueKVStoreReply.value reply)        ++str \")\"    | LocalKVStorageMsg.SetValueRequest req :=      \"KVSetReq(key:\"        ++str storageKeyToString (SetValueKVStoreRequest.key req)        ++str \",val:\"        ++str storageValueToString (SetValueKVStoreRequest.value req)        ++str \")\"    | LocalKVStorageMsg.SetValueReply reply :=      \"KVSetReply(key:\"        ++str storageKeyToString (SetValueKVStoreReply.key reply)        ++str \",ok:\"        ++str boolToString (SetValueKVStoreReply.success reply)        ++str \")\"    | LocalKVStorageMsg.DeleteValueRequest req :=      \"KVDelReq(key:\"        ++str storageKeyToString (DeleteValueKVStoreRequest.key req)        ++str \")\"    | LocalKVStorageMsg.DeleteValueReply reply :=      \"KVDelReply(key:\"        ++str storageKeyToString (DeleteValueKVStoreReply.key reply)        ++str \",ok:\"        ++str boolToString (DeleteValueKVStoreReply.success reply)        ++str \")\"    | LocalKVStorageMsg.ValueChanged notice :=      \"KVChanged(key:\"        ++str storageKeyToString (ValueChangedKVStore.key notice)        ++str \",val:\"        ++str storageValueToString (ValueChangedKVStore.value notice)        ++str \",ts:\"        ++str epochTimestampToString (ValueChangedKVStore.timestamp notice)        ++str \")\";</pre></code></pre> <pre><code><pre>wallClockMsgToString (wcMsg : WallClockMsg) : String :=  case wcMsg of    | WallClockMsg.GetTime := \"GetTimeReq\"    | WallClockMsg.GetTimeResult reply :=      \"GetTimeReply(ts:\"        ++str epochTimestampToString (TimeResult.epochTime reply)        ++str \")\";</pre></code></pre> <pre><code><pre>localTSStorageMsgToString (tsMsg : LocalTSStorageMsg) : String :=  case tsMsg of    | LocalTSStorageMsg.GetRequest req :=      \"TSGetReq(q:\"        ++str tsStorageDBQueryToString (GetDataTSStorageDBRequest.query req)        ++str \")\"    | LocalTSStorageMsg.GetReply reply :=      \"TSGetReply(q:\"        ++str tsStorageDBQueryToString (GetDataTSStorageDBReply.query reply)        ++str \",data:\"        ++str tsStorageDBDataToString (GetDataTSStorageDBReply.data reply)        ++str \")\"    | LocalTSStorageMsg.RecordRequest req :=      \"TSRecordReq(q:\"        ++str tsStorageDBQueryToString (RecordDataTSStorageDBRequest.query req)        ++str \")\"    | LocalTSStorageMsg.RecordReply reply :=      \"TSRecordReply(q:\"        ++str tsStorageDBQueryToString (RecordDataTSStorageDBReply.query reply)        ++str \",ok:\"        ++str boolToString (RecordDataTSStorageDBReply.success reply)        ++str \")\"    | LocalTSStorageMsg.DeleteRequest req :=      \"TSDeleteReq(q:\"        ++str tsStorageDBQueryToString (DeleteDataTSStorageDBRequest.query req)        ++str \")\"    | LocalTSStorageMsg.DeleteReply reply :=      \"TSDeleteReply(q:\"        ++str tsStorageDBQueryToString (DeleteDataTSStorageDBReply.query reply)        ++str \",ok:\"        ++str boolToString (DeleteDataTSStorageDBReply.success reply)        ++str \")\"    | LocalTSStorageMsg.DataChanged notice :=      \"TSDataChanged(q:\"        ++str tsStorageDBQueryToString (DataChangedTSStorageDB.query notice)        ++str \",data:\"        ++str tsStorageDBDataToString (DataChangedTSStorageDB.data notice)        ++str \",ts:\"        ++str epochTimestampToString (DataChangedTSStorageDB.timestamp notice)        ++str \")\";</pre></code></pre>","tags":["simulator","visualizer","mermaid"]},{"location":"arch/node/integration/visualizer.html#network-and-transport-message-converters","title":"Network and Transport Message Converters","text":"<p>Converters for networking, routing, and transport-related messages.</p> <pre><code><pre>netRegistryMsgToString (nrMsg : NetworkRegistryMsg) : String :=  case nrMsg of    | NetworkRegistryMsg.NodeAdvert advert :=      \"NodeAdvert(id:\"        ++str nodeIdToString (NodeAdvert.id advert)        ++str \",v:\"        ++str natToString (NodeAdvert.version advert)        ++str \")\"    | NetworkRegistryMsg.TopicAdvert advert :=      \"TopicAdvert(id:\"        ++str topicIdToString (TopicAdvert.id advert)        ++str \",v:\"        ++str natToString (TopicAdvert.version advert)        ++str \")\"    | NetworkRegistryMsg.GetNodeAdvertRequest req :=      \"GetNodeAdvertReq(id:\" ++str nodeIdToString req ++str \")\"    | NetworkRegistryMsg.GetNodeAdvertReply reply :=      \"GetNodeAdvertReply(ok:\" ++str boolToString (isRight reply) ++str \")\"    | NetworkRegistryMsg.GetTopicAdvertRequest req :=      \"GetTopicAdvertReq(id:\" ++str topicIdToString req ++str \")\"    | NetworkRegistryMsg.GetTopicAdvertReply reply :=      \"GetTopicAdvertReply(ok:\" ++str boolToString (isRight reply) ++str \")\";</pre></code></pre> <pre><code><pre>routerMsgToString (rMsg : RouterMsg Msg) : String :=  case rMsg of    | RouterMsg.NodeAdvert advert :=      \"NodeAdvert(id:\" ++str nodeIdToString (NodeAdvert.id advert) ++str \")\"    | RouterMsg.Send outMsg :=      \"RouterSend(to:\"        ++str engineIdToString (EngineMsg.target (NodeOutMsg.msg outMsg))        ++str \")\"    | RouterMsg.Recv inMsg :=      \"RouterRecv(seq:\" ++str natToString (NodeMsg.seq inMsg) ++str \")\"    | RouterMsg.ConnectRequest req :=      \"RouterConnectReq(src:\"        ++str nodeIdToString (ConnectRequest.src_node_id req)        ++str \")\"    | RouterMsg.ConnectReply reply :=      \"RouterConnectReply(ok:\" ++str boolToString (isRight reply) ++str \")\"    | RouterMsg.SetPermanence perm :=      \"SetPermanence(\"        ++str case perm of {                | ConnectionPermanence.RouterMsgConnectionEphemeral := \"Eph\"                | ConnectionPermanence.RouterMsgConnectionPermanent := \"Perm\"              }        ++str \")\";</pre></code></pre> <pre><code><pre>transportProtocolMsgToString (tpMsg : TransportProtocolMsg) : String :=  case tpMsg of    | TransportProtocolMsg.Send req :=      \"TpSend(addr:\"        ++str transportAddressToString (TransportOutMsg.addr req)        ++str \")\";</pre></code></pre> <pre><code><pre>transportConnectionMsgToString (tcMsg : TransportConnectionMsg) : String :=  case tcMsg of    | TransportConnectionMsg.Send outMsg :=      let        innerNodeMsg := TransportConnectionOutMsg.msg outMsg;        seqStr := natToString (NodeMsg.seq innerNodeMsg);        encMsgDetailStr := encryptedMsgToString (NodeMsg.msg innerNodeMsg);      in \"TcSend(seq:\"        ++str seqStr        ++str \", msg:\"        ++str encMsgDetailStr        ++str \")\";</pre></code></pre> <pre><code><pre>pubSubTopicMsgToString (psMsg : PubSubTopicMsg) : String :=  case psMsg of    | PubSubTopicMsg.Forward _ := \"PsForward\"    | PubSubTopicMsg.SubRequest req :=      \"PsSubReq(topic:\"        ++str topicIdToString (TopicSubRequest.topic req)        ++str \")\"    | PubSubTopicMsg.SubReply reply :=      \"PsSubReply(ok:\" ++str boolToString (isRight reply) ++str \")\"    | PubSubTopicMsg.UnsubRequest req :=      \"PsUnsubReq(topic:\"        ++str topicIdToString (TopicUnsubRequest.topic req)        ++str \")\"    | PubSubTopicMsg.UnsubReply reply :=      \"PsUnsubReply(ok:\" ++str boolToString (isRight reply) ++str \")\";</pre></code></pre> <pre><code><pre>storageMsgToString (stMsg : StorageMsg) : String :=  case stMsg of    | StorageMsg.ChunkGetRequest req :=      \"ChunkGetReq(id:\"        ++str chunkIdToString (ChunkGetRequest.chunk req)        ++str \")\"    | StorageMsg.ChunkGetReply reply :=      \"ChunkGetReply(ok:\" ++str boolToString (isRight reply) ++str \")\"    | StorageMsg.ChunkPutRequest _ := \"ChunkPutReq\"    | StorageMsg.ChunkPutReply reply :=      \"ChunkPutReply(ok:\" ++str boolToString (isRight reply) ++str \")\";</pre></code></pre>","tags":["simulator","visualizer","mermaid"]},{"location":"arch/node/integration/visualizer.html#template-and-utility-message-converters","title":"Template and Utility Message Converters","text":"<p>Converters for template engines and utility services like ticker.</p> <pre><code><pre>tickerMsgToString (tMsg : TickerMsg) : String :=  case tMsg of    | TickerMsg.Increment := \"TickInc\"    | TickerMsg.CountRequest := \"TickCountReq\"    | TickerMsg.CountReply reply :=      \"TickCountReply(val:\"        ++str natToString (CountReply.counter reply)        ++str \")\";</pre></code></pre> <pre><code><pre>templateMsgToString (tMsg : TemplateMsg) : String :=  case tMsg of    | TemplateMsg.JustHi := \"TemplateHi\"    | TemplateMsg.ExampleRequest ExampleRequest.mk@{                                   argOne := a1;                                   argTwo := a2;                                 } :=      \"TemplateExampleReq(a1:\"        ++str natToString a1        ++str \",a2:\"        ++str natToString a2        ++str \")\"    | TemplateMsg.ExampleReply reply :=      \"TemplateExampleReply(ok:\" ++str boolToString (isRight reply) ++str \")\";</pre></code></pre> <pre><code><pre>templateMinimumMsgToString  (tmMsg : TemplateMinimum.TemplateMinimumMsg) : String :=  case tmMsg of    | TemplateMinimum.TemplateMinimumMsg.JustHi := \"TemplateMinimumHi\"    | TemplateMinimum.TemplateMinimumMsg.ExampleRequest req :=      \"TemplateMinExampleReq(a1:\"        ++str natToString (TemplateMinimum.ExampleRequest.argOne req)        ++str \",a2:\"        ++str natToString (TemplateMinimum.ExampleRequest.argTwo req)        ++str \")\"    | TemplateMinimum.TemplateMinimumMsg.ExampleReply reply :=      case reply of        | right payload :=          \"TemplateMinExampleReply(ok:\"            ++str TemplateMinimum.ReplyPayload.payload payload            ++str \")\"        | left err :=          \"TemplateMinExampleReply(err:\"            ++str TemplateMinimum.ReplyError.error err            ++str \")\";</pre></code></pre>","tags":["simulator","visualizer","mermaid"]},{"location":"arch/node/integration/visualizer.html#main-message-dispatcher-and-mermaid-generation","title":"Main Message Dispatcher and Mermaid Generation","text":"<p>The core functions that tie everything together - the main message dispatcher and the Mermaid diagram generation logic.</p> <pre><code><pre>terminatingmsgToString (actualMsg : Msg) : String :=  case actualMsg of    | Msg.MempoolWorker mwMsg := mempoolWorkerMsgToString mwMsg    | Msg.Shard shardMsg := shardMsgToString shardMsg    | Msg.Executor execMsg := executorMsgToString execMsg    | Msg.IdentityManagement imMsg := identityManagementMsgToString imMsg    | Msg.Decryption decMsg := decryptionMsgToString decMsg    | Msg.Encryption encMsg := encryptionMsgToString encMsg    | Msg.Commitment comMsg := commitmentMsgToString comMsg    | Msg.Verification verMsg := verificationMsgToString verMsg    | Msg.ReadsFor rfMsg := readsForMsgToString rfMsg    | Msg.SignsFor sfMsg := signsForMsgToString sfMsg    | Msg.Naming nMsg := namingMsgToString nMsg    | Msg.LocalKVStorage kvMsg := localKVStorageMsgToString kvMsg    | Msg.Logging logMsg := loggingMsgToString logMsg    | Msg.WallClock wcMsg := wallClockMsgToString wcMsg    | Msg.LocalTSStorage tsMsg := localTSStorageMsgToString tsMsg    | Msg.Router rMsg := routerMsgToString rMsg    | Msg.TransportProtocol tpMsg := transportProtocolMsgToString tpMsg    | Msg.TransportConnection tcMsg := transportConnectionMsgToString tcMsg    | Msg.PubSubTopic psMsg := pubSubTopicMsgToString psMsg    | Msg.Storage stMsg := storageMsgToString stMsg    | Msg.Ticker tMsg := tickerMsgToString tMsg    | Msg.Template tMsg := templateMsgToString tMsg    | Msg.TemplateMinimum tmMsg := templateMinimumMsgToString tmMsg;messageToMermaid (message : EngineMsg Msg) : String :=  let    senderStr : String := engineIdToString (EngineMsg.sender message);    targetStr : String := engineIdToString (EngineMsg.target message);    label : String := msgToString (EngineMsg.msg message);  in \"    \"    ++str senderStr    ++str \"-&gt;&gt;\"    ++str targetStr    ++str \": \"    ++str label    ++str \"\\n\";prettyPrintMessageList (messages : List (EngineMsg Msg)) : String :=  let    participantsSet : Set String := getParticipants messages;    participantDeclarations : String :=      stringJoin        \"\\n    \"        (map \\{p := \"participant \" ++str p} (Set.toList participantsSet));    messageLines : String := stringJoin \"\" (map messageToMermaid messages);  in \"sequenceDiagram\\n\"    ++str \"    autonumber\\n\"    ++str if       | Set.isEmpty participantsSet := \"\"      | else := \"    \" ++str participantDeclarations ++str \"\\n\"    ++str messageLines;</pre></code></pre>","tags":["simulator","visualizer","mermaid"]},{"location":"arch/node/integration/examples/increment.html","title":"Increment Simulation Example","text":"<p>This example demonstrates a simulation of a simple network performing an increment-and-write operation distributed across multiple engines. It involves:</p> <ul> <li>One Mempool Worker engine to coordinate transactions.</li> <li>Two Shard engines, managing keys \"a\" (97) and \"b\" (98) respectively.</li> <li>Two initial transactions:     1.  Write the value 3 to key \"a\".     2.  Read the value from \"a\", increment it, and write the result to \"b\".</li> <li>Nockma programs for each transaction, executed via the <code>nockmaRunnable</code>.</li> </ul> <p>The simulation uses the <code>selectFirstMessage</code> strategy and illustrates the interaction flow between the client (initiating transactions), the Mempool Worker, Shards, and Executors.</p> Juvix Code <p><pre><code><pre>module arch.node.integration.examples.increment;import prelude open;import Stdlib.Prelude as IO;import arch.node.types.basics open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.engine_config open;import arch.node.types.engine_environment open;import arch.node.types.engine_behaviour open;import arch.node.types.engine open;import arch.node.types.anoma_engines open;import arch.node.types.anoma_message open;import arch.node.types.anoma_config open;import arch.node.types.anoma_environment open;import arch.node.integration.simulator open;import arch.node.integration.visualizer open;import arch.node.engines.mempool_worker_config open;import arch.node.engines.mempool_worker_messages open;import arch.node.engines.mempool_worker_environment open;import arch.node.engines.mempool_worker_behaviour open;import arch.node.engines.shard_config open;import arch.node.engines.shard_environment open;import arch.node.engines.shard_behaviour open;import arch.node.engines.executor_config open;import arch.node.engines.executor_environment open;import arch.node.engines.executor_behaviour open;import arch.system.state.resource_machine.notes.nockma open;import arch.system.state.resource_machine.notes.runnable open;import arch.system.state.resource_machine.notes.nockma_runnable open;zeroNoun : Noun := Noun.Atom 0;oneNoun : Noun := Noun.Atom 1;keyA : Noun := Noun.Atom 97;keyB : Noun := Noun.Atom 98;val3 : Noun := Noun.Atom 3;writeAOutputNoun : Noun :=  Noun.Cell (Noun.Atom 0) (Noun.Cell (Noun.Cell keyA val3) zeroNoun);writeAProgram : Noun := Noun.Cell oneNoun writeAOutputNoun;incWriteProgram : Noun :=  let    const0 : Noun := Noun.Cell (Noun.Atom 1) (Noun.Atom 0);    const98 : Noun := Noun.Cell (Noun.Atom 1) (Noun.Atom 98);    getVal : Noun := Noun.Cell (Noun.Atom 0) (Noun.Atom 7);    incVal : Noun := Noun.Cell (Noun.Atom 4) getVal;    writePair : Noun := Noun.Cell const98 incVal;    reqList : Noun := Noun.Cell writePair const0;  in Noun.Cell const0 reqList;initialState : Noun := Noun.Atom 0;storage : Storage Nat Nat := emptyStorage;initialGas : Nat := 1000;externalInput1 : Noun := Noun.Cell (Noun.Atom 0) (Noun.Atom 0);subject1 : Noun := Noun.Cell initialState externalInput1;prog1Result : Result String (Pair Noun Nat) :=  GasState.runGasState    (nock storage (Noun.Cell subject1 writeAProgram))    initialGas;externalInput2 : Noun := Noun.Cell (Noun.Atom 97) (Noun.Atom 3);subject2 : Noun := Noun.Cell initialState externalInput2;prog2Result : Result String (Pair Noun Nat) :=  GasState.runGasState    (nock storage (Noun.Cell subject2 incWriteProgram))    initialGas;nodeId : NodeID := PublicKey.Curve25519PubKey \"0xSIMNODE\";shardAId : EngineID := mkPair (some nodeId) \"shardA\";shardBId : EngineID := mkPair (some nodeId) \"shardB\";mempoolWorkerId : EngineID := mkPair (some nodeId) \"mempoolWorker\";keyToShardMap (k : KVSKey) : EngineID :=  if     | k == 97 := shardAId    | k == 98 := shardBId    | else := shardAId;mempoolWorkerLocalCfg : MempoolWorkerLocalCfg :=  MempoolWorkerLocalCfg.mk@{    keyToShard := keyToShardMap;  };mempoolWorkerCfg : MempoolWorkerCfg :=  EngineCfg.mk@{    node := nodeId;    name := \"mempoolWorker\";    cfg := mempoolWorkerLocalCfg;  };mempoolWorkerEnv : MempoolWorkerEnv :=  mempool_worker_environment_example.mempoolWorkerEnv;mempoolWorker : Eng :=  Eng.MempoolWorker    Engine.mk@{      cfg := mempoolWorkerCfg;      env := mempoolWorkerEnv;      behaviour := mempoolWorkerBehaviour;    };shardACfg : ShardCfg :=  EngineCfg.mk@{    node := nodeId;    name := \"shardA\";    cfg := ShardLocalCfg.mk;  };shardAEnv : ShardEnv := shard_environment_example.shardEnv;shardA : Eng :=  Eng.Shard    Engine.mk@{      cfg := shardACfg;      env := shardAEnv;      behaviour := shardBehaviour;    };shardBCfg : ShardCfg :=  EngineCfg.mk@{    node := nodeId;    name := \"shardB\";    cfg := ShardLocalCfg.mk;  };shardBEnv : ShardEnv := shard_environment_example.shardEnv;shardB : Eng :=  Eng.Shard    Engine.mk@{      cfg := shardBCfg;      env := shardBEnv;      behaviour := shardBehaviour;    };initialNode : Node :=  Node.mkNode@{    engines :=      OMap.fromList        [          mkPair (snd mempoolWorkerId) mempoolWorker;          mkPair (snd shardAId) shardA;          mkPair (snd shardBId) shardB;        ];  };txWriteA : TransactionCandidate KVSKey KVSKey Executable :=  TransactionCandidate.mkTransactionCandidate@{    label :=      TransactionLabel.mkTransactionLabel@{        read := [97];        write := [97];      };    executable := writeAProgram;  };txIncWrite : TransactionCandidate KVSKey KVSKey Executable :=  TransactionCandidate.mkTransactionCandidate@{    label :=      TransactionLabel.mkTransactionLabel@{        read := [97];        write := [98];      };    executable := incWriteProgram;  };clientSenderId : EngineID := mkPair none \"client\";initialMessages : List (EngineMsg Msg) :=  [    EngineMsg.mk@{      sender := clientSenderId;      target := mempoolWorkerId;      mailbox := none;      msg :=        Msg.MempoolWorker          (MempoolWorkerMsg.TransactionRequest            TransactionRequest.mkTransactionRequest@{              tx := txWriteA;              resubmission := none;            });    };    EngineMsg.mk@{      sender := clientSenderId;      target := mempoolWorkerId;      mailbox := none;      msg :=        Msg.MempoolWorker          (MempoolWorkerMsg.TransactionRequest            TransactionRequest.mkTransactionRequest@{              tx := txIncWrite;              resubmission := none;            });    };  ];initialNetworkState : NetworkState :=  NetworkState.mkNetworkState@{    nodes := OMap.singleton nodeId initialNode;    messages := initialMessages;    currentTime := left 0;    incrementId := \\{n := n};    nextId := nodeId;  };simulationResult : String :=  prettyPrintMessageList (simulate selectFirstMessage initialNetworkState 20);simulationResult2 : Pair (List (EngineMsg Msg)) (List (EngineMsg Msg)) :=  simulateWithFailures selectFirstMessage initialNetworkState 20;main : IO.IO := IO.printStringLn simulationResult;</pre></code></pre></p> <p>This setup defines the necessary components, initial state, and transaction logic using Nockma Nouns. The simulation is executed, and the resulting message trace is stored in <code>simulationResult</code>.</p>","tags":["simulator","example","nockma","work-in-progress"]},{"location":"arch/node/subsystems/hardware.html","title":"Hardware subsystem overview","text":"Juvix imports <p><pre><code><pre>module arch.node.subsystems.hardware;import arch.node.engines.local_key_value_storage open;import arch.node.engines.local_time_series_storage open;import arch.node.engines.logging open;import arch.node.engines.wall_clock open;</pre></code></pre></p>","tags":["node-architecture","hardware-subsystem","index"]},{"location":"arch/node/subsystems/hardware.html#hardware-subsystem","title":"Hardware Subsystem","text":"","tags":["node-architecture","hardware-subsystem","index"]},{"location":"arch/node/subsystems/hardware.html#purpose","title":"Purpose","text":"<p>The Hardware Subsystem is responsible for managing the hardware resources of the node.</p>","tags":["node-architecture","hardware-subsystem","index"]},{"location":"arch/node/subsystems/hardware.html#overview","title":"Overview","text":"<p>The Hardware Subsystem consists of the following engines.</p> <p>Engines</p> <p>Add engines here.</p>","tags":["node-architecture","hardware-subsystem","index"]},{"location":"arch/node/subsystems/identity.html","title":"Identity subsystem overview","text":"Juvix imports <p><pre><code><pre>module arch.node.subsystems.identity;import arch.node.engines.identity_management open;import arch.node.engines.decryption open;import arch.node.engines.encryption open;import arch.node.engines.commitment open;import arch.node.engines.verification open;import arch.node.engines.reads_for open;import arch.node.engines.signs_for open;import arch.node.engines.naming open;</pre></code></pre></p>","tags":["node-architecture","identity-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/identity.html#identity-subsystem","title":"Identity Subsystem","text":"","tags":["node-architecture","identity-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/identity.html#purpose","title":"Purpose","text":"<p>The Identity Subsystem is responsible for managing the identity of the node.</p>","tags":["node-architecture","identity-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/net.html","title":"Network subsystem overview","text":"Juvix imports <p><pre><code><pre>module arch.node.subsystems.net;import arch.node.engines.net_registry open;import arch.node.engines.router open;import arch.node.engines.transport_connection open;import arch.node.engines.transport_protocol open;import arch.node.engines.pub_sub_topic open;import arch.node.engines.storage open;import arch.node.engines.verification open;</pre></code></pre></p>","tags":["node-architecture","network-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/net.html#network-subsystem","title":"Network Subsystem","text":"","tags":["node-architecture","network-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/net.html#purpose","title":"Purpose","text":"<p>The Network Subsystem is responsible for sending and receiving messages to and from remote nodes, and offers distributed pub/sub and storage protocols.</p>","tags":["node-architecture","network-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/net.html#overview","title":"Overview","text":"<p>The Network Subsystem consists of the following engines.</p>","tags":["node-architecture","network-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/net.html#network-registry","title":"Network Registry","text":"","tags":["node-architecture","network-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/net.html#router","title":"Router","text":"<p>The Router engine is responsible for routing messages between local engines and remote nodes.</p>","tags":["node-architecture","network-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/net.html#transport-connection","title":"Transport Connection","text":"","tags":["node-architecture","network-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/net.html#transport-protocol","title":"Transport Protocol","text":"","tags":["node-architecture","network-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/net.html#pubsub-topic","title":"Pub/Sub Topic","text":"","tags":["node-architecture","network-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/net.html#storage","title":"Storage","text":"","tags":["node-architecture","network-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/net.html#diagrams","title":"Diagrams","text":"","tags":["node-architecture","network-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/net.html#spawn-tree-message-flow","title":"Spawn tree &amp; message flow","text":"<pre><code>flowchart TD\n\nN(Node)\n\nE1(Engine1)\nE2(Engine2)\nE3(Engine3)\n\nsubgraph Network Subsystem\n  R(Router)\n\n  subgraph NodeProxies\n    NP1(NProxy-1)\n    NP2(NProxy-2)\n    NP3(NProxy-3)\n  end\n\n  subgraph PubSub\n    T1(Topic-1)\n    T2(Topic-2)\n    T3(Topic-3)\n  end\n\n  subgraph Transport\n    TP1(TProto-1)\n    TP2(TProto-2)\n    TP3(TProto-3)\n\n    TC11(TConn-1-1)\n    TC12(TConn-1-2)\n    TC21(TConn-2-1)\n    TC31(TConn-3-1)\n    TC32(TConn-3-2)\n  end\nend\n\nNET(Network)\n\n%% Spawn tree\n\nN -.-&gt; R &amp; TP1 &amp; TP2 &amp; TP3 &amp; E1 &amp; E2 &amp; E3\nR -.-&gt; NP1 &amp; NP2 &amp; NP3 &amp; T1 &amp; T2 &amp; T3\nTP1 -.-&gt; TC11 &amp; TC12\nTP2 -.-&gt; TC21\nTP3 -.-&gt; TC31 &amp; TC32\n\n%% Message flow\n\n%% Intra-node communacation between local engines\nE1 -- Send --&gt; E2\n\n%% First message via R to open a connection\nE2 -- NodeSend --&gt; R -- Send --&gt; NP2 -- Send --&gt; TP2 -- Send --&gt; TC21 --&gt; NET\nE2 -- TopicForward --&gt; R -- Forward --&gt; T1\n\n%% Subsequent messages\nE2 -- Send --&gt; NP2\nE2 -- Forward --&gt; T1\n\nT1 -- Send --&gt; E3\nT1 -- Send --&gt; NP1 -- Send --&gt; TP1 -- Send --&gt; TC12 --&gt; NET</code></pre>   Spawn tree &amp; message flow: - dotted: spawn - solid: message send","tags":["node-architecture","network-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/ordering.html","title":"Ordering subsystem overview","text":"Juvix imports <pre><code><pre>module arch.node.subsystems.ordering;import arch.node.engines.executor open;import arch.node.engines.mempool_worker open;</pre></code></pre>","tags":["node-architecture","ordering-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/ordering.html#ordering-subsystem","title":"Ordering Subsystem","text":"","tags":["node-architecture","ordering-subsystem","index"],"boost":2},{"location":"arch/node/subsystems/ordering.html#purpose","title":"Purpose","text":"<p>The Ordering Subsystem is responsible for ordering transactions in the node.</p>","tags":["node-architecture","ordering-subsystem","index"],"boost":2},{"location":"arch/node/types/anoma.html","title":"Anoma","text":"Juvix imports <p><pre><code><pre>module arch.node.types.anoma;import arch.node.types.anoma_message open public;import arch.node.types.anoma_config open public;import arch.node.types.anoma_environment open public;</pre></code></pre></p>","tags":["node-architecture","prelude","index"]},{"location":"arch/node/types/anoma.html#wrapper-types-for-anoma","title":"Wrapper types for Anoma","text":"<ul> <li>Anoma Message</li> <li>Anoma Configuration</li> <li>Anoma Environment</li> </ul>","tags":["node-architecture","prelude","index"]},{"location":"arch/node/types/anoma_config.html","title":"Anoma Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.types.anoma_config;import prelude open;import arch.system.state.resource_machine.notes.nockma open;import arch.node.engines.identity_management_config open;import arch.node.engines.decryption_config open;import arch.node.engines.encryption_config open;import arch.node.engines.commitment_config open;import arch.node.engines.verification_config open;import arch.node.engines.reads_for_config open;import arch.node.engines.signs_for_config open;import arch.node.engines.naming_config open;import arch.node.engines.local_key_value_storage_config open;import arch.node.engines.logging_config open;import arch.node.engines.wall_clock_config open;import arch.node.engines.local_time_series_storage_config open;import arch.node.engines.net_registry_config open;import arch.node.engines.router_config open;import arch.node.engines.transport_protocol_config open;import arch.node.engines.transport_connection_config open;import arch.node.engines.pub_sub_topic_config open;import arch.node.engines.storage_config open;import arch.node.engines.mempool_worker_config open;import arch.node.engines.executor_config open;import arch.node.engines.shard_config open;import arch.node.engines.ticker_config open;import tutorial.engines.template_config open;import tutorial.engines.template_minimum_config open;</pre></code></pre></p>","tags":["node-architecture","types","engine","configuration","prelude"],"boost":2},{"location":"arch/node/types/anoma_config.html#anoma-engine-configuration","title":"Anoma Engine Configuration","text":"<p>An Anoma engine configuration contains static, read-only configuration for an engine. See Engine Configuration for more information.</p> <p>Below is the definition of the type <code>Config</code>, which represents an Anoma engine configuration. This means that each Anoma engine instance has a constant configuration of type <code>Config</code>, initialised at creation.</p> <p>For example, a configuration for an engine instance of the engine <code>TickerEngine</code> is of type <code>TickerCfg</code>.</p> <pre><code><pre>type Cfg :=  | CfgIdentityManagement IdentityManagementCfg  | CfgDecryption DecryptionCfg  | CfgEncryption EncryptionCfg  | CfgCommitment CommitmentCfg  | CfgVerification VerificationCfg  | CfgReadsFor ReadsForCfg  | CfgSignsFor SignsForCfg  | CfgNaming NamingCfg  | CfgLocalKeyValueStorage LocalKVStorageCfg  | CfgLogging LoggingCfg  | CfgWallClock WallClockCfg  | CfgLocalTSeries LocalTSStorageCfg  | CfgRouter RouterCfg  | CfgTransportProtocol TransportProtocolCfg  | CfgTransportConnection TransportConnectionCfg  | CfgPubSubTopic PubSubTopicCfg  | CfgStorage StorageCfg  | CfgMempoolWorker MempoolWorkerCfg  | CfgExecutor ExecutorCfg  | CfgShard ShardCfg  | CfgTicker TickerCfg  | CfgTemplate TemplateCfg  | CfgTemplateMinimum TemplateMinimumCfg;</pre></code></pre>","tags":["node-architecture","types","engine","configuration","prelude"],"boost":2},{"location":"arch/node/types/anoma_engines.html","title":"Anoma engines","text":"<pre><code><pre>module arch.node.types.anoma_engines;import prelude open;import arch.node.types.anoma_message open;import arch.node.types.anoma_config open;import arch.node.types.anoma_environment open;import arch.node.types.engine open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine_behaviour open;import arch.node.types.router open;import arch.node.engines.router_config open;import arch.node.engines.router_environment open;import arch.node.engines.transport_protocol_config open;import arch.node.engines.transport_protocol_environment open;import arch.node.engines.transport_connection_config open;import arch.node.engines.transport_connection_environment open;import arch.node.engines.pub_sub_topic_config open;import arch.node.engines.pub_sub_topic_environment open;import arch.node.engines.storage_config open;import arch.node.engines.storage_environment open;import arch.system.state.resource_machine.notes.nockma open;import arch.node.engines.identity_management open;import arch.node.engines.decryption open;import arch.node.engines.encryption open;import arch.node.engines.commitment open;import arch.node.engines.verification open;import arch.node.engines.reads_for open;import arch.node.engines.signs_for open;import arch.node.engines.naming open;import arch.node.engines.local_key_value_storage open;import arch.node.engines.logging open;import arch.node.engines.wall_clock open;import arch.node.engines.local_time_series_storage open;import arch.node.engines.router open;import arch.node.engines.transport_protocol open;import arch.node.engines.transport_connection open;import arch.node.engines.pub_sub_topic open;import arch.node.engines.storage open;import arch.node.engines.mempool_worker open;import arch.node.engines.executor open;import arch.node.engines.shard open;import arch.node.engines.ticker open;import tutorial.engines.template open;import tutorial.engines.template_minimum open;import arch.node.types.crypto open;type Eng :=  | IdentityManagement IdentityManagementEngine  | Decryption DecryptionEngine  | Encryption EncryptionEngine  | Commitment CommitmentEngine  | Verification VerificationEngine  | ReadsFor ReadsForEngine  | SignsFor SignsForEngine  | Naming NamingEngine  | LocalKeyValueStorage LocalKVStorageEngine  | Logging LoggingEngine  | WallClock WallClockEngine  | LocalTSeries LocalTSStorageEngine  | Router RouterEngine  | TransportProtocol TransportProtocolEngine  | TransportConnection TransportConnectionEngine  | PubSubTopic PubSubTopicEngine  | Storage StorageEngine  | MempoolWorker MempoolWorkerEngine  | Executor ExecutorEngine  | Shard ShardEngine  | Ticker TickerEngine  | Template TemplateEngine  | TemplateMinimum TemplateMinimumEngine;</pre></code></pre> <pre><code><pre>mkEng (nodeId : NodeID) (p : Pair Cfg Env) : Option (Pair Eng EngineID) :=  case p of    | mkPair (Cfg.CfgIdentityManagement cfg) (Env.EnvIdentityManagement env) :=      let        eng :=          Eng.IdentityManagement            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := identityManagementBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgDecryption cfg) (Env.EnvDecryption env) :=      let        eng :=          Eng.Decryption            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := decryptionBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgEncryption cfg) (Env.EnvEncryption env) :=      let        eng :=          Eng.Encryption            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := encryptionBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgCommitment cfg) (Env.EnvCommitment env) :=      let        eng :=          Eng.Commitment            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := commitmentBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgVerification cfg) (Env.EnvVerification env) :=      let        eng :=          Eng.Verification            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := verificationBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgReadsFor cfg) (Env.EnvReadsFor env) :=      let        eng :=          Eng.ReadsFor            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := readsForBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgSignsFor cfg) (Env.EnvSignsFor env) :=      let        eng :=          Eng.SignsFor            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := signsForBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgNaming cfg) (Env.EnvNaming env) :=      let        eng :=          Eng.Naming            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := namingBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgLocalKeyValueStorage cfg) (Env.EnvLocalKeyValueStorage env) :=      let        eng :=          Eng.LocalKeyValueStorage            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := localKVStorageBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgLogging cfg) (Env.EnvLogging env) :=      let        eng :=          Eng.Logging            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := loggingBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgWallClock cfg) (Env.EnvWallClock env) :=      let        eng :=          Eng.WallClock            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := wallClockBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgLocalTSeries cfg) (Env.EnvLocalTSeries env) :=      let        eng :=          Eng.LocalTSeries            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := localTSStorageBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgRouter cfg) (Env.EnvRouter env) :=      let        eng :=          Eng.Router            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := TODO;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgTransportProtocol cfg) (Env.EnvTransportProtocol env) :=      let        eng :=          Eng.TransportProtocol            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := TODO;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgTransportConnection cfg) (Env.EnvTransportConnection env) :=      let        eng :=          Eng.TransportConnection            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := TODO;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgPubSubTopic cfg) (Env.EnvPubSubTopic env) :=      let        eng :=          Eng.PubSubTopic            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := TODO;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgStorage cfg) (Env.EnvStorage env) :=      let        eng :=          Eng.Storage            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := TODO;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgMempoolWorker cfg) (Env.EnvMempoolWorker env) :=      let        eng :=          Eng.MempoolWorker            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := mempoolWorkerBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgExecutor cfg) (Env.EnvExecutor env) :=      let        eng :=          Eng.Executor            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := executorBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgShard cfg) (Env.EnvShard env) :=      let        eng :=          Eng.Shard            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := shardBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgTicker cfg) (Env.EnvTicker env) :=      let        eng :=          Eng.Ticker            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := tickerBehaviour;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgTemplate cfg) (Env.EnvTemplate env) :=      let        eng :=          Eng.Template            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := TODO;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | mkPair (Cfg.CfgTemplateMinimum cfg) (Env.EnvTemplateMinimum env) :=      let        eng :=          Eng.TemplateMinimum            Engine.mk@{              cfg := cfg@EngineCfg{node := nodeId};              env := env;              behaviour := TODO;            };        engineId := mkPair (some nodeId) (EngineCfg.name cfg);      in some (mkPair eng engineId)    | _ := none;</pre></code></pre>"},{"location":"arch/node/types/anoma_environment.html","title":"Anoma Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.types.anoma_environment;import prelude open;import arch.system.state.resource_machine.notes.nockma open;import arch.node.engines.identity_management_environment open;import arch.node.engines.decryption_environment open;import arch.node.engines.encryption_environment open;import arch.node.engines.commitment_environment open;import arch.node.engines.verification_environment open;import arch.node.engines.reads_for_environment open;import arch.node.engines.signs_for_environment open;import arch.node.engines.naming_environment open;import arch.node.engines.local_key_value_storage_environment open;import arch.node.engines.logging_environment open;import arch.node.engines.wall_clock_environment open;import arch.node.engines.local_time_series_storage_environment open;import arch.node.engines.net_registry_environment open;import arch.node.engines.router_environment open;import arch.node.engines.transport_protocol_environment open;import arch.node.engines.transport_connection_environment open;import arch.node.engines.pub_sub_topic_environment open;import arch.node.engines.storage_environment open;import arch.node.engines.mempool_worker_environment open;import arch.node.engines.executor_environment open;import arch.node.engines.shard_environment open;import arch.node.engines.ticker_environment open;import tutorial.engines.template_environment open;import tutorial.engines.template_minimum_environment open;</pre></code></pre></p>","tags":["node-architecture","types","engine","environment","prelude"],"boost":2},{"location":"arch/node/types/anoma_environment.html#anoma-engine-environments","title":"Anoma Engine Environments","text":"<p>An Anoma engine environment is a collection of all the necessary information/context that an engine instance needs to operate. See Engine Environment for more information on engine environments.</p> <p>Below is the definition of the type <code>Env</code>, which represents an Anoma engine environment. This means, an Anoma engine instance would have an environment of type <code>Env</code>.</p> Why a sum type for all engines? <p>The sum type will be useful for specifying the \"initial\" state of any newly created engine instance. In this way, we can omit any initialization, but we can have it by sending \"init messages\" to the newly created engine at the same time as we create new engines.</p> <p>For example, an environment for an engine instance of the engine <code>TickerEngine</code> is of type <code>TickerEnvironment</code>.</p> <pre><code><pre>type Env :=  | EnvIdentityManagement IdentityManagementEnv  | EnvDecryption DecryptionEnv  | EnvEncryption EncryptionEnv  | EnvCommitment CommitmentEnv  | EnvVerification VerificationEnv  | EnvReadsFor ReadsForEnv  | EnvSignsFor SignsForEnv  | EnvNaming NamingEnv  | EnvLocalKeyValueStorage LocalKVStorageEnv  | EnvLogging LoggingEnv  | EnvWallClock WallClockEnv  | EnvLocalTSeries LocalTSStorageEnv  | EnvRouter RouterEnv  | EnvTransportProtocol TransportProtocolEnv  | EnvTransportConnection TransportConnectionEnv  | EnvPubSubTopic PubSubTopicEnv  | EnvStorage StorageEnv  | EnvMempoolWorker MempoolWorkerEnv  | EnvExecutor ExecutorEnv  | EnvShard ShardEnv  | EnvTicker TickerEnv  | EnvTemplate TemplateEnv  | EnvTemplateMinimum TemplateMinimumEnv;</pre></code></pre>","tags":["node-architecture","types","engine","environment","prelude"],"boost":2},{"location":"arch/node/types/anoma_message.html","title":"Anoma Message","text":"Juvix imports <p><pre><code><pre>module arch.node.types.anoma_message;import prelude open;import arch.system.state.resource_machine.notes.nockma open;import arch.node.engines.identity_management_messages open;import arch.node.engines.decryption_messages open;import arch.node.engines.encryption_messages open;import arch.node.engines.commitment_messages open;import arch.node.engines.verification_messages open;import arch.node.engines.reads_for_messages open;import arch.node.engines.signs_for_messages open;import arch.node.engines.naming_messages open;import arch.node.engines.local_key_value_storage_messages open;import arch.node.engines.logging_messages open;import arch.node.engines.wall_clock_messages open;import arch.node.engines.local_time_series_storage_messages open;import arch.node.engines.net_registry_messages open;import arch.node.engines.router_messages open;import arch.node.engines.transport_protocol_messages open;import arch.node.engines.transport_connection_messages open;import arch.node.engines.pub_sub_topic_messages open;import arch.node.engines.storage_messages open;import arch.node.engines.mempool_worker_messages open;import arch.node.engines.executor_messages open;import arch.node.engines.shard_messages open;import arch.node.engines.ticker_messages open;import tutorial.engines.template_messages open;import tutorial.engines.template_minimum_messages open;</pre></code></pre></p>","tags":["node-architecture","types","engine","message-types","prelude"]},{"location":"arch/node/types/anoma_message.html#anoma-message","title":"Anoma Message","text":"<p>The Anoma message type contains all admissible messages that can be sent between nodes in the network. An Anoma message is of the type <code>Msg</code>. Each constructor of the type <code>Msg</code> corresponds to a specific type of message comming from a specific engine. For example, the engine <code>TickerEngine</code> has a corresponding message type <code>TickerMsg</code>.</p> <pre><code><pre>type Msg :=  | IdentityManagement IdentityManagementMsg  | Decryption DecryptionMsg  | Encryption EncryptionMsg  | Commitment CommitmentMsg  | Verification VerificationMsg  | ReadsFor ReadsForMsg  | SignsFor SignsForMsg  | Naming NamingMsg  | LocalKVStorage LocalKVStorageMsg  | Logging LoggingMsg  | WallClock WallClockMsg  | LocalTSStorage LocalTSStorageMsg  | Router (RouterMsg Msg)  | TransportProtocol TransportProtocolMsg  | TransportConnection TransportConnectionMsg  | PubSubTopic PubSubTopicMsg  | Storage StorageMsg  | MempoolWorker (MempoolWorkerMsg Noun)  | Executor ExecutorMsg  | Shard ShardMsg  | Ticker TickerMsg  | Template TemplateMsg  | TemplateMinimum TemplateMinimumMsg;</pre></code></pre>","tags":["node-architecture","types","engine","message-types","prelude"]},{"location":"arch/node/types/basics.html","title":"Basics","text":"Juvix imports <p><pre><code><pre>module arch.node.types.basics;import prelude open public;</pre></code></pre></p>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/basics.html#juvix-prelude-of-the-anoma-node-architecture","title":"Juvix Prelude of the Anoma Node Architecture","text":"<p>This document describes the basic types and functions used in the node architecture prelude. For a more general prelude, please refer to Prelude. (1) </p> <ol> <li>If you are unfamiliar with Juvix, please refer to the Juvix documentation.</li> </ol>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/basics.html#basic-types","title":"Basic types","text":"","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/basics.html#hash","title":"<code>Hash</code>","text":"<p>Natural numbers are used (for now) to represent hash values, bytes sizes, and other non-negative integers.</p> <pre><code><pre>syntax alias Hash := Nat;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/basics.html#reltime","title":"<code>RelTime</code>","text":"<p>Relative time. In seconds from now.</p> <pre><code><pre>syntax alias RelTime := Nat;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/basics.html#abstime","title":"<code>AbsTime</code>","text":"<p>Absolute time. In minutes since epoch (2024-01-01 00:00).</p> <pre><code><pre>syntax alias AbsTime := Nat;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/basics.html#time","title":"<code>Time</code>","text":"<p>Either absolute or relative time.</p> <pre><code><pre>Time : Type := Either RelTime AbsTime;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/basics.html#version","title":"<code>Version</code>","text":"<p>Semantic version number (major.minor.patch).</p> <pre><code><pre>type Version :=  mkVersion@{    major : Nat;    minor : Nat;    patch : Nat;  };</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/crypto.html","title":"Crypto","text":"Juvix imports <p><pre><code><pre>module arch.node.types.crypto;import prelude open;</pre></code></pre></p>","tags":["node-architecture","types","crypto","prelude"],"boost":2},{"location":"arch/node/types/crypto.html#cryptographic-primitives","title":"Cryptographic primitives","text":"","tags":["node-architecture","types","crypto","prelude"],"boost":2},{"location":"arch/node/types/crypto.html#publickey","title":"<code>PublicKey</code>","text":"<p>Public key for public-key cryptography.</p> <pre><code><pre>type PublicKey := | Curve25519PubKey ByteString;publicKeyEq : PublicKey -&gt; PublicKey -&gt; Bool  | (PublicKey.Curve25519PubKey s1) (PublicKey.Curve25519PubKey s2) := s1 == s2;instancePublicKeyEq : Eq PublicKey :=  Eq.mk@{    isEqual := publicKeyEq;  };instancePublicKeyOrd : Ord PublicKey :=  Ord.mk@{    compare := \\{_ _ := Equal};  };</pre></code></pre>","tags":["node-architecture","types","crypto","prelude"],"boost":2},{"location":"arch/node/types/crypto.html#privatekey","title":"<code>PrivateKey</code>","text":"<p>Private key for public-key cryptography.</p> <pre><code><pre>type PrivateKey := | Curve25519PrivKey ByteString;instancePrivateKeyOrd : Ord PrivateKey :=  Ord.mk@{    compare := \\{_ _ := Equal};  };</pre></code></pre>","tags":["node-architecture","types","crypto","prelude"],"boost":2},{"location":"arch/node/types/crypto.html#secretkey","title":"<code>SecretKey</code>","text":"<p>Secret key for secret-key cryptography.</p> <pre><code><pre>type SecretKey := | ChaCha20Key;</pre></code></pre>","tags":["node-architecture","types","crypto","prelude"],"boost":2},{"location":"arch/node/types/crypto.html#signature","title":"<code>Signature</code>","text":"<p>Cryptographic signature.</p> <pre><code><pre>type Signature := | Ed25519Signature ByteString;</pre></code></pre>","tags":["node-architecture","types","crypto","prelude"],"boost":2},{"location":"arch/node/types/crypto.html#digest","title":"<code>Digest</code>","text":"<p>Message digest. Output of a cryptographic hash function.</p> <pre><code><pre>type Digest := | Blake3Digest ByteString;</pre></code></pre>","tags":["node-architecture","types","crypto","prelude"],"boost":2},{"location":"arch/node/types/engine.html","title":"Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.types.engine;import prelude open;import arch.node.types.identities open;import arch.node.types.engine_config open public;import arch.node.types.engine_environment open public;import arch.node.types.engine_behaviour open public;</pre></code></pre></p>","tags":["node-architecture","types","engine","prelude"]},{"location":"arch/node/types/engine.html#the-type-for-engines","title":"The type for engines","text":"<p>Engine</p> <p>An engine is a computational unit with a specific name and behaviour, plus an initial environment, which comprises the specific state, the mailbox cluster, the acquaintances, and the timers.</p> <p>We refer to the type of engines as <code>Engine</code>, instantiated with the following type parameters:</p> <ul> <li><code>A</code>: the type for the action arguments,</li> <li><code>C</code>: the type for the read-only engine configuration,</li> <li><code>S</code>: the type for the local engine-specific state,</li> <li><code>B</code>: the type for the mailbox state,</li> <li><code>H</code>: the type for the timer handles,</li> <li><code>AM</code>: the type for all engine messages (<code>Msg</code>),</li> <li><code>AC</code>: the type for all engine configurations (<code>Cfg</code>), and</li> <li><code>AE</code>: the type for all engine environments (<code>Env</code>).</li> </ul> <p>Each engine, not its type, is associated with:</p> <ul> <li>a specific [Engine Configuration|configuration],   which contains the engine name (unique across the system), node ID, and engine-specific configuration,</li> <li>a declaration of its own execution context, that is,   the engine-specific local state, the mailbox cluster, the acquaintances, and the timers,</li> <li>as well as a specific behaviour.</li> </ul> <pre><code><pre>type Engine C S B H A AM AC AE :=  mk@{    cfg : EngineCfg C;    env : EngineEnv S B H AM;    behaviour : EngineBehaviour C S B H A AM AC AE;  };</pre></code></pre> Arguments <code>cfg</code> the engine configuration, <code>env</code> the engine environment, and <code>behaviour</code> the engine behaviour.","tags":["node-architecture","types","engine","prelude"]},{"location":"arch/node/types/engine.html#on-the-type-parameters","title":"On the type parameters","text":"<p>In the related types to <code>Engine</code> such as <code>EngineBehaviour</code>, we try to follow the following convention:</p> <ul> <li>the type parameters are ordered such that they form a subsequence of the   type parameters sequence in the <code>Engine</code> type, and</li> <li>the first type parameter of <code>EngineBehaviour</code> is always <code>C</code>, the type for   the read-only engine configuration.</li> </ul>","tags":["node-architecture","types","engine","prelude"]},{"location":"arch/node/types/engine.html#example-voting-engine","title":"Example: Voting Engine","text":"<p>As an example, we could define an engine type for a voting system:</p> <ul> <li><code>S</code> could be a record with fields like <code>votes</code>, <code>voters</code>, and <code>results</code>.</li> <li>The engine-specific message type might be a coproduct of <code>Vote</code> and <code>Result</code>.</li> <li> <p>The behaviour of this engine may include guarded actions such as:</p> <ul> <li><code>storeVote</code> to store a vote in the local state,</li> <li><code>computeResult</code> to compute the result of the election, and</li> <li><code>announceResult</code> to send the result to some other engine instances.</li> </ul> </li> </ul> <p>With each different election or kind of voters, we obtain a new engine instance, while the underlining voting system, the voting engine family, remains the same.</p>","tags":["node-architecture","types","engine","prelude"]},{"location":"arch/node/types/engine_behaviour.html","title":"Engine Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.types.engine_behaviour;import arch.node.types.basics open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.engine_config open;import arch.node.types.engine_environment open;</pre></code></pre></p>","tags":["node-architecture","types","engine","behaviour","prelude"]},{"location":"arch/node/types/engine_behaviour.html#engine-behaviour","title":"Engine behaviour","text":"<p>Each engine processes only one message at a time. The behaviour of an engine is specified by a finite set of guards and an action function, which both determine how engine instances react to received messages or timer notifications.</p>","tags":["node-architecture","types","engine","behaviour","prelude"]},{"location":"arch/node/types/engine_behaviour.html#guards","title":"Guards","text":"<p>Guards are terms of type <code>Guard</code>, which is a function type, where the trigger of type <code>TimestampedTrigger H AM</code> is a term that captures the message received with a timestamp or a clock notification about timers that have elapsed during the engine's operation. Guards return data of type <code>GuardOutput A</code> if the precondition of the action that they are guarding is met.</p> <p>Recall that the behaviour is described by a set of guards and an action function. The guard is a function that evaluates conditions in the engine environment to determine what action should be performed; for this, each guard creates an action label, that then is \"interpreted\" by the action function.</p> <p>The guard function receives three arguments:</p> <ul> <li>the timestamped trigger that caused guard evaluation;</li> <li>the unchanging engine configuration; and</li> <li>the current environment of the engine instance.</li> </ul> <p>Given these inputs, the guard function computes an action label, which encodes</p> <ul> <li>all information necessary to infer how the engine will react</li> <li>additional information on how this action contributes to properties of the Anoma protocol instance the engine is part of.</li> </ul> <p>The action function then computes the effects of the action label; besides changes to the engine environment, an action effect comprises sending messages, creating new engine instances, and updating timers.</p>","tags":["node-architecture","types","engine","behaviour","prelude"]},{"location":"arch/node/types/engine_behaviour.html#actions","title":"Actions","text":"","tags":["node-architecture","types","engine","behaviour","prelude"]},{"location":"arch/node/types/engine_behaviour.html#action","title":"<code>Action</code>","text":"<p>The input of the action function is parameterized by the types for:</p> <ul> <li><code>C</code>: engine configuration,</li> <li><code>S</code>: local state,</li> <li><code>B</code>: mailbox state,</li> <li><code>H</code>: timer handles,</li> <li><code>A</code>: action arguments,</li> <li><code>AM</code>: type for all engine messages (<code>Msg</code>),</li> <li><code>AC</code>: type for all engine configurations (<code>Cfg</code>), and</li> <li><code>AE</code>: type for all engine environments (<code>Env</code>).</li> </ul> <p>The <code>Action</code> function receives as argument the <code>ActionInput</code>, and returns the <code>ActionEffect</code>.</p> <pre><code><pre>Action (C S B H A AM AC AE : Type) : Type :=  (input : ActionInput C S B H A AM) -&gt; Option (ActionEffect S B H AM AC AE);</pre></code></pre> On creating new engine instances <p>To create new engine instances, we need to specify the following data:</p> <ul> <li>A unique name for the new engine instance.</li> <li>The initial state of the engine instance.</li> <li>The corresponding set of guards and the action function.</li> </ul> <p>The last point is however implicit.</p> <p>If the guard does not give a result, this means that none of its guarded actions are triggered.</p> On the type signature of the guard function <p>In principle, borrowing terminology from Hoare logic, a guard is a precondition to run an action. The corresponding predicate is activated by a trigger and evaluated within the context of the engine's environment. It then returns a boolean when the predicate is satisfied, specifically of type</p> <pre><code>Trigger H AM -&gt; EngineEnv S B H AM -&gt; Bool;\n</code></pre> <p>However, as a design choice, guards will return additional data of type <code>GuardOutput A</code> that may or may not use the engine environment if the condition is met. Thus, if the guard is satisfied, this data (of type <code>GuardOutput A</code>) is assumed to be passed to the action function. Then, if the guard is not satisfied, no data is returned.</p>","tags":["node-architecture","types","engine","behaviour","prelude"]},{"location":"arch/node/types/engine_behaviour.html#actioninput","title":"<code>ActionInput</code>","text":"<pre><code><pre>type ActionInput C S B H A AM :=  mk@{    args : A;    cfg : EngineCfg C;    env : EngineEnv S B H AM;    trigger : TimestampedTrigger H AM;  };</pre></code></pre> Arguments <code>args</code> the action arguments, <code>cfg</code> the engine configuration, <code>env</code> the engine environment, and <code>trigger</code> the timestamped trigger that caused the guard evaluation.","tags":["node-architecture","types","engine","behaviour","prelude"]},{"location":"arch/node/types/engine_behaviour.html#actioneffect","title":"<code>ActionEffect</code>","text":"<p>The <code>ActionEffect S B H AM AC AE</code> type defines the effects produced by the action. The action can perform any of the following:</p> <ul> <li>Update the engine environment.</li> <li>Produce a set of messages to be sent to other engine instances.</li> <li>Set, discard, or supersede timers.</li> <li>Define new engine instances to be created.</li> </ul> <pre><code><pre>type ActionEffect S B H AM AC AE :=  mk@{    env : EngineEnv S B H AM;    msgs : List (EngineMsg AM);    timers : List (Timer H);    engines : List (Pair AC AE);  };</pre></code></pre> Arguments <code>env</code> the engine environment, <code>msgs</code> the messages to be sent to other engine instances, <code>timers</code> the timers to be set, discarded, or superseded, and <code>engines</code> the new engine instances to be created.","tags":["node-architecture","types","engine","behaviour","prelude"]},{"location":"arch/node/types/engine_behaviour.html#actionexec","title":"<code>ActionExec</code>","text":"<p>cf. monadic effect descriptions &gt;=v0.2</p> <p>As brainstormed today, engine IDs could naturally be generated freshly, by use of monads; as we are talking about monads, <code>ActionExec</code> would deserve a thorough overhaul:</p> <ul> <li>proper monadic \"task execution\" instead of the list of actions,   of which there may be only one as a reaction   to a trigger (leading to an event with duration)</li> <li>related, other features, in particular<ul> <li>concurrency of several tasks</li> <li>cf. one \"thread\" for each mailbox</li> </ul> </li> <li>message send, engine spawn, and timer updates, could also be monadic</li> </ul> <p>It is allowed to have several actions executed.<sup>1</sup></p> <pre><code><pre>type ActionExec C S B H A AM AC AE := | Seq (List (Action C S B H A AM AC AE));</pre></code></pre>","tags":["node-architecture","types","engine","behaviour","prelude"]},{"location":"arch/node/types/engine_behaviour.html#guard","title":"<code>Guard</code>","text":"<p>A guard implements\u2014first and foremost\u2014a pre-condition for an action, which checks whether the associated action or action sequence is to be performed.</p> Relation to other notions of guards <p>Guards generalize guards as used in Erlang. In future versions, simplified forms of guards and a DSL may come so that we do not always have to write in the most general style.</p> <p>If the pre-condition of a guard is satisfied, the guard produces an output that is part of the input of actions; otherwise, it returns nothing.</p> <pre><code><pre>Guard (C S B H A AM AC AE : Type) : Type :=  (trigger : TimestampedTrigger H AM)    -&gt; (cfg : EngineCfg C)    -&gt; (env : EngineEnv S B H AM)    -&gt; Option (GuardOutput C S B H A AM AC AE);</pre></code></pre>","tags":["node-architecture","types","engine","behaviour","prelude"]},{"location":"arch/node/types/engine_behaviour.html#guardoutput","title":"<code>GuardOutput</code>","text":"<p>The guard output defines an action sequence, the programmatic action to be performed, and action arguments.</p> <pre><code><pre>type GuardOutput C S B H A AM AC AE :=  mk@{    action : ActionExec C S B H A AM AC AE;    args : A;  };</pre></code></pre> Arguments <code>action</code> the action sequence to be executed, <code>args</code> the action arguments.","tags":["node-architecture","types","engine","behaviour","prelude"]},{"location":"arch/node/types/engine_behaviour.html#guardeval","title":"<code>GuardEval</code>","text":"<pre><code><pre>type GuardEval C S B H A AM AC AE :=  | First (List (Guard C S B H A AM AC AE))  | Any (List (Guard C S B H A AM AC AE));</pre></code></pre> <p>The <code>GuardEval</code> type defines the criteria for evaluating actions associated with guards inside the given list. The evaluation strategies are as follows:</p> <ul> <li>With <code>First</code>, we say that the first guard in the provided list that holds, i.e., yields a result, upon sequential evaluation is selected, its associated action is performed, and the evaluation stops.</li> </ul> <ul> <li>With <code>Any</code>, we say that any guard in the provided list that holds upon sequential evaluation is selected, their associated actions are performed, and the evaluation stops.</li> </ul>","tags":["node-architecture","types","engine","behaviour","prelude"]},{"location":"arch/node/types/engine_behaviour.html#the-type-for-engine-behaviours","title":"The type for engine behaviours","text":"<p>The <code>EngineBehaviour</code> type encapsulates the concept of behaviours within Anoma. Each engine is associated with a specific term of type <code>EngineBehaviour</code> that defines its core dynamics and operational characteristics. The behaviour determines how the engine processes inputs, manages state, and interacts with other components. As defined, it clears up that engines are essentially a collection of guarded state-transition functions. Using the terminology introduced earlier, an <code>EngineBehaviour</code> is a set of guards and an action function.</p> <pre><code><pre>type EngineBehaviour C S B H A AM AC AE :=  mk@{    guards : GuardEval C S B H A AM AC AE;  };</pre></code></pre> Arguments <code>guards</code> the guards to be evaluated. <p>Summary of behaviour</p> <p>Roughly, engines are a collection of guarded state-transition functions, using terminology of Moore or Mealy machines. The presentation in terms of a set of guards is in the spirit of Dijkstra's guarded command language, where the commands are replaced by actions. Effectively, the data of engine behaviour indirectly describes a function that determines how the received timestamped trigger is to be handled, expressed as a set of action effects.<sup>2</sup></p> <ol> <li> <p>This is likely to change in future versions.\u00a0\u21a9</p> </li> <li> <p>In future versions, this may be done using <code>do notation</code> (as provided by monads).\u00a0\u21a9</p> </li> </ol>","tags":["node-architecture","types","engine","behaviour","prelude"]},{"location":"arch/node/types/engine_config.html","title":"Engine Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.types.engine_config;import arch.node.types.basics open public;import arch.node.types.identities open;import arch.node.types.messages open;</pre></code></pre></p>","tags":["node-architecture","types","engine","configuration","prelude"]},{"location":"arch/node/types/engine_config.html#engine-configuration","title":"Engine configuration","text":"","tags":["node-architecture","types","engine","configuration","prelude"]},{"location":"arch/node/types/engine_config.html#engine-configuration-type","title":"Engine configuration type","text":"<p>The engine configuration contains the following static information for engine instances:</p> <ul> <li>A global reference, <code>name</code>, for the engine instance.</li> <li>The local <code>NodeID</code>.</li> <li>Engine-specific configuration.</li> </ul> <p>This is defined in the <code>EngineCfg</code> type, which is parametrized by:</p> <ul> <li><code>C</code>: represents the engine-specific configuration, which corresponds to the <code>Cfg</code> type.</li> </ul> <pre><code><pre>type EngineCfg C :=  mk@{    node : NodeID;    name : EngineName;    cfg : C;  };</pre></code></pre>","tags":["node-architecture","types","engine","configuration","prelude"]},{"location":"arch/node/types/engine_config.html#getengineidfromenginecfg","title":"<code>getEngineIDFromEngineCfg</code>","text":"<ul> <li>Get the local <code>EngineID</code> from an <code>EngineCfg</code>:</li> </ul> <pre><code><pre>getEngineIDFromEngineCfg {C} (cfg : EngineCfg C) : EngineID :=  mkPair (some (EngineCfg.node cfg)) (EngineCfg.name cfg);</pre></code></pre>","tags":["node-architecture","types","engine","configuration","prelude"]},{"location":"arch/node/types/engine_environment.html","title":"Engine Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.types.engine_environment;import arch.node.types.basics open public;import arch.node.types.identities open;import arch.node.types.messages open;</pre></code></pre></p>","tags":["node-architecture","types","engine","environment","prelude"]},{"location":"arch/node/types/engine_environment.html#engine-environment","title":"Engine environment","text":"","tags":["node-architecture","types","engine","environment","prelude"]},{"location":"arch/node/types/engine_environment.html#engine-environment-type","title":"Engine environment type","text":"<p>The engine environment contains the following dynamic information for engine instances:</p> <ul> <li>Local state whose type is specific to the engine.</li> <li>Mailbox cluster, which is a map of mailbox IDs to mailboxes.</li> <li>A set of names of acquainted engine instances. It is implicit that the engine   instance is acquainted with itself, so there is no need to include its own name.</li> <li>A list of timers that have been set.</li> </ul> <p>This data is encapsulated within the <code>EngineEnv</code> type, which is parameterised by four types, which represent:</p> <ul> <li><code>S</code>: the local state,</li> <li><code>B</code>: the type of mailboxes' states,</li> <li><code>H</code>: the type of handles for timers, and</li> <li><code>AM</code>: the type of all engine messages (<code>Msg</code>).</li> </ul> <p>These same letters will be used in the rest of the document to represent these types.</p> <pre><code><pre>type EngineEnv S B H AM :=  mk@{    localState : S;    mailboxCluster : Map MailboxID (Mailbox B AM);    acquaintances : Set EngineName;    timers : List (Timer H);  };</pre></code></pre> Arguments <code>localState</code> the local state, <code>mailboxCluster</code> the mailbox cluster, <code>acquaintances</code> the set of acquainted engine instances, and <code>timers</code> the list of timers. On the mailbox cluster <p>The mailbox cluster is a map of mailbox IDs to mailboxes. The mailbox ID is an index type, and the mailbox is a record containing the following data:</p> <ul> <li>The enveloped messages that the mailbox contains.</li> <li>The mailbox state, which is of type <code>Option B</code>, i.e., it could be none.</li> </ul> <p>If you don't need multiple mailboxes, you can use any ID as the key. For example, you can use <code>0</code> for a default mailbox.</p>","tags":["node-architecture","types","engine","environment","prelude"]},{"location":"arch/node/types/identities.html","title":"Identities","text":"Juvix imports <p><pre><code><pre>module arch.node.types.identities;import arch.node.types.crypto open public;import arch.system.state.resource_machine.notes.nockma open;import arch.system.state.resource_machine.notes.nockma_runnable open;import prelude open;</pre></code></pre></p>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#types-for-network-identities","title":"Types for network identities","text":"<p>Types in this section are used to represent identities within the network.</p>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#basic-types","title":"Basic Types","text":"","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#signable","title":"<code>Signable</code>","text":"<p>A type representing data that can be cryptographically signed.</p> <pre><code><pre>Signable : Type := ByteString;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#plaintext","title":"<code>Plaintext</code>","text":"<p>Raw unencrypted data.</p> <pre><code><pre>Plaintext : Type := ByteString;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#ciphertext","title":"<code>Ciphertext</code>","text":"<p>Encrypted data.</p> <pre><code><pre>Ciphertext : Type := ByteString;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#decryptionkey","title":"<code>DecryptionKey</code>","text":"<pre><code><pre>DecryptionKey : Type := ByteString;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#signingkey","title":"<code>SigningKey</code>","text":"<pre><code><pre>SigningKey : Type := ByteString;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#identity-types","title":"Identity Types","text":"","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#externalid","title":"<code>ExternalID</code>","text":"<p>A unique identifier, such as a public key, represented as a natural number.</p> <pre><code><pre>syntax alias ExternalID := PublicKey;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#internalid","title":"<code>InternalID</code>","text":"<p>A unique identifier, such as a private key, used internally within the network.</p> <pre><code><pre>syntax alias InternalID := PrivateKey;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#identity","title":"<code>Identity</code>","text":"<p>A pair combining an <code>ExternalID</code> and an <code>InternalID</code>.</p> <pre><code><pre>Identity : Type := Pair ExternalID InternalID;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#commitment","title":"<code>Commitment</code>","text":"<p>A cryptographic signature or commitment.</p> <pre><code><pre>syntax alias Commitment := Signature;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#emptycommitment","title":"<code>emptyCommitment</code>","text":"<p>An empty commitment.</p> <pre><code><pre>axiom emptyCommitment : Commitment;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#network-identifiers","title":"Network Identifiers","text":"","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#nodeid","title":"<code>NodeID</code>","text":"<p>Cryptographic node identity.</p> <pre><code><pre>syntax alias NodeID := ExternalID;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#topicid","title":"<code>TopicID</code>","text":"<p>Cryptographic topic identity.</p> <pre><code><pre>syntax alias TopicID := ExternalID;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#publisherid","title":"<code>PublisherID</code>","text":"<p>Cryptographic identity of a publisher in a pub/sub topic.</p> <pre><code><pre>syntax alias PublisherID := ExternalID;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#domainid","title":"<code>DomainID</code>","text":"<p>Cryptographic domain identity.</p> <pre><code><pre>syntax alias DomainID := ExternalID;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#memberid","title":"<code>MemberID</code>","text":"<p>Cryptographic identity of a member in a domain.</p> <pre><code><pre>syntax alias MemberID := ExternalID;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#chunkid","title":"<code>ChunkID</code>","text":"<p>Cryptographic content addressed hash digest of a data chunk.</p> <pre><code><pre>syntax alias ChunkID := Digest;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#engine-related-types","title":"Engine Related Types","text":"","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#enginename","title":"<code>EngineName</code>","text":"<p>Engine instance name as an opaque string.</p> <pre><code><pre>syntax alias EngineName := String;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#externalidentity","title":"<code>ExternalIdentity</code>","text":"<p>An alias for engine name.</p> <pre><code><pre>syntax alias ExternalIdentity := EngineName;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#engineid","title":"<code>EngineID</code>","text":"<p>Engine instance identity combining node identity and engine name.</p> <pre><code><pre>EngineID : Type := Pair (Option NodeID) EngineName;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#islocalengineid","title":"<code>isLocalEngineID</code>","text":"<pre><code><pre>isLocalEngineID (eid : EngineID) : Bool :=  case eid of    | mkPair none _ := true    | _ := false;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#isremoteengineid","title":"<code>isRemoteEngineID</code>","text":"<pre><code><pre>isRemoteEngineID (eid : EngineID) : Bool := not (isLocalEngineID eid);</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#namegen","title":"<code>nameGen</code>","text":"<pre><code><pre>nameGen (str : String) (name : EngineName) (addr : EngineID) : EngineName :=  name ++str \"_\" ++str str ++str \"_\" ++str snd addr;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#identity-parameters-and-capabilities","title":"Identity Parameters and Capabilities","text":"","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#idparams","title":"<code>IDParams</code>","text":"<p>Supported identity parameter types.</p> <pre><code><pre>type IDParams :=  | Ed25519  | Secp256k1  | BLS;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#backend","title":"<code>Backend</code>","text":"<p>Backend connection types.</p> <pre><code><pre>type Backend :=  | LocalMemory  | LocalConnection@{      subtype : String;    }  | RemoteConnection@{      externalIdentity : ExternalIdentity;    };</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#capabilities","title":"<code>Capabilities</code>","text":"<p>Available identity capabilities.</p> <pre><code><pre>type Capabilities :=  | Commit  | Decrypt  | CommitAndDecrypt;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#identity-evidence-types","title":"Identity Evidence Types","text":"","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#identityname","title":"<code>IdentityName</code>","text":"<p>Hierarchical identity naming structure.</p> <pre><code><pre>type IdentityName :=  | LocalName@{      name : String;    }  | DotName@{      parent : ExternalIdentity;      child : String;    };</pre></code></pre> Instances","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#ordering-instance-for-identityname","title":"Ordering instance for <code>IdentityName</code>","text":"<p><pre><code><pre>axiom IdentityNameCmpDummy : IdentityName -&gt; IdentityName -&gt; Ordering;instanceIdentityNameOrd : Ord IdentityName :=  Ord.mk@{    compare := IdentityNameCmpDummy;  };</pre></code></pre></p>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#readsforevidence","title":"<code>ReadsForEvidence</code>","text":"<p>Evidence of read permissions between identities.</p> <pre><code><pre>type ReadsForEvidence :=  mkReadsForEvidence@{    fromIdentity : ExternalIdentity;    toIdentity : ExternalIdentity;    proof : ByteString;  };</pre></code></pre> Instances","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#ordering-instance-for-readsforevidence","title":"Ordering instance for <code>ReadsForEvidence</code>","text":"<p><pre><code><pre>axiom ReadsForCmpDummy : ReadsForEvidence -&gt; ReadsForEvidence -&gt; Ordering;instanceReadsForOrd : Ord ReadsForEvidence :=  Ord.mk@{    compare := ReadsForCmpDummy;  };</pre></code></pre></p>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#signsforevidence","title":"<code>SignsForEvidence</code>","text":"<p>Evidence of signing permissions between identities.</p> <pre><code><pre>type SignsForEvidence :=  mkSignsForEvidence@{    fromIdentity : ExternalIdentity;    toIdentity : ExternalIdentity;    proof : ByteString;  };</pre></code></pre> Instances","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#ordering-instance-for-signsforevidence","title":"Ordering instance for <code>SignsForEvidence</code>","text":"<p><pre><code><pre>axiom SignsForCmpDummy : SignsForEvidence -&gt; SignsForEvidence -&gt; Ordering;instanceSignsForOrd : Ord SignsForEvidence :=  Ord.mk@{    compare := SignsForCmpDummy;  };</pre></code></pre></p>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#identitynameevidence","title":"<code>IdentityNameEvidence</code>","text":"<p>Evidence linking identity names to external identities.</p> <pre><code><pre>type IdentityNameEvidence :=  mkIdentityNameEvidence@{    identityName : IdentityName;    externalIdentity : ExternalIdentity;    proof : ByteString;  };</pre></code></pre> Instances","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#ordering-instance-for-identitynameevidence","title":"Ordering instance for <code>IdentityNameEvidence</code>","text":"<p><pre><code><pre>axiom IdentityNameEvidenceCmpDummy  : IdentityNameEvidence -&gt; IdentityNameEvidence -&gt; Ordering;instanceIdentityNameEvidenceOrd : Ord IdentityNameEvidence :=  Ord.mk@{    compare := IdentityNameEvidenceCmpDummy;  };</pre></code></pre></p>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#ordering-aliases","title":"Ordering Aliases","text":"<pre><code><pre>type TransactionLabel ReadLabel WriteLabel :=  mkTransactionLabel@{    read : List ReadLabel;    write : List WriteLabel;  };</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#txfingerprint","title":"<code>TxFingerprint</code>","text":"<pre><code><pre>syntax alias TxFingerprint := Nat;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#transactioncandidate","title":"<code>TransactionCandidate</code>","text":"<pre><code><pre>type TransactionCandidate ReadLabel WriteLabel Executable :=  mkTransactionCandidate@{    label : TransactionLabel ReadLabel WriteLabel;    executable : Executable;  };</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#narwhalblock","title":"<code>NarwhalBlock</code>","text":"<pre><code><pre>syntax alias NarwhalBlock := String;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#batchnumber","title":"<code>BatchNumber</code>","text":"<pre><code><pre>syntax alias BatchNumber := Nat;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#wallclocktime","title":"<code>WallClockTime</code>","text":"<pre><code><pre>syntax alias WallClockTime := Nat;</pre></code></pre>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/identities.html#sharding","title":"Sharding","text":"<pre><code><pre>syntax alias KVSKey := Nat;</pre></code></pre> <pre><code><pre>syntax alias KVSDatum := Nat;</pre></code></pre> <pre><code><pre>syntax alias ProgramState := NockmaProgramState;</pre></code></pre> <pre><code><pre>syntax alias Executable := Noun;</pre></code></pre> <p>v0.3</p> <p>Is the map from keys to shards still assumed to be fixed?</p>","tags":["node-architecture","types","prelude"],"boost":2},{"location":"arch/node/types/messages.html","title":"Messages & Mailboxes","text":"Juvix imports <p><pre><code><pre>module arch.node.types.messages;import prelude open public;import arch.node.types.basics open;import arch.node.types.crypto open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#messages-and-mailboxes","title":"Messages and mailboxes","text":"","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#types","title":"Types","text":"<p>A message is a piece of data dispatched from one engine, termed the sender, to another engine, referred to as the target. When a message is sent, it is enveloped with additional metadata such as the target address and potentially the sender address, in case the sender wants to be identified. Upon arrival at the target engine, the message is stored in the target engine's mailboxes. These mailboxes are indexed by an identifier that are only unique to their engine. If the target engine has only one mailbox, the mailbox identifier is redundant.</p> <p>The following types are used to represent these messages and mailboxes.</p>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#enginemsgid","title":"<code>EngineMsgID</code>","text":"<p>An engine message identifier. The cryptographic hash of the corresponding <code>EngineMsg</code>.</p> <pre><code><pre>syntax alias EngineMsgID := Digest;</pre></code></pre>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#mailbox-s","title":"<code>Mailbox S</code>","text":"<p>A mailbox is a container for engine messages and optionally a mailbox state. The mailbox state could be used to store additional information about the mailbox, such as the priority of the messages in the mailbox.</p> Where does mailbox state come from? <p>The mailbox state is related to the capabilities of mailboxes of the paper <sup>1</sup>. In particular, at any given point in time, a mailbox will have a capability for receiving messages (in later versions of the specs). As mailbox state can be useful in general, we already have it now.</p> <pre><code><pre>type Mailbox S M :=  mkMailbox@{    messages : List (EngineMsg M);    mailboxState : Option S;  };</pre></code></pre>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#mailboxid","title":"<code>MailboxID</code>","text":"<p>A mailbox identifier is a natural number used to index mailboxes.</p> Where do mailbox identifiers come from? <p>The concept of mailbox identifier is taken from the paper <sup>1</sup> (see also Mailbox Cluster and <sup>2</sup>).</p> <pre><code><pre>syntax alias MailboxID := Nat;</pre></code></pre>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#enginemsg","title":"<code>EngineMsg</code>","text":"<p>An engine message is a message between engines. It consists of a sender, a target, an optional mailbox identifier, and the message itself.</p> <pre><code><pre>type EngineMsg M :=  mk@{    sender : EngineID;    target : EngineID;    mailbox : Option MailboxID;    msg : M;  };</pre></code></pre>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#timer-h","title":"<code>Timer H</code>","text":"<pre><code><pre>type Timer H :=  mkTimer@{    time : Time;    handle : H;  };</pre></code></pre>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#trigger-h","title":"<code>Trigger H</code>","text":"<pre><code><pre>type Trigger H M :=  | MessageArrived@{      msg : EngineMsg M;    }  | Elapsed@{      timers : List (Timer H);    };</pre></code></pre>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#getenginemsgfromtrigger","title":"<code>getEngineMsgFromTrigger</code>","text":"<p>Extract the <code>EngineMsg</code> from a trigger in case it has one:</p> <pre><code><pre>getEngineMsgFromTrigger {H M} (tr : Trigger H M) : Option (EngineMsg M) :=  case tr of    | Trigger.MessageArrived@{msg} := some msg    | Trigger.Elapsed@{} := none;</pre></code></pre>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#getmsgfromtrigger","title":"<code>getMsgFromTrigger</code>","text":"<p>Extract the <code>Msg</code> from a trigger in case it has one:</p> <pre><code><pre>getMsgFromTrigger {H M} (tr : Trigger H M) : Option M :=  case tr of    | Trigger.MessageArrived@{msg} := some (EngineMsg.msg msg)    | Trigger.Elapsed@{} := none;</pre></code></pre>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#getsenderfromtrigger","title":"<code>getSenderFromTrigger</code>","text":"<pre><code><pre>getSenderFromTrigger {H M} (tr : Trigger H M) : Option EngineID :=  case tr of    | Trigger.MessageArrived@{msg} := some (EngineMsg.sender msg)    | Trigger.Elapsed@{} := none;</pre></code></pre>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#gettargetfromtrigger","title":"<code>getTargetFromTrigger</code>","text":"<pre><code><pre>getTargetFromTrigger {H M} (tr : Trigger H M) : Option EngineID :=  case tr of    | Trigger.MessageArrived@{msg} := some (EngineMsg.target msg)    | Trigger.Elapsed@{} := none;</pre></code></pre>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#timestampedtrigger-h","title":"<code>TimestampedTrigger H</code>","text":"<pre><code><pre>type TimestampedTrigger H M :=  mkTimestampedTrigger@{    time : Time;    trigger : Trigger H M;  };</pre></code></pre>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#getenginemsgfromtimestampedtrigger","title":"<code>getEngineMsgFromTimestampedTrigger</code>","text":"<pre><code><pre>getEngineMsgFromTimestampedTrigger  {H M} (tr : TimestampedTrigger H M) : Option (EngineMsg M) :=  getEngineMsgFromTrigger (TimestampedTrigger.trigger tr);</pre></code></pre>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#getmsgfromtimestampedtrigger","title":"<code>getMsgFromTimestampedTrigger</code>","text":"<pre><code><pre>getMsgFromTimestampedTrigger {H M} (tr : TimestampedTrigger H M) : Option M :=  getMsgFromTrigger (TimestampedTrigger.trigger tr);</pre></code></pre>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#getsenderfromtimestampedtrigger","title":"<code>getSenderFromTimestampedTrigger</code>","text":"<pre><code><pre>getSenderFromTimestampedTrigger  {H M} (tr : TimestampedTrigger H M) : Option EngineID :=  getSenderFromTrigger (TimestampedTrigger.trigger tr);</pre></code></pre>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/messages.html#gettargetfromtimestampedtrigger","title":"<code>getTargetFromTimestampedTrigger</code>","text":"<pre><code><pre>getTargetFromTimestampedTrigger  {H M} (tr : TimestampedTrigger H M) : Option EngineID :=  getTargetFromTrigger (TimestampedTrigger.trigger tr);</pre></code></pre> <ol> <li> <p>Simon Fowler, Duncan Paul Attard, Franciszek Sowul, Simon J. Gay, and Phil Trinder. Special delivery: programming with mailbox types. Proceedings of the ACM on Programming Languages, 7(ICFP):78\u2013107, August 2023. URL: http://dx.doi.org/10.1145/3607832, doi:10.1145/3607832.\u00a0\u21a9\u21a9</p> </li> <li> <p>Shams M. Imam and Vivek Sarkar. Selectors: actors with multiple guarded mailboxes. AGERE! '14: Proceedings of the 4th International Workshop on Programming based on Actors Agents and Decentralized Control, October 2014. URL: http://dx.doi.org/10.1145/2687357.2687360, doi:10.1145/2687357.2687360.\u00a0\u21a9</p> </li> </ol>","tags":["work-in-progress","node-architecture","types","message-types","mailboxes","prelude"],"boost":2},{"location":"arch/node/types/router.html","title":"Router","text":"Juvix imports <p><pre><code><pre>module arch.node.types.router;import prelude open;import arch.node.types.basics open;import arch.node.types.transport open;import arch.node.types.crypto open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","types","network-subsystem","router","prelude"],"boost":2},{"location":"arch/node/types/router.html#router-types","title":"Router Types","text":"","tags":["node-architecture","types","network-subsystem","router","prelude"],"boost":2},{"location":"arch/node/types/router.html#nodeadvert","title":"<code>NodeAdvert</code>","text":"<p>A self-signed node advertisement contains the node's cryptographic identity and transport addresses.</p> <pre><code><pre>type NodeAdvert :=  mkNodeAdvert@{    id : NodeID;    addrs : List TransportAddress;    version : Nat;    created : AbsTime;    sig : Commitment;  };</pre></code></pre> Arguments <code>id</code> Node identity. <code>addrs</code> Transport addresses with preferences expressed as weights. <code>version</code> Version number (incremented at every change). <code>created</code> Time of creation. <code>sig</code> Signature by <code>id</code>.","tags":["node-architecture","types","network-subsystem","router","prelude"],"boost":2},{"location":"arch/node/types/router.html#topicadvert","title":"<code>TopicAdvert</code>","text":"<p>A topic advertisement signed by the topic creator contains the topic's cryptographic identity, and the <code>NodeID</code> of a set of relay nodes that can be used to subscribe to the topic. These may be publishers, subscribers, or dedicated relay nodes for the topic.</p> <pre><code><pre>type TopicAdvert :=  mkTopicAdvert@{    id : TopicID;    relays : List NodeID;    tags : List String;    version : Nat;    created : AbsTime;    sig : Commitment;  };</pre></code></pre> Arguments <code>id</code> Topic identity. <code>relays</code> List of relay nodes. <code>tags</code> List of tags. <code>version</code> Version number (incremented at every change). <code>created</code> Time of creation. <code>sig</code> Signature by <code>id</code>.","tags":["node-architecture","types","network-subsystem","router","prelude"],"boost":2},{"location":"arch/node/types/storage.html","title":"Storage","text":"Juvix imports <p><pre><code><pre>module arch.node.types.storage;import prelude open;import arch.node.types.basics open;import arch.node.types.crypto open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","types","network-subsystem","storage","prelude"],"boost":2},{"location":"arch/node/types/storage.html#storage-types","title":"Storage Types","text":"","tags":["node-architecture","types","network-subsystem","storage","prelude"],"boost":2},{"location":"arch/node/types/storage.html#acl","title":"<code>ACL</code>","text":"<p>Access control list stored in a Storage object.</p> <p>Contains <code>ExternalID</code>s that are members of the list, the version of the ACL, which is incremented at each update, and a signature by the ACL owner.</p> <p>The ACL may be updated by sending an updated version to a pub/sub topic identified by the ACL owner's <code>ExternalID</code>.</p> <pre><code><pre>type ACL :=  mkACL@{    members : Set ExternalID;    version : Nat;    sig : Commitment;  };</pre></code></pre> Arguments <code>members</code> Set of <code>ExternalID</code>s that are members of the ACL. <code>version</code> Version of the ACL. <code>sig</code> Signature of the ACL by the ACL owner.","tags":["node-architecture","types","network-subsystem","storage","prelude"],"boost":2},{"location":"arch/node/types/storage.html#chunk","title":"<code>Chunk</code>","text":"<p>A chunk of a storage object.</p> <pre><code><pre>type Chunk :=  mkChunk@{    children : List ChunkID;    expiry : AbsTime;    acl : Option ACL;    content : ByteString;  };</pre></code></pre> Arguments <code>children</code> List of chunk IDs of children in the Merkle tree. <code>expiry</code> Expiration time after which the chunk must be deleted by each node storing it. <code>content</code> Encrypted <code>ChunkContent</code>. <code>acl</code> Nodes that are allowed to request the chunk.","tags":["node-architecture","types","network-subsystem","storage","prelude"],"boost":2},{"location":"arch/node/types/storage.html#chunkcontent","title":"<code>ChunkContent</code>","text":"<p>The content of a <code>Chunk</code>.</p> <pre><code><pre>type ChunkContent :=  | InternalNode (List SecretKey)  | LeafNode ByteString;</pre></code></pre> <code>ChunkContent</code> constructors <code>InternalNode</code> An internal node of the Merkle tree. Contains decryption keys of its children. <code>LeafNode</code> A leaf node of the Merkle tree. Contains a data chunk.","tags":["node-architecture","types","network-subsystem","storage","prelude"],"boost":2},{"location":"arch/node/types/storage.html#chunkcommitment","title":"<code>ChunkCommitment</code>","text":"<p>Commitment by a node to store a chunk for a certain period of time.</p> <p>Contains a reference to a <code>Chunk</code>, along with the <code>NodeID</code> where it is stored, and an expiry time</p> <pre><code><pre>type ChunkCommitment :=  mkChunkCommitment@{    chunk : ChunkID;    node : NodeID;    expiry : AbsTime;    sig : Commitment;  };</pre></code></pre> Arguments <code>id</code> <code>ChunkID</code> to commit to. <code>node</code> <code>NodeID</code> where the <code>Chunk</code> can be found. <code>expiry</code> Expiration time, until <code>node</code> guarantees storage. <code>sig</code> Cryptographic signature of the above fields by <code>node</code>.","tags":["node-architecture","types","network-subsystem","storage","prelude"],"boost":2},{"location":"arch/node/types/transport.html","title":"Transport","text":"Juvix imports <p><pre><code><pre>module arch.node.types.transport;import arch.node.types.basics open;import arch.node.types.crypto open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["node-architecture","types","network-subsystem","transport","prelude"],"boost":2},{"location":"arch/node/types/transport.html#transport-types","title":"Transport types","text":"","tags":["node-architecture","types","network-subsystem","transport","prelude"],"boost":2},{"location":"arch/node/types/transport.html#ipv4address","title":"<code>IPv4Address</code>","text":"<pre><code><pre>syntax alias IPv4Address := Nat;</pre></code></pre>","tags":["node-architecture","types","network-subsystem","transport","prelude"],"boost":2},{"location":"arch/node/types/transport.html#ipv6address","title":"<code>IPv6Address</code>","text":"<pre><code><pre>syntax alias IPv6Address := Nat;</pre></code></pre>","tags":["node-architecture","types","network-subsystem","transport","prelude"],"boost":2},{"location":"arch/node/types/transport.html#ipaddress","title":"<code>IPAddress</code>","text":"<pre><code><pre>IPAddress : Type := Either IPv4Address IPv6Address;</pre></code></pre>","tags":["node-architecture","types","network-subsystem","transport","prelude"],"boost":2},{"location":"arch/node/types/transport.html#transportprotocol","title":"<code>TransportProtocol</code>","text":"<p>Supported network transport protocols.</p> <pre><code><pre>type TransportProtocol :=  | QUIC  | TLS  | WebTransport  | WebSocket  | TCP  | UDP;</pre></code></pre>","tags":["node-architecture","types","network-subsystem","transport","prelude"],"boost":2},{"location":"arch/node/types/transport.html#tlsaddress","title":"<code>TLSAddress</code>","text":"<p>TLS or QUIC address.</p> <pre><code><pre>type TLSAddress :=  mkTLSAddress@{    ip : IPAddress;    port : Nat;    cert_issuer : String;  };</pre></code></pre> Arguments <code>ip</code> IP address <code>port</code> Port number <code>cert_issuer</code> TLS certificate issuer fingerprint","tags":["node-architecture","types","network-subsystem","transport","prelude"],"boost":2},{"location":"arch/node/types/transport.html#transportaddress","title":"<code>TransportAddress</code>","text":"<pre><code><pre>type TransportAddress :=  | QUICAddr TLSAddress  | TLSAddr TLSAddress  | IPAddr IPAddress;</pre></code></pre>","tags":["node-architecture","types","network-subsystem","transport","prelude"],"boost":2},{"location":"arch/node/types/transport.html#transportorderingprefs","title":"<code>TransportOrderingPrefs</code>","text":"<p>Transport ordering preferences for an outgoing message.</p> <pre><code><pre>type TransportOrderingPrefs :=  | TransportOrdered  | TransportUnordered;</pre></code></pre>","tags":["node-architecture","types","network-subsystem","transport","prelude"],"boost":2},{"location":"arch/node/types/transport.html#transportreliabilityprefs","title":"<code>TransportReliabilityPrefs</code>","text":"<p>Transport reliability preferences for an outgoing message.</p> <pre><code><pre>type TransportReliabilityPrefs :=  | TransportReliable  | TransportUnreliable;</pre></code></pre>","tags":["node-architecture","types","network-subsystem","transport","prelude"],"boost":2},{"location":"arch/node/types/transport.html#transportsecurityprefs","title":"<code>TransportSecurityPrefs</code>","text":"<p>Transport ordering preferences for an outgoing message.</p> <pre><code><pre>type TransportSecurityPrefs := | TransportDirect;</pre></code></pre>","tags":["node-architecture","types","network-subsystem","transport","prelude"],"boost":2},{"location":"arch/node/types/transport.html#transportprefs","title":"<code>TransportPrefs</code>","text":"<p>Transport preferences for an outgoing message.</p> <pre><code><pre>type TransportPrefs :=  mkTransportPrefs@{    ordering : TransportOrderingPrefs;    reliability : TransportReliabilityPrefs;    security : TransportSecurityPrefs;  };</pre></code></pre> Arguments <code>ordering</code> Transport ordering preferences <code>reliability</code> Transport reliability preferences <code>security</code> Transport security preferences","tags":["node-architecture","types","network-subsystem","transport","prelude"],"boost":2},{"location":"arch/node/types/transport.html#serializedmsg","title":"<code>SerializedMsg</code>","text":"<p>Serialized message. Contains an <code>EngineMsg</code>.</p> <pre><code><pre>type SerializedMsg := | BARE ByteString;</pre></code></pre> Arguments <code>SerializedMsgBARE</code> BARE","tags":["node-architecture","types","network-subsystem","transport","prelude"],"boost":2},{"location":"arch/node/types/transport.html#encryptedmsg","title":"<code>EncryptedMsg</code>","text":"<p>Serialized message encrypted with the specified algorithm. Contains a <code>SerializedMsg</code>.</p> <pre><code><pre>type EncryptedMsg := | EncryptedMsgNull ByteString;</pre></code></pre> Arguments <code>EncryptedMsgNull</code> No encryption.","tags":["node-architecture","types","network-subsystem","transport","prelude"],"boost":2},{"location":"arch/system/identity/identity.html","title":"Identity Architecture Types","text":"Juvix imports <p><pre><code><pre>module arch.system.identity.identity;import prelude open;</pre></code></pre></p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#identity-architecture","title":"Identity Architecture","text":"Type definitions <p><pre><code><pre>type OrdKey OrdKeyType :=  mkOrdKey@{    compare : OrdKeyType -&gt; OrdKeyType -&gt; Ordering;  };</pre></code></pre></p> <p><pre><code><pre>type HASH OrdKeyType Hashable :=  mkHASH@{    ordKey : OrdKey OrdKeyType;    hash : Hashable -&gt; OrdKeyType;  };</pre></code></pre></p> <p><pre><code><pre>type OrdMap (OrdKeyType : Type) (MapCon : Type -&gt; Type) :=  mkMap@{    ordKey : OrdKey OrdKeyType;    empty {A} : MapCon A;    map {A B} : (A -&gt; B) -&gt; MapCon A -&gt; MapCon B;    insert {A} : Pair (MapCon A) (Pair OrdKeyType A) -&gt; MapCon A;    foldl {A B} : (Pair A B -&gt; B) -&gt; B -&gt; MapCon A -&gt; B;    intersectWith      {A B C} : (Pair A B -&gt; C) -&gt; Pair (MapCon A) (MapCon B) -&gt; MapCon C;    all {A} : (A -&gt; Bool) -&gt; MapCon A -&gt; Bool;  };</pre></code></pre></p> <p>The base abstraction of the protocol is a knowledge-based identity  interface, where the identity of an agent is defined entirely on the  basis of whether or not they know some secret information.</p> <p>Agents can use private information (likely randomness) to create an  internal identity, from which they can derive an  external identity to which it corresponds. The external identity can be shared with other parties. The agent who knows the internal identity can sign messages, which any  agent who knows the external identity can verify, and any agent who  knows the external identity can encrypt messages which the agent with  knowledge of the internal identity can decrypt. This identity interface is independent of the particular cryptographic  mechanisms, which may vary.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#identity-interface","title":"Identity Interface","text":"","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#internal-identity","title":"Internal Identity","text":"<p>An internal identity includes private information necessary for signing and  decryption. Formally, an internal identity has two parts: a Signer and a Decryptor.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#signer-juvix-type","title":"Signer Juvix Type","text":"<p>A signature describing a type <code>SignerType</code> that can cryptographically  <code>sign</code> (or credibly commit) to something (a <code>Signable</code>), forming a  <code>Commitment</code>. Implementations should ultimately include, for example  BLS keys,   which should be able to sign anything that can be marshaled into a   bitstring.</p> <p>Properties:</p> <ul> <li> <p>In general, every <code>S : Signer</code> needs a corresponding <code>V : Verifier</code>, and   every <code>s : SignerType</code> needs a corresponding <code>v : VerifierType</code>, such that:</p> <ul> <li>For any message <code>m</code> : <code>verify v m x = (x = (sign s m))</code></li> </ul> <ul> <li>for most cryptosystems, a computationally bounded adversary should not be   able to approximate <code>s</code> knowing only <code>v</code>.</li> </ul> </li> </ul> <pre><code><pre>type Signer SignerType Signable Commitment :=  mkSigner@{    sign : SignerType -&gt; Signable -&gt; Commitment;  };</pre></code></pre>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#decryptor-juvix-type","title":"Decryptor Juvix Type","text":"<p>A signature describing a type <code>DecryptorType</code> that can cryptographically  <code>decrypt</code> something (a <code>Ciphertext</code>), resulting in a <code>Plaintext</code>  (or <code>none</code>, if decryption fails). Implementations should ultimately include, for example,  AES-256  keys,  which should be able to decrypt bitstrings into anything that  can be unmarshaled from a bitstring.</p> <p>Properties:</p> <ul> <li>a computationally bounded adversary should not be able to   approximate <code>decrypt d</code> without knowledge of <code>d</code>.</li> </ul> <ul> <li><code>decrypt</code> should take polynomial time (in the size of its inputs)</li> </ul> <ul> <li> <p>Each <code>D : Decryptor</code> should have a corresponding <code>E : Encryptor</code>, and   each <code>d : DecryptorType</code> has a corresponding <code>e : EncryptorType</code> such   that:</p> <ul> <li>for all <code>c : Ciphertext</code>, <code>p : Plaintext</code>:   <code>decrypt d c = Some p</code> iff <code>c = encrypt e p</code></li> </ul> <ul> <li>if <code>d = e</code>, we call this \"symmetric encryption,\" and otherwise   it's \"asymmetric encryption\"</li> </ul> </li> </ul> <pre><code><pre>type Decryptor DecryptorType Plaintext Ciphertext :=  mkDecryptor@{    decrypt : DecryptorType -&gt; Ciphertext -&gt; Option Plaintext;  };</pre></code></pre>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#internal-identity-juvix-type","title":"Internal Identity Juvix Type","text":"<p>An Internal Identity structure simply specifies everything specified by both Signer and Decryptor.</p> <p>An Internal Identity structure specifies the necessary types and  functions for both a Signer and a Decryptor. Implementations should ultimately include, for example,  RSA private keys,  which should be able to decrypt integers into anything that can be  unmarshaled from a bitstring, and sign anything which can be  marshaled into a bytestring to form an integer.</p> <p>An internal_identity includes:</p> <ul> <li>a type <code>SignerType</code> that can cryptographically   <code>sign</code> (or credibly commit) to something (a <code>Signable</code>), forming a   <code>Commitment</code>.</li> </ul> <ul> <li>a type <code>DecryptorType</code> that can cryptographically <code>decrypt</code> something   (a <code>Ciphertext</code>), resulting in a <code>Plaintext</code>   (or <code>none</code>, if decryption fails).</li> </ul> <p>Properties are inherited from <code>Signer</code> and <code>Decryptor</code>.</p> <pre><code><pre>type InternalIdentity SignerType Signable Commitment DecryptorType Plaintext Ciphertext :=  mkInternalIdentity@{    signer : Signer SignerType Signable Commitment;    decryptor : Decryptor DecryptorType Plaintext Ciphertext;  };</pre></code></pre>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#external-identity","title":"External Identity","text":"<p>An external identity includes only public information. An external identity can verify signatures produced by an internal identity, and encrypt messages the internal identity can then decrypt. Formally, an external identity has two parts: a verifier and an Encryptor. Each is hashable: any structure specifying verifier and Encryptor types must also specify a hash function, so that external identities can be specified by hash.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#verifier-juvix-type","title":"Verifier Juvix Type","text":"<p>A signature describing a type <code>VerifierType</code> that can cryptographically  <code>verify</code> that a <code>Commitment</code> (or cryptographic signature) corresponds  to a given message (a <code>Signable</code>), and was signed by the <code>SignerType</code>  corresponding to this <code>VerifierType</code>. A <code>VerifierType</code> can be hashed (producing a unique identifier), so a  structure with signature <code>Verifier</code> must specify a <code>VerifierHash</code>  structure defining a suitable <code>hash</code> function. Implementations should ultimately include, for example  BLS  identities.</p> <p>Properties:</p> <ul> <li> <p>In general, every <code>V : Verifier</code> needs a corresponding <code>S : Signer</code>, and   every <code>s : SignerType</code> needs a corresponding <code>v : VerifierType</code>, such that:</p> <ul> <li>For any message <code>m</code> : <code>verify v m x = (x = (sign s m))</code></li> </ul> <ul> <li>for most cryptosystems, a computationally bounded adversary should not be   able to approximate <code>s</code> knowing only <code>v</code>.</li> </ul> </li> </ul> <pre><code><pre>type Verifier OrdKey VerifierType Signable Commitment :=  mkVerifier@{    verify : VerifierType -&gt; Signable -&gt; Commitment -&gt; Bool;    verifierHash : HASH OrdKey VerifierType;  };</pre></code></pre>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#encryptor-juvix-type","title":"Encryptor Juvix Type","text":"<p>A signature describing a type <code>EncryptorType</code> that can cryptographically  <code>encrypt</code> a <code>Plaintext</code> (message) to create a <code>Ciphertext</code> readable  only by the corresponding <code>DecryptorType</code>. An <code>EncryptorType</code> can be hashed (producing a unique identifier), so a  structure with signature <code>Encryptor</code> must specify an <code>encryptorHash</code>  structure defining a suitable hash function. Implementations should ultimately include, for example,  AES-256  keys,  which should be able to decrypt bitstrings into anything that  can be  unmarshaled from a bitstring.</p> <p>Properties:</p> <ul> <li><code>encrypt</code> should take polynomial time (in the size of its inputs)</li> </ul> <ul> <li> <p>Each <code>E : Encryptor</code> should have a corresponding <code>D : Decryptor</code>, and   each <code>d : DecryptorType</code> has a corresponding <code>e : EncryptorType</code> such   that:</p> <ul> <li>for all <code>c : Ciphertext</code>, <code>p : Plaintext</code>:   <code>decrypt d c = Some p</code> iff <code>c = encrypt e p</code></li> </ul> <ul> <li>if <code>d = e</code>, we call this \"symmetric encryption,\" and otherwise   it's \"asymmetric encryption.\"   In an asymmetric cryptosystem, a computationally bounded adversary   should not be able to approximate <code>d</code> knowing only <code>e</code>.</li> </ul> </li> </ul> <pre><code><pre>type Encryptor OrdKey EncryptorType Plaintext Ciphertext :=  mkEncryptor@{    encrypt : EncryptorType -&gt; Plaintext -&gt; Ciphertext;    encryptorHash : HASH OrdKey EncryptorType;  };</pre></code></pre>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#external-identity-juvix-type","title":"External Identity Juvix Type","text":"<p>An External Identity structure specifies the necessary types and  functions for both a Verifier and an Encryptor. Implementations should ultimately include, for example,  RSA public keys.</p> <p>An external_identity includes:</p> <ul> <li>a type <code>VerifierType</code> that can cryptographically <code>verify</code> that a   <code>Commitment</code> (or cryptographic signature) corresponds to a given   message (a <code>Signable</code>), and was signed by the <code>SignerType</code>   corresponding to this <code>VerifierType</code>.</li> </ul> <ul> <li>a type <code>EncryptorType</code> that can cryptographically <code>encrypt</code> a   <code>Plaintext</code> (message) to create a <code>Ciphertext</code> readable only by the   corresponding <code>DecryptorType</code>.</li> </ul> <p>Properties are inherited from <code>Verifier</code> and <code>Encryptor</code>.</p> <pre><code><pre>type ExternalIdentity VerifierOrdKeyType VerifierType Signable Commitment EncryptorOrdKeyType EncryptorType Plaintext Ciphertext :=  mkExternalIdentity@{    verifier : Verifier VerifierOrdKeyType VerifierType Signable Commitment;    encryptor      : Encryptor EncryptorOrdKeyType EncryptorType Plaintext Ciphertext;  };</pre></code></pre>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#identity-juvix-type","title":"Identity Juvix Type","text":"<p>An Identity structure, formally, specifies all the types for  corresponding internal and external identities. So, for a given Identity structure <code>I</code>, its <code>VerifierType</code> should be the  type of objects that can verify <code>Commitment</code>s produced by a  corresponding object of type <code>SignerType</code>. Likewise, its <code>DecryptorType</code> should be the type of objects that can decrypt  <code>Ciphertext</code>s produced by a corresponding object of type  <code>EncryptorType</code>. Implementations should ultimately include, for example,  RSA  public / private keys sytems.</p> <p>An Identity includes:</p> <ul> <li>a type <code>SignerType</code> that can cryptographically <code>sign</code> (or credibly commit) to something (an <code>InternalSignable</code>), forming an <code>InternalCommitment</code>.</li> </ul> <ul> <li>a type <code>DecryptorType</code> that can cryptographically <code>decrypt</code> something (an <code>InternalCiphertext</code>), resulting in an <code>InternalPlaintext</code> (or <code>none</code>, if decryption fails).</li> </ul> <ul> <li>a type <code>VerifierType</code> that can cryptographically <code>verify</code> that an <code>ExternalCommitment</code> (or cryptographic signature) corresponds to a given message (an <code>ExternalSignable</code>), and was signed by the <code>SignerType</code> corresponding to this <code>VerifierType</code>.</li> </ul> <ul> <li>a type <code>EncryptorType</code> that can cryptographically <code>encrypt</code> an <code>ExternalPlaintext</code> (message) to create an <code>ExternalCiphertext</code> readable only by the corresponding <code>DecryptorType</code>.</li> </ul> <p>Properties are inherited from <code>Verifier</code>, <code>Encryptor</code>, <code>Signer</code>, and <code>Decryptor</code>.</p> <pre><code><pre>type Identity SignerType InternalSignable InternalCommitment DecryptorType InternalCiphertext InternalPlaintext VerifierOrdKeyType VerifierType ExternalSignable ExternalCommitment EncryptorOrdKeyType EncryptorType ExternalPlaintext ExternalCiphertext :=  mkIdentity@{    internalIdentity      : InternalIdentity        SignerType        InternalSignable        InternalCommitment        DecryptorType        InternalPlaintext        InternalCiphertext;    externalIdentity      : ExternalIdentity        VerifierOrdKeyType        VerifierType        ExternalSignable        ExternalCommitment        EncryptorOrdKeyType        EncryptorType        ExternalPlaintext        ExternalCiphertext;  };</pre></code></pre>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#signsfor-relation","title":"SignsFor Relation","text":"<p>Some identities may have the authority to sign statements on behalf of other  identities. For example, Alice might grant Bob the authority to sign arbitrary messages on her behalf. We write this relationship as Bob <code>signsFor</code> Alice.</p> <p>In general, <code>signsFor</code> is a partial order over identities. This means <code>signsFor</code> is transitive: if A <code>signsFor</code> B and B <code>signsFor</code> C, then A <code>signsFor</code> C. The <code>signsFor</code> relation becomes especially useful with regard to composed identities, discussed below.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#signsfor-evidence","title":"SignsFor Evidence","text":"<p>We do not specify all the ways one might know if one identity <code>signsFor</code> another. In general, an Identity Engine might accept (and perhaps store) a variety of forms of evidence as proof. As one simple form of evidence, we can specify a format for signed statements from B that proves some specified A <code>signsFor</code> B.</p> <p>Note that <code>signsFor</code> evidence cannot be revoked, and so a <code>signsFor</code> relation is not stateful: it cannot depend on the current state of, for example, a blockchain.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#signsfor-juvix-type","title":"SignsFor Juvix Type","text":"<p>Formally, a <code>signsFor</code> relation requires a type of evidence, and a  <code>Verifier</code> structure. This codifies a belief about what <code>VerifierType</code>'s <code>Commitments</code> are  \"at least as good as\" another <code>VerifierType</code>'s. Evidence can be signed statements, proofs, or even local state about beliefs.</p> <p>For example, suppose <code>Alice</code> wants to grant authority to <code>Bob</code> to  <code>sign</code> on her behalf. Nodes who want to take this into account might accept some sort of  <code>e : Evidence</code>, perhaps a signed statement from <code>Alice</code>, so that they  can recognize that <code>signsFor e (Bob, Alice)</code>.</p> <p>Note that <code>signsFor</code> is not symmetric: <code>signsFor e (x,y)</code> does not  imply that any <code>z</code> exists such that <code>signsFor z (y,x)</code>.</p> <pre><code><pre>type SignsFor OrdKey VerifierType Signable Commitment Evidence :=  mkSignsFor@{    verifier : Verifier OrdKey VerifierType Signable Commitment;    signsFor : Evidence -&gt; Pair VerifierType VerifierType -&gt; Bool;  };</pre></code></pre>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#signsfor-equivalence","title":"SignsFor Equivalence","text":"<p>We can also define a kind of identity equivalence : A <code>signsSameAs</code> B  precisely when A <code>signsFor</code> B and B <code>signsFor</code> A. This means that (in  general), if you want to sign a message as A, but for whatever reason it's cheaper to sign a message as B, it's safe to just use B instead, and vice  versa.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#readsfor-relation","title":"ReadsFor Relation","text":"<p>Similar to <code>signsFor</code>, it is useful to sometimes note that one identity can read  information encrypted to another identity. For example, suppose Alice gives her private <code>DecryptorType</code> to Bob, and wants to let everyone know that Bob can  now read anything encrypted to Alice. Nodes who want to take this into  account might accept some sort of <code>evidence</code>, perhaps a signed statement from Alice, so that they can recognize that Bob <code>readsFor</code> Alice.</p> <p>Like <code>signsFor</code>, <code>readsFor</code> is a partial order over identities. This means <code>readsFor</code> is transitive: if A <code>readsFor</code> B and B <code>readsFor</code> C, then A <code>readsFor</code> C. The <code>readsFor</code> relation becomes especially useful with regard to composed identities, discussed below.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#readsfor-evidence","title":"ReadsFor Evidence","text":"<p>We do not specify all the ways one might know if one identity <code>readsFor</code>  another. In general, an Identity Engine might accept (and perhaps store) a variety of forms of evidence as proof. As one simple form of  evidence, we can specify a format for signed statements from B that proves A <code>readsFor</code> B.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#readsfor-juvix-type","title":"ReadsFor Juvix Type","text":"<p>Formally, a <code>readsFor</code> relation requires a type of evidence, and an  <code>Encryptor</code> structure. This codifies a belief about what <code>Decryptor</code>s can read other  <code>Encryptor</code>s ciphertext. Evidence can be signed statements, proofs, or even local state about beliefs.</p> <p>Specifically, if a node expresses a <code>readsFor</code> relation, and  <code>readsFor e (x,y)</code>, then the node believes that any node knowing the  decryptor corresponding to <code>x</code> can decrypt <code>encrypt y p</code>. If there is some Plaintext <code>p</code> such that some node knowing a decryptor  corresponding to <code>x</code> cannot read <code>encrypt y p</code>, then the node's  beliefs, as encoded in the <code>readsFor</code> relation, are incorrect.</p> <p>For example, suppose <code>Alice</code> gives her private <code>DecryptorType</code> to <code>Bob</code>,  and wants to let everyone know that <code>Bob</code> can now read anything  encrypted to <code>Alice</code>. Nodes who want to take this into account might accept some sort of  <code>e : Evidence</code>, perhaps a signed statement from <code>Alice</code>, so that they  can recognize that <code>readsFor e (Bob, Alice)</code>.</p> <p>Note that <code>readsFor</code> is not symmetric: <code>readsFor e (x,y)</code> does not  imply that any <code>z</code> exists such that <code>readsFor z (y,x)</code>.</p> <pre><code><pre>type ReadsFor (OrdKey EncryptorType Plaintext Ciphertext Evidence : Type) :=  mkReadsFor@{    encryptor : Encryptor OrdKey EncryptorType Plaintext Ciphertext;    readsFor : Evidence -&gt; Pair EncryptorType EncryptorType -&gt; Bool;  };</pre></code></pre>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#equivalence","title":"Equivalence","text":"<p>We can also define a kind of identity equivalence: A <code>readsSameAs</code> B precisely when A <code>readsFor</code> B and B <code>readsFor</code> A. This means that, in general, if you want to encrypt a message to A, but for whatever reason it's cheaper to encrypt a message for B, it's safe to just use B instead, and vice versa.</p> <p>In total, A <code>equivalent</code> B when A <code>readsSameAs</code> B and A <code>signsSameAs</code> B. This means that (in general) A and B can be used interchangeably.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#composition","title":"Composition","text":"<p>There are a variety of ways to refer to groups of identities as  single, larger identities.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#threshold-composition","title":"Threshold Composition","text":"<p>Suppose we want an identity M that refers to any majority from a  set of shareholders. A signature from M would require that a majority of shareholders  participated in signing, and encrypting information for M would  require that a majority of shareholders participate in decryption. To construct M, we start with a set of shareholder identities, each  paired with a weight (their share), and define a weight threshold  which specifies the minimum weight for a \"majority.\"</p> <p>There are several ways we could imagine constructing Threshold  Composition Identities, but without specifying anything about the  underlying identities:</p> <ul> <li>A threshold composition identity signature is a map from (hashes of)    external identities, to signatures.   To verify a signature for some message <code>x</code>, we verify each signature    with <code>x</code> and its external identity, and check that the weights of    the external identities sum to at least the threshold.</li> </ul> <ul> <li>A threshold composition identity encrypted message is a map from    (hashes of) external identities, to ciphertexts.   To decrypt, any subset of internal identities with weights summing    to at least the threshold must decrypt their corresponding    ciphertexts, and the resulting plaintexts must be combined using an    erasure coding scheme.</li> </ul>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#threshold-composition-juvix-type-signer-and-verifier","title":"Threshold Composition Juvix Type (Signer and verifier)","text":"<p>A <code>ThresholdCompose</code> <code>VerifierType</code> consists of a  threshold (<code>Nat</code>), and a set of <code>VerifierType</code>s, each paired with a  weight (<code>Nat</code>).  (this set is encoded as a <code>Map.map</code> from hashes of <code>verifiers</code> to   <code>Pair Nat VerifierType</code> pairs). <code>Commitments</code> are simply <code>Map</code>s from hashes of the underlying  identities to <code>Commitments</code> signed by that identitity. A <code>Commitment</code> verifies iff the set of valid Commitments included  correspond to a set of <code>verifiers</code> whose weights sum to at least  the threshold. Note that this satisfies both signatures <code>Verifier</code> and <code>Signer</code>.</p> <p>In general, <code>ThresholdCompose</code> <code>SignerType</code>s and <code>VerifierType</code>s may not be  used much directly. Instead, nodes can make more efficient identities (using cryptographic  signature aggregation techniques), and express their relationship to  <code>ThresholdCompose</code> <code>VerifierType</code>s as a <code>SignsFor</code> relationship. This will let nodes reason about identities using simple  <code>ThresholdCompose</code> <code>VerifierType</code>s, while actually using more efficient  implementations.</p> <p>Formally, to specify a <code>ThresholdCompose</code>, we need:</p> <ul> <li><code>verifier</code>, the structure of the underlying <code>Verifiers</code>.</li> </ul> <ul> <li><code>signer</code>, the corresponding structure of the underlying <code>Signers</code>.</li> </ul> <ul> <li><code>map : OrdMap</code>, to be used to encode weights and <code>Commitment</code>s.   (Note that this needs the <code>OrdKey</code> to be the hash type of the    underlying <code>verifier</code>)</li> </ul> <ul> <li><code>thresholdComposeHash</code>, which specifies a <code>hash</code> function that can    hash our composed <code>VerifierType</code>s (type <code>ComposeHashable VerifierType MapCon</code>).</li> </ul> <pre><code><pre>type ComposeHashable (VerifierType : Type) (MapCon : Type -&gt; Type) :=  mkComposeHashable@{    threshold : Nat;    weights : MapCon (Pair Nat VerifierType);  };</pre></code></pre> <p>A <code>ThresholdCompose</code> structure provides:</p> <ul> <li><code>map : OrdMap</code> the underlying <code>OrdMap</code> used in    <code>VerifierType</code> and <code>Commitment</code></li> </ul> <ul> <li><code>underlyingVerifier : Verifier</code> the structure describing    the types of the underlying <code>VerifierType</code>s which can be composed.</li> </ul> <ul> <li><code>underlyingSigner : Signer</code> the structure describing    the types of the underlying <code>SignerType</code>s which can be composed.</li> </ul> <ul> <li><code>VerifierHash : HASH</code> describes the hash function for    hashing these composed <code>verifiers</code></li> </ul> <ul> <li>The <code>SignerType</code> type of the composed verifiers is the type of composed signers.    These are just <code>MapCon Commitment</code>, meaning each is    stored under the hash of the corresponding    <code>VerifierType</code>.    This <code>SignerType</code> does not need to encode weights or threshold.</li> </ul> <ul> <li>The <code>VerifierType</code> type of composed verifiers. These are    <code>ComposeHashable VerifierType MapCon</code></li> </ul> <ul> <li>The <code>Signable</code> type , being the type of message that can be signed. This is    exactly the same as what the underlying verifiers can sign    (<code>Signable</code> of <code>underlyingVerifier</code>).</li> </ul> <ul> <li>The <code>Commitment</code> type describes composed signatures, these are a    <code>MapCon</code> from hashes of underlying verifiers to signatures    (<code>Commitment</code> of <code>underlyingVerifier</code>)</li> </ul> <ul> <li>The <code>sign</code> function creates a <code>Commitment</code> using all    <code>underlyingSigner</code> <code>SignerType</code>s in the composed <code>SignerType</code>.</li> </ul> <ul> <li>The <code>verify</code> function returns true iff the set of valid Commitments included    correspond to a set of <code>underlyingVerifier</code> <code>VerifierType</code>s whose weights    sum to at least the threshold.</li> </ul> <ul> <li>The <code>signerCompose</code> function constructs a composed <code>SignerType</code> from a list of    <code>Pair VerifierType SignerType</code> pairs.    Note that each <code>SignerType</code> must be paired with its correct <code>VerifierType</code>,     or the composed <code>SignerType</code> will not produce verifiable     <code>Commitment</code>s.</li> </ul> <ul> <li> <p>The <code>verifierCompose</code> function is useful for constructing the composition of    a list of verifiers.   Returns a composed <code>VerifierType</code>.   Its arguments are:</p> <ul> <li>the threshold (<code>Nat</code>)</li> </ul> <ul> <li>a <code>list</code> of weights(<code>Nat</code>), <code>VerifierType</code> pairs.</li> </ul> </li> </ul> <ul> <li>The <code>verifierAnd</code> function creates a composed <code>VerifierType</code> that is the \"&amp;&amp;\" of    two input verifiers: a <code>SignerType</code> must encode the information of the    signers for both <code>x</code> and <code>y</code> to sign statements <code>verifierAnd x y</code>    will verify.</li> </ul> <ul> <li>The <code>verifierOr</code> function creates a composed <code>VerifierType</code> that is the \"||\" of    two input verifiers: a <code>SignerType</code> must encode the information of the    signers for either <code>x</code> or <code>y</code> to sign statements <code>verifierOr x y</code>    will verify.</li> </ul> <pre><code><pre>type ThresholdCompose (OrdKey : Type) (MapCon : Type  -&gt; Type) (VerifierType Signable Commitment SignerType VerifierHashOrdKeyType : Type) :=  mkThresholdCompose@{    map : OrdMap OrdKey MapCon;    underlyingVerifier : Verifier OrdKey VerifierType Signable Commitment;    underlyingSigner : Signer SignerType Signable Commitment;    verifierHash      : HASH VerifierHashOrdKeyType (ComposeHashable VerifierType MapCon);    sign : MapCon SignerType -&gt; Signable -&gt; MapCon Commitment;    verify      : ComposeHashable VerifierType MapCon        -&gt; Signable        -&gt; MapCon Commitment        -&gt; Bool;    signerCompose : List (Pair VerifierType SignerType) -&gt; MapCon SignerType;    verifierCompose      : Nat        -&gt; List (Pair Nat VerifierType)        -&gt; ComposeHashable VerifierType MapCon;    verifierAnd      : VerifierType -&gt; VerifierType -&gt; ComposeHashable VerifierType MapCon;    verifierOr      : VerifierType -&gt; VerifierType -&gt; ComposeHashable VerifierType MapCon;  };</pre></code></pre> <pre><code><pre>projectVerifier  {MapCon : Type -&gt; Type}  {OrdKey VerifierType Signable Commitment SignerType VerifierHashOrdKeyType : Type}  (tc : ThresholdCompose    OrdKey    MapCon    VerifierType    Signable    Commitment    SignerType    VerifierHashOrdKeyType)  : Verifier    VerifierHashOrdKeyType    (ComposeHashable VerifierType MapCon)    Signable    (MapCon Commitment) :=  Verifier.mkVerifier@{    verify := ThresholdCompose.verify tc;    verifierHash := ThresholdCompose.verifierHash tc;  };</pre></code></pre> <pre><code><pre>ThresholdComposeFunctor  {MapCon : Type -&gt; Type}  {OrdKey VerifierType Signable Commitment SignerType VerifierHashOrdKeyType : Type}  (verifier : Verifier OrdKey VerifierType Signable Commitment)  (signer : Signer SignerType Signable Commitment)  (mapIn : OrdMap OrdKey MapCon)  (thresholdComposeHash : HASH    VerifierHashOrdKeyType    (ComposeHashable VerifierType MapCon))  : ThresholdCompose    OrdKey    MapCon    VerifierType    Signable    Commitment    SignerType    VerifierHashOrdKeyType :=  ThresholdCompose.mkThresholdCompose@{    map := mapIn;    underlyingVerifier := verifier;    underlyingSigner := signer;    verifierHash := thresholdComposeHash;    sign := \\{s m := OrdMap.map map \\{i := Signer.sign underlyingSigner i m} s};    verify :=      \\{| (ComposeHashable.mkComposeHashable t ws) s c :=        t          &lt;= OrdMap.foldl            map            \\{(mkPair x y) := x + y}            0            (OrdMap.intersectWith              map              \\{| (mkPair (mkPair w v) x) :=                if                   | Verifier.verify underlyingVerifier v s x := w                  | else := 0}              (mkPair ws c))};    signerCompose :=      \\{l :=        foldl          \\{m (mkPair v s) :=            OrdMap.insert              map              (mkPair                m                (mkPair                  (HASH.hash (Verifier.verifierHash underlyingVerifier) v)                  s))}          (OrdMap.empty map)          l};    verifierCompose :=      \\{threshold weights :=        ComposeHashable.mkComposeHashable          threshold          (foldl            \\{m (mkPair w v) :=              OrdMap.insert                map                (mkPair                  m                  (mkPair                    (HASH.hash (Verifier.verifierHash underlyingVerifier) v)                    (mkPair w v)))}            (OrdMap.empty map)            weights)};    verifierAnd := \\{x y := verifierCompose 2 [mkPair 1 x; mkPair 1 y]};    verifierOr := \\{x y := verifierCompose 1 [mkPair 1 x; mkPair 1 y]};  };</pre></code></pre> <p>While this construction is rather naive, it is general, and crucially, we can reason about  equivalence with any number of more interesting schemes:</p> <ul> <li>We can show that a threshold RSA signature scheme <code>signsSameAs</code> as a Threshold Composition    Identity.</li> </ul> <ul> <li>We can show that a secret sharing scheme <code>readsSameAs</code> a Threshold Composition Identity.</li> </ul> <p>By phrasing our discussion in terms of equivalence and Threshold Composition Identities, we can  abstract over the actual cryptography used. We can also derive some <code>signsFor</code> and <code>readsFor</code>  relations that must hold, by looking at the relations that must hold for Threshold Composition Identities:</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#signsfor-threshold-composition","title":"<code>signsFor</code> Threshold Composition","text":"<p>Like any identity, Threshold Composition Identities can define any number of ways to delegate signing power, or be delegated signing power. However, some cases should always hold: A <code>signsFor</code> B if every identity in A has no more weight (divided by threshold) than identities it <code>signsFor</code> in B. This implies that any collection of identities that can sign as A can also sign as B.</p> <p>A <code>signsFor</code> relation for easy comparison of   <code>ThresholdCompose</code> <code>VerifierType</code>s  x <code>signsFor</code> y if every underlying VerifierType in x has no more   weight (divided by threshold) as verifiers it <code>signsFor</code> in y. This implies that anything which can sign as x can also sign  as y.</p> <p>This requires an underlying <code>S : SignsFor</code> for comparing the weighted  signers in x and y, which in turn may require evidence. No additional evidence is required.</p> <p>Other parameters necessary to define the <code>ThresholdCompose</code> <code>verifiers</code> include:</p> <ul> <li><code>signer</code>, the corresponding structure of the underlying <code>signers</code>.</li> </ul> <ul> <li><code>map : OrdMap</code>, to be used to encode weights and <code>Commitment</code>s.   (Note that this needs <code>OrdKey</code> to be the hash type of the    underlying <code>verifier</code>)</li> </ul> <ul> <li><code>thresholdComposeHash</code>, which specifies a <code>hash</code> function that can    hash our composed <code>VerifierType</code>s (type    <code>ComposeHashable VerifierType MapCon</code>).</li> </ul> <pre><code><pre>type ThresholdComposeSignsFor (OrdKey VerifierType Signable Commitment Evidence : Type) (MapCon : Type  -&gt; Type) VerifierHashOrdKeyType :=  mkThresholdComposeSignsFor@{    underlyingSignsFor      : SignsFor OrdKey VerifierType Signable Commitment Evidence;    verifier      : ThresholdCompose        OrdKey        MapCon        VerifierType        Signable        Commitment        VerifierType        VerifierHashOrdKeyType;    signsFor      : Evidence        -&gt; Pair          (ComposeHashable VerifierType MapCon)          (ComposeHashable VerifierType MapCon)        -&gt; Bool;  };</pre></code></pre> <pre><code><pre>projectSignsFor  {OrdKey VerifierType Signable Commitment Evidence}  {MapCon : Type -&gt; Type}  {VerifierHashOrdKeyType : Type}  (tc : ThresholdComposeSignsFor    OrdKey    VerifierType    Signable    Commitment    Evidence    MapCon    VerifierHashOrdKeyType)  : SignsFor    VerifierHashOrdKeyType    (ComposeHashable VerifierType MapCon)    Signable    (MapCon Commitment)    Evidence :=  SignsFor.mkSignsFor@{    verifier := projectVerifier (ThresholdComposeSignsFor.verifier tc);    signsFor := ThresholdComposeSignsFor.signsFor tc;  };</pre></code></pre> <pre><code><pre>ThresholdComposeSignsForFunctor  {OrdKey VerifierType Signable Commitment Evidence}  {MapCon : Type -&gt; Type}  {VerifierHashOrdKeyType : Type}  (S : SignsFor OrdKey VerifierType Signable Commitment Evidence)  (signer : Signer VerifierType Signable Commitment)  (map : OrdMap OrdKey MapCon)  (thresholdComposeHash : HASH    VerifierHashOrdKeyType    (ComposeHashable VerifierType MapCon))  : ThresholdComposeSignsFor    OrdKey    VerifierType    Signable    Commitment    Evidence    MapCon    VerifierHashOrdKeyType :=  ThresholdComposeSignsFor.mkThresholdComposeSignsFor@{    underlyingSignsFor := S;    verifier :=      ThresholdComposeFunctor        (SignsFor.verifier underlyingSignsFor)        signer        map        thresholdComposeHash;    signsFor :=      \\{e (mkPair (ComposeHashable.mkComposeHashable t0 w0) (ComposeHashable.mkComposeHashable t1 w1)) :=        OrdMap.all          map          \\{(mkPair w v) :=            w * t1              &lt;= OrdMap.foldl                  map                  \\{(mkPair (mkPair x v1) s) :=                    if                       | SignsFor.signsFor underlyingSignsFor e (mkPair v v1) :=                        x + s                      | else := s}                  0                  w1                * t0}          w0};  };</pre></code></pre>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#encryptor-threshold-composition","title":"<code>Encryptor</code> Threshold Composition","text":"<p>DANGER: NOT YET IMPLEMENTED</p> <p>Implementing this requires secret sharing.  The threshold composed <code>encryptor</code> is a threshold, and a set of weights  paired with <code>UnderlyingEncryptor.encryptor</code>s. There are stored in a <code>Map.map</code>  under their hashes, to ensure uniqueness.</p> <p>The idea is that an encrypted <code>plaintext</code> should only be  decryptable by a <code>decryptor</code> that encodes the information from a  set of <code>decryptor</code>s corresponding to a set of <code>encryptor</code>s whose  weight sums to at least the threshold.</p> <pre><code><pre>type ThresholdComposeEncryptor (OrdKey EncryptorType Plaintext Ciphertext : Type) (MapCon : Type  -&gt; Type) (EncryptorHashOrdKeyType : Type) :=  mkThresholdComposeEncryptor@{    map : OrdMap OrdKey MapCon;    underlyingEncryptor : Encryptor OrdKey EncryptorType Plaintext Ciphertext;    encryptorHash      : HASH EncryptorHashOrdKeyType (ComposeHashable EncryptorType MapCon);    compose      : Nat        -&gt; List (Pair Nat EncryptorType)        -&gt; ComposeHashable EncryptorType MapCon;    encrypt : ComposeHashable EncryptorType MapCon -&gt; Plaintext -&gt; Ciphertext;  };</pre></code></pre> <pre><code><pre>projectEncryptor  {OrdKey EncryptorType Plaintext Ciphertext}  {MapCon : Type -&gt; Type}  {EncryptorHashOrdKeyType}  (tc : ThresholdComposeEncryptor    OrdKey    EncryptorType    Plaintext    Ciphertext    MapCon    EncryptorHashOrdKeyType)  : Encryptor    EncryptorHashOrdKeyType    (ComposeHashable EncryptorType MapCon)    Plaintext    Ciphertext :=  Encryptor.mkEncryptor@{    encrypt := ThresholdComposeEncryptor.encrypt tc;    encryptorHash := ThresholdComposeEncryptor.encryptorHash tc;  };</pre></code></pre> <pre><code><pre>axiom encrypt_DUMMY  {EncryptorType Plaintext Ciphertext}  {MapCon}  : ComposeHashable EncryptorType MapCon -&gt; Plaintext -&gt; Ciphertext;</pre></code></pre> <pre><code><pre>ThresholdComposeEncryptorFunctor  {OrdKey EncryptorType Plaintext Ciphertext}  {MapCon : Type -&gt; Type}  {EncryptorHashOrdKeyType}  (encryptor : Encryptor OrdKey EncryptorType Plaintext Ciphertext)  (mapIn : OrdMap OrdKey MapCon)  (thresholdComposeHash : HASH    EncryptorHashOrdKeyType    (ComposeHashable EncryptorType MapCon))  : ThresholdComposeEncryptor    OrdKey    EncryptorType    Plaintext    Ciphertext    MapCon    EncryptorHashOrdKeyType :=  ThresholdComposeEncryptor.mkThresholdComposeEncryptor@{    map := mapIn;    underlyingEncryptor := encryptor;    encryptorHash := thresholdComposeHash;    compose :=      \\{t w :=        ComposeHashable.mkComposeHashable@{          threshold := t;          weights :=            foldl              \\{m (mkPair w e) :=                OrdMap.insert                  map                  (mkPair                    m                    (mkPair                      (HASH.hash                        (Encryptor.encryptorHash underlyingEncryptor)                        e)                      (mkPair w e)))}              (OrdMap.empty map)              w;        }};    encrypt := encrypt_DUMMY;  };</pre></code></pre>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#readsfor-threshold-composition","title":"<code>readsFor</code> Threshold Composition","text":"<p>Like any identity, ThresholdCompositionIdentities can have arbitrary  <code>readsFor</code> relationships. However, some cases should always hold : A <code>readsFor</code> B if every  identity in A has no more weight (divided by threshold) than  identities it <code>readsFor</code> in B. This implies that any collection of identities that can read messages  encrypted with A can also read messages encrypted as B.</p> <p>A <code>readsFor</code> relation for easy comparison of   <code>ThresholdComposeEncryptor</code> <code>EncryptorType</code>s  x <code>readsFor</code> y if every underlying <code>EncryptorType</code> in x has no more   weight (divided by threshold) as encryptors it <code>readsFor</code> in y. This implies that anything which can decrypt as x can also decrypt  as y.</p> <p>This requires an underlying <code>R : ReadsFor</code> for comparing the weighted  encryptors in  x and y, which in turn may require evidence. No additional evidence is required.</p> <pre><code><pre>type ThresholdComposeReadsFor (OrdKey EncryptorType Plaintext Ciphertext Evidence : Type) (MapCon : Type  -&gt; Type) (EncryptorHashOrdKeyType : Type) :=  mkThresholdComposeReadsFor@{    underlyingReadsFor      : ReadsFor OrdKey EncryptorType Plaintext Ciphertext Evidence;    encryptor      : ThresholdComposeEncryptor        OrdKey        EncryptorType        Plaintext        Ciphertext        MapCon        EncryptorHashOrdKeyType;    readsFor      : Evidence        -&gt; Pair          (ComposeHashable EncryptorType MapCon)          (ComposeHashable EncryptorType MapCon)        -&gt; Bool;  };</pre></code></pre> <pre><code><pre>projectReadsFor  {OrdKey VerifierType Signable Commitment Evidence}  {MapCon : Type -&gt; Type}  {EncryptorHashOrdKeyType : Type}  (tc : ThresholdComposeReadsFor    OrdKey    VerifierType    Signable    Commitment    Evidence    MapCon    EncryptorHashOrdKeyType)  : ReadsFor    EncryptorHashOrdKeyType    (ComposeHashable VerifierType MapCon)    Signable    Commitment    Evidence :=  ReadsFor.mkReadsFor@{    encryptor := projectEncryptor (ThresholdComposeReadsFor.encryptor tc);    readsFor := ThresholdComposeReadsFor.readsFor tc;  };</pre></code></pre> <pre><code><pre>ThresholdComposeReadsForFunctor  {OrdKey EncryptorType Plaintext Ciphertext Evidence}  {MapCon : Type -&gt; Type}  {EncryptorHashOrdKeyType}  (r : ReadsFor OrdKey EncryptorType Plaintext Ciphertext Evidence)  (map : OrdMap OrdKey MapCon)  (thresholdComposeHash : HASH    EncryptorHashOrdKeyType    (ComposeHashable EncryptorType MapCon))  : ThresholdComposeReadsFor    OrdKey    EncryptorType    Plaintext    Ciphertext    Evidence    MapCon    EncryptorHashOrdKeyType :=  ThresholdComposeReadsFor.mkThresholdComposeReadsFor@{    underlyingReadsFor := r;    encryptor :=      ThresholdComposeEncryptorFunctor        (ReadsFor.encryptor underlyingReadsFor)        map        thresholdComposeHash;    readsFor :=      \\{e (mkPair (ComposeHashable.mkComposeHashable t0 w0) (ComposeHashable.mkComposeHashable t1 w1)) :=        OrdMap.all          map          \\{(mkPair w v) :=            w * t1              &lt;= OrdMap.foldl                  map                  \\{(mkPair (mkPair x v1) s) :=                    if                       | ReadsFor.readsFor underlyingReadsFor e (mkPair v v1) :=                        x + s                      | else := s}                  0                  w1                * t0}          w0};  };</pre></code></pre>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#and-identities","title":"\"And\" Identities","text":"<p>We can compose identities with conjunction: A <code>&amp;&amp;</code> B is the identity which requires an agent to have both A's internal identity and B's internal identity to sign or decrypt. It represents A and B working together. In practice, A <code>&amp;&amp;</code> B can be defined as a special case of Threshold composition (see <code>verifierAnd</code> above).</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#or-identities","title":"\"Or\" Identities","text":"<p>We can compose identities with disjunction as well: A <code>||</code> B requires an agent to have either A's internal identity or B's internal identity. It represents either A or B, without specifying which. In practice, A <code>||</code> B can be defined as a special case of Threshold Composition (see <code>verifierOr</code> above).</p> <p>In principle, we could define things differently: Threshold Composition could be defined using <code>&amp;&amp;</code> and <code>||</code> as primitives, by building a disjunction of every possible conjunction that satisfies the threshold. In several important cases, however, this takes much more space to express, so we use the equally general and more numerically efficient threshold composition abstraction.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#opaque-composition","title":"Opaque Composition","text":"<p>A group of agents can also compose an opaque identity such that composition information is not available to the outside. One example would be using distributed key generation and a threshold cryptosystem e.g. Threshold RSA. Here the agents compute one RSA keypair together, with only shares of the private key being generated by each agent. Decryption of messages encrypted to the single public key then requires cooperation of a subset of agents holding key shares, fulfilling the threshold requirements. This group would have a single External Identity based on a regular RSA public key, and it would not necessarily be clear how the identity was composed.</p> <p>Specific evidence could prove that this threshold cryptosystem identity is <code>equivalent</code> to some  <code>ThresholdCompose</code> identity. This kind of proof requires <code>readsFor</code> and <code>signsFor</code> relations tailored to the cryptosystem used. Once equivalence is proven, however, one could use the threshold  cryptosystem identity for efficiency, but reason using the  <code>ThresholdCompose</code> identity.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#special-identities","title":"Special identities","text":"<p>The following special identities illustrate the generality of our identity abstractions:</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#true-all","title":"\"true / All\"","text":"<p>Anyone can sign and decrypt (<code>verify</code> returns true and <code>encrypt</code> returns the <code>Plaintext</code>). No secret knowledge is required, so all agents can take on this identity.</p> <p>The true identity preserves structure under conjunction (x <code>&amp;&amp;</code> true <code>equivalent</code> x) and forgets structure under disjunction (x <code>||</code> true <code>equivalent</code> true).</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#false-none","title":"\"false / None\"","text":"<p>No one can sign or decrypt (<code>verify</code> returns false and <code>encrypt</code>  returns empty string). No secret knowledge exists that fulfills these  requirements, so no agent can take on this identity.</p> <p>The false identity forgets structure under disjunction  (x <code>&amp;&amp;</code> false <code>equivalent</code> false) and preserves structure under  disjunction (x <code>||</code> false <code>equivalent</code> x).</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#identity-names","title":"Identity Names","text":"<p>Sometimes it is useful to have a name for an external identity before the relevant cryptographic values are available. For example, we might refer to \"a quorum of validators from chain <code>X</code> at epoch <code>Y</code>\". Before epoch <code>Y</code> has begun, chain <code>X</code> may not have yet decided who constitutes a quorum.</p> <p>It would be possible to build a <code>Verifier</code>, where the evidence that the signers are in fact a quorum of validators from chain <code>X</code> at epoch <code>Y</code> is part of the signature. One might later build a simpler <code>Verifier</code>, which elides this evidence, and then prove that the two <code>signsSameAs</code> using the evidence. However, barring some really exciting cryptography, we'd need to know the quorums from chain <code>X</code> at epoch <code>Y</code> before we could make an <code>Encryptor</code>.</p> <p>We therefore introduce a new type, Identity Name, which represents a placeholder to be filled in when an appropriate external identity can be found. Specifically, each type of identity name comes with a predicate, which can be satisfied by an external identity, and accompanying evidence. Identity names can also be hashed, like external identities.</p> <p>Identity names can be described in two structures: one for checking that  a <code>VerifierType</code> corresponds with an <code>IdentityName</code>, and one for checking  that an <code>EncryptorType</code> corresponds with an <code>IdentityName</code>. The same name can refer to both a <code>VerifierType</code> and an <code>EncryptorType</code>.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#verifier-name-juvix-type","title":"Verifier Name Juvix Type","text":"<p>An <code>IdentityName</code> can be mapped to an appropriate <code>VerifierType</code>  when suitable <code>Evidence</code> is found. Here, <code>checkVerifierName</code> defines what evidence is acceptable for a  <code>VerifierType</code>.</p> <p>Note that <code>IdentityName</code>s are also hashable: we require a structure  <code>verifierNameHash</code> that details how to hash them.</p> <pre><code><pre>type VerifierName OrdKey VerifierType Signable Commitment Evidence IdentityName VerifierNameHashOrdKeyType :=  mkVerifierName@{    verifier : Verifier OrdKey VerifierType Signable Commitment;    checkVerifierName : IdentityName -&gt; VerifierType -&gt; Evidence -&gt; Bool;    verifierNameHash : HASH VerifierNameHashOrdKeyType IdentityName;  };</pre></code></pre>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#encryptor-name-juvix-type","title":"Encryptor Name Juvix Type","text":"<p>An <code>IdentityName</code> can be mapped to an appropriate Encryptor <code>EncryptorType</code>  when suitable <code>Evidence</code> is found. Here, <code>checkEncryptorName</code> defines what evidence is acceptable for an  <code>Encryptor</code> <code>EncryptorType</code>. Note that <code>IdentityName</code>s are also hashable: we require a structure  <code>encryptorNameHash</code> that details how to hash them.</p> <pre><code><pre>type EncryptorName OrdKey EncryptorType Plaintext Ciphertext Evidence IdentityName EncryptorNameHashOrdKeyType :=  mkEncryptorName@{    verifier : Encryptor OrdKey EncryptorType Plaintext Ciphertext;    checkEncryptorName : IdentityName -&gt; EncryptorType -&gt; Evidence -&gt; Bool;    encryptorNameHash : HASH EncryptorNameHashOrdKeyType IdentityName;  };</pre></code></pre> <p>For example, for the identity name \"a quorum of validators from chain <code>X</code> at epoch <code>Y</code>\", a satisfying external identity would be composed from the validators selected for epoch <code>Y</code>, and the accompanying evidence would be a light-client proof from chain <code>X</code> that these are the correct validators for epoch <code>Y</code>.</p> <p>Note that multiple identity names can refer to the same external identity, and in principle, multiple external identities could have the same identity name. Usually, multiple external identities only have the same identity name when there is Byzantine behaviour, but that is not explicitly part of the identity abstractions at this layer.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#sub-identities","title":"Sub-Identities","text":"<p>One particularly common case for identity names is when one party (the super-identity) wants to designate a specific name they use to refer to another identity. Here, the super-identity is acting like a certificate authority: they designate which external identity corresponds with this identity name. This sub-identity is often something the super-identity controls: a specific machine they own, or a process they run on that machine. Such a sub-identity might be associated with a string, such as <code>\"acceptor\"</code>, which might designate the process participating in consensus within a validator. In this case, the predicate should check that the super-identity has signed a statement declaring that the external identity matches the sub-identity.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#notation","title":"\".\" Notation","text":"<p>Because sub-identities using string names are so common, we have a short-cut notation for expressing identity names. Given some identity Alice, for any string <code>\"foo\"</code>, Alice.foo is an identity name. For example, even before they learn anything about Alice, validators might refer to Alice.acceptor to mean the specific process Alice is running to participate in consensus. The identity Alice can sign statements to let people know what external identity they should (immutably) use for Alice.foo or Alice.acceptor. These are left associative, so Alice.foo can designate Alice.foo.bar (shorthand for (Alice.foo).bar) and Alice.foo.bar can designate Alice.foo.bar.baz (shorthand for ((Alice.foo).bar).baz), and so on. These are a special case of sub-identities: X.Y is a sub-identity of X.</p> <p>Formally, we use <code>mkPair (hash Alice) \"foo\"</code> as the Juvix representation of Alice.foo:</p> <p>A specific kind of identity name, wher ethe evidence is a signed  statement from a specified parent saying that it associates this  VerifierType with a specific <code>name</code>.</p> <p>Here,</p> <ul> <li><code>Name</code> is the type the parent identifies with a child.   For example, for <code>name = string</code>, and some identity Alice, we can specify   <code>(hash(Alice),\"bob\")</code>, or Alice.bob, as the identity that   Alice refers to as <code>\"bob\"</code>.</li> </ul> <ul> <li><code>child</code> : <code>Verifier</code> type that can be identified with a name.</li> </ul> <ul> <li> <p><code>parent</code> : <code>Verifier</code> type that signs evidence statements.</p> <p>Crucially, it must be able to sign tuples of the form (string, name, child's hash type) In our example, where Alice refers to Bob as Alice.<code>\"bob\"</code>, <code>child</code> describes Bob, <code>parent</code> describes Alice, and <code>name</code> describes <code>\"bob\"</code>.</p> </li> </ul> <ul> <li><code>hash</code> Describes what will become the <code>verifierNameHash</code>.   Crucially, it must be able to hash pairs of the form   (parent's hash type, name)</li> </ul> <pre><code><pre>SubVerifierFunctor  (OrdKey VerifierType Signable Commitment Name ParentOrdKeyType : Type)  (child : Verifier OrdKey VerifierType Signable Commitment)  (parent : Verifier    ParentOrdKeyType    VerifierType    (Pair String (Pair Name OrdKey))    Commitment)  (hash : HASH ParentOrdKeyType (Pair ParentOrdKeyType Name))  : VerifierName    OrdKey    VerifierType    Signable    Commitment    (Pair VerifierType Commitment)    (Pair ParentOrdKeyType Name)    ParentOrdKeyType :=  VerifierName.mkVerifierName@{    verifier := child;    checkVerifierName :=      \\{(mkPair ph n) c (mkPair pv pc) :=        Verifier.verify            parent            pv            (mkPair              \"I identify this verifier with this name : \"              (mkPair n (HASH.hash (Verifier.verifierHash child) c)))            pc          &amp;&amp; OrdKey.compare              (HASH.ordKey (Verifier.verifierHash parent))              ph              (HASH.hash (Verifier.verifierHash parent) pv)            == Equal};    verifierNameHash := hash;  };</pre></code></pre> <p>In other words, we have a specific, standardized thing an external identity can sign to designate that another external identity corresponds to a \".\" name.</p> <p>Note that we can use \".\" sub-identities for purposes other than identifying identities that the super-identity controls. Alice might have a friend Bob, and designate his external identity as Alice.bob. This is an example of a place where \"sub-identity-ness\" is not transitive: Alice.bob.carol is (Alice.bob).carol, a sub-identity of Alice.bob, so it is up to Bob to designate which external identity he associates with <code>\"carol\"</code>, and Alice has no say: Alice.bob.carol is not a sub-identity of Alice.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#identity-engine","title":"Identity Engine","text":"<p>In practice, using Identity Names requires each physical machine to maintain a mapping from identity names to known external identities. The machine does not have to store the accompanying evidence for each, although it might be useful to do so sometimes (for example, in order to present to a third party). When any process on that machine wants to do any operation using an identity name instead of an external identity, it can query this mapping to see if there is a known external identity to use for that operation.</p> <p>An Identity Engine can also store evidence for known <code>signsFor</code> and <code>readsFor</code> relationships, and help choose which external identity is most efficient for a task. For example, if an agent wants to encrypt a message to \"a quorum of validators from chain <code>X</code> at epoch <code>Y</code>\", they would first resolving the identity name to an identity (possibly a Threshold Composed Identity), and might then ask if there is some known equivalent identity (such as a threshold encryption identity) with cheaper encryption.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/identity/identity.html#identity-name-resolution","title":"Identity Name Resolution","text":"<p>There is no general mechanism for finding external identities (and accompanying evidence) for arbitrary identity names, with arbitrary forms of evidence. However, for some common types of identity names, such as \".\" sub-identities, we can establish a standard server and query language, which participating Identity Engines can query to resolve those identity names.</p>","tags":["system-architecture","identity"],"boost":2},{"location":"arch/system/state/resource_machine/index.html","title":"Index","text":"<pre><code><pre>module arch.system.state.resource_machine.index;</pre></code></pre>","tags":["resource-machine","protocol","commitment","nullifier","accumulator","resource logic"],"boost":2},{"location":"arch/system/state/resource_machine/index.html#introduction","title":"Introduction","text":"<p>The Anoma Resource Machine (ARM) is the part of the Anoma protocol that defines and enforces the rules for valid state updates that satisfy users' preferences. The new proposed state is then agreed on by the consensus participants. In that sense the role of the Anoma Resource Machine in the Anoma protocol is similar to the role of the Ethereum Virtual Machine in the Ethereum protocol.</p>","tags":["resource-machine","protocol","commitment","nullifier","accumulator","resource logic"],"boost":2},{"location":"arch/system/state/resource_machine/index.html#data-structures","title":"Data structures","text":"<p>The atomic unit of the ARM state is called a resource. Resources are immutable, they can be created once and consumed once. The system state is represented by the set of active resources: the resources that were created but not nullified.</p> <p>Transactions produced by the ARM represent the proposed state update. They consist of actions, which group resources with the same execution context.</p> <p>Ensuring the correctness of the transaction is achieved with the help of non-interactive proofs attached to it:</p> <ol> <li>to prove the transaction is balanced correctly, there are delta proofs. Balance is the criterion of a transaction's completeness.</li> <li>to prove the transaction complies with the ARM rules, there are compliance proofs. Actions are partitioned into compliance units that define the compliance proof scope.</li> <li>to prove the transaction satisfies the user constraints, there are resource logic proofs.</li> </ol> <p></p>","tags":["resource-machine","protocol","commitment","nullifier","accumulator","resource logic"],"boost":2},{"location":"arch/system/state/resource_machine/index.html#common-flavours-of-arms","title":"Common flavours of ARMs","text":"<p>A resource machine instantiation is called shielded if it achieves both data and function privacy. Any other resource machine is considered transparent from the privacy perspective.</p>","tags":["resource-machine","protocol","commitment","nullifier","accumulator","resource logic"],"boost":2},{"location":"arch/system/state/resource_machine/index.html#the-role-of-the-arm","title":"The role of the ARM","text":"<p>The ARM is used to create, compose, and verify transactions. It is stateless and run by every node that processes transactions. Anoma users submit their intents to the intent gossip network in the form of unbalanced ARM transactions with metadata, which are received and processed by solvers that output balanced ARM transactions. These transactions are then ordered and finally sent to the executor node, that verifies and executes the transactions in the determined order, updating the global state.</p>","tags":["resource-machine","protocol","commitment","nullifier","accumulator","resource logic"],"boost":2},{"location":"arch/system/state/resource_machine/index.html#the-specification","title":"The specification","text":"<p>This specification describes a common interface shared by all ARM instantiations. Depending on the primitive instantiation choices, the resulting ARM instantiation will have different properties. For example, using zk-SNARKs to create and verify the ARM proofs might result in a succinct or even shielded ARM instantiation. The ARM interface is designed to provide interoperability between different ARM instantiations.</p> <p>The design of the Anoma Resource Machine was significantly inspired by the Zcash protocol.</p> <ul> <li>Keywords: anoma, blockchain technology, protocol design, resource machine</li> </ul>","tags":["resource-machine","protocol","commitment","nullifier","accumulator","resource logic"],"boost":2},{"location":"arch/system/state/resource_machine/data_structures/action/index.html","title":"Action","text":"<pre><code><pre>module arch.system.state.resource_machine.data_structures.action.index;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/action/index.html#action","title":"Action","text":"<p>An action is a composite structure of type <code>Action</code> that contains the following components:</p> Component Type Description <code>logicVerifierInputs</code> <code>Map Tag (isConsumed: Bool, logicVKOuter: LogicVKOuterHash, applicationData: List (BitString, DeletionCriterion), proof: ResourceLogicProvingSystem.Proof)</code> Resource logic proofs for resources associated with the action and accompanying data. The key of each map entry is the tag of the resource for which a RL proof is to be verified. The deletion criterion field is described here. <code>complianceUnits</code> <code>List ComplianceUnit</code> The set of transaction's compliance units <p>Note</p> <p>For function privacy in the shielded context, instead of a logic proof we verify a proof of logic proof validity - a recursive proof. <code>LogicVKOuterHash</code> type corresponds to the RL VK commitment while verifying key in <code>logicVerifierInputs</code> refers to the key to be used for verification (i.e., a verifier circuit verifying key as opposed to a resource logic verifying key). RL VK commitment should be included somewhere else, e.g., in <code>applicationData</code>.</p> <p>Actions partition the state change induced by a transaction and limit the evaluation context of resource logics: proofs created in the context of an action have access only to the resources associated with the action. A resource is said to be associated with an action if its tag is a key of the <code>logicVerifierInputs</code> map. A resource is associated with at most two actions: resource creation is associated with exactly one action and resource consumption is associated with exactly one action. A resource is said to be consumed in the action for a valid action if its nullifier is a key of the <code>logicVerifierInputs</code> map. A resource is said to be created in the action for a valid action if its commitment is a key of the <code>logicVerifierInputs</code> map.</p> <p>Note</p> <p>Unlike transactions, actions don't need to be balanced, but if an action is valid and balanced, it is sufficient to create a balanced transaction.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/action/index.html#interface","title":"Interface","text":"<ol> <li><code>create(List (NullifierKey, Resource, deltaExtraInput, CMtreePath, CMTreeRoot, List (BitString, DeletionCriterion)), List (Resource, deltaExtraInput, List (BitString, DeletionCriterion)), appWitness: BitString) -&gt; Action</code></li> <li><code>verify(Action) -&gt; Bool</code></li> <li><code>delta(Action) -&gt; DeltaHash</code></li> <li><code>to_instance(Action, Tag) -&gt; Maybe ResourceLogicProvingSystem.Instance</code></li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/action/index.html#proofs","title":"Proofs","text":"<p>For each resource consumed or created in the action, it is required to provide a proof that the logic associated with that resource evaluates to <code>True</code> given the input parameters that describe the state transition induced by the action. The number of such proofs in an action equals to the amount of resources (both created and consumed) in that action, even if some resources have the same logics. Resource logic proofs are further described here.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/action/index.html#create","title":"<code>create</code>","text":"<ol> <li><code>complianceUnits</code>: Partition the resources into compliance units and compute a compliance proof for each unit</li> <li><code>logicVerifierInputs</code>: For each resource, compute a resource logic proof and associate each proof with the tag of the resource and other components that are required to verify it.</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/action/index.html#verify","title":"<code>verify</code>","text":"<p>Validity of an action can only be determined for actions that are associated with a transaction. Assuming that an action is associated with a transaction, an action is considered valid if all of the following conditions hold:</p> <ol> <li>All resource logic proofs associated with the action are valid</li> <li>All compliance proofs associated with the action are valid: <code>cu.verify() = True for cu in complianceUnits</code></li> <li><code>logicVerifierInputs</code> keys = the list of tags associated with <code>complianceUnits</code> (ignoring the order)</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/action/index.html#delta","title":"<code>delta</code>","text":"<p><code>action.delta()</code> computes the action delta. Action delta is computed from <code>r.delta()</code> of the resources that comprise the action and defined as <code>action.delta() = sum(cu.delta() for cu in action.complianceUnits)</code>.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/action/index.html#to_instance","title":"<code>to_instance</code>","text":"<p>This function assembles the instance required to verify a resource logic proof from the data in the action.</p> <p>The main task is to assemble the <code>consumed</code> and <code>created</code> lists of resources. The proposed mechanism works as follows: 1. Iterate over all compliance units and accumulate the lists of created and consumed resources. The resulting list of consumed resources contains all consumed resources in the action. The resulting list of created resources contains all created resources in the action. 2. Erase the <code>self</code> resource from the relevant list. If the resource is consumed and its nullifier is stored under index <code>n</code> in the list of consumed resources, the resulting list is <code>l[0], l[1], ..., l[n - 1], l[n + 1], ...</code>. Keep the list of created resources the same. 3. If <code>self</code> is created, erase the resource from the list of created resources as in step 2. Keep the list of consumed resources the same. For each resource we assemble an instance for, we erase only one resource - itself - from one list.</p> <p>Note</p> <p>When verifying multiple logic proofs from the same action, it might make sense to create the 'full' lists once and erase resources one at a time to create a particular instance. Note that the next instance must be created from the original <code>full</code> list, not the list with previously erased resources.</p> <p>All other fields of the instance (resource tag, <code>isConsumed</code>, <code>applicationData</code>) are taken from the relevant entry of the <code>logicVerifierInputs</code> map.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/action/resource_logic_proof.html","title":"Resource logic proof","text":"<pre><code><pre>module arch.system.state.resource_machine.data_structures.action.resource_logic_proof;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/action/resource_logic_proof.html#resource-logic-proof","title":"Resource logic proof","text":"<p>Resource logic proofs attest to validity of resource logics. A resource logic is a computable predicate associated with a resource (this resource is referred to as <code>self</code> in this context) that constrains the creation and consumption of a resource. Each time a resource is created or consumed, the corresponding resource logic proof is required in order for the action (and thus the transaction) to be valid.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/action/resource_logic_proof.html#proving","title":"Proving","text":"<p>When proving, resource logics take as input resources created and consumed in that action.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/action/resource_logic_proof.html#instance","title":"Instance","text":"<ol> <li>Resource's commitment/nullifier</li> <li><code>isConsumed</code> - a flag that tells the logic if the resource is consumed or created</li> <li><code>consumed</code> (excluding the tagged resource, if it is consumed)</li> <li><code>created</code> (excluding the tagged resource, if it is created)</li> <li><code>applicationData</code></li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/action/resource_logic_proof.html#witness","title":"Witness","text":"<ol> <li><code>self</code> resource object</li> <li>If <code>isConsumed = True</code>: nullifier key of <code>self</code></li> <li>Resource objects of consumed resources: <code>List (Resource, NullifierKey)</code></li> <li>Resource objects of created resources: <code>List Resource</code></li> <li>Application-specific inputs</li> </ol> <p>Note</p> <p>Instance and witness elements are expected to go in the same order: the first element of the instance corresponds to the first elements of the witness and so on.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/action/resource_logic_proof.html#constraints","title":"Constraints","text":"<ol> <li>For created resources: created commitment integrity: <code>r.commitment() = cm</code></li> <li>For consumed resources: <code>r.nullifier(nullifierKey) = nf</code></li> <li>Application-specific constraints</li> </ol> <p>Checks that require access to global <code>CMTree</code> and <code>NullifierSet</code>:</p> <ol> <li>each created resource wasn't created in prior transactions</li> <li>each consumed resource wasn't consumed in prior transactions</li> </ol> <p>Note</p> <p>Actions can be verified as parts of supposedly valid transactions and individually, when building a valid transaction (e.g., in the partial solving case). In case the actions are verified not individually, all global checks can be aggregated and verified at once to reduce the amount of global communication.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/compliance_unit/compliance_proof.html","title":"Compliance proof","text":"<pre><code><pre>module arch.system.state.resource_machine.data_structures.compliance_unit.compliance_proof;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/compliance_unit/compliance_proof.html#compliance-proof","title":"Compliance proof","text":"<p>Compliance proofs are created by <code>ComplianceProvingSystem</code> and computed over compliance units. Compliance proofs ensure that the provided state transition complies with the resource machine definitions.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/compliance_unit/compliance_proof.html#compliance-inputs","title":"Compliance inputs","text":"","boost":2},{"location":"arch/system/state/resource_machine/data_structures/compliance_unit/compliance_proof.html#instance","title":"Instance","text":"Name Type Description <code>consumed</code> <code>List (nf: Nullifier, root: CMTree.Value, logicVKOuter: LogicVKOuterHash)</code> Each entry corresponds to a consumed resource and includes a hash of the resource's <code>logicRef</code> component <code>created</code> <code>List (cm: Commitment, logicVKOuter: LogicVKOuterHash)</code> Each entry corresponds to a created resource <code>unitDelta</code> <code>DeltaHash</code>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/compliance_unit/compliance_proof.html#witness","title":"Witness","text":"<ol> <li> <p>for consumed resources:</p> <p>1. resource object <code>r</code></p> <p>2. <code>nullifierKey</code></p> <p>3. <code>CMtree</code> path to the consumed resource commitment</p> <p>4. pre-image of <code>logicVKOuter</code></p> <p>5. <code>deltaExtraInput</code> used to compute resource delta</p> </li> <li> <p>for created resources:</p> <ol> <li> <p>resource object <code>r</code></p> </li> <li> <p>pre-image of <code>logicVKOuter</code></p> </li> <li> <p><code>deltaExtraInput</code> used to compute resource delta</p> </li> </ol> </li> </ol> <p>Note</p> <p>Instance and witness elements are expected to go in the same order: the first element of the instance corresponds to the first (4 for consumed and 2 for created) elements of the witness and so on.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/compliance_unit/compliance_proof.html#compliance-constraints","title":"Compliance constraints","text":"<p>Each resource machine compliance proof must check the following:</p> <ol> <li> <p>Merkle path validity: <code>CMTree::Verify(r.commitment(), path, root) = True</code> for each resource associated with a nullifier from the <code>consumed</code>. For ephemeral resources a \"fake\" relation is checked.</p> </li> <li> <p>For each consumed resource <code>r</code>:</p> <ol> <li>Nullifier integrity: <code>r.nullifier(nullifierKey) is in consumed</code></li> <li>Logic integrity: <code>logicVKOuter = logicVKOuterHash(r.logicRef, ...)</code></li> </ol> </li> <li> <p>For each created resource <code>r</code>:</p> <ol> <li>Commitment integrity: <code>r.commitment() is in created</code></li> <li>Logic integrity: <code>logicVKOuter = logicVKOuterHash(r.logicRef, ...)</code></li> </ol> </li> <li> <p>Delta integrity: <code>unitDelta = sum(r.delta(deltaExtraInput(r)) for r in consumed) - sum(r.delta(deltaExtraInput(r)) for r in created)</code> where <code>deltaExtraInput(r)</code> returns <code>deltaExtraInput</code> associated with resource <code>r</code></p> </li> </ol> <p>Note</p> <p>Kind integrity is checked implicitly in delta integrity</p> <p>Note</p> <p>[2.3, 3.2]: Combined with checking the logic proofs, logic integrity checks allow to ensure that the logics associated with the resources are satisfied</p> <p>Note</p> <p>[2.1, 3.1]: To ensure correct binding between the instance and the witness, resource tags have to be recomputed from the witness and compared to what is provided in the instance.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/compliance_unit/compliance_unit.html","title":"Compliance unit","text":"<pre><code><pre>module arch.system.state.resource_machine.data_structures.compliance_unit.compliance_unit;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/compliance_unit/compliance_unit.html#compliance-unit","title":"Compliance unit","text":"<p><code>ComplianceUnit</code> is a data structure used to verify compliance proofs. It partitions the action, meaning that:</p> <ol> <li>there might be multiple compliance units for a single action</li> <li>the sets of resource tags validated by any two compliance units don't intersect</li> <li>together the compliance units cover all of the resources in the action</li> </ol> <p>The table below describes the components of a compliance unit:</p> Component Type Description <code>vk</code> <code>ComplianceProvingSystem.VerifyingKey</code> <code>instance</code> <code>ComplianceProvingSystem.Instance</code> The instance required to verify the compliance proof. Includes the tags of the checked resources, compliance unit delta, <code>CMtree</code> roots for consumed resources. <code>proof</code> <code>ComplianceProvingSystem.Proof</code> <p>The number of created and consumed resources in each unit is determined by the resource machine instantiation. The total number of compliance proofs required for an action is determined by the number of compliance units that comprise the action. For example, if the instantiation defines a single compliance proof to include 1 input and 1 output resource, and an action contains 3 input and 2 output resources, the total number of compliance units will be 3 (with a placeholder output resource in the third compliance unit).</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/compliance_unit/compliance_unit.html#interface","title":"Interface","text":"<ol> <li><code>create(ComplianceProvingSystem.ProvingKey, ComplianceProvingSystem.VerifyingKey, ComplianceProvingSystem.Instance, ComplianceProvingSystem.Witness) -&gt; ComplianceUnit</code> - computes the compliance unit proof and populates the compliance unit</li> <li><code>created(ComplianceUnit) -&gt; List Commimtent</code> - returns the commitments of the created resources checked in the unit</li> <li><code>consumed(ComplianceUnit) -&gt; List Nullifier</code> - returns the nullifiers of the consumed resources checked in the unit</li> <li><code>verify(ComplianceUnit) -&gt; Bool</code> - returns <code>ComplianceProvingSystem.Verify(vk, instance, proof)</code></li> <li><code>delta(ComplianceUnit) -&gt; DeltaHash</code> - returns the compliance unit delta, which is stored in <code>complianceData</code>: <code>unit.delta() = unit.complianceData.delta</code></li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/compliance_unit/compliance_unit.html#create","title":"<code>create</code>","text":"<p>Create is a function that provers use to create a compliance unit.</p> <ol> <li>Compute the compliance proof: <code>ComplianceProvingSystem.Prove(ComplianceProvingSystem.ProvingKey, ComplianceProvingSystem.Instance, ComplianceProvingSystem.Witness) -&gt; ComplianceProvingSystem.Proof</code>. What comprises the instance and witness here is described in Compliance proof.</li> <li>Create the compliance unit given the proof, verifying key, and instance.</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/compliance_unit/compliance_unit.html#delta","title":"Delta","text":"<p>Compliance unit delta is used to compute action and transaction deltas and is itself computed from resource deltas: <code>delta = sum(r.delta(deltaExtraInput(r))) for r in outputResources - sum(r.delta(deltaExtraInput(r)) for r in inputResources))</code>. Note that the delta is computed by the prover (who knows the resource objects of resources associated with the unit) and is a part of the instance. The compliance proof must ensure the correct computation of delta from the resource deltas available at the proving time.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/compliance_unit/compliance_unit.html#delta-for-computing-balance","title":"Delta for computing balance","text":"<p>From the homomorphic properties of Delta hash, for the resources of the same kind \\(kind\\), adding together the deltas of the resources results in the delta corresponding to the total quantity of that resource kind: \\(\\sum_j{h_\\Delta(kind, q_{r_{i_j}})} - \\sum_j{h_\\Delta(kind, q_{r_{o_j}})} = \\sum_j{\\Delta_{r_{i_j}}} - \\sum_j{\\Delta_{r_{o_j}}} =  h_\\Delta(kind, q_{kind})\\), where \\(q_{kind}\\) is the total quantity of the resources of kind \\(kind\\).</p> <p>The kind-distinctness property of \\(h_\\Delta\\) allows computing \\(\\Delta = \\sum_j{\\Delta_{r_{i_j}}} - \\sum_j{\\Delta_{r_{o_j}}}\\) adding resources of all kinds together without the need to account for distinct resource kinds explicitly: \\(\\sum_j{\\Delta_{r_{i_j}}} - \\sum_j{\\Delta_{r_{o_j}}} = \\sum_j{h_\\Delta(kind_j, q_{kind_j})}\\).</p> <p>Note</p> <p>The delta extra inputs omitted in the formulae above are added/subtracted accordingly.</p> <p>As a result, the properties of <code>DeltaHash</code> allow computing the total balance for a compliance unit, action, or transaction, without having direct access to quantities and kinds of the resources that comprise the data structure.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/compliance_unit/compliance_unit.html#verify","title":"<code>verify</code>","text":"<ol> <li><code>ComplianceProvingSystem.Verify(vk, instance, proof) = True</code></li> <li>Global check: <code>CMTree</code> roots used to verify the proof are valid <code>CMTree</code> roots</li> </ol> <p>Note</p> <p>Compliance units can be verified as parts of supposedly valid transactions and individually, when building a valid transaction (e.g., in the partial solving case). In case the compliance units are verified not individually, all global checks can be aggregated and verified at once to reduce the amount of global communication.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/resource/index.html","title":"Index","text":"<pre><code><pre>module arch.system.state.resource_machine.data_structures.resource.index;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/resource/index.html#resource","title":"Resource","text":"<p>A resource is a composite structure <code>Resource</code> that contains the following components:</p> Component Type Description <code>logicRef</code> <code>LogicVKCompact</code> Resource logic's verifying key <code>labelRef</code> <code>LabelHash</code> Hash of the resource label. Resource label specifies the fungibility domain for the resource. Resources within the same fungibility domain are seen as equivalent kinds of different quantities. Resources from different fungibility domains are seen and treated as non-equivalent kinds. This distinction comes into play in the balance check described later <code>valueRef</code> <code>ValueHash</code> Hash of the resource value. Resource value is the fungible data associated with the resource. It contains extra information but does not affect the resource's fungibility <code>quantity</code> <code>Quantity</code> is a number representing the quantity of the resource <code>isEphemeral</code> <code>Bool</code> is a flag that reflects the resource's ephemerality. Ephemeral resources do not get checked for existence when being consumed <code>nonce</code> <code>Nonce</code> guarantees the uniqueness of the resource computable components <code>nullifierKeyCommitment</code> <code>NullifierKeyCommitment</code> is a nullifier key commitment. Corresponds to the nullifier key \\(nk\\) used to derive the resource nullifier (nullifiers are further described here) <code>randSeed</code> <code>RandSeed</code> randomness seed used to derive whatever randomness needed <p>To distinguish between the resource data structure consisting of the resource components and a resource as a unit of state identified by just one (or some) of the resource computed fields, we sometimes refer to the former as a resource object. Data which is referenced by the resource object - such as the preimage of <code>valueRef</code> - we refer to as resource-linked data.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/resource/computable_components/delta.html","title":"Delta","text":"<pre><code><pre>module arch.system.state.resource_machine.data_structures.resource.computable_components.delta;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/resource/computable_components/delta.html#resource-delta","title":"Resource Delta","text":"<p>Resource delta is used to reason about the total quantities of different kinds of resources in transactions. For a resource <code>r</code>, its delta is computed as <code>r.delta(deltaExtraInput) = deltaHash(r.kind(), r.quantity, deltaExtraInput)</code>. <code>deltaExtraInput</code> contains the extra data required to derive resource delta, e.g., randomness. It may be empty if no extra data is required.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/resource/computable_components/delta.html#delta-for-data-structures","title":"Delta for data structures","text":"<p>Delta is a computable component that can be computed for compliance units, actions, and transactions from resource deltas of the resources comprising the data structures.</p> <p>Note that transactions are partitioned into actions, actions are partitioned into compliance units, and compliance units are partitioned into resources. For that reason, the mechanism for computation of the deltas of these data structures is almost the same.</p> <ol> <li>For compliance units, delta is computed by using signed addition over the deltas of the resources that comprise the unit: <code>unit.delta() = sum(r.delta(deltaExtraInput(r))) for r in outputResources - sum(r.delta(deltaExtraInput(r)) for r in inputResources))</code></li> <li>For actions, delta is computed by adding the deltas of the compliance units that comprise the action: <code>action.delta() = sum(unit.delta() for unit in action)</code>. To make sure the action's delta is computed correctly, validate the compliance unit delta and make sure the action's deltas are computed using compliance unit deltas values.</li> <li>For transactions, delta is computed by adding the deltas of the actions that comprise the transaction: <code>transaction.delta() = sum(action.delta() for unit in transaction)</code>. To make sure transaction's delta is computed correctly, make sure it is computed using the validated action deltas.</li> </ol> <p>Note</p> <p>For every data structure, the delta can also be computed directly from resource deltas that comprise it, the way it is done for compliance units.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/resource/computable_components/introduction.html","title":"Introduction","text":"<pre><code><pre>module arch.system.state.resource_machine.data_structures.resource.computable_components.introduction;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/resource/computable_components/introduction.html#computable-components","title":"Computable components","text":"<p>Resource computable components are the components that are not a resource component but can be derived from the resource components, other computable components, and possibly some extra data.</p> <p>Resources have four computable components:</p> <ol> <li>Resource Commitment</li> <li>Nullifier</li> <li>Kind</li> <li>Delta</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/resource/computable_components/introduction.html#tag","title":"Tag","text":"<p>The resource tag is used to identify a resource when checking constraints without referring to the resource's plaintext directly: <code>tag(Resource, Bool) -&gt; Commitment or Nullifier</code>.</p> <p>For created resources: <code>r.tag(consumed=False) = r.commitment()</code>; for consumed resources: <code>r.tag(consumed=True) = r.nullifier(nullifierKey)</code></p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/resource/computable_components/kind.html","title":"Kind","text":"<pre><code><pre>module arch.system.state.resource_machine.data_structures.resource.computable_components.kind;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/resource/computable_components/kind.html#kind","title":"Kind","text":"<p>For a resource <code>r</code>, its kind is computed as: <code>r.kind() = kindHash(r.labelRef, r.logicRef)</code>.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/resource/computable_components/nullifier.html","title":"Nullifier","text":"<pre><code><pre>module arch.system.state.resource_machine.data_structures.resource.computable_components.nullifier;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/resource/computable_components/nullifier.html#nullifier","title":"Nullifier","text":"<p>A resource nullifier is a computed field, the publishing of which marks the resource associated with the nullifier as consumed.</p> <p>For a resource <code>r</code>, <code>r.nullifier(nullifierKey) = nullifierHash(nullifierKey, r)</code>, where <code>nullifierKey</code> is a key provided externally.</p> <p>A resource can be consumed only once. Nullifiers of consumed resources are stored in a public append-only structure called the resource nullifier set. This structure is external to the resource machine, but the resource machine can read from it and append to it.</p> <p>Note</p> <p>Every time a resource is consumed, it has to be checked that the resource existed before (the resource's commitment is in the commitment tree) and has not been consumed yet (the resource's nullifier is not in the nullifier set).</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/resource/computable_components/resource_commitment.html","title":"Commitment","text":"<pre><code><pre>module arch.system.state.resource_machine.data_structures.resource.computable_components.resource_commitment;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/resource/computable_components/resource_commitment.html#resource-commitment","title":"Resource Commitment","text":"<p>Resource commitment is a unique identifier of a resource used to prove the resource's existence and address the resource. Using resource commitment allows to decouple resource semantics (contained in the resource object) and the fact of the resource's existence. For a resource <code>r</code>, <code>r.commitment() = commitmentHash(r)</code>.</p> <p>To establish the resource's existence, its commitment is added to a global structure called a commitment tree. This structure is external to the resource machine but the resource machine can read from it.</p> <p>Note</p> <p>The resource commitment is also used as the resource's address \\(r.addr\\) in the content-addressed storage.</p> <p>Note</p> <p>Consumption of the resource does not necessarily affect the resource's status in the storage (e.g., it doesn't get deleted).</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/delta_proof.html","title":"Delta proof","text":"<pre><code><pre>module arch.system.state.resource_machine.data_structures.transaction.delta_proof;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/delta_proof.html#delta-proof","title":"Delta proof","text":"","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/delta_proof.html#instance","title":"Instance","text":"Name Type Description <code>delta</code> <code>DeltaHash</code> Transaction delta (computed from compliance unit deltas by adding them together) <code>expectedBalance</code> <code>Balance</code> Balanced transactions have delta pre-image 0 for all involved kinds, for unbalanced transactions <code>expectedBalance</code> is a non-zero value","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/delta_proof.html#witness","title":"Witness","text":"<ol> <li>Resource delta pre-images</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/delta_proof.html#constraints","title":"Constraints","text":"<ol> <li><code>delta = sum(unit.delta() for unit in action.units for action in tx)</code> - can be checked outside of the circuit since all values are public</li> <li><code>delta</code>'s preimage's quantity component is <code>expectedBalance</code></li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/transaction.html","title":"Transaction","text":"<pre><code><pre>module arch.system.state.resource_machine.data_structures.transaction.transaction;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/transaction.html#transaction","title":"Transaction","text":"<p>A transaction is a necessary and sufficient collection of fields required to validate and apply a state update to the state. It is a composite structure that contains the following components:</p> Component Type Description <code>actions</code> <code>Set Action</code> A set of actions that comprise the transaction <code>deltaProof</code> <code>DeltaProvingSystem.Proof</code> Balance proof. It makes sure that <code>transactionDelta</code> is correctly derived from the actions' deltas and commits to the expected publicly known value, called a balancing value. There is just one delta proof per transaction <code>delta_vk</code> <code>DeltaProvingSystem.VerifyingKey</code> Used to verify the delta proof. Might be optional in case the key is computable from other components <code>expectedBalance</code> Balanced transactions have delta pre-image 0 for all involved kinds, for unbalanced transactions <code>expectedBalance</code> is a non-zero value.","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/transaction.html#interface","title":"Interface","text":"<ol> <li><code>create(Set Actions, DeltaProvingSystem.ProvingKey, DeltaProvingSystem.Instance, DeltaProvingSystem.Witness) -&gt; Transaction</code></li> <li><code>compose(Transaction, Transaction) -&gt; Transaction</code></li> <li><code>verify(Transaction) -&gt; Bool</code></li> <li><code>delta(Transaction) -&gt; DeltaHash</code></li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/transaction.html#create","title":"<code>create</code>","text":"<p>Given a set of actions alongside delta data, a transaction is formed as follows:</p> <ol> <li><code>tx.actions = actions</code></li> <li><code>tx.deltaProof = DeltaProvingSystem.Prove(DeltaProvingSystem.ProvingKey, DeltaProvingSystem.Instance, DeltaProvingSystem.Witness)</code></li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/transaction.html#compose","title":"<code>compose</code>","text":"<p>Having two transactions <code>tx1</code> and <code>tx2</code>, their composition <code>compose(tx1, tx2)</code> is defined as a transaction <code>tx</code>, where:</p> <ol> <li><code>tx.actions = Set.union(tx1.actions, tx2.actions)</code></li> <li><code>tx.deltaProof, tx.delta_vk = DeltaProvingSystem.aggregate(tx1.deltaProof, tx1.delta_vk, tx2.deltaProof, tx2.delta_vk)</code></li> </ol> <p>Note</p> <p>When composing transactions, action sets are simply united. For example, composing a transaction with two actions and another transaction with three actions will result in a transaction with five actions, given all actions are distinct.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/transaction.html#verify","title":"<code>verify</code>","text":"<p>A transaction is considered valid if the following statements hold:</p> <p>Checks that do not require access to global structures:</p> <ol> <li>all actions in the transaction are valid, as defined per action validity rules</li> <li>actions partition the state change induced by the transaction:<ol> <li>there is no resource created more than once across actions</li> <li>there is no resource consumed more than once across actions</li> </ol> </li> <li><code>deltaProof</code> is valid</li> </ol> <p>A transaction is executable if it is valid and <code>transactionDelta</code> commits to the expected balancing value.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/transaction.html#delta","title":"<code>delta</code>","text":"<p>Transaction delta is a hash of transaction balance - the total quantity change per resource kind induced by the transaction. It isn't computed from the transaction balance directly by applying a hash function to it, but rather by using the homomoprhic properties of <code>deltaHash</code>: adding action deltas together results in transaction delta.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/transaction_function.html","title":"Transaction Function","text":"<pre><code><pre>module arch.system.state.resource_machine.data_structures.transaction.transaction_function;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/transaction_function.html#transaction-function","title":"Transaction Function","text":"<p>A transaction function <code>TransactionFunction</code> is a function that outputs a transaction: <code>transactionFunction() -&gt; Transaction</code>.</p> <p>Transaction functions take no input but can perform I/O operations to read information about global state either by reading data at the specified global storage address or by fetching data by index. The requirements for transaction functions are further described in Transaction function format.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/transaction_with_payment.html","title":"Transaction With Payment","text":"<pre><code><pre>module arch.system.state.resource_machine.data_structures.transaction.transaction_with_payment;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/transaction_with_payment.html#transaction-with-payment","title":"Transaction With Payment","text":"<p><code>TransactionWithPayment</code> is a data structure that allows paying for the desired state transitions.</p>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/transaction_with_payment.html#definition","title":"Definition","text":"<p><code>TransactionWithPayment</code> contains the following fields:</p> Type <code>stateTransitionFunction</code> <code>TransactionFunction</code> The desired state update. <code>paymentTransaction</code> <code>Transaction</code> The payment transaction. It is unbalanced, contains consumed resources (gas payment sent) but not created (the receiver is not specified). Includes in a special application data field the hash of the transaction function and the gas limit. <code>gasLimit</code> <code>Arithmetic</code> The maximum amount of gas that can be used for execution of the <code>StateTransition</code>","boost":2},{"location":"arch/system/state/resource_machine/data_structures/transaction/transaction_with_payment.html#execution","title":"Execution","text":"<p>When executing a <code>TransactionFunctionWithPayment</code>, the executor takes the following steps:</p> <ol> <li>Checks that <code>paymentTransaction</code> is \u201csimple\u201d. What exactly this means can be executor-specific, but roughly \u201csimple\u201d means \u201cinexpensive to verify\u201d. A basic (very restrictive) check could be that the payment transaction has exactly one consumed resource and nothing else.</li> <li>Decide whether this gas payment is sufficient. This decision can be controller-specific (maybe there are certain assets and certain prices accepted for gas).</li> <li>Alter <code>paymentTransaction</code>, adding new resources assigned to the executor (or whoever is supposed to receive the gas payments) as necessary to make the payment transaction balanced.</li> <li>Verify <code>paymentTransaction</code>, including in a special application data field the hash of the transaction function and the gas limit.</li> <li>Execute <code>paymentTransaction</code> (apply the state changes).</li> <li>Evaluate <code>stateTransitionFunction</code>, limited by <code>gasLimit</code>.</li> <li>If <code>stateTransitionFunction</code> evaluation finishes within <code>gasLimit</code> (returning a transaction object), check that the transaction object is valid and balanced (gas is charged for these checks as well), and if so apply it to state (as previously in the RM).</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/execution_flow/flow.html","title":"Execution flow","text":"<pre><code><pre>module arch.system.state.resource_machine.execution_flow.flow;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/execution_flow/flow.html#intro","title":"Intro","text":"<p>This section describes the resource machine execution flow and how it is used by various actors.</p>","boost":2},{"location":"arch/system/state/resource_machine/execution_flow/flow.html#resource-machine","title":"Resource machine","text":"<p>A resource machine is a deterministic stateless machine that creates, composes, and verifies transaction functions.</p> <p>It has read-only access to the external global state, which includes the content-addressed storage system (which in particular stores resources), global commitment accumulator, and the global nullifier set, and can produce writes to the external local state that will later be applied to the system state.</p> <p>The resource machine must have the functionality to produce, compose, and evaluate transaction functions and transactions.</p> <p>Actors working with resource machine include users, solvers, and executor nodes.</p>","boost":2},{"location":"arch/system/state/resource_machine/execution_flow/flow.html#users","title":"Users","text":"<p>Users are the initiators of the state change. To initiate the state change, users send the information about the desired state change to solvers. Users own the resources to be consumed/created in the transaction, meaning they are the <code>nullifierKey</code> holders and they control the transaction authorisation mechanism (resource logics).</p> <p>Users are not always online and limited in computational power.</p> <p>Users can create initial actions and transactions that don't require matching, but are assumed to delegate all matching computations to solvers (note that users can take the solver role for themselves as well). To create such transactions, users are expected to be able to do all of the things required to create a transaction, which includes creating all existing data structures, creating all types of proofs, and being able to access the global state.</p>","boost":2},{"location":"arch/system/state/resource_machine/execution_flow/flow.html#solvers","title":"Solvers","text":"<p>Solvers are the parties that have the computational power. Solvers are the parties that see intents and try to match them and output a transaction. Users give solvers the data required to create the future transactions, which may include resource objects, <code>nullifierKey</code>, signed messages, etc. Given the data, solvers create, compose, and verify transactions. Once the transaction is complete and valid, the transaction function is sent for ordering.</p>","boost":2},{"location":"arch/system/state/resource_machine/execution_flow/flow.html#executor","title":"Executor","text":"<p>Executors are the final nodes that receive transaction functions after ordering and produce a state change. After receiving a transaction function, the executor runs it, outputting a transaction that describes a state update. The executor node validates the resulting transaction, by performing the checks described here. In case the transaction is valid, the executor applies the state changes: adds nullifiers to the nullifier set, commitments to the commitment tree, and possibly some other data to the storage.</p>","boost":2},{"location":"arch/system/state/resource_machine/execution_flow/flow.html#post-and-pre-ordering-execution","title":"Post- and pre-ordering execution","text":"<p>Pre-ordering execution implies partial evaluation of the transaction function. In practice pre-ordering execution happens before the transactions are ordered by the ordering component external to the ARM.</p> <p>Post-ordering execution implies full evaluation of the transaction function. As the name suggests, post-ordering execution happens after the ordering component external to the ARM completed the ordering of transaction functions.</p>","boost":2},{"location":"arch/system/state/resource_machine/notes/applications.html","title":"Applications","text":"<pre><code><pre>module arch.system.state.resource_machine.notes.applications;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/notes/applications.html#applications","title":"Applications","text":"<p>The ARM applications are characterised by a set of resource logics and associated read and write interfaces.</p> <p>\\(Application = (AppLogic, AppReadInterface, AppWriteInterface)\\), where</p> <ol> <li>\\(AppLogic \\subseteq \\mathbb{F}_l\\) is a set of resource logics.</li> <li>\\(AppWriteInterface = \\{tf: TransactionFunction\\}\\) is a set of functions that represents what kinds of state transitions the application offers.</li> <li>\\(AppReadInterface = \\{pf: ProjectionFunction\\}\\) is a set of functions that interprete the current state. Projection functions are defined as \\(ProjectionFunction: AppState \\rightarrow T\\), where \\(AppState = AppResources \\times AppData\\), with \\(AppResources\\) containing all resources bound to the application\u2019s logic and \\(AppData\\) referring to the non-linear data the application might assume.</li> </ol> <p>As any abstract state transition can be represented as a transaction consuming and creating resources of certain kinds (or a transaction function that evaluates to such a transaction), the transaction functions associated with the application represent the set of actions that the application can provide to its users. Each transaction function would require a subset of the application resource logics to approve the transaction in order to realise the desired action. The transaction function evaluated with the exact resources to be created and consumed forms a transaction.</p> <p>The resources that are bound with the application resource logics are said to belong to the application and, along with some non-linear data the application might assume, constitute the application state. When the application does not have any resources that were created but not consumed yet, the application only exists virtually but not tangibly.</p> <p>The abstraction of an application is virtual - applications are not deployed or tracked in any sort of global registry, and the ARM is unaware of the existence of applications.</p> <p>We define \\(AppKinds \\subseteq \\mathbb{F}_{kind}\\) as a union of all resource kinds that are involved in the transaction functions that comprise the application interface.</p>","boost":2},{"location":"arch/system/state/resource_machine/notes/applications.html#composition","title":"Composition","text":"<p>Applications are composable. The composition of two (or more) applications would be a composition of the corresponding logics and interfaces.</p> <p>\\(App_12 = App_1 \\circ App_2\\):</p> <ol> <li>\\(AppLogic_{12} = AppLogic_1 \\cup AppLogic_2\\)</li> <li>\\(AppWriteInterface_{12} = AppWriteInterface_1 \\cup AppWriteInterface_2\\)</li> <li>\\(AppReadInterface_{12} = AppReadInterface_1 \\cup AppReadInterface_2\\)</li> <li>\\(AppKinds_{12} = AppKinds_1 \\cup AppKinds_2\\)</li> </ol> <p>In this type of composition the order in which the applications are composed doesn't matter.</p>","boost":2},{"location":"arch/system/state/resource_machine/notes/applications.html#application-extension","title":"Application extension","text":"<p>Application extension is a way to generate a new application starting from an existing one by enhancing the application logic and the application interface with operations on more resource kinds. The new application is dependent on the initial one, meaning that the new application logic includes constraints involving the first application resource kinds, and the new interface requires the presence of resources of the first application kinds.</p>","boost":2},{"location":"arch/system/state/resource_machine/notes/applications.html#distributed-application-state-synchronisation","title":"Distributed application state synchronisation","text":"<p>In the controllers report, a controller is defined as a component that orders transactions. The resource machine is designed to work in both single-controller and multi-controller environments, such as Anoma. In the context of multi-controller environments, each resource contains information about its current controller, can only be consumed on its controller, and can be transferred from one controller to another, meaning that a new controller becomes responsible for the correct resource consumption. Transferring a resource can be done by consuming a resource on the old controller and creating a similar resource on the new controller.</p> <p>Applications do not have to exist within the bounds of a single controller, and can maintain a single virtual state while the application resources being distributed among multiple controllers, which forms a distributed application state. To make sure such a distributed state correctly represents the application state, state synchronisation between multiple controllers is required.</p>","boost":2},{"location":"arch/system/state/resource_machine/notes/applications.html#controller-state-synchronisation","title":"Controller state synchronisation","text":"<p>Each controller would have their own commitment tree associated with it. Treated as subtrees of a larger Merkle tree, the controller commitment trees comprise a global commitment tree, where the leaves are the roots of the controller trees.</p>","boost":2},{"location":"arch/system/state/resource_machine/notes/nockma.html","title":"Nockma implementation","text":"Juvix imports <p><pre><code><pre>module arch.system.state.resource_machine.notes.nockma;import prelude open;import Stdlib.Data.Nat open;import Stdlib.Data.List open;import Stdlib.Trait.Show open;</pre></code></pre></p>","boost":2},{"location":"arch/system/state/resource_machine/notes/nockma.html#nockma-implementation","title":"Nockma Implementation","text":"Operation Code Name Description 0 Slash (/) Address/path selection 1 Constant Returns operand unchanged 2 Apply/Ap/S Function application 3 Cell test (?) Tests if noun is cell 4 Increment (+) Add 1 to atom 5 Equality test (=) Compare nouns 6 If-then-else Conditional execution 7 Compose Function composition 8 Extend subject Extends the subject 9 Invoke Call function by arm name 10 Pound (#) Handle operation 11 Match Case split on Cells vs Atoms 12 Scry Read storage","boost":2},{"location":"arch/system/state/resource_machine/notes/nockma.html#core-data-types","title":"Core Data Types","text":"<p>The fundamental data structures for Nockma implementation, including the <code>Noun</code> type that represents all data in Nock, along with equality and display instances.</p> <pre><code><pre>type Noun :=  | Atom : Nat -&gt; Noun  | Cell : Noun -&gt; Noun -&gt; Noun;</pre></code></pre> <pre><code><pre>terminatingnounEq (n1 n2 : Noun) : Bool :=  case mkPair n1 n2 of    | mkPair (Noun.Atom x) (Noun.Atom y) := x == y    | mkPair (Noun.Cell a b) (Noun.Cell c d) := nounEq a c &amp;&amp; nounEq b d    | _ := false;instanceEqNoun : Eq Noun :=  Eq.mk@{    isEqual := nounEq;  };</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/notes/nockma.html#pretty-printer-for-noun","title":"Pretty-printer for Noun","text":"<pre><code><pre>terminatingshowNoun (n : Noun) : String :=  case n of    | Noun.Atom a := natToString a    | Noun.Cell l r := \"[\" ++str showNoun l ++str \" \" ++str showNoun r ++str \"]\";instanceShowNoun : Show Noun :=  Show.mk@{    show := showNoun;  };</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/notes/nockma.html#storage-system-and-operation-types","title":"Storage System and Operation Types","text":"<p>Storage abstraction for scrying operations and the enumeration of all Nock operations with their corresponding opcodes.</p> <pre><code><pre>axiom convertToNoun : {val : Type} -&gt; val -&gt; Noun;axiom convertFromNoun : {val : Type} -&gt; Noun -&gt; Option val;</pre></code></pre> <pre><code><pre>type ScryOp :=  | Direct  | Index;</pre></code></pre> <pre><code><pre>type Storage addr val :=  mkStorage@{    readDirect : addr -&gt; Option val;    readIndex : val -&gt; Option val;  };emptyStorage {addr val : Type} : Storage addr val :=  Storage.mkStorage@{    readDirect := \\{_ := none};    readIndex := \\{_ := none};  };axiom externalStorage : {addr val : Type} -&gt; Storage addr val;</pre></code></pre> <pre><code><pre>type NockOp :=  | Slash  | Constant  | Apply  | CellTest  | Increment  | EqualOp  | IfThenElse  | Compose  | Extend  | Invoke  | Pound  | Match  | Scry;</pre></code></pre> <pre><code><pre>opOr {A : Type} (n m : Option A) : Option A :=  case n of    | none := m    | some n := some n;</pre></code></pre> <pre><code><pre>parseOp (n : Nat) : Option NockOp :=  let    test :=      \\{m op :=        case n == m of          | true := some op          | false := none};  in foldr    opOr    none    (zipWith      test      [0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12]      [        NockOp.Slash;        NockOp.Constant;        NockOp.Apply;        NockOp.CellTest;        NockOp.Increment;        NockOp.EqualOp;        NockOp.IfThenElse;        NockOp.Compose;        NockOp.Extend;        NockOp.Invoke;        NockOp.Pound;        NockOp.Match;        NockOp.Scry;      ]);</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/notes/nockma.html#gas-state-monad","title":"Gas State Monad","text":"<p>A monadic framework for tracking gas consumption and handling errors during Nock evaluation. This ensures computations can be bounded and failures can be properly handled.</p> <pre><code><pre>type GasState A :=  mk@{    runGasState : Nat -&gt; Result String (Pair A Nat);  };</pre></code></pre> <pre><code><pre>instanceGasStateMonad : Monad GasState :=  Monad.mk@{    applicative :=      Applicative.mk@{        functor :=          Functor.mk@{            map :=              \\{f s :=                GasState.mk                  \\{gas :=                    case GasState.runGasState s gas of                      | ok (mkPair x remaining) := ok (mkPair (f x) remaining)                      | error e := error e}};          };        pure := \\{x := GasState.mk \\{gas := ok (mkPair x gas)}};        ap :=          \\{sf sa :=            GasState.mk              \\{gas :=                case GasState.runGasState sf gas of                  | ok (mkPair f remaining) :=                    case GasState.runGasState sa remaining of {                      | ok (mkPair x final) := ok (mkPair (f x) final)                      | error e := error e                    }                  | error e := error e}};      };    bind :=      \\{ma f :=        GasState.mk          \\{gas :=            case GasState.runGasState ma gas of              | ok (mkPair a remaining) := GasState.runGasState (f a) remaining              | error e := error e}};  };err {A : Type} (str : String) : GasState A := GasState.mk \\{_ := error str};</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/notes/nockma.html#gas-management-and-storage-operations","title":"Gas Management and Storage Operations","text":"<p>Functions for managing computational costs and implementing storage read operations (scrying) that allow Nock programs to interact with external data.</p> <pre><code><pre>getGasCost (cost : NockOp) : Nat :=  case cost of    | NockOp.Slash := 1    | NockOp.CellTest := 1    | NockOp.Increment := 1    | NockOp.EqualOp := 2    | NockOp.IfThenElse := 3    | NockOp.Compose := 2    | NockOp.Extend := 2    | NockOp.Invoke := 3    | NockOp.Pound := 1    | NockOp.Scry := 10    | _ := 0;</pre></code></pre> <pre><code><pre>consume (op : NockOp) : GasState Unit :=  GasState.mk    \\{gas :=      let        cost := getGasCost op;      in case cost &gt; gas of           | true := error \"Out of gas\"           | false := ok (mkPair unit (sub gas cost))};</pre></code></pre> <pre><code><pre>scry  {val : Type}  (stor : Storage Nat val)  (op : ScryOp)  (addr : Nat)  : Result String Noun :=  case op of    | ScryOp.Direct :=      case Storage.readDirect stor addr of {        | some val := ok (convertToNoun val)        | none := error \"Direct storage read failed\"      }    | ScryOp.Index :=      case Storage.readDirect stor addr of        | some indexFn :=          case Storage.readIndex stor indexFn of {            | some val := ok (convertToNoun val)            | none := error \"Index computation failed\"          }        | none := error \"Index function not found\";</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/notes/nockma.html#helper-operations","title":"Helper Operations","text":"<p>Implementation of the fundamental slash (<code>/</code>) and pound (<code>#</code>) operations that provide tree navigation and editing capabilities respectively.</p> <pre><code><pre>terminatingslash  {val : Type}  (stor : Storage Nat val)  (n : Noun)  (subject : Noun)  : GasState Noun :=  case n of    | Noun.Atom x :=      case x == 1 of {        | true := pure subject        | false :=          case x == 2 of {            | true :=              case subject of {                | Noun.Cell a _ := pure a                | _ :=                  err                    (\"Cannot take slash (/2) of atom: \" ++str showNoun subject)              }            | false :=              case x == 3 of {                | true :=                  case subject of {                    | Noun.Cell _ b := pure b                    | _ :=                      err                        (\"Cannot take slash (/3) of atom: \"                          ++str showNoun subject)                  }                | false :=                  case mod x 2 == 0 of {                    | true :=                      consume NockOp.Slash                        &gt;&gt;= \\{_ :=                          slash stor (Noun.Atom (div x 2)) subject                            &gt;&gt;= \\{res :=                              consume NockOp.Slash                                &gt;&gt;= \\{_ := slash stor (Noun.Atom 2) res}}}                    | false :=                      consume NockOp.Slash                        &gt;&gt;= \\{_ :=                          slash stor (Noun.Atom (div x 2)) subject                            &gt;&gt;= \\{res :=                              consume NockOp.Slash                                &gt;&gt;= \\{_ := slash stor (Noun.Atom 3) res}}}                  }              }          }      }    | _ := err (\"Slash axis must be atom, got: \" ++str showNoun n);</pre></code></pre> <pre><code><pre>terminatingpound  {val : Type}  (stor : Storage Nat val)  (n : Noun)  (b : Noun)  (c : Noun)  : GasState Noun :=  case n of    | Noun.Atom x :=      case x == 1 of {        | true := pure b        | false :=          case mod x 2 == 0 of {            | true :=              case c of {                | Noun.Cell _ _ :=                  consume NockOp.Slash                    &gt;&gt;= \\{_ :=                      slash stor (Noun.Atom (2 * div x 2 + 1)) c                        &gt;&gt;= \\{slashResult :=                          consume NockOp.Pound                            &gt;&gt;= \\{_ :=                              pound                                stor                                (Noun.Atom (div x 2))                                (Noun.Cell b slashResult)                                c}}}                | _ :=                  err (\"Invalid pound target (must be cell): \" ++str showNoun c)              }            | false :=              case c of {                | Noun.Cell _ _ :=                  consume NockOp.Slash                    &gt;&gt;= \\{_ :=                      slash stor (Noun.Atom (2 * div x 2)) c                        &gt;&gt;= \\{slashResult :=                          consume NockOp.Pound                            &gt;&gt;= \\{_ :=                              pound                                stor                                (Noun.Atom (div x 2))                                (Noun.Cell slashResult b)                                c}}}                | _ :=                  err (\"Invalid pound target (must be cell): \" ++str showNoun c)              }          }      }    | _ := err (\"Pound axis must be atom, got: \" ++str showNoun n);</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/notes/nockma.html#operation-evaluator","title":"Operation Evaluator","text":"<p>The main dispatcher that handles evaluation of each Nock operation according to the Nock specification. Each case implements one of the 13 fundamental Nock operations.</p> <pre><code><pre>terminatingevalOp  {val : Type}  (stor : Storage Nat val)  (op : NockOp)  (a : Noun)  (args : Noun)  : GasState Noun :=  case op of    | NockOp.Slash := slash stor args a    | NockOp.Constant := pure args    | NockOp.Apply :=      case args of {        | Noun.Cell b c :=          nock stor (Noun.Cell a b)            &gt;&gt;= \\{r1 :=              nock stor (Noun.Cell a c)                &gt;&gt;= \\{r2 := nock stor (Noun.Cell r1 r2)}}        | _ :=          err (\"Invalid apply (2) args (must be cell): \" ++str showNoun args)      }    | NockOp.CellTest :=      case args of {        | Noun.Cell b _ :=          nock stor (Noun.Cell a b)            &gt;&gt;= \\{res :=              case res of                | Noun.Cell _ _ := pure (Noun.Atom 0)                | _ := pure (Noun.Atom 1)}        | _ :=          err            (\"Invalid cell test (3) args (must be cell): \" ++str showNoun args)      }    | NockOp.Increment :=      nock stor (Noun.Cell a args)        &gt;&gt;= \\{res :=          case res of            | Noun.Atom n := pure (Noun.Atom (suc n))            | x :=              err (\"Increment (4) target must be atom, got: \" ++str showNoun x)}    | NockOp.EqualOp :=      case args of {        | Noun.Cell b c :=          nock stor (Noun.Cell a b)            &gt;&gt;= \\{r1 :=              nock stor (Noun.Cell a c)                &gt;&gt;= \\{r2 :=                  pure                    (Noun.Atom                      case nounEq r1 r2 of {                        | true := 0                        | false := 1                      })}}        | _ :=          err (\"Invalid equality (5) args (must be cell): \" ++str showNoun args)      }    | NockOp.IfThenElse :=      case args of {        | Noun.Cell b (Noun.Cell c d) :=          nock              stor              (Noun.Cell                a                (Noun.Cell (Noun.Atom 4) (Noun.Cell (Noun.Atom 4) b)))            &gt;&gt;= \\{r1 :=              nock                  stor                  (Noun.Cell                    (Noun.Cell (Noun.Atom 2) (Noun.Atom 3))                    (Noun.Cell (Noun.Atom 0) r1))                &gt;&gt;= \\{r2 :=                  nock                      stor                      (Noun.Cell (Noun.Cell c d) (Noun.Cell (Noun.Atom 0) r2))                    &gt;&gt;= \\{r3 := nock stor (Noun.Cell a r3)}}}        | _ :=          err            (\"Invalid if-then-else (6) args (must be [b [c d]]): \"              ++str showNoun args)      }    | NockOp.Compose :=      case args of {        | Noun.Cell b c :=          nock stor (Noun.Cell a b) &gt;&gt;= \\{r := nock stor (Noun.Cell r c)}        | _ :=          err (\"Invalid compose (7) args (must be cell): \" ++str showNoun args)      }    | NockOp.Extend :=      case args of {        | Noun.Cell b c :=          nock stor (Noun.Cell a b)            &gt;&gt;= \\{r := nock stor (Noun.Cell (Noun.Cell r a) c)}        | _ :=          err (\"Invalid extend (8) args (must be cell): \" ++str showNoun args)      }    | NockOp.Invoke :=      case args of {        | Noun.Cell b c :=          nock stor (Noun.Cell a c)            &gt;&gt;= \\{core :=              let                formula :=                  Noun.Cell                    (Noun.Atom 2)                    (Noun.Cell                      (Noun.Cell (Noun.Atom 0) (Noun.Atom 1))                      (Noun.Cell (Noun.Atom 0) b));              in nock stor (Noun.Cell core formula)}        | _ :=          err (\"Invalid invoke (9) args (must be cell): \" ++str showNoun args)      }    | NockOp.Pound :=      case args of {        | Noun.Cell (Noun.Cell b c) d :=          nock stor (Noun.Cell a c)            &gt;&gt;= \\{r1 :=              nock stor (Noun.Cell a d) &gt;&gt;= \\{r2 := pound stor b r1 r2}}        | _ :=          err            (\"Invalid pound (10) args (must be [[b c] d]): \"              ++str showNoun args)      }    | NockOp.Match :=      case args of {        | Noun.Cell (Noun.Cell b c) d :=          nock stor (Noun.Cell a c)            &gt;&gt;= \\{r1 :=              nock stor (Noun.Cell a d)                &gt;&gt;= \\{r2 :=                  nock                    stor                    (Noun.Cell                      (Noun.Cell r1 r2)                      (Noun.Cell (Noun.Atom 0) (Noun.Atom 3)))}}        | Noun.Cell b c := nock stor (Noun.Cell a c)        | _ :=          err (\"Invalid match (11) args (must be cell): \" ++str showNoun args)      }    | Scry :=      case args of        | Noun.Cell b (Noun.Cell c d) :=          nock stor b            &gt;&gt;= \\{opcode :=              case opcode of                | Noun.Atom opval :=                  nock stor c                    &gt;&gt;= \\{addr :=                      case addr of                        | Noun.Atom addrVal :=                          let                            scryType :=                              case opval == 0 of                                | true := ScryOp.Direct                                | false := ScryOp.Index;                          in GasState.mk                            \\{gas :=                              scry stor scryType addrVal                                &gt;&gt;= \\{scryResult :=                                  GasState.runGasState                                    (nock                                      stor                                      (Noun.Cell a (Noun.Cell scryResult d)))                                    gas}}                        | _ :=                          err                            (\"Scry address must be atom, got: \"                              ++str showNoun addr)}                | _ :=                  err (\"Scry type must be atom, got: \" ++str showNoun opcode)}        | _ :=          err            (\"Invalid scry (12) args (must be [b [c d]]): \" ++str showNoun args);</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/notes/nockma.html#core-nockma-evaluator","title":"Core Nockma Evaluator","text":"<p>The main entry point for Nock evaluation. This function handles the parsing of Nock expressions and dispatches to the appropriate operation evaluators.</p> <pre><code><pre>terminatingnock {val : Type} (stor : Storage Nat val) (input : Noun) : GasState Noun :=  case input of    | Noun.Atom n :=      err (\"Cannot evaluate atom as program: \" ++str showNoun (Noun.Atom n))    | Noun.Cell a b :=      case b of        | Noun.Cell first rest :=          case first of {            | Noun.Cell b c :=              nock stor (Noun.Cell a (Noun.Cell b c))                &gt;&gt;= \\{r1 :=                  nock stor (Noun.Cell a rest)                    &gt;&gt;= \\{r2 := pure (Noun.Cell r1 r2)}}            | Noun.Atom n :=              case parseOp n of {                | some opcode :=                  consume opcode &gt;&gt;= \\{_ := evalOp stor opcode a rest}                | none :=                  err                    (\"Invalid operation code: \"                      ++str natToString n                      ++str \" in formula: \"                      ++str showNoun b)              }          }        | Noun.Atom bn :=          err            (\"Formula cannot be an atom: \"              ++str showNoun (Noun.Atom bn)              ++str \" in input: \"              ++str showNoun input);</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/notes/nockma_runnable.html","title":"Nockma runnable","text":"Juvix imports <p><pre><code><pre>module arch.system.state.resource_machine.notes.nockma_runnable;import prelude open;import arch.system.state.resource_machine.notes.nockma open;import arch.system.state.resource_machine.notes.runnable open;</pre></code></pre></p>","boost":2},{"location":"arch/system/state/resource_machine/notes/nockma_runnable.html#nockma-runnable-implementation","title":"Nockma Runnable Implementation","text":"<p>This module implements the <code>Runnable</code> trait for Nockma, allowing it to be used as an executor in the Anoma system.</p>","boost":2},{"location":"arch/system/state/resource_machine/notes/nockma_runnable.html#types","title":"Types","text":"<pre><code><pre>type NockmaProgramState :=  mk@{    current_noun : Noun;    storage : Storage Nat Noun;    gas_limit : Nat;  };</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/notes/nockma_runnable.html#runnable-instance","title":"Runnable Instance","text":"<pre><code><pre>instancenockmaRunnable : Runnable Nat Nat Noun NockmaProgramState :=  Runnable.mkRunnable@{    executeStep :=      \\{executable state input :=        let          input_noun :=            Noun.Cell (Noun.Atom (fst input)) (Noun.Atom (snd input));          subject :=            Noun.Cell (NockmaProgramState.current_noun state) input_noun;          full_input := Noun.Cell subject executable;          result :=            GasState.runGasState              (nock (NockmaProgramState.storage state) full_input)              (NockmaProgramState.gas_limit state);        in case result of             | error err := error err             | ok (mkPair result_noun remaining_gas) :=               case result_noun of                 | Noun.Cell (Noun.Atom new_state) requests :=                   let                     parseRequest                       (req : Noun) : Option (Either Nat (Pair Nat Nat)) :=                       case req of                         | Noun.Atom key := some (left key)                         | Noun.Cell (Noun.Atom key) (Noun.Atom value) :=                           some (right (mkPair key value))                         | _ := none;                     terminating                     parseRequests                       (reqs : Noun) : List (Either Nat (Pair Nat Nat)) :=                       case reqs of                         | Noun.Atom zero := nil                         | Noun.Cell (Noun.Atom req) rest :=                           case parseRequest (Noun.Atom req) of {                             | none := parseRequests rest                             | some parsed := parsed :: parseRequests rest                           }                         | _ := nil;                     parsed_requests := parseRequests requests;                     new_state :=                       state@NockmaProgramState{                         current_noun := Noun.Atom new_state;                         gas_limit := remaining_gas;                       };                   in ok (mkPair new_state parsed_requests)                 | _ := error \"Invalid result format\"};    halted :=      \\{state :=        NockmaProgramState.gas_limit state == zero          || case NockmaProgramState.current_noun state of {               | Noun.Atom n := n == 1702390132               | _ := false             }};    startingState :=      NockmaProgramState.mk@{        current_noun := Noun.Atom zero;        storage := emptyStorage;        gas_limit := 1000;      };  };</pre></code></pre> <p>This implementation:</p> <ol> <li> <p>Defines a <code>NockmaProgramState</code> type that tracks:</p> <ul> <li>The current Noun being evaluated</li> <li>The storage interface for reading/writing Nouns</li> <li>The remaining gas limit</li> </ul> </li> <li> <p>Implements <code>executeStep</code> to:</p> <ul> <li>Convert input key-value pair to a Noun (using direct Noun.Atom construction since KVSDatum is Nat)</li> <li>Construct the Nock subject: [state [key val]]</li> <li>Construct the full input for Nock evaluation: [subject formula]</li> <li>Run one step of Nockma evaluation</li> <li>Parse the result which should be of the form (Noun.Atom new_state output_requests)</li> <li>Parse the output_requests which is a linked list of requests</li> <li>Each request is either:<ul> <li>(Noun.Atom key) for read requests</li> <li>(Noun.Atom key value) for write requests</li> </ul> </li> <li>Update program state with new state and remaining gas</li> <li>Return new state and parsed requests</li> </ul> </li> <li> <p>Implements <code>halted</code> to check if program has run out of gas or is in designated halting state</p> </li> <li> <p>Provides <code>startingState</code> with initial values</p> </li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/notes/roles_and_requirements.html","title":"Roles and requirements","text":"<pre><code><pre>module arch.system.state.resource_machine.notes.roles_and_requirements;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/notes/roles_and_requirements.html#roles-and-requirements","title":"Roles and requirements","text":"<p>The table below contains a list of resource-related roles. In the Anoma protocol, the role of the resource creator will often be taken by a solver, which creates additional security requirements compared to the case when protocol users solve their own intents. Because of that, extra measures are required to ensure reliable distribution of the information about the created resource to the resource receiver.</p> Role Description Authorizer approves the resource consumption on the application level. The resource logic encodes the mechanism that connects the authorizer's external identity (public key) to the decision-making process Annuler knows the data required to nullify a resource Creator creates the resource and shares the data with the receiver Owner can both authorize and annul a resource Sender owns the resources that were consumed to create the created resource Receiver owns the created resource","boost":2},{"location":"arch/system/state/resource_machine/notes/roles_and_requirements.html#reliable-resource-object-distribution","title":"Reliable resource object distribution","text":"<p>In the case of in-band distribution of created resources in contexts with higher security requirements, the resource creator is responsible for encrypting the resource object. Verifiable encryption must be used to ensure the correctness of the encrypted data: the encrypted object must be proven to correspond to the resource object, which is passed as a private input.</p>","boost":2},{"location":"arch/system/state/resource_machine/notes/roles_and_requirements.html#reliable-nullifier-key-distribution","title":"Reliable nullifier key distribution","text":"<p>Knowing the resource\u2019s nullifier reveals information about when the resource is consumed, as the nullifier will be published when it happens, which might be undesirable in the contexts with higher security requirements. For that reason, it is advised to keep the number of parties who can compute the resource\u2019s nullifier as low as possible in such contexts.</p> <p>In particular, the resource creator should not be able to compute the resource nullifier, and as the nullifier key allows to compute the resource's nullifier, it shouldn't be known to the resource creator. At the same time, the resource object must contain some information about the nullifier key. One way to fulfil both requirements is, instead of sharing the nullifier key itself with the resource creator, to share some parameter derived from the nullifier key, but that does not allow computing the nullifier key or any meaningful information about it. This parameter is called a nullifier key commitment and is computed as \\(cnk = h_{cnk}(nk)\\).</p> <p>These concerns are not meaningful in the contexts with lower security requirements.</p>","boost":2},{"location":"arch/system/state/resource_machine/notes/runnable.html","title":"Runnable trait","text":"Juvix imports <p><pre><code><pre>module arch.system.state.resource_machine.notes.runnable;import prelude open;</pre></code></pre></p> <pre><code><pre>traittype Runnable KVSKey KVSDatum Executable ProgramState :=  mkRunnable@{    executeStep      : Executable        -&gt; ProgramState        -&gt; Pair KVSKey KVSDatum        -&gt; Result          String          (Pair ProgramState (List (Either KVSKey (Pair KVSKey KVSDatum))));    halted : ProgramState -&gt; Bool;    startingState : ProgramState;  };</pre></code></pre> <code>executeStep</code>: Takes the executable code, current program state, and read key-value pair and returns either:   - Error string on failure   - New program state and list of either:     - Left key for read requests     - Right (key, value) for write requests","tags":["node-architecture","ordering-subsystem","engine","executor","environment"]},{"location":"arch/system/state/resource_machine/notes/storage.html","title":"Stored data format","text":"<pre><code><pre>module arch.system.state.resource_machine.notes.storage;</pre></code></pre> <p>Warning</p> <p>Will be updated soon</p>","boost":2},{"location":"arch/system/state/resource_machine/notes/storage.html#stored-data-format","title":"Stored data format","text":"<p>The ARM state that needs to be stored includes resource objects, the commitment accumulator and the nullifier set. The table below defines the format of that data assumed by the ARM.</p> Name Structure Key Type Value Type Commitment accumulator (node) Cryptographic accumulator timestamp \\(\\mathbb{F}\\) Commitment accumulator (leaf) - (<code>timestamp</code>, \\(\\mathbb{F}\\)) \\(\\mathbb{F}\\) Nullifier set Set \\(\\mathbb{F}\\) \\(\\mathbb{F}\\) Hierarchical index Chained Hash sets Tree path \\(\\mathbb{F}\\) Data blob storage Key-value store with deletion criterion \\(\\mathbb{F}\\) (<code>variable length byte array</code>, <code>deletion criterion</code>)","boost":2},{"location":"arch/system/state/resource_machine/notes/storage.html#cmtree","title":"\\(CMtree\\)","text":"<p>Each commitment tree node has a timestamp associated with it, such that a lower depth (closer to the root) tree node corresponds to a less specified timestamp: a parent node timestamp is a prefix of the child node timestamp, and only the leaves of the tree have fully specified timestamps (i.e. they are only prefixes of themselves). For a commitment tree of depth \\(d\\), a timestamp for a commitment \\(cm\\) would look like \\(t_{cm} =t_1:t_2:..:t_d\\), with the parent node corresponding to it having a timestamp \\(t_1:t_2:..:*\\). The timestamps are used as keys for the key-value store. For the tree leaves, \\(&lt;cm, t_{cm}&gt;\\) pairs are used as keys. Merkle paths to resource commitments can be computed from the hierarchy of the timestamps.</p>","boost":2},{"location":"arch/system/state/resource_machine/notes/storage.html#nfset","title":"\\(NFset\\)","text":"<p>Nullifiers are used as keys in the key-value store. In future versions, a more complex structure that supports efficient non-membership proofs might be used for storing the nullifier set.</p>","boost":2},{"location":"arch/system/state/resource_machine/notes/storage.html#hierarchical-index","title":"Hierarchical index","text":"<p>The hierarchical index is organised as a tree where the leaves refer to the resources, and the intermediate nodes refer to resource subkinds that form a hierarchy. The label of a resource \\(r\\) stored in the hierarchical index tree is interpreted as an array of sublabels: \\(r.label = [label_1, label_2, label_3, ...]\\), and the i-th subkind is computed as \\(r.subkind_i = H_{kind}(r.l, r.label_i)\\).</p> <p>In the current version, only the subkinds derived from the same resource logic can be organized in the same hierarchical index path.</p> <p>The interface of the tree enables efficient querying of all children of a specific path and verifying that the returned children are the requested nodes. Permissions to add data to the hierarchical index are enforced by the resource logics and do not require additional checks.</p>","boost":2},{"location":"arch/system/state/resource_machine/notes/storage.html#data-blob-storage","title":"Data blob storage","text":"<p>Data blob storage stores data without preserving any specific structure. The data is represented as a variable length byte array and comes with a deletion criterion that determines for how long the data will be stored. The deletion criterion, in principle, is an arbitrary predicate, which in practice currently is assumed to be instantiated by one of the following options:</p> <ol> <li>delete immediately</li> <li>delete after \\(block\\)</li> <li>delete after \\(timestamp\\)</li> <li>delete after \\(sig\\) over \\(data\\)</li> <li>delete after either predicate \\(p_1\\) or \\(p_2\\) is true; the predicates are instantiated by options from this list</li> <li>store forever</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/notes/function_formats/transaction_function_format.html","title":"Transaction function format","text":"<pre><code><pre>module arch.system.state.resource_machine.notes.function_formats.transaction_function_format;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/notes/function_formats/transaction_function_format.html#transaction-function-format","title":"Transaction function format","text":"<p>The system used to represent and interpret transaction functions must have a deterministic computation model; each operation should have a fixed cost of space and time (for total cost computation). To support content addressing, it must have memory and support memory operations (specifically <code>read</code>, <code>write</code>, <code>allocate</code>).</p> <p>The system must support the following I/O operations:</p> <ol> <li><code>readStorage</code>(<code>address</code>: <code>Commitment</code>): read the global content-addressed storage at the specified address and return the value stored at the address. If the value is not found, the operation should return an error. Storage not accessible to the machine should be treated as non-existent.</li> <li><code>dataByIndex</code>(<code>indexFunction)</code>: read data from the storage (either resources or arbitrary data kept in the storage requested by the transaction function) at the execution time by the specified index function. If the index function output is invalid or uncomputable, or the data cannot be located, the operation should return an error. Typically, the index functions allowed will be very restricted, e.g. an index function returning current unspent resources of a particular kind.</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/notes/function_formats/transaction_function_format.html#gas-model","title":"Gas model","text":"<p>To compute and bound the total cost of computation, the transaction function system must support a gas model. Each evaluation would have a gas limit \\(g_{limit}\\), and the evaluation would start with \\(g_{count} = 0\\). Evaluating an operation, the system would add the cost of the operation to the counter \\(g_{count}\\) and compare it to \\(g_{limit}\\). When making recursive calls, \\(g_{count}\\) is incremented before the recursion occurs. If the value of \\(g_{count}\\) is greater than \\(g_{limit}\\), the execution is terminated with an error message indicating that the gas limit has been surpassed.</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/commitment_accumulator.html","title":"Commitment accumulator","text":"<pre><code><pre>module arch.system.state.resource_machine.primitive_interfaces.commitment_accumulator;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/commitment_accumulator.html#commitment-accumulator","title":"Commitment accumulator","text":"<p>All resource commitments are stored in an append-only data structure called a commitment accumulator. Every time a resource is created, its commitment is added to the commitment accumulator. The resource commitment accumulator is external to the resource machine, but the resource machine can read from it. A commitment accumulator is a cryptographic accumulator that allows to prove membership for elements accumulated in it, provided a witness and the accumulated value.</p> <p>Each time a commitment is added to the accumulator, the accumulator and all witnesses of the already accumulated commitments are updated. For a commitment that existed in the accumulator before a new one was added, both the old witness and the new witness (with the corresponding accumulated value parameter) can be used to prove membership. However, the older the witness (and, consequently, the accumulator) that is used in the proof, the more information about the resource it reveals (an older accumulator gives more concrete boundaries on the resource's creation time). For that reason, it is recommended to use fresher parameters when proving membership.</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/commitment_accumulator.html#accumulator-functionality","title":"Accumulator functionality","text":"<p>Note</p> <p>The witness we are talking about here is not related to proving system witness. It is a distinct concept of cryptographic accumulators.</p> <p>The commitment accumulator has type <code>Accumulator</code> and is parametrised over the types <code>AccumulatorWitness</code>,<code>CommitmentIdentifier</code>, and <code>AccumulatedValue</code>. The commitment accumulator interface must support the following functionality:</p> <ol> <li><code>add(Accumulator, CommitmentIdentifier) -&gt; AccumulatorWitness</code> adds an element to the accumulator, returning the accumulator witness used to prove membership.</li> <li><code>witness(Accumulator, CommitmentIdentifier) -&gt; Maybe AccumulatorWitness</code> for a given element, returns the accumulator witness used to prove membership if the element is present, otherwise returns nothing.</li> <li><code>verify(CommitmentIdentifier, AccumulatorWitness, AccumulatedValue) -&gt; Bool</code> verifies the membership proof for a commitment identified with <code>CommitmentIdentifier</code> element with a membership witness <code>AccumulatorWitness</code> for the accumulated value <code>AccumulatedValue</code>.</li> <li><code>value(Accumulator) -&gt; AccumulatedValue</code> returns the accumulator value.</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/commitment_accumulator.html#merkle-tree","title":"Merkle tree","text":"<p>Currently, the commitment accumulator is assumed to be a Merkle tree <code>CMTree</code> of depth \\(depth_{CMtree}\\), where the leaves contain the resource commitments and the intermediate nodes' values are of type <code>MerkleTreeNodeHash</code>.</p> <p>Note</p> <p>The type <code>MerkleTreeNodeHash</code> of the <code>CMTree</code> nodes and the type of the leafs <code>Commitment</code> are distinct types.</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/commitment_accumulator.html#interface","title":"Interface","text":"<p>For a Merkle tree:</p> <ol> <li><code>CommitmentIdentifier</code> type corresponds to the identifier of the resource commitment used to locate the commitment's position in the tree</li> <li><code>AccumulatorWitness</code> element is a path to the stored commitment</li> <li><code>AccumulatedValue</code> corresponds to the Merkle tree root</li> </ol> <p>and the functions:</p> <ol> <li><code>add</code> adds the resource commitment to the tree, returning the path to the commitment</li> <li><code>witness</code> finds the resource commitment in the tree and returns the path to it</li> <li><code>verify</code> uses the resource commitment and the path to reconstruct the root. Returns <code>True</code> if the constructed value is equal to the provided value</li> <li><code>value</code> returns the tree root</li> </ol> <p>Todo</p> <p>shielded notes: To support the systems with stronger privacy requirements, the witness for such a proof must be a private input when proving membership.</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/index.html","title":"Index","text":"<pre><code><pre>module arch.system.state.resource_machine.primitive_interfaces.index;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/index.html#primitive-interfaces","title":"Primitive interfaces","text":"<p>This section defines the hierarchy of primitives used in resource machine design and describes interfaces for each primitive.</p> <p>The diagram below illustrates the primitive types required for resource machine. Red nodes correspond to primitive interfaces, green nodes correspond to instantiations of the interfaces. Each primitive instantiation has an associated type, e.g. delta hash instantiation of <code>Hash</code> interface has an associated type <code>DeltaHash</code>. Primitive instantiations' names are derived from the type name but written in lower camel case, e.g., for <code>DeltaHash</code> the corresponding function would be <code>deltaHash(..)</code>.</p> <pre><code>flowchart LR\n    ProvingSystem\n    Map --&gt; MapInstance\n    CommitmentAccumulator --&gt; CommitmentAccumulatorInstance\n    NullifierSet --&gt; NullifierSetInstance\n\n    List --&gt; ListInstance\n    Set --&gt; SetInstance\n\n    style SetInstance fill:transparent\n    style ListInstance fill:transparent\n    style MapInstance fill:transparent\n    style CommitmentAccumulatorInstance fill:transparent\n    style NullifierSetInstance fill:transparent\n\n\n    ProvingSystem --&gt; ComplianceProvingSystem\n    ProvingSystem --&gt; ResourceLogicProvingSystem\n    ProvingSystem --&gt; IDeltaProvingSystem\n    IDeltaProvingSystem --&gt; DeltaProvingSystem\n    style ComplianceProvingSystem fill:transparent\n    style ResourceLogicProvingSystem fill:transparent\n    style DeltaProvingSystem fill:transparent</code></pre> Primitive interfaces <pre><code>flowchart LR\n\n    FixedSize --&gt; Arithmetic\n    FixedSize --&gt; Hash\n\n\n    FixedSize --&gt; Nonce\n    FixedSize --&gt; RandSeed\n    FixedSize --&gt; NullifierKeyCommitment\n    FixedSize --&gt; NullifierKey\n\n    style Nonce fill:transparent\n    style RandSeed fill:transparent\n    style NullifierKey fill:transparent\n    style NullifierKeyCommitment fill:transparent\n\n\n    Arithmetic --&gt; Quantity\n    Arithmetic --&gt; Balance\n\n    Arithmetic --&gt; DeltaHash\n\n    style Quantity fill:transparent\n    style Balance fill:transparent\n    style DeltaHash fill:transparent\n\n\n    Hash --&gt; PS\\.VerifyingKey\n    Hash --&gt; LabelHash\n    Hash --&gt; ValueHash\n    Hash --&gt; DeltaHash\n\n    Hash --&gt; Commitment\n    Hash --&gt; Nullifier\n    Hash --&gt; Kind\n    Hash --&gt; LogicVKOuterHash\n    Hash --&gt; MerkleTreeNodeHash\n\n    style LogicVKCompact fill:transparent\n    style LabelHash fill:transparent\n    style ValueHash fill:transparent\n    style DeltaHash fill:transparent\n    style Commitment fill:transparent\n    style Nullifier fill:transparent\n    style Kind fill:transparent\n    style LogicVKOuterHash fill:transparent\n    style MerkleTreeNodeHash fill:transparent\n\n\n    Hash --&gt; AppDataValueHash\n    style AppDataValueHash fill:transparent</code></pre> Primitive types","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/list.html","title":"List","text":"Juvix Markdown error <pre><code>\n    ***/arch/system/state/resource_machine/primitive_interfaces/list.juvix.md:9:8-75: error: The top module\narch.system.state.resource_machine.primitive_interfaces.ordered_set is defined in the file:\n***/arch/system/state/resource_machine/primitive_interfaces/list.juvix.md But it should be in the file:\n***/arch/system/state/resource_machine/primitive_interfaces/ordered_set.juvix.md\n\n</code></pre> <pre><code>module arch.system.state.resource_machine.primitive_interfaces.ordered_set;\n</code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/list.html#list","title":"List","text":"<ol> <li><code>new() -&gt; List</code> - creates an empty list</li> <li><code>size(Set) -&gt; Nat</code> - returns the number of elements in the list</li> <li><code>elem(List, Nat) -&gt; Maybe T</code> - returns an element from the list at the given position</li> <li><code>append(List, T) -&gt; List</code> - appends an element to the list</li> <li><code>delete(List, Nat) -&gt; List</code> - removes an element at the given position from the list</li> <li><code>contains(List, T) -&gt; Bool</code> - checks if an element is in the list</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/list.html#used-in","title":"Used in","text":"<ol> <li>Action</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/map.html","title":"Map","text":"<pre><code><pre>module arch.system.state.resource_machine.primitive_interfaces.map;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/map.html#map","title":"Map","text":"<p>Map is a structure that contains pairs (key: value), where key is of type <code>K</code> and value is of type <code>V</code>.</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/map.html#interface","title":"Interface","text":"<ol> <li><code>new() -&gt; Map</code></li> <li><code>add(Map, K, V) -&gt; Map</code></li> <li><code>size(Map) -&gt; Nat</code></li> <li><code>get(Map, K) -&gt; V</code></li> <li><code>keys(Map) -&gt; List K</code></li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/map.html#used-in","title":"Used in","text":"<ol> <li>Action</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/nullifier_set.html","title":"Nullifier set","text":"<pre><code><pre>module arch.system.state.resource_machine.primitive_interfaces.nullifier_set;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/nullifier_set.html#nullifier-set","title":"Nullifier set","text":"<p>The nullifier set interface requires two main operations:</p> <ol> <li><code>insert(NFSet, T) -&gt; NFSet</code> - adds the nullifier of type T to the nullifier set.</li> <li><code>contains(NFSet, T) -&gt; Bool</code> - searchers for the given element and returns <code>True</code> if the element was found.</li> </ol> <p>At this point, this interface seems to be fully covered by the set interface.</p> <p>Note</p> <p>For the future versions of the nullifier set:</p> <pre><code>1.`Contains` should perform the check in O(1)\n2. The data structure should support proofs of non-existence\n</code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/ordered_set.html","title":"Ordered set","text":"<pre><code><pre>module arch.system.state.resource_machine.primitive_interfaces.ordered_set;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/ordered_set.html#ordered-set","title":"Ordered set","text":"<p>Ordered set is a set that preserves order</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/ordered_set.html#used-in","title":"Used in","text":"<ol> <li>Action (commitments, nullifiers)</li> <li>Compliance unit</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/set.html","title":"Set interface","text":"<pre><code><pre>module arch.system.state.resource_machine.primitive_interfaces.set;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/set.html#set-primitive-interface","title":"Set primitive interface","text":"<p>A set is an unordered data structure that contains only distinct elements.</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/set.html#the-interface","title":"The interface","text":"<p>For a set parametrised over the element type <code>T</code>:</p> <ol> <li><code>new() -&gt; Set</code> - creates an empty set.</li> <li><code>new(List) -&gt; Set</code> - creates a set from the given list of elements. If the list contains duplicating elements, ignores them.</li> <li><code>size(Set) -&gt; Nat</code> - returns the number of elements in the set.</li> <li><code>insert(Set, T) -&gt; Set</code> - adds an element of type <code>T</code> to the set.</li> <li><code>union(Set, Set) -&gt; Set</code> - computes the union of two sets.</li> <li><code>intersection(Set, Set) -&gt; Set</code> - computes the intersection of two sets.</li> <li><code>difference(Set, Set) -&gt; Set</code> - computes the difference of two sets. Note that this operation is not commutative.</li> <li><code>disjointUnion(Set, Set) -&gt; Set</code> - computes the union of two sets. If the sets intersect, returns an error.</li> <li><code>contains(Set, T) -&gt; Bool</code> - checks if an element is in the set.</li> </ol> <pre><code>\nclassDiagram\n\n    class ISet~T~ {\n         &lt;&lt;Interface&gt;&gt;\n         new() Set\n         new(List) Set\n         size(Set) Nat\n         insert(Set, T) Set\n         union(Set, Set) Set\n         intersection(Set, Set) Set\n         difference(Set, Set) Set\n         disjointUnion(Set, Set) Set\n         contains(Set, T) Bool\n    }\n\n    class IList~T~ {\n         &lt;&lt;Interface&gt;&gt;\n    }\n\n    ISet &lt;|-- IList\n\n    ISet &lt;-- Set\n\n    IList &lt;-- List\n</code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/set.html#used-in","title":"Used in","text":"<ol> <li>Transaction</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/transaction_function_vm.html","title":"Transaction function vm","text":"<pre><code><pre>module arch.system.state.resource_machine.primitive_interfaces.transaction_function_vm;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/transaction_function_vm.html#transaction-function-vm","title":"Transaction function VM","text":"<p>Transaction function VM is used to interpret transaction functions.</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/transaction_function_vm.html#interface","title":"Interface","text":"<ul> <li><code>eval(TransactionFunction, GasLimit) -&gt; Transaction</code></li> </ul> <p>Examples: - nock (transparent-only; transaction function) - (?) cairo, risc0 (circuits)</p> <p>Todo</p> <p>are nock and cairo/risc0 on the same level? What exactly transaction functions look like in cairo/risk0 case? What about the relationship with proving systems?</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/fixed_size_type/arithmetic.html","title":"Arithmetic","text":"<pre><code><pre>module arch.system.state.resource_machine.primitive_interfaces.fixed_size_type.arithmetic;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/fixed_size_type/arithmetic.html#arithmetic","title":"Arithmetic","text":"<p>Arithmetic fixed size type is a type of fixed size that additionally supports addition and subtraction.</p> <pre><code>\nclassDiagram\n    class FixedSize~T, Arg~ {\n         &lt;&lt;Interface&gt;&gt;\n         +bit_size: Int\n         +new(Arg) T\n         +equal(T, T) Bool\n    }\n\n    FixedSize &lt;|-- Arithmetic\n\n    class Arithmetic~T, Arg~ {\n        &lt;&lt;Interface&gt;&gt;\n        +add(T, T) T\n        +sub(T, T) T\n    }\n\n    Arithmetic &lt;|-- Quantity\n    Arithmetic &lt;|-- Balance\n</code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/fixed_size_type/arithmetic.html#used-in","title":"Used in","text":"<ol> <li>Resource component: <code>quantity</code></li> <li><code>DeltaHash</code></li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/fixed_size_type/delta_hash.html","title":"Delta hash","text":"<pre><code><pre>module arch.system.state.resource_machine.primitive_interfaces.fixed_size_type.delta_hash;import prelude open;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/fixed_size_type/delta_hash.html#delta-hash","title":"Delta hash","text":"<p>Delta hash is an interface that implements both <code>Hash</code> type and <code>Arithmetic</code> type. It is also required to be additively homomorphic and kind-distinct:</p> <ol> <li>For resources of the same kind \\(kind\\), \\(h_{\\Delta}\\) should be additively homomorphic: \\(\\Delta_1 + \\Delta_2 = h_{\\Delta}(kind, q_1) + h_{\\Delta}(kind, q_2) = h_{\\Delta}(kind, q_1 + q_2)\\)</li> </ol> <pre><code><pre>--- A trait describing additive homomorphicity.traittype AdditivelyHomomorphic T :=  mkAdditivelyHomomorphic@{    --- Adds two types implementing the ;AdditivelyHomomorphic; trait.    add : (v1 v2 : T) -&gt; T;  };</pre></code></pre> <pre><code><pre>--- Implements the trait ;Eq; for ;AdditivelyHomomorphic; types.Property-AdditivelyHomomorphic  {T} {{Eq T}} {{AdditivelyHomomorphic T}} (f : T -&gt; T) (v1 v2 : T) : Bool :=  f (AdditivelyHomomorphic.add v1 v2) == AdditivelyHomomorphic.add (f v1) (f v2);</pre></code></pre> <ol> <li>For resources of different kinds, \\(h_\\Delta\\) has to be computationally kind-distinct: if there exists \\(kind\\) and \\(q\\) s.t. \\(h_\\Delta(kind_1, q_1) + h_\\Delta(kind_2, q_2) = h_\\Delta(kind, q)\\), it is computationally infeasible to compute \\(kind\\) and \\(q\\).</li> </ol> <pre><code><pre>--- A trait describing kind distinctness.traittype KindDistinct T :=  mkKindDistinct@{    --- Adds two types implementing the ;KindDistinct; trait.    add : (v1 v2 : T) -&gt; T;  };</pre></code></pre> <p>Note</p> <p>An example of a function that satisfies these properties is the Pedersen commitment scheme: it is additively homomorphic, and its kind-distinctness property comes from the discrete logarithm assumption.</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/fixed_size_type/delta_hash.html#used-in","title":"Used in","text":"<ol> <li>Resource delta</li> <li>Compliance unit delta</li> <li>Action delta</li> <li>Transaction delta</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/fixed_size_type/fixed_size_type.html","title":"Interface","text":"<pre><code><pre>module arch.system.state.resource_machine.primitive_interfaces.fixed_size_type.fixed_size_type;import prelude open;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/fixed_size_type/fixed_size_type.html#fixed-size-type","title":"Fixed Size Type","text":"<pre><code><pre>type FixedSize T := mkFixedSize@{};</pre></code></pre> <p>Fixed size type is a type, as the name suggests, of a fixed size. An example of such a type could be a prime field, unit32, or a string of a fixed size. An example of a type of not fixed size would be a list. All resource components and computable components are elements of a fixed size type. <p>The two child interfaces are arithmetic fixed size type - the fixed size type that supports addition and subtraction, and hash - the fixed size type for which the type derivation function <code>new(Arg)</code> is binding.</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/fixed_size_type/fixed_size_type.html#fixed-size-type-hierarchy-diagram","title":"Fixed size type hierarchy diagram","text":"<pre><code>\nclassDiagram\n    class FixedSize~T, Arg~ {\n         &lt;&lt;Interface&gt;&gt;\n         +bit_size: Int\n         +new(Arg) T\n         +equal(T, T) Bool\n    }\n\n    FixedSize &lt;|-- Nonce\n    FixedSize &lt;|-- RandSeed\n    FixedSize &lt;|-- NullifierKeyCommitment\n    FixedSize &lt;|-- NullifierKey\n\n    FixedSize &lt;|-- Arithmetic\n    FixedSize &lt;|-- Hash\n\n\n    note for Hash \"fixed size types that are binding (to Arg) and collision resistant\"\n    class Hash~T, Arg~ {\n        &lt;&lt;Interface&gt;&gt;\n    }\n\n    class Arithmetic~T, Arg~ {\n        &lt;&lt;Interface&gt;&gt;\n        +add(T, T) T\n        +sub(T, T) T\n    }\n\n    Hash &lt;|-- DeltaHash\n    Arithmetic &lt;|-- DeltaHash\n\n    note for DeltaHash \"additively homomorphic and kind-distnict\"\n    class DeltaHash {\n        &lt;&lt;Interface&gt;&gt;\n    }\n</code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/fixed_size_type/fixed_size_type.html#used-in-raw","title":"Used in (raw)","text":"<ol> <li> <p>Resource components:</p> <ol> <li><code>randSeed</code></li> <li><code>nonce</code></li> <li><code>nullifierKeyCommitment</code></li> </ol> </li> <li> <p><code>nullifierKey</code></p> </li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/fixed_size_type/hash.html","title":"Hash","text":"<pre><code><pre>module arch.system.state.resource_machine.primitive_interfaces.fixed_size_type.hash;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/fixed_size_type/hash.html#hash","title":"Hash","text":"<p>Hash type is defined as a fixed size type that is binding, meaning that if the input value of type <code>Arg</code> changed, the output value would change as well.</p> <p>In the context of hashes, we say <code>a</code> is an opening of a hash <code>h: Hash</code> if <code>h = hash(a)</code>.</p> <p>Todo</p> <ol> <li>for shielded: cryptographic hash, hiding</li> <li>do we want a separate interface for the logic hash, given it is a verifier key? UPD in Taiga we had the verifier key hashed. Is it fixed size? If not, what was the reason for tripple hashing? vk + hash + function privacy commitment</li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/fixed_size_type/hash.html#hash-interface-diagram","title":"Hash interface diagram","text":"<pre><code>\nclassDiagram\n\n    class Hash~T, Arg~ {\n         &lt;&lt;Interface&gt;&gt;\n    }\n\n    Hash &lt;|-- LogicVKCompact\n    Hash &lt;|-- LabelHash\n    Hash &lt;|-- ValueHash\n\n    Hash &lt;|-- Commitment\n    Hash &lt;|-- Nullifier\n    Hash &lt;|-- Kind\n    Hash &lt;|-- DeltaHash\n    Hash &lt;|-- LogicVKOuterHash\n    Hash &lt;|-- MerkleTreeNodeHash\n\n    Hash &lt;|-- AppDataValueHash\n</code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/fixed_size_type/hash.html#used-in","title":"Used in","text":"<ol> <li> <p>Resource components:</p> <ol> <li><code>logicRef</code></li> <li><code>labelRef</code></li> <li><code>valueRef</code></li> </ol> </li> <li> <p>Resource computable components:</p> <ol> <li><code>commitment</code></li> <li><code>nullifier</code></li> <li><code>kind</code></li> <li><code>delta</code></li> </ol> </li> <li> <p>Computing Merkle tree nodes and roots</p> </li> </ol>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/proving_system/index.html","title":"Index","text":"<pre><code>module arch.system.state.resource_machine.primitive_interfaces.proving_system.proving_system;\n</code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/proving_system/index.html#proving-system","title":"Proving system","text":"<p>Todo</p> <p>add efficiency expectations (what to prioritise)</p> <p>The resource machine differentiates between three kinds of proofs, each of which can have a distinct proving system used to produce that sort of proofs:</p> <ol> <li>resource logic proofs</li> <li>compliance proofs</li> <li>delta proofs</li> </ol> Execution context Constraints defined by Are the constraints public by default? Meaning Resource logic proof Action Application No Action is compliant with the application constraints Compliance proof Compliance unit RM instance Yes Action (partitioned into compliance units) is compliant with the RM rules Delta proof Transaction RM interface Yes Transaction is balanced <p>Every proof has three types of inputs and constraints:</p> <ol> <li>Architecture-level inputs and constraints. This type of inputs and constraints allow to enforce certain resource machine properties and have to be present in each resource logic, no matter in the context of which instantiation and application the resource logic was produced. These contraints ensure basic resource machine properties.</li> <li>Instantiation-level inputs and constraints. These inputs and constraints must be present in every resource logic compatible with a concrete resource machine instantiation but might not be required by other instantiations. These constraints ensure additional resource machine properties desired by the instantiation.</li> <li>Application-level (custom) inputs and constraints that are present in every resource logic specified by a concrete application. These constraints define how the application works.</li> </ol> <p>This specification explicitly defines only the architecture-level inputs and constraints. Only application-level constraints are referred to as custom.</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/proving_system/index.html#proving-system-requirements","title":"Proving system requirements","text":"<p>The first two kinds of proofs, resource logic proofs and compliance proofs, follow the standard proving system interface defined here. The delta proof has an additional functionality required and is further described here.</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/proving_system/index.html#resource-logic-proving-system-choice","title":"Resource logic proving system choice","text":"<p>Resource logic proof is the most common proof type. Each action that modifies the state of <code>n</code> resources (creates or consumes) has at least <code>n</code> resource logic proofs attached to it. In principle, the predicate checked with each proof can be different for all <code>n</code> proofs. For that reason, the proving system of choice should support easy proof instantiation process for new predicates (e.g., a SNARK that requires a trusted setup ceremony initiated for every predicate is probably not the most efficient choice for this proving system).</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/proving_system/index.html#compliance-proving-system-choice","title":"Compliance proving system choice","text":"<p>Compliance constraints are fixed per RM instantiation, meaning that the predicate being checked is the same for each compliance unit, with only the instance and witness being different each time. For that reason, a proving system that prioritises efficiency for a single predicate over the ease of creating proofs for new predicates might be more suitable.</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/proving_system/index.html#proving-system-hierarchy","title":"Proving system hierarchy","text":"<p>The diagram below describes the relationships between the proving system and delta proof interfaces and their instantiations that correspond to the proving system for each proof type.</p> <pre><code>---\ntitle: Proving System hierarchy\n---\nclassDiagram\n    class IProvingSystem~VerifyingKey, ProvingKey, Instance, Witness, Proof~ {\n         &lt;&lt;Interface&gt;&gt;\n         +prove(ProvingKey, Instance, Witness) Proof\n         +verify(VerifyingKey, Instance, Proof) Bool\n    }\n\n    IProvingSystem &lt;|-- ResourceLogicProvingSystem\n    IProvingSystem &lt;|-- ComplianceProvingSystem\n    IProvingSystem &lt;|-- IDeltaProvingSystem\n\n    class ResourceLogicProvingSystem\n    class ComplianceProvingSystem\n\n    class IDeltaProvingSystem~VerifyingKey, ProvingKey, Instance, Witness, Proof~ {\n         &lt;&lt;Interface&gt;&gt;\n        +aggregate(Proof, Proof) Proof\n    }\n    IDeltaProvingSystem &lt;|-- DeltaProvingSystem\n\n    class DeltaProvingSystem\n</code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/proving_system/proving_system_delta.html","title":"Delta proving system","text":"<pre><code><pre>module arch.system.state.resource_machine.primitive_interfaces.proving_system.proving_system_delta;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/proving_system/proving_system_delta.html#delta-proving-system","title":"Delta Proving System","text":"<p>Delta proving system is used to prove that the transaction delta is equal to a certain value. To support transaction composition that results in a new transaction being produced, the delta proving system must, in addition to the standard proving system interface, provide a proof aggregation function:</p> <p><code>DeltaProvingSystem</code>:</p> <ol> <li><code>prove(PS.ProvingKey, PS.Instance, PS.Witness) -&gt; PS.Proof</code></li> <li><code>verify(PS.VerifyingKey, PS.Instance, PS.Proof) -&gt; Bool</code></li> <li><code>aggregate(PS.Proof, PS.Proof) -&gt; PS.Proof</code></li> </ol> <p>The aggregation function allows to aggregate proofs in a way that if \\(\\pi_1\\) proves that the first transaction's balance is \\(b_1\\) and the second proof \\(\\pi_2\\) proves the second transaction's balance is \\(b_2\\), then the proof \\(Aggregate(\\pi_1, \\pi_2)\\) proves that the composed transaction's balance is \\(b_1 + b_2\\).</p> <pre><code>---\ntitle: Proving System hierarchy\n---\nclassDiagram\n    class IProvingSystem~VerifyingKey, ProvingKey, Instance, Witness, Proof~ {\n         &lt;&lt;Interface&gt;&gt;\n         +prove(ProvingKey, Instance, Witness) Proof\n         +verify(VerifyingKey, Instance, Proof) Bool\n    }\n\n    IProvingSystem &lt;|-- IDeltaProvingSystem\n\n    class IDeltaProvingSystem~VerifyingKey, ProvingKey, Instance, Witness, Proof~ {\n         &lt;&lt;Interface&gt;&gt;\n        +aggregate(Proof, Proof) Proof\n    }\n    IDeltaProvingSystem &lt;|-- DeltaProvingSystem\n\n    class DeltaProvingSystem\n</code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/proving_system/proving_system_types.html","title":"Definitions","text":"<pre><code><pre>module arch.system.state.resource_machine.primitive_interfaces.proving_system.proving_system_types;</pre></code></pre>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/proving_system/proving_system_types.html#proving-system-definition","title":"Proving system definition","text":"<p>We define a set of structures required to define a proving system \\(PS\\) as follows:</p> <ul> <li>Proof \\(\\pi: PS.Proof\\) - proves that a specific statement <code>f</code> with the inputs <code>x</code> and <code>w</code> evaluates to <code>True</code>.</li> <li>Instance \\(x: PS.Instance\\) is the ordered input data structure used to produce and verify a proof.</li> <li>Witness \\(w: PS.Witness\\) is the ordered input data structure used to produce (but not verify) a proof.</li> <li>Proving key \\(pk: PS.ProvingKey\\) contains the data required to produce a proof for a pair \\((x, w)\\). Specific to a particular statement (different statements <code>f</code> and <code>f'</code> imply different proving keys) being proven, but doesn't depend on the inputs.</li> <li>Verifying key \\(vk: PS.VerifyingKey\\) contains the data required, along with the instance \\(x\\), to verify a proof \\(\\pi\\). Specific to a particular statement being proven (different statements <code>f</code> and <code>f'</code> imply different verifying keys), but doesn't depend on the inputs. The verifying key is assumed to be of fixed size.</li> </ul> <p>A proving system \\(PS\\) consists of a pair of algorithms, \\((Prove, Verify)\\):</p> <ul> <li>\\(Prove(pk, x, w): PS.ProvingKey \\times PS.Instance \\times PS.Witness \\rightarrow PS.Proof\\)</li> <li>\\(Verify(vk, x, \\pi): PS.VerifyingKey \\times PS.Instance \\times PS.Proof \\rightarrow Bool\\).</li> </ul> <p>Note</p> <p>To verify a proof created for instance <code>x</code>, the same instance <code>x</code> must be used. For instances that contain elements of the same type, the order of the elements must be preserved.</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/proving_system/proving_system_types.html#properties","title":"Properties","text":"<p>A proving system must have the following properties:</p> <ul> <li>Completeness: it must be possible to make a proof for a statement which is true.</li> <li>Soundness: it must not be possible to make a proof for a statement which is false.</li> </ul> <p>For a statement <code>f</code>, <code>Verify(vk, x, proof) = True</code> implies that <code>f x w = True</code> and <code>Verify(vk, x, proof) = False</code> implies that <code>f x w = False</code>.</p> <p>Certain proving systems may also be zero-knowledge, meaning that the produced proofs reveal no information other than their own validity.</p> <p>A proof \\(\\pi\\) for which \\(Verify(pr) = True\\) is considered valid.</p>","boost":2},{"location":"arch/system/state/resource_machine/primitive_interfaces/proving_system/proving_system_types.html#common-proving-scheme-types","title":"Common proving scheme types","text":"<ul> <li>The trivial scheme is one where computation is simply replicated. The   trivial scheme is defined as <code>verify(predicate, x, _) = predicate x</code>. It has no extra security assumptions but is not succinct. In this case, all of the data is used for both proving and verifying and witness and proof has unit type <code>()</code>.</li> </ul> <ul> <li>The trusted delegation scheme is one where computation is delegated to a   known, trusted party whose work is not checked. The trusted delegation scheme   is defined as <code>verify((predicate, pk), x, sig) = checkSignature pk (predicate, x) sig</code>, where the trusted party is assumed to produce such a   signature only if <code>predicate x = True</code>. This scheme is succinct but requires a   trusted party assumption (which could be generalised to a threshold quorum in   the obvious way). Note that since the computation is still verifiable, a   signer of <code>(predicate, x)</code> where <code>predicate x = False</code> could be held   accountable by anyone else who later evaluated the predicate. In this case witness also has unit type and the proof has the type <code>Signature</code>.</li> </ul> <ul> <li>The succinct proof-of-knowledge scheme is one where the result of computation is attested to with a cryptographic proof (of the sort commonly instantiated by modern-day SNARKs &amp; STARKs). Succinct proof-of-knowledge schemes provide succinctness as well as verifiability subject to the scheme-specific cryptographic assumptions. They may also possibly be zero-knowledge, in which the verifier learns nothing other than <code>predicate x w = True</code> (in this case, and in others, <code>w</code> will be \"hidden\" with hash functions and <code>x</code> will remain public (and include the hiding representations of <code>w</code>), such that the verifier knows only <code>hash w</code> and <code>x</code> but the substance of the relation obtains over the preimages).</li> </ul> <p>Assuming the proving system is used to verify that a predicate evaluated on its inputs returns <code>True</code>, the table below describes what each parameter will be for each of the three common proving system instantiations:</p> Proving key Verifying key Instance (x) Witness (w) Proof Properties Trivial scheme hash of the predicate hash of the predicate predicate's arguments, predicate () () transparent, not succinct Trusted delegation hash of the predicate + signing key hash of the predicate + signature verifying key predicate's arguments, predicate () signature succinct, trusted, verifiable Succinct PoK defined by the scheme (incl. predicate representation) defined by the scheme public input private input defined by the scheme succinct, verifiable, possibly zero knowledge <p>Note</p> <p>In the trivial scheme, verification requires the pre-images of the verifying key / instance hashes. In the trusted delegation case, the pre-images are not required if the signature is produced over the hashed values.</p> <p>Note</p> <p>Proving-related data structures described further are written with a PoK proving system in mind. For a transparent system, all values that are marked as witness in the specification shouldn't be discarded but rather moved to instance.</p> <p>Note</p> <p>For application developers: writing applications that can work with all types of proving systems can be challenging since different proof types require different argument split between instance and witness (e.g., trivial scheme, unlike succinct PoK, expects no witness). The current solution is to write applications with succinct PoK types of proving systems in mind, which then can be translated to other proving systems by moving witness arguments to instance.</p>","boost":2},{"location":"indexes/engines.html","title":"Engines","text":"","tags":["index"]},{"location":"indexes/engines.html#list-of-engines","title":"List of engines","text":"","tags":["index"]},{"location":"indexes/engines.html#tag:engine-definition","title":"engine-definition","text":"<ul> <li>            Commitment Engine          </li> <li>            Decryption Engine          </li> <li>            Encryption Engine          </li> <li>            Executor Engine          </li> <li>            Identity Management Engine          </li> <li>            Local Key Value Storage Engine          </li> <li>            Local Time Series Storage Engine          </li> <li>            Logging Engine          </li> <li>            Mempool Worker Engine          </li> <li>            Naming Engine          </li> <li>            Network Registry Engine          </li> <li>            Pub/Sub Topic Engine          </li> <li>            ReadsFor Engine          </li> <li>            Router Engine          </li> <li>            Shard Engine          </li> <li>            Storage Engine          </li> <li>            Ticker Engine          </li> <li>            Transport          </li> <li>            Verification Engine          </li> <li>            Wall Clock Engine          </li> </ul>","tags":["index"]},{"location":"indexes/modules.html","title":"Modules","text":"<p>All the Juvix modules for the Anoma Specification are listed below.</p>","tags":["index"]},{"location":"indexes/modules.html#juvix-package-version","title":"Juvix Package version","text":"<pre><code>package : Package :=\n  defaultPackage@{\n    name := \"nspec\";\n    version := mkVersion 0 1 4;\n    dependencies :=\n      [github \"anoma\" \"juvix-stdlib\" \"v0.11.0\"]\n  };\n</code></pre>","tags":["index"]},{"location":"indexes/modules.html#modules-by-letter","title":"Modules by letter","text":"","tags":["index"]},{"location":"indexes/modules.html#a","title":"A","text":"<ul> <li>arch.node.types.anoma</li> </ul> <ul> <li>arch.node.types.anoma_config</li> </ul> <ul> <li>arch.node.types.anoma_engines</li> </ul> <ul> <li>arch.node.types.anoma_environment</li> </ul> <ul> <li>arch.node.types.anoma_message</li> </ul> <ul> <li>anomian</li> </ul> <ul> <li>arch.system.state.resource_machine.notes.applications</li> </ul> <ul> <li>arch.system.state.resource_machine.primitive_interfaces.fixed_size_type.arithmetic</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#b","title":"B","text":"<ul> <li>arch.node.types.basics</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#c","title":"C","text":"<ul> <li>arch.node.engines.commitment</li> </ul> <ul> <li>arch.system.state.resource_machine.primitive_interfaces.commitment_accumulator</li> </ul> <ul> <li>arch.node.engines.commitment_behaviour</li> </ul> <ul> <li>arch.node.engines.commitment_config</li> </ul> <ul> <li>arch.node.engines.commitment_environment</li> </ul> <ul> <li>arch.node.engines.commitment_messages</li> </ul> <ul> <li>arch.system.state.resource_machine.data_structures.compliance_unit.compliance_proof</li> </ul> <ul> <li>arch.system.state.resource_machine.data_structures.compliance_unit.compliance_unit</li> </ul> <ul> <li>arch.node.types.crypto</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#d","title":"D","text":"<ul> <li>arch.node.engines.decryption</li> </ul> <ul> <li>arch.node.engines.decryption_behaviour</li> </ul> <ul> <li>arch.node.engines.decryption_config</li> </ul> <ul> <li>arch.node.engines.decryption_environment</li> </ul> <ul> <li>arch.node.engines.decryption_messages</li> </ul> <ul> <li>arch.system.state.resource_machine.data_structures.resource.computable_components.delta</li> </ul> <ul> <li>arch.system.state.resource_machine.primitive_interfaces.fixed_size_type.delta_hash</li> </ul> <ul> <li>arch.system.state.resource_machine.data_structures.transaction.delta_proof</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#e","title":"E","text":"<ul> <li>arch.node.engines.encryption</li> </ul> <ul> <li>arch.node.engines.encryption_behaviour</li> </ul> <ul> <li>arch.node.engines.encryption_config</li> </ul> <ul> <li>arch.node.engines.encryption_environment</li> </ul> <ul> <li>arch.node.engines.encryption_messages</li> </ul> <ul> <li>arch.node.types.engine</li> </ul> <ul> <li>arch.node.types.engine_behaviour</li> </ul> <ul> <li>arch.node.types.engine_config</li> </ul> <ul> <li>arch.node.types.engine_environment</li> </ul> <ul> <li>everything</li> </ul> <ul> <li>arch.node.engines.executor</li> </ul> <ul> <li>arch.node.engines.executor_behaviour</li> </ul> <ul> <li>arch.node.engines.executor_config</li> </ul> <ul> <li>arch.node.engines.executor_environment</li> </ul> <ul> <li>arch.node.engines.executor_messages</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#f","title":"F","text":"<ul> <li>arch.system.state.resource_machine.primitive_interfaces.fixed_size_type.fixed_size_type</li> </ul> <ul> <li>arch.system.state.resource_machine.execution_flow.flow</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#h","title":"H","text":"<ul> <li>arch.node.subsystems.hardware</li> </ul> <ul> <li>arch.system.state.resource_machine.primitive_interfaces.fixed_size_type.hash</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#i","title":"I","text":"<ul> <li>arch.node.types.identities</li> </ul> <ul> <li>arch.system.identity.identity</li> </ul> <ul> <li>arch.node.subsystems.identity</li> </ul> <ul> <li>arch.node.engines.identity_management</li> </ul> <ul> <li>arch.node.engines.identity_management_behaviour</li> </ul> <ul> <li>arch.node.engines.identity_management_config</li> </ul> <ul> <li>arch.node.engines.identity_management_environment</li> </ul> <ul> <li>arch.node.engines.identity_management_messages</li> </ul> <ul> <li>arch.node.integration.examples.increment</li> </ul> <ul> <li>arch.system.state.resource_machine.index</li> </ul> <ul> <li>arch.system.state.resource_machine.primitive_interfaces.index</li> </ul> <ul> <li>arch.system.state.resource_machine.data_structures.action.index</li> </ul> <ul> <li>arch.system.state.resource_machine.data_structures.resource.index</li> </ul> <ul> <li>arch.system.state.resource_machine.data_structures.resource.computable_components.introduction</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#k","title":"K","text":"<ul> <li>arch.system.state.resource_machine.data_structures.resource.computable_components.kind</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#l","title":"L","text":"<ul> <li>arch.system.state.resource_machine.primitive_interfaces.list</li> </ul> <ul> <li>arch.node.engines.local_key_value_storage</li> </ul> <ul> <li>arch.node.engines.local_key_value_storage_behaviour</li> </ul> <ul> <li>arch.node.engines.local_key_value_storage_config</li> </ul> <ul> <li>arch.node.engines.local_key_value_storage_environment</li> </ul> <ul> <li>arch.node.engines.local_key_value_storage_messages</li> </ul> <ul> <li>arch.node.engines.local_time_series_storage</li> </ul> <ul> <li>arch.node.engines.local_time_series_storage_behaviour</li> </ul> <ul> <li>arch.node.engines.local_time_series_storage_config</li> </ul> <ul> <li>arch.node.engines.local_time_series_storage_environment</li> </ul> <ul> <li>arch.node.engines.local_time_series_storage_messages</li> </ul> <ul> <li>arch.node.engines.logging</li> </ul> <ul> <li>arch.node.engines.logging_behaviour</li> </ul> <ul> <li>arch.node.engines.logging_config</li> </ul> <ul> <li>arch.node.engines.logging_environment</li> </ul> <ul> <li>arch.node.engines.logging_messages</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#m","title":"M","text":"<ul> <li>arch.system.state.resource_machine.primitive_interfaces.map</li> </ul> <ul> <li>arch.node.engines.mempool_worker</li> </ul> <ul> <li>arch.node.engines.mempool_worker_behaviour</li> </ul> <ul> <li>arch.node.engines.mempool_worker_config</li> </ul> <ul> <li>arch.node.engines.mempool_worker_environment</li> </ul> <ul> <li>arch.node.engines.mempool_worker_messages</li> </ul> <ul> <li>arch.node.types.messages</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#n","title":"N","text":"<ul> <li>arch.node.engines.naming</li> </ul> <ul> <li>arch.node.engines.naming_behaviour</li> </ul> <ul> <li>arch.node.engines.naming_config</li> </ul> <ul> <li>arch.node.engines.naming_environment</li> </ul> <ul> <li>arch.node.engines.naming_messages</li> </ul> <ul> <li>arch.node.subsystems.net</li> </ul> <ul> <li>arch.node.engines.net_registry</li> </ul> <ul> <li>arch.node.engines.net_registry_behaviour</li> </ul> <ul> <li>arch.node.engines.net_registry_config</li> </ul> <ul> <li>arch.node.engines.net_registry_environment</li> </ul> <ul> <li>arch.node.engines.net_registry_messages</li> </ul> <ul> <li>arch.system.state.resource_machine.notes.nockma</li> </ul> <ul> <li>arch.system.state.resource_machine.notes.nockma_runnable</li> </ul> <ul> <li>arch.system.state.resource_machine.data_structures.resource.computable_components.nullifier</li> </ul> <ul> <li>arch.system.state.resource_machine.primitive_interfaces.nullifier_set</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#o","title":"O","text":"<ul> <li>arch.system.state.resource_machine.primitive_interfaces.ordered_set</li> </ul> <ul> <li>arch.node.subsystems.ordering</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#p","title":"P","text":"<ul> <li>prelude</li> </ul> <ul> <li>arch.system.state.resource_machine.primitive_interfaces.proving_system.proving_system_delta</li> </ul> <ul> <li>arch.system.state.resource_machine.primitive_interfaces.proving_system.proving_system_types</li> </ul> <ul> <li>arch.node.engines.pub_sub_topic</li> </ul> <ul> <li>arch.node.engines.pub_sub_topic_behaviour</li> </ul> <ul> <li>arch.node.engines.pub_sub_topic_config</li> </ul> <ul> <li>arch.node.engines.pub_sub_topic_environment</li> </ul> <ul> <li>arch.node.engines.pub_sub_topic_messages</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#r","title":"R","text":"<ul> <li>arch.node.engines.reads_for</li> </ul> <ul> <li>arch.node.engines.reads_for_behaviour</li> </ul> <ul> <li>arch.node.engines.reads_for_config</li> </ul> <ul> <li>arch.node.engines.reads_for_environment</li> </ul> <ul> <li>arch.node.engines.reads_for_messages</li> </ul> <ul> <li>arch.system.state.resource_machine.data_structures.resource.computable_components.resource_commitment</li> </ul> <ul> <li>arch.system.state.resource_machine.data_structures.action.resource_logic_proof</li> </ul> <ul> <li>arch.system.state.resource_machine.notes.roles_and_requirements</li> </ul> <ul> <li>arch.node.types.router</li> </ul> <ul> <li>arch.node.engines.router</li> </ul> <ul> <li>arch.node.engines.router_behaviour</li> </ul> <ul> <li>arch.node.engines.router_config</li> </ul> <ul> <li>arch.node.engines.router_environment</li> </ul> <ul> <li>arch.node.engines.router_messages</li> </ul> <ul> <li>arch.system.state.resource_machine.notes.runnable</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#s","title":"S","text":"<ul> <li>arch.system.state.resource_machine.primitive_interfaces.set</li> </ul> <ul> <li>arch.node.engines.shard</li> </ul> <ul> <li>arch.node.engines.shard_behaviour</li> </ul> <ul> <li>arch.node.engines.shard_config</li> </ul> <ul> <li>arch.node.engines.shard_environment</li> </ul> <ul> <li>arch.node.engines.shard_messages</li> </ul> <ul> <li>arch.node.engines.signs_for</li> </ul> <ul> <li>arch.node.engines.signs_for_behaviour</li> </ul> <ul> <li>arch.node.engines.signs_for_config</li> </ul> <ul> <li>arch.node.engines.signs_for_environment</li> </ul> <ul> <li>arch.node.engines.signs_for_messages</li> </ul> <ul> <li>arch.node.integration.simulator</li> </ul> <ul> <li>arch.system.state.resource_machine.notes.storage</li> </ul> <ul> <li>arch.node.types.storage</li> </ul> <ul> <li>arch.node.engines.storage</li> </ul> <ul> <li>arch.node.engines.storage_behaviour</li> </ul> <ul> <li>arch.node.engines.storage_config</li> </ul> <ul> <li>arch.node.engines.storage_environment</li> </ul> <ul> <li>arch.node.engines.storage_messages</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#t","title":"T","text":"<ul> <li>tutorial.engines.template</li> </ul> <ul> <li>tutorial.engines.template_behaviour</li> </ul> <ul> <li>tutorial.engines.template_config</li> </ul> <ul> <li>tutorial.engines.template_environment</li> </ul> <ul> <li>tutorial.engines.template_messages</li> </ul> <ul> <li>tutorial.engines.template_minimum</li> </ul> <ul> <li>tutorial.engines.template_minimum_behaviour</li> </ul> <ul> <li>tutorial.engines.template_minimum_config</li> </ul> <ul> <li>tutorial.engines.template_minimum_environment</li> </ul> <ul> <li>tutorial.engines.template_minimum_messages</li> </ul> <ul> <li>arch.node.engines.ticker</li> </ul> <ul> <li>arch.node.engines.ticker_behaviour</li> </ul> <ul> <li>arch.node.engines.ticker_config</li> </ul> <ul> <li>arch.node.engines.ticker_environment</li> </ul> <ul> <li>arch.node.engines.ticker_messages</li> </ul> <ul> <li>arch.system.state.resource_machine.data_structures.transaction.transaction</li> </ul> <ul> <li>arch.system.state.resource_machine.data_structures.transaction.transaction_function</li> </ul> <ul> <li>arch.system.state.resource_machine.notes.function_formats.transaction_function_format</li> </ul> <ul> <li>arch.system.state.resource_machine.primitive_interfaces.transaction_function_vm</li> </ul> <ul> <li>arch.system.state.resource_machine.data_structures.transaction.transaction_with_payment</li> </ul> <ul> <li>arch.node.types.transport</li> </ul> <ul> <li>arch.node.engines.transport</li> </ul> <ul> <li>arch.node.engines.transport_behaviour</li> </ul> <ul> <li>arch.node.engines.transport_config</li> </ul> <ul> <li>arch.node.engines.transport_connection</li> </ul> <ul> <li>arch.node.engines.transport_connection_behaviour</li> </ul> <ul> <li>arch.node.engines.transport_connection_config</li> </ul> <ul> <li>arch.node.engines.transport_connection_environment</li> </ul> <ul> <li>arch.node.engines.transport_connection_messages</li> </ul> <ul> <li>arch.node.engines.transport_environment</li> </ul> <ul> <li>arch.node.engines.transport_messages</li> </ul> <ul> <li>arch.node.engines.transport_protocol</li> </ul> <ul> <li>arch.node.engines.transport_protocol_behaviour</li> </ul> <ul> <li>arch.node.engines.transport_protocol_config</li> </ul> <ul> <li>arch.node.engines.transport_protocol_environment</li> </ul> <ul> <li>arch.node.engines.transport_protocol_messages</li> </ul> <ul> <li>arch.node.types</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#v","title":"V","text":"<ul> <li>arch.node.engines.verification</li> </ul> <ul> <li>arch.node.engines.verification_behaviour</li> </ul> <ul> <li>arch.node.engines.verification_config</li> </ul> <ul> <li>arch.node.engines.verification_environment</li> </ul> <ul> <li>arch.node.engines.verification_messages</li> </ul> <ul> <li>arch.node.integration.visualizer</li> </ul>","tags":["index"]},{"location":"indexes/modules.html#w","title":"W","text":"<ul> <li>arch.node.engines.wall_clock</li> </ul> <ul> <li>arch.node.engines.wall_clock_behaviour</li> </ul> <ul> <li>arch.node.engines.wall_clock_config</li> </ul> <ul> <li>arch.node.engines.wall_clock_environment</li> </ul> <ul> <li>arch.node.engines.wall_clock_messages</li> </ul>","tags":["index"]},{"location":"indexes/tags.html","title":"List of tags","text":"","tags":["index"]},{"location":"indexes/tags.html#tag:accumulator","title":"accumulator","text":"<ul> <li>            Index          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:behaviour","title":"behaviour","text":"<ul> <li>            Commitment Behaviour          </li> <li>            Decryption Behaviour          </li> <li>            Encryption Behaviour          </li> <li>            Engine Behaviour          </li> <li>            Executor Behaviour          </li> <li>            Identity Management Behaviour          </li> <li>            Local Key Value Storage Behaviour          </li> <li>            Local Time Series Storage Behaviour          </li> <li>            Logging Behaviour          </li> <li>            Mempool Worker Behaviour          </li> <li>            Naming Behaviour          </li> <li>            Network Registry Behaviour          </li> <li>            Pub/Sub Topic Behaviour          </li> <li>            ReadsFor Behaviour          </li> <li>            Router Behaviour          </li> <li>            Shard Behaviour          </li> <li>            SignsFor Behaviour          </li> <li>            Storage Behaviour          </li> <li>            Ticker Behaviour          </li> <li>            Transport Connection Behaviour          </li> <li>            Transport Protocol Behaviour          </li> <li>            Transport behaviour          </li> <li>            Verification Behaviour          </li> <li>            Wall Clock Behaviour          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:commitment","title":"commitment","text":"<ul> <li>            Commitment Behaviour          </li> <li>            Commitment Configuration          </li> <li>            Commitment Engine          </li> <li>            Commitment Environment          </li> <li>            Commitment Messages          </li> <li>            Index          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:concept","title":"concept","text":"<ul> <li>            Engine          </li> <li>            Node          </li> <li>            Subsystem          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:configuration","title":"configuration","text":"<ul> <li>            Anoma Configuration          </li> <li>            Commitment Configuration          </li> <li>            Decryption Configuration          </li> <li>            Encryption Configuration          </li> <li>            Engine Configuration          </li> <li>            Executor Configuration          </li> <li>            Identity Management Configuration          </li> <li>            Local Key Value Storage Configuration          </li> <li>            Local Time Series Storage Configuration          </li> <li>            Logging Configuration          </li> <li>            Mempool Worker Configuration          </li> <li>            Naming Configuration          </li> <li>            Network Registry Configuration          </li> <li>            Pub/Sub Topic Configuration          </li> <li>            ReadsFor Configuration          </li> <li>            Router Configuration          </li> <li>            Shard Configuration          </li> <li>            SignsFor Configuration          </li> <li>            Storage Configuration          </li> <li>            Ticker Configuration          </li> <li>            Transport Connection Configuration          </li> <li>            Transport Protocol Configuration          </li> <li>            Transport config          </li> <li>            Verification Configuration          </li> <li>            Wall Clock Configuration          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:crypto","title":"crypto","text":"<ul> <li>            Crypto          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:decryption","title":"decryption","text":"<ul> <li>            Decryption Behaviour          </li> <li>            Decryption Configuration          </li> <li>            Decryption Engine          </li> <li>            Decryption Environment          </li> <li>            Decryption Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:encryption","title":"encryption","text":"<ul> <li>            Encryption Behaviour          </li> <li>            Encryption Configuration          </li> <li>            Encryption Engine          </li> <li>            Encryption Environment          </li> <li>            Encryption Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:engine","title":"engine","text":"<ul> <li>            Anoma Configuration          </li> <li>            Anoma Environment          </li> <li>            Anoma Message          </li> <li>            Commitment Behaviour          </li> <li>            Commitment Configuration          </li> <li>            Commitment Engine          </li> <li>            Commitment Environment          </li> <li>            Commitment Messages          </li> <li>            Decryption Behaviour          </li> <li>            Decryption Configuration          </li> <li>            Decryption Engine          </li> <li>            Decryption Environment          </li> <li>            Decryption Messages          </li> <li>            Encryption Behaviour          </li> <li>            Encryption Configuration          </li> <li>            Encryption Engine          </li> <li>            Encryption Environment          </li> <li>            Encryption Messages          </li> <li>            Engine          </li> <li>            Engine          </li> <li>            Engine Behaviour          </li> <li>            Engine Configuration          </li> <li>            Engine Environment          </li> <li>            Engine Simulator          </li> <li>            Executor Behaviour          </li> <li>            Executor Configuration          </li> <li>            Executor Engine          </li> <li>            Executor Environment          </li> <li>            Executor Messages          </li> <li>            Identity Management Behaviour          </li> <li>            Identity Management Configuration          </li> <li>            Identity Management Engine          </li> <li>            Identity Management Environment          </li> <li>            Identity Management Messages          </li> <li>            Local Key Value Storage Behaviour          </li> <li>            Local Key Value Storage Configuration          </li> <li>            Local Key Value Storage Engine          </li> <li>            Local Key Value Storage Environment          </li> <li>            Local Key Value Storage Messages          </li> <li>            Local Time Series Storage Behaviour          </li> <li>            Local Time Series Storage Configuration          </li> <li>            Local Time Series Storage Engine          </li> <li>            Local Time Series Storage Environment          </li> <li>            Local Time Series Storage Messages          </li> <li>            Logging Behaviour          </li> <li>            Logging Configuration          </li> <li>            Logging Engine          </li> <li>            Logging Environment          </li> <li>            Logging Messages          </li> <li>            Mempool Worker Behaviour          </li> <li>            Mempool Worker Configuration          </li> <li>            Mempool Worker Engine          </li> <li>            Mempool Worker Environment          </li> <li>            Mempool Worker Messages          </li> <li>            Naming Behaviour          </li> <li>            Naming Configuration          </li> <li>            Naming Engine          </li> <li>            Naming Environment          </li> <li>            Naming Messages          </li> <li>            Network Registry Behaviour          </li> <li>            Network Registry Configuration          </li> <li>            Network Registry Engine          </li> <li>            Network Registry Messages          </li> <li>            Pub/Sub Topic Behaviour          </li> <li>            Pub/Sub Topic Configuration          </li> <li>            Pub/Sub Topic Engine          </li> <li>            Pub/Sub Topic Environment          </li> <li>            Pub/Sub Topic Messages          </li> <li>            ReadsFor Behaviour          </li> <li>            ReadsFor Configuration          </li> <li>            ReadsFor Engine          </li> <li>            ReadsFor Environment          </li> <li>            ReadsFor Messages          </li> <li>            Router Behaviour          </li> <li>            Router Configuration          </li> <li>            Router Engine          </li> <li>            Router Environment          </li> <li>            Router Messages          </li> <li>            Runnable trait          </li> <li>            Shard Behaviour          </li> <li>            Shard Configuration          </li> <li>            Shard Engine          </li> <li>            Shard Environment          </li> <li>            Shard Messages          </li> <li>            SignsFor Behaviour          </li> <li>            SignsFor Configuration          </li> <li>            SignsFor Engine          </li> <li>            SignsFor Environment          </li> <li>            SignsFor Messages          </li> <li>            Storage Behaviour          </li> <li>            Storage Configuration          </li> <li>            Storage Engine          </li> <li>            Storage Environment          </li> <li>            Storage Messages          </li> <li>            Ticker Behaviour          </li> <li>            Ticker Configuration          </li> <li>            Ticker Engine          </li> <li>            Ticker Environment          </li> <li>            Ticker Messages          </li> <li>            Transport          </li> <li>            Transport Connection Behaviour          </li> <li>            Transport Connection Configuration          </li> <li>            Transport Connection Environment          </li> <li>            Transport Connection Messages          </li> <li>            Transport Protocol Behaviour          </li> <li>            Transport Protocol Configuration          </li> <li>            Transport Protocol Environment          </li> <li>            Transport Protocol Messages          </li> <li>            Transport behaviour          </li> <li>            Transport config          </li> <li>            Transport environment          </li> <li>            Transport messages          </li> <li>            Verification Behaviour          </li> <li>            Verification Configuration          </li> <li>            Verification Engine          </li> <li>            Verification Environment          </li> <li>            Verification Messages          </li> <li>            Wall Clock Behaviour          </li> <li>            Wall Clock Configuration          </li> <li>            Wall Clock Engine          </li> <li>            Wall Clock Environment          </li> <li>            Wall Clock Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:engine-definition","title":"engine-definition","text":"<ul> <li>            Commitment Engine          </li> <li>            Decryption Engine          </li> <li>            Encryption Engine          </li> <li>            Executor Engine          </li> <li>            Identity Management Engine          </li> <li>            Local Key Value Storage Engine          </li> <li>            Local Time Series Storage Engine          </li> <li>            Logging Engine          </li> <li>            Mempool Worker Engine          </li> <li>            Naming Engine          </li> <li>            Network Registry Engine          </li> <li>            Pub/Sub Topic Engine          </li> <li>            ReadsFor Engine          </li> <li>            Router Engine          </li> <li>            Shard Engine          </li> <li>            Storage Engine          </li> <li>            Ticker Engine          </li> <li>            Transport          </li> <li>            Verification Engine          </li> <li>            Wall Clock Engine          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:environment","title":"environment","text":"<ul> <li>            Anoma Environment          </li> <li>            Commitment Environment          </li> <li>            Decryption Environment          </li> <li>            Encryption Environment          </li> <li>            Engine Environment          </li> <li>            Executor Environment          </li> <li>            Identity Management Environment          </li> <li>            Local Key Value Storage Environment          </li> <li>            Local Time Series Storage Environment          </li> <li>            Logging Environment          </li> <li>            Mempool Worker Environment          </li> <li>            Naming Environment          </li> <li>            Network Registry Environment          </li> <li>            Pub/Sub Topic Environment          </li> <li>            ReadsFor Environment          </li> <li>            Router Environment          </li> <li>            Runnable trait          </li> <li>            Shard Environment          </li> <li>            SignsFor Environment          </li> <li>            Storage Environment          </li> <li>            Ticker Environment          </li> <li>            Transport Connection Environment          </li> <li>            Transport Protocol Environment          </li> <li>            Transport environment          </li> <li>            Verification Environment          </li> <li>            Wall Clock Environment          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:evm","title":"evm","text":"<ul> <li>            Ethereum Virtual Machine          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:example","title":"example","text":"<ul> <li>            Increment Example          </li> <li>            Template Engine          </li> <li>            Ticker Behaviour          </li> <li>            Ticker Configuration          </li> <li>            Ticker Engine          </li> <li>            Ticker Environment          </li> <li>            Ticker Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:executor","title":"executor","text":"<ul> <li>            Executor Behaviour          </li> <li>            Executor Configuration          </li> <li>            Executor Engine          </li> <li>            Executor Environment          </li> <li>            Executor Messages          </li> <li>            Runnable trait          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:hardware-subsystem","title":"hardware-subsystem","text":"<ul> <li>            Local Key Value Storage Behaviour          </li> <li>            Local Key Value Storage Configuration          </li> <li>            Local Key Value Storage Engine          </li> <li>            Local Key Value Storage Environment          </li> <li>            Local Key Value Storage Messages          </li> <li>            Local Time Series Storage Behaviour          </li> <li>            Local Time Series Storage Configuration          </li> <li>            Local Time Series Storage Engine          </li> <li>            Local Time Series Storage Environment          </li> <li>            Local Time Series Storage Messages          </li> <li>            Logging Behaviour          </li> <li>            Logging Configuration          </li> <li>            Logging Engine          </li> <li>            Logging Environment          </li> <li>            Logging Messages          </li> <li>            Wall Clock Behaviour          </li> <li>            Wall Clock Configuration          </li> <li>            Wall Clock Engine          </li> <li>            Wall Clock Environment          </li> <li>            Wall Clock Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:identity","title":"identity","text":"<ul> <li>            Identity Architecture Types          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:identity-management","title":"identity-management","text":"<ul> <li>            Identity Management Behaviour          </li> <li>            Identity Management Configuration          </li> <li>            Identity Management Engine          </li> <li>            Identity Management Environment          </li> <li>            Identity Management Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:identity-subsystem","title":"identity-subsystem","text":"<ul> <li>            Commitment Behaviour          </li> <li>            Commitment Configuration          </li> <li>            Commitment Engine          </li> <li>            Commitment Environment          </li> <li>            Commitment Messages          </li> <li>            Decryption Behaviour          </li> <li>            Decryption Configuration          </li> <li>            Decryption Engine          </li> <li>            Decryption Environment          </li> <li>            Decryption Messages          </li> <li>            Encryption Behaviour          </li> <li>            Encryption Configuration          </li> <li>            Encryption Engine          </li> <li>            Encryption Environment          </li> <li>            Encryption Messages          </li> <li>            Identity Management Behaviour          </li> <li>            Identity Management Configuration          </li> <li>            Identity Management Engine          </li> <li>            Identity Management Environment          </li> <li>            Identity Management Messages          </li> <li>            Naming Behaviour          </li> <li>            Naming Configuration          </li> <li>            Naming Engine          </li> <li>            Naming Environment          </li> <li>            Naming Messages          </li> <li>            ReadsFor Behaviour          </li> <li>            ReadsFor Configuration          </li> <li>            ReadsFor Engine          </li> <li>            ReadsFor Environment          </li> <li>            ReadsFor Messages          </li> <li>            SignsFor Behaviour          </li> <li>            SignsFor Configuration          </li> <li>            SignsFor Engine          </li> <li>            SignsFor Environment          </li> <li>            SignsFor Messages          </li> <li>            Verification Behaviour          </li> <li>            Verification Configuration          </li> <li>            Verification Engine          </li> <li>            Verification Environment          </li> <li>            Verification Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:local-key-value-storage","title":"local-key-value-storage","text":"<ul> <li>            Local Key Value Storage Behaviour          </li> <li>            Local Key Value Storage Configuration          </li> <li>            Local Key Value Storage Engine          </li> <li>            Local Key Value Storage Environment          </li> <li>            Local Key Value Storage Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:local-time-series-storage","title":"local-time-series-storage","text":"<ul> <li>            Local Time Series Storage Behaviour          </li> <li>            Local Time Series Storage Configuration          </li> <li>            Local Time Series Storage Engine          </li> <li>            Local Time Series Storage Environment          </li> <li>            Local Time Series Storage Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:logging","title":"logging","text":"<ul> <li>            Logging Behaviour          </li> <li>            Logging Configuration          </li> <li>            Logging Engine          </li> <li>            Logging Environment          </li> <li>            Logging Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:mailboxes","title":"mailboxes","text":"<ul> <li>            Messages &amp; Mailboxes          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:mempool-worker","title":"mempool-worker","text":"<ul> <li>            Mempool Worker Behaviour          </li> <li>            Mempool Worker Configuration          </li> <li>            Mempool Worker Engine          </li> <li>            Mempool Worker Environment          </li> <li>            Mempool Worker Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:mermaid","title":"mermaid","text":"<ul> <li>            Engine Visualizer          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:message-types","title":"message-types","text":"<ul> <li>            Anoma Message          </li> <li>            Commitment Messages          </li> <li>            Decryption Messages          </li> <li>            Encryption Messages          </li> <li>            Executor Messages          </li> <li>            Identity Management Messages          </li> <li>            Local Key Value Storage Messages          </li> <li>            Local Time Series Storage Messages          </li> <li>            Logging Messages          </li> <li>            Mempool Worker Messages          </li> <li>            Messages &amp; Mailboxes          </li> <li>            Naming Messages          </li> <li>            Network Registry Messages          </li> <li>            Pub/Sub Topic Messages          </li> <li>            ReadsFor Messages          </li> <li>            Router Messages          </li> <li>            Shard Messages          </li> <li>            SignsFor Messages          </li> <li>            Storage Messages          </li> <li>            Ticker Messages          </li> <li>            Transport Connection Messages          </li> <li>            Transport Protocol Messages          </li> <li>            Transport messages          </li> <li>            Verification Messages          </li> <li>            Wall Clock Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:naming","title":"naming","text":"<ul> <li>            Naming Behaviour          </li> <li>            Naming Configuration          </li> <li>            Naming Engine          </li> <li>            Naming Environment          </li> <li>            Naming Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:network-subsystem","title":"network-subsystem","text":"<ul> <li>            Network Registry Behaviour          </li> <li>            Network Registry Configuration          </li> <li>            Network Registry Engine          </li> <li>            Network Registry Environment          </li> <li>            Network Registry Messages          </li> <li>            Pub/Sub Topic Behaviour          </li> <li>            Pub/Sub Topic Configuration          </li> <li>            Pub/Sub Topic Engine          </li> <li>            Pub/Sub Topic Environment          </li> <li>            Pub/Sub Topic Messages          </li> <li>            Router          </li> <li>            Router Behaviour          </li> <li>            Router Configuration          </li> <li>            Router Engine          </li> <li>            Router Environment          </li> <li>            Router Messages          </li> <li>            Storage          </li> <li>            Storage Behaviour          </li> <li>            Storage Configuration          </li> <li>            Storage Engine          </li> <li>            Storage Environment          </li> <li>            Storage Messages          </li> <li>            Transport          </li> <li>            Transport          </li> <li>            Transport Connection Behaviour          </li> <li>            Transport Connection Configuration          </li> <li>            Transport Connection Environment          </li> <li>            Transport Connection Messages          </li> <li>            Transport Protocol Behaviour          </li> <li>            Transport Protocol Configuration          </li> <li>            Transport Protocol Environment          </li> <li>            Transport Protocol Messages          </li> <li>            Transport behaviour          </li> <li>            Transport config          </li> <li>            Transport environment          </li> <li>            Transport messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:nockma","title":"nockma","text":"<ul> <li>            Increment Example          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:node","title":"node","text":"<ul> <li>            Node          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:node-architecture","title":"node-architecture","text":"<ul> <li>            Anoma Configuration          </li> <li>            Anoma Environment          </li> <li>            Anoma Message          </li> <li>            Basics          </li> <li>            Commitment Behaviour          </li> <li>            Commitment Configuration          </li> <li>            Commitment Engine          </li> <li>            Commitment Environment          </li> <li>            Commitment Messages          </li> <li>            Crypto          </li> <li>            Decryption Behaviour          </li> <li>            Decryption Configuration          </li> <li>            Decryption Engine          </li> <li>            Decryption Environment          </li> <li>            Decryption Messages          </li> <li>            Encryption Behaviour          </li> <li>            Encryption Configuration          </li> <li>            Encryption Engine          </li> <li>            Encryption Environment          </li> <li>            Encryption Messages          </li> <li>            Engine          </li> <li>            Engine          </li> <li>            Engine Behaviour          </li> <li>            Engine Configuration          </li> <li>            Engine Environment          </li> <li>            Executor Behaviour          </li> <li>            Executor Configuration          </li> <li>            Executor Engine          </li> <li>            Executor Environment          </li> <li>            Executor Messages          </li> <li>            Identities          </li> <li>            Identity Management Behaviour          </li> <li>            Identity Management Configuration          </li> <li>            Identity Management Engine          </li> <li>            Identity Management Environment          </li> <li>            Identity Management Messages          </li> <li>            Local Key Value Storage Behaviour          </li> <li>            Local Key Value Storage Configuration          </li> <li>            Local Key Value Storage Engine          </li> <li>            Local Key Value Storage Environment          </li> <li>            Local Key Value Storage Messages          </li> <li>            Local Time Series Storage Behaviour          </li> <li>            Local Time Series Storage Configuration          </li> <li>            Local Time Series Storage Engine          </li> <li>            Local Time Series Storage Environment          </li> <li>            Local Time Series Storage Messages          </li> <li>            Logging Behaviour          </li> <li>            Logging Configuration          </li> <li>            Logging Engine          </li> <li>            Logging Environment          </li> <li>            Logging Messages          </li> <li>            Mempool Worker Behaviour          </li> <li>            Mempool Worker Configuration          </li> <li>            Mempool Worker Engine          </li> <li>            Mempool Worker Environment          </li> <li>            Mempool Worker Messages          </li> <li>            Messages &amp; Mailboxes          </li> <li>            Naming Behaviour          </li> <li>            Naming Configuration          </li> <li>            Naming Engine          </li> <li>            Naming Environment          </li> <li>            Naming Messages          </li> <li>            Network Registry Behaviour          </li> <li>            Network Registry Configuration          </li> <li>            Network Registry Engine          </li> <li>            Network Registry Environment          </li> <li>            Network Registry Messages          </li> <li>            Node          </li> <li>            Pub/Sub Topic Behaviour          </li> <li>            Pub/Sub Topic Configuration          </li> <li>            Pub/Sub Topic Engine          </li> <li>            Pub/Sub Topic Environment          </li> <li>            Pub/Sub Topic Messages          </li> <li>            ReadsFor Behaviour          </li> <li>            ReadsFor Configuration          </li> <li>            ReadsFor Engine          </li> <li>            ReadsFor Environment          </li> <li>            ReadsFor Messages          </li> <li>            Router          </li> <li>            Router Behaviour          </li> <li>            Router Configuration          </li> <li>            Router Engine          </li> <li>            Router Environment          </li> <li>            Router Messages          </li> <li>            Runnable trait          </li> <li>            Shard Behaviour          </li> <li>            Shard Configuration          </li> <li>            Shard Engine          </li> <li>            Shard Environment          </li> <li>            Shard Messages          </li> <li>            SignsFor Behaviour          </li> <li>            SignsFor Configuration          </li> <li>            SignsFor Engine          </li> <li>            SignsFor Environment          </li> <li>            SignsFor Messages          </li> <li>            Storage          </li> <li>            Storage Behaviour          </li> <li>            Storage Configuration          </li> <li>            Storage Engine          </li> <li>            Storage Environment          </li> <li>            Storage Messages          </li> <li>            Subsystem          </li> <li>            Template Engine          </li> <li>            Ticker Behaviour          </li> <li>            Ticker Configuration          </li> <li>            Ticker Engine          </li> <li>            Ticker Environment          </li> <li>            Ticker Messages          </li> <li>            Transport          </li> <li>            Transport          </li> <li>            Transport Connection Behaviour          </li> <li>            Transport Connection Configuration          </li> <li>            Transport Connection Environment          </li> <li>            Transport Connection Messages          </li> <li>            Transport Protocol Behaviour          </li> <li>            Transport Protocol Configuration          </li> <li>            Transport Protocol Environment          </li> <li>            Transport Protocol Messages          </li> <li>            Transport behaviour          </li> <li>            Transport config          </li> <li>            Transport environment          </li> <li>            Transport messages          </li> <li>            Verification Behaviour          </li> <li>            Verification Configuration          </li> <li>            Verification Engine          </li> <li>            Verification Environment          </li> <li>            Verification Messages          </li> <li>            Wall Clock Behaviour          </li> <li>            Wall Clock Configuration          </li> <li>            Wall Clock Engine          </li> <li>            Wall Clock Environment          </li> <li>            Wall Clock Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:nullifier","title":"nullifier","text":"<ul> <li>            Index          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:ordering","title":"ordering","text":"<ul> <li>            Mempool Worker Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:ordering-subsystem","title":"ordering-subsystem","text":"<ul> <li>            Executor Behaviour          </li> <li>            Executor Configuration          </li> <li>            Executor Engine          </li> <li>            Executor Environment          </li> <li>            Executor Messages          </li> <li>            Mempool Worker Behaviour          </li> <li>            Mempool Worker Configuration          </li> <li>            Mempool Worker Engine          </li> <li>            Mempool Worker Environment          </li> <li>            Runnable trait          </li> <li>            Shard Behaviour          </li> <li>            Shard Configuration          </li> <li>            Shard Engine          </li> <li>            Shard Environment          </li> <li>            Shard Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:prelude","title":"prelude","text":"<ul> <li>            Anoma Configuration          </li> <li>            Anoma Environment          </li> <li>            Anoma Message          </li> <li>            Basics          </li> <li>            Crypto          </li> <li>            Engine          </li> <li>            Engine Behaviour          </li> <li>            Engine Configuration          </li> <li>            Engine Environment          </li> <li>            Identities          </li> <li>            Messages &amp; Mailboxes          </li> <li>            Router          </li> <li>            Storage          </li> <li>            Transport          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:protocol","title":"protocol","text":"<ul> <li>            Index          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:protocol-adapter","title":"protocol-adapter","text":"<ul> <li>            Ethereum Virtual Machine          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:pub-sub-topic","title":"pub-sub-topic","text":"<ul> <li>            Pub/Sub Topic Behaviour          </li> <li>            Pub/Sub Topic Configuration          </li> <li>            Pub/Sub Topic Engine          </li> <li>            Pub/Sub Topic Environment          </li> <li>            Pub/Sub Topic Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:readsfor","title":"readsfor","text":"<ul> <li>            ReadsFor Behaviour          </li> <li>            ReadsFor Configuration          </li> <li>            ReadsFor Engine          </li> <li>            ReadsFor Environment          </li> <li>            ReadsFor Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:registry","title":"registry","text":"<ul> <li>            Network Registry Behaviour          </li> <li>            Network Registry Configuration          </li> <li>            Network Registry Engine          </li> <li>            Network Registry Environment          </li> <li>            Network Registry Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:resource-logic","title":"resource logic","text":"<ul> <li>            Index          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:resource-machine","title":"resource-machine","text":"<ul> <li>            Ethereum Virtual Machine          </li> <li>            Index          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:router","title":"router","text":"<ul> <li>            Router          </li> <li>            Router Behaviour          </li> <li>            Router Configuration          </li> <li>            Router Engine          </li> <li>            Router Environment          </li> <li>            Router Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:shard","title":"shard","text":"<ul> <li>            Shard Behaviour          </li> <li>            Shard Configuration          </li> <li>            Shard Engine          </li> <li>            Shard Environment          </li> <li>            Shard Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:signsfor","title":"signsfor","text":"<ul> <li>            SignsFor Behaviour          </li> <li>            SignsFor Configuration          </li> <li>            SignsFor Engine          </li> <li>            SignsFor Environment          </li> <li>            SignsFor Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:simulator","title":"simulator","text":"<ul> <li>            Engine Simulator          </li> <li>            Engine Visualizer          </li> <li>            Increment Example          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:storage","title":"storage","text":"<ul> <li>            Storage          </li> <li>            Storage Behaviour          </li> <li>            Storage Configuration          </li> <li>            Storage Engine          </li> <li>            Storage Environment          </li> <li>            Storage Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:subsystem","title":"subsystem","text":"<ul> <li>            Subsystem          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:system-architecture","title":"system-architecture","text":"<ul> <li>            Identity Architecture Types          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:ticker","title":"ticker","text":"<ul> <li>            Ticker Behaviour          </li> <li>            Ticker Configuration          </li> <li>            Ticker Engine          </li> <li>            Ticker Environment          </li> <li>            Ticker Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:transport","title":"transport","text":"<ul> <li>            Transport          </li> <li>            Transport          </li> <li>            Transport Connection Behaviour          </li> <li>            Transport Connection Configuration          </li> <li>            Transport Connection Environment          </li> <li>            Transport Connection Messages          </li> <li>            Transport Protocol Behaviour          </li> <li>            Transport Protocol Configuration          </li> <li>            Transport Protocol Environment          </li> <li>            Transport Protocol Messages          </li> <li>            Transport behaviour          </li> <li>            Transport config          </li> <li>            Transport environment          </li> <li>            Transport messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:types","title":"types","text":"<ul> <li>            Anoma Configuration          </li> <li>            Anoma Environment          </li> <li>            Anoma Message          </li> <li>            Basics          </li> <li>            Crypto          </li> <li>            Engine          </li> <li>            Engine Behaviour          </li> <li>            Engine Configuration          </li> <li>            Engine Environment          </li> <li>            Identities          </li> <li>            Messages &amp; Mailboxes          </li> <li>            Router          </li> <li>            Storage          </li> <li>            Transport          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:verification","title":"verification","text":"<ul> <li>            Verification Behaviour          </li> <li>            Verification Configuration          </li> <li>            Verification Engine          </li> <li>            Verification Environment          </li> <li>            Verification Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:visualizer","title":"visualizer","text":"<ul> <li>            Engine Visualizer          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:wall-clock-engine","title":"wall-clock-engine","text":"<ul> <li>            Wall Clock Behaviour          </li> <li>            Wall Clock Configuration          </li> <li>            Wall Clock Engine          </li> <li>            Wall Clock Environment          </li> <li>            Wall Clock Messages          </li> </ul>","tags":["index"]},{"location":"indexes/tags.html#tag:work-in-progress","title":"work-in-progress","text":"<ul> <li>            Engine Simulator          </li> <li>            Ethereum Virtual Machine          </li> <li>            Increment Example          </li> <li>            Messages &amp; Mailboxes          </li> </ul>","tags":["index"]},{"location":"tutorial/branch.html","title":"Git branching strategy","text":"<p>The general workflow is to branch off from the latest version's branch, perform your changes, open a pull request, and merge your updates.</p>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#branching-strategy","title":"Branching strategy","text":"","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#for-changes-to-the-latest-version","title":"For changes to the latest version","text":"<p>For changes to the latest version, branch off from <code>main</code>. Name your branch by prefixing your name and an issue identifier, like <code>your-name/issue-identifier</code>.</p> <pre><code>git fetch\ngit checkout -b your-name/issue-identifier origin/main\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#for-changes-to-older-published-versions","title":"For changes to older published versions","text":"<p>For patching older versions, branch off from the specific version branch. Published versions follow the pattern <code>vX</code>, where <code>X</code> is the version number. For example, say the latest version is <code>v0.1.0</code>.</p> <p>Name your branch by prefixing your name and a patch topic, like <code>your-name/patch-topic</code>.</p> <pre><code>git checkout -b your-name/patch-topic v0.1.0\n</code></pre> <p>The git graph will look like:</p> <pre><code>%%{init: { 'theme': 'neutral' } }%%\ngitGraph:\n    commit\n    branch vX\n    checkout vX\n    commit\n    branch your-name/issue-identifier\n    checkout your-name/issue-identifier\n    commit\n    checkout vX\n    merge your-name/issue-identifier</code></pre> <p>So, if your PR is merged, the changes will be incorporated into the version branch and on the website.</p>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#pushing-changes","title":"Pushing changes","text":"<p>When pushing changes for the first time in a new branch, set the upstream tracking branch:</p> <pre><code>git push -u origin some-branch:some-branch\n</code></pre> <p>Afterwards, for subsequent pushes the following is sufficient: <pre><code>git push\n</code></pre></p>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#rebasing-your-work","title":"Rebasing your work","text":"<p>Every once in a while, you should rebase your branch onto the base branch, if the current version has been updated. This will incorporate the latest changes from the base branch into your branch. The steps to rebase are usually the following.</p> <ul> <li>Switch to your working branch:<pre><code>git checkout your-name/issue-identifier\n</code></pre> </li> </ul> <ul> <li>Initiate the rebase onto the target branch:<pre><code>git pull origin main --rebase\n</code></pre> <p>Or merge the changes from the base branch which is convenient most of the   time:</p> <pre><code>git merge main\n</code></pre> </li> </ul>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#resolve-conflicts","title":"Resolve conflicts","text":"<ul> <li>Git will pause for conflict resolution.</li> <li> <p>After resolving each conflict:</p> <pre><code>git rebase --continue\n</code></pre> </li> </ul> <ul> <li> <p>To stop the rebase process:</p> <pre><code>git rebase --abort\n</code></pre> </li> </ul>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#push-your-changes","title":"Push your changes","text":"<ul> <li>Once rebase is complete, push changes:<pre><code>git push origin your-name/issue-identifier\n</code></pre> </li> </ul> <ul> <li>A force push may be required:<pre><code>git push origin your-name/issue-identifier --force-with-lease\n</code></pre> </li> </ul>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#important-notes","title":"Important notes","text":"<ul> <li>Ensure you are on the correct branch before making changes.</li> <li>Regularly update your branch to minimise conflicts.</li> <li>Ask for help if you encounter any issues to the maintainers.</li> </ul>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#merging-prs","title":"Merging PRs","text":"<p>Before a PR can be merged into the <code>main</code> branch, it must be able to build the whole codebase. The CI checks this automatically, and can be also verified manually:</p> <p>First, we must check the Juvix codebase, running the following command:</p> <pre><code>juvix typecheck docs/everything.juvix.md\n</code></pre> <p>Next, we must verify the MkDocs site build by running the following command:</p> <pre><code>uv run mkdocs build\n</code></pre> <p>or with <code>just</code></p> <pre><code>just build\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#integration-branches-for-complex-changes","title":"Integration branches for complex changes","text":"<p>When making complex changes that consist of a set of interdependent changes, it's best to split them up into smaller PRs that each address a single topic.</p> <p>For example, making a change to a type can be in one PR, a change to a different type in a second PR, and applying the type changes in the rest of the code base in a third one. In this case, branch 3 needs to merge branch 1 &amp; 2 first.</p> <p>We also need to create an integration branch, which becomes the base branch for all the interdependent PRs, and a corresponding integration PR to be merged into the <code>main</code> branch.</p> <p>On GitHub, make sure to include the list of auxiliary PRs as part of the description of the integration PR.</p> <p>This way the topic branches need not be able to build the whole codebase, while the integration branch must be able to build it once all the topic branches are merged into it.</p> <p>A possible diagram of the integration branch and topic branches is the following, assuming the integration branch is <code>example/integration</code> against <code>main</code>, and the topic branches are <code>example/topic-1</code> against <code>main</code>, <code>example/topic-2</code> against <code>main</code>, and <code>example/topic-3</code> against <code>main</code>. The topic branches are squashed-and-merged into the integration branch.</p> <pre><code>%%{init: { 'theme': 'neutral' } }%%\ngitGraph:\n    commit\n    branch example/topic-1\n    checkout example/topic-1\n    commit\n    checkout main\n    branch example/topic-2\n    checkout example/topic-2\n    commit\n    checkout main\n    branch example/integration\n    checkout example/integration\n    merge example/topic-1\n    merge example/topic-2\n    commit \"Fix merge conflicts\"\n    checkout main\n    merge example/integration</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#fetch-the-latest-updates","title":"Fetch the latest updates","text":"<pre><code>git fetch\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#create-integration-branch","title":"Create integration branch","text":"<pre><code>git branch example/integration origin/main\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#create-topic-branches","title":"Create topic branches","text":"<pre><code>git branch example/topic-1 example/integration\ngit branch example/topic-2 example/integration\ngit branch example/topic-3 example/integration\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#merge-dependencies","title":"Merge dependencies","text":"<pre><code>git checkout example/topic-3\ngit merge example/topic-1\ngit merge example/topic-2\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#using-git-worktrees","title":"Using Git Worktrees","text":"<p>When working on multiple branches simultaneously, git worktrees come handy. Here's how to use them.</p>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#fetch-the-latest-updates_1","title":"Fetch the latest updates","text":"<pre><code>git fetch\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#create-a-branch","title":"Create a branch","text":"<pre><code>git branch some-branch origin/main\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/branch.html#create-a-worktree-for-the-branch","title":"Create a Worktree for the branch","text":"<p>Either inside the repo starting with a dot (to avoid build issues):</p> <pre><code>git worktree add /path/to/repo/.tree/some-branch some-branch\n</code></pre> <p>Or outside the repo:</p> <pre><code>git worktree add /path/to/repo-some-branch some-branch\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/changelog.html","title":"Managing the Changelog","text":"<p>We now use <code>Commitizen</code> to manage our changelog entries. This simplifies the process and ensures consistent formatting. The <code>Commitizen</code> binary should be available after installation.</p>","tags":["tutorial","changelog"],"boost":3},{"location":"tutorial/changelog.html#adding-a-new-unreleased-entry","title":"Adding a New Unreleased Entry","text":"<p>To add a new changelog entry, use the <code>cz</code> command provided by <code>Commitizen</code>. This will guide you through the process interactively.</p>","tags":["tutorial","changelog"],"boost":3},{"location":"tutorial/changelog.html#using-commitizen","title":"Using Commitizen","text":"","tags":["tutorial","changelog"],"boost":3},{"location":"tutorial/changelog.html#available-types","title":"Available Types","text":"<p>When prompted, choose one of these types for your commit message:</p> <ul> <li><code>feat</code> - For new features</li> <li><code>fix</code> - For bug fixes</li> <li><code>docs</code> - For documentation changes</li> <li><code>style</code> - For code style changes (formatting, missing semi-colons, etc.)</li> <li><code>refactor</code> - For code changes that neither fix a bug nor add a feature</li> <li><code>perf</code> - For performance improvements</li> <li><code>test</code> - For adding or correcting tests</li> <li><code>chore</code> - For changes to the build process or auxiliary tools</li> </ul>","tags":["tutorial","changelog"],"boost":3},{"location":"tutorial/changelog.html#recommended-commit-message-format","title":"Recommended Commit Message Format","text":"<p>For consistency, follow the prompts to:</p> <ul> <li>Specify the type of change</li> <li>Provide a concise description of the change</li> <li>Optionally, include the issue number if the change is related to an issue</li> </ul> <p>More information about the command syntax can be found in the Commitizen documentation.</p>","tags":["tutorial","changelog"],"boost":3},{"location":"tutorial/commit_checks.html","title":"Run pre-commit checks","text":"<p>Pre-commit hooks are scripts that run before each commit to ensure code quality by checking for common issues.</p>","tags":["tutorial","conventions"],"boost":3},{"location":"tutorial/commit_checks.html#running-pre-commit-checks","title":"Running pre-commit checks","text":"<p>After installing the development tools, you can, for example, invoke all checks, by running the following command:</p> <pre><code>uv run pre-commit -- run --all-files\n</code></pre> <p>Or shorter:</p> <pre><code>just check\n</code></pre>","tags":["tutorial","conventions"],"boost":3},{"location":"tutorial/file_naming.html","title":"<code>snake_case</code> convention for naming files and folders","text":"<p>The Anoma Specification uses the <code>snake_case</code> convention for naming files and folders.</p>","tags":["tutorial","conventions"],"boost":3},{"location":"tutorial/file_naming.html#guidelines","title":"Guidelines","text":"<ul> <li>Use lowercase letters.</li> <li>Separate words with underscores <code>_</code>, instead of dashes <code>-</code> or camel case.</li> <li>No special characters or spaces.</li> </ul>","tags":["tutorial","conventions"],"boost":3},{"location":"tutorial/file_naming.html#pros","title":"Pros","text":"<ul> <li>Readability: Improves readability by clearly separating words in names, making   code more understandable.</li> <li>Consistency: Creates a uniform naming style throughout the codebase.</li> <li>Compatibility: Widely supported across different programming languages and   platforms, no issues with case sensitivity.</li> </ul>","tags":["tutorial","conventions"],"boost":3},{"location":"tutorial/file_naming.html#cons","title":"Cons","text":"<ul> <li>Length: Can make names longer.</li> <li>Visual Clutter: The underscores can create visual clutter, especially in   longer names. We suffer from this, specially in engine's description files.</li> </ul> <p>Info</p> <p>If you find any file or folder that does not follow this convention, please create an issue or a pull request to fix it. Thank you for your help!</p>","tags":["tutorial","conventions"],"boost":3},{"location":"tutorial/juvix.html","title":"Render Juvix code","text":"<p>Another feature of the Anoma documentation is the inclusion of Juvix code throughout its Markdown support. Here we assume you have Juvix already installed.</p> <p>A Juvix Markdown file is a file with extension <code>.juvix.md</code>. These files are preprocesses by the Juvix compiler to generate the final Markdown file. For this website, we are using <code>mkdocs-juvix-plugin</code>.</p>","tags":["tutorial","juvix"]},{"location":"tutorial/juvix.html#juvix-markdown-file-structure","title":"Juvix Markdown file structure","text":"<p>Very important to note is that the first Juvix code block must declare a module with the name of the file, and each block should be a sequence of well-defined expressions. This means submodules cannot be split across blocks. The name of  module must follow the folder structure of the file is in. For example, the  file <code>tutorial/basics.juvix.md</code> must declare the module <code>tutorial.basics</code>.</p> <pre><code>```juvix\nmodule tutorial.basics;\n-- ...\n```</code></pre> <p>Refer to the <code>everything.juvix.md</code> file located in the <code>docs</code> folder to see an example.</p>","tags":["tutorial","juvix"]},{"location":"tutorial/juvix.html#hide-juvix-code-blocks","title":"Hide Juvix code blocks","text":"<p>Juvix code blocks come with a few extra features, such as the ability to hide the code block from the final output. This is done by adding the <code>hide</code> attribute to the code block. For example:</p> <pre><code>```juvix hide\nmodule tutorial.basics;\n-- ...\n```</code></pre>","tags":["tutorial","juvix"]},{"location":"tutorial/juvix.html#extract-inner-module-statements","title":"Extract inner module statements","text":"<p>Another feature is the ability to extract inner module statements from the code block. This is done by adding the <code>extract-module-statements</code> attribute to the code block. This option can be accompanied by a number to indicate the number of statements to extract. For example, the following would only display the content inside the module <code>B</code>, that is, the module <code>C</code>.</p> <pre><code>```juvix extract-module-statements\nmodule B;\nmodule C;\n-- ...\n```</code></pre>","tags":["tutorial","juvix"]},{"location":"tutorial/juvix.html#snippets-of-juvix-code","title":"Snippets of Juvix code","text":"<p>You can also include snippets of Juvix code in your Markdown files. This is done by adding the <code>--8&lt;--</code> comment followed by the path to the file, and optionally a snippet identifier.</p> <p>Note</p> <p>If the path of the file ends with <code>!</code>, the raw content of the file will be included. Otherwise, for Juvix Markdown files, the content will be preprocessed by the Juvix compiler and then the generated HTML will be included.</p> <p>Snippet identifier</p> <p>To use a snippet identifier, you must wrap the Juvix code block with the syntax <code>&lt;!-- --8&lt;-- [start:snippet_identifier] --&gt;</code> and <code>&lt;!-- --8&lt;-- [end:snippet_identifier] --&gt;</code>. This technique is useful for including specific sections of a file. Alternatively, you use the standard <code>--8&lt;--</code> markers within the code and extract the snippet by appending a ! at the end of the path.</p>","tags":["tutorial","juvix"]},{"location":"tutorial/principles_and_guidelines.html","title":"Global principles and guidelines for writing Anoma Specification documentation","text":"","tags":["tutorial"]},{"location":"tutorial/principles_and_guidelines.html#principles","title":"Principles","text":"","tags":["tutorial"]},{"location":"tutorial/principles_and_guidelines.html#clarity","title":"Clarity","text":"<p>Make every page clear and concise. Footnotes may be used to add context. Additional notes that exceed a paragraph may deserve to be put into a separate file (and thus will appear in the navigation bar).</p>","tags":["tutorial"]},{"location":"tutorial/principles_and_guidelines.html#dont-repeat-yourself","title":"Don't repeat yourself!","text":"<p>Do not paste any copied material. Instead, include the material, e.g., via snippeting. The only exception is material for which there is no established method for inclusion; in this case, include the material inside a todo note <code>!!! todo \"unrepeat this\"</code>, paired with a reference to its source.</p>","tags":["tutorial"]},{"location":"tutorial/principles_and_guidelines.html#consistency","title":"Consistency","text":"<p>Terms from the glossary must be used consistently throughout the specification. Where applicable, adhere to naming schemes.</p>","tags":["tutorial"]},{"location":"tutorial/principles_and_guidelines.html#style","title":"Style","text":"<p>Conform to style guides, unless this would lead to inconsistency.</p>","tags":["tutorial"]},{"location":"tutorial/principles_and_guidelines.html#citations","title":"Citations","text":"<p>Use citations to refer to articles, books, and similar publications.</p>","tags":["tutorial"]},{"location":"tutorial/principles_and_guidelines.html#guidelines","title":"Guidelines","text":"","tags":["tutorial"]},{"location":"tutorial/principles_and_guidelines.html#accessibility","title":"Accessibility","text":"<p>The specification should be accessible to its intended readership, which should encompass at least the members of the Anoma engineering team.</p>","tags":["tutorial"]},{"location":"tutorial/principles_and_guidelines.html#internal-and-external-linking","title":"Internal and external linking","text":"<p>If you have a link for something, please use it. Chances are that it improves accessibility and moreover it helps discover inconsistencies. Use wikilinks for internal links and URL links (<code>[target](URL)</code>) only for external material (or if wikilinks do not work as expected).</p>","tags":["tutorial"]},{"location":"tutorial/principles_and_guidelines.html#implementability","title":"Implementability","text":"<p>The specification should keep design decisions to a minimum, but design decisions that are left to the potential implementer on purpose should be discussed in footnotes or notes.</p>","tags":["tutorial"]},{"location":"tutorial/versioning.html","title":"Versioning","text":"<p>The Anoma Specification follows semantic versioning.</p> <pre><code>MAJOR.MINOR.PATCH\n</code></pre> <ul> <li>MAJOR version when you make incompatible API changes</li> <li>MINOR version when you add functionality in a backward compatible manner</li> <li>PATCH version when you make backward compatible bug fixes</li> </ul>","tags":["tutorial","conventions","versioning"]},{"location":"tutorial/versioning.html#more-on-versioning-criteria","title":"More on versioning criteria","text":"<ul> <li>Major version (X.0.0): Incremented for backwards-incompatible changes, like:<p>- Breaking changes to core interfaces or types   - Removal of deprecated functionality   - Major architectural changes</p> </li> </ul> <ul> <li>Minor version (0.X.0): Incremented for backwards-compatible feature additions:<p>- New engines, message types, or behaviours   - New functionality that doesn't break existing code   - Deprecation notices for future breaking changes</p> </li> </ul> <ul> <li>Patch version (0.0.X): Incremented for backwards-compatible bug fixes:<p>- Documentation improvements   - Bug fixes that don't change interfaces   - Minor code clean-up and refactoring</p> </li> </ul>","tags":["tutorial","conventions","versioning"]},{"location":"tutorial/versioning.html#preparing-a-new-version","title":"Preparing a new version","text":"<ul> <li> Update <code>mkdocs.yml</code></li> <li> Update <code>docs/Package.juvix</code></li> <li> Update <code>docs/references/ref.bib</code></li> <li> Make sure to run <code>just sync</code> to update the dependencies and <code>just build</code> to check that the code is still typechecking.</li> <li> Git tag the new version</li> <li> Release a new changelog entry</li> </ul>","tags":["tutorial","conventions","versioning"]},{"location":"tutorial/versioning.html#update-mkdocsyml","title":"Update <code>mkdocs.yml</code>","text":"<p>Update the <code>site_version</code> to the new version.</p> mkdocs.yml<pre><code>- site_version: !ENV [SITE_VERSION, \"v0.1.0\"]\n+ site_version: !ENV [SITE_VERSION, \"v0.1.1\"]\n</code></pre>","tags":["tutorial","conventions","versioning"]},{"location":"tutorial/versioning.html#update-nspec-juvix-package-version","title":"Update <code>nspec</code> Juvix package version","text":"docs/Package.juvix<pre><code>package : Package :=\n  defaultPackage@{\n    name := \"nspec\";\n-    version := mkVersion 0 1 0;\n+    version := mkVersion 0 1 1;\n    dependencies :=\n      [github \"anoma\" \"juvix-stdlib\" \"v0.6.0\"; github \"anoma\" \"juvix-containers\" \"v0.14.1\"]\n  };\n</code></pre>","tags":["tutorial","conventions","versioning"]},{"location":"tutorial/versioning.html#update-docsrefbib","title":"Update <code>docs/ref.bib</code>","text":"<p>Update the version of the <code>nspec</code> package in the <code>ref.bib</code> file.</p> docs/ref.bib<pre><code>@software{nspec,\n  author = {Anoma},\n  title = {Anoma Specification},\n-  version = {0.1.0},\n+  version = {0.1.1},\n  url = {https://github.com/anoma/nspec}\n}\n</code></pre>","tags":["tutorial","conventions","versioning"]},{"location":"tutorial/versioning.html#update-version","title":"Update <code>VERSION</code>","text":"VERSION<pre><code>-0.1.0\n+0.1.1\n</code></pre>","tags":["tutorial","conventions","versioning"]},{"location":"tutorial/versioning.html#update-pyprojecttoml","title":"Update <code>pyproject.toml</code>","text":"pyproject.toml<pre><code>- version = \"0.1.0\"\n+ version = \"0.1.1\"\n</code></pre>","tags":["tutorial","conventions","versioning"]},{"location":"tutorial/versioning.html#git-tag-the-new-version","title":"Git tag the new version","text":"<pre><code>git tag v0.1.1\n</code></pre>","tags":["tutorial","conventions","versioning"]},{"location":"tutorial/versioning.html#release-a-new-changelog-entry","title":"Release a new changelog entry","text":"<p>Follow the Updating the changelog tutorial for more information on how to release a new changelog entry. This tutorial uses <code>unclog</code> to create a new changelog entry.</p> <p>The package started at version 0.1.0 as the initial release.</p>","tags":["tutorial","conventions","versioning"]},{"location":"tutorial/engines/index.html","title":"Tutorials on Engine Families","text":"<ul> <li>Conventions for writing engines</li> </ul>","tags":["tutorial","engine"]},{"location":"tutorial/engines/index.html#templates-for-writing-engines","title":"Templates for writing engines","text":"<ul> <li>Engine template<ul> <li>Template Engine Overview</li> <li>Template Messages</li> <li>Template Configuration</li> <li>Template Environment</li> <li>Template Behaviour</li> </ul> </li> </ul>","tags":["tutorial","engine"]},{"location":"tutorial/engines/index.html#simple-examples","title":"Simple examples","text":"<ul> <li>Ticker engine:<ul> <li>Ticker Engine Overview</li> <li>Ticker Messages</li> <li>Ticker Configuration</li> <li>Ticker Environment</li> <li>Ticker Behaviour</li> </ul> </li> </ul>","tags":["tutorial","engine"]},{"location":"tutorial/engines/interactive_timelines.html","title":"Engine Timeline Visualizer","text":"","tags":["tutorial","example","interactive"]},{"location":"tutorial/engines/interactive_timelines.html#engine-communication","title":"Engine communication","text":"<p>This interactive tutorial helps you explore how we envision engines communicating through message passing. The visualization tool takes a JSON configuration and renders an animated timeline of message interactions between engines.</p>","tags":["tutorial","example","interactive"]},{"location":"tutorial/engines/interactive_timelines.html#getting-started","title":"Getting Started","text":"","tags":["tutorial","example","interactive"]},{"location":"tutorial/engines/interactive_timelines.html#how-to-use","title":"how to use","text":"<ol> <li>Start the visualization by clicking dotted message lines.</li> <li>Hover over elements to see detailed tooltips.</li> <li>Watch the timeline scroll automatically as messages propagate.</li> <li>Observe engine states update in real-time above each engine.</li> </ol>","tags":["tutorial","example","interactive"]},{"location":"tutorial/engines/interactive_timelines.html#visual-interface-overview","title":"Visual interface overview","text":"<ul> <li>Engine Nodes: Coloured boxes at top representing system components.</li> <li>Timeline: Vertical lines showing message history and potential paths.</li> <li>Message Types:<ul> <li>Dotted Lines: Potential messages (click to send).</li> <li>Solid Lines: Active message animations</li> <li>Faded Lines: Historical messages</li> </ul> </li> </ul>","tags":["tutorial","example","interactive"]},{"location":"tutorial/engines/interactive_timelines.html#core-concepts","title":"Core Concepts","text":"","tags":["tutorial","example","interactive"]},{"location":"tutorial/engines/interactive_timelines.html#message-lifecycle","title":"message lifecycle","text":"<ol> <li>Initiation: Click potential message (dotted line).</li> <li>Transmission: Animation shows message travelling between engines.</li> <li>Processing: Receiving engine evaluates message against handlers.</li> <li>Response: New potential messages generated based on updated state.</li> </ol>","tags":["tutorial","example","interactive"]},{"location":"tutorial/engines/interactive_timelines.html#configuration-guide","title":"Configuration Guide","text":"JSON Schema Structure <pre><code>{\n\"engines\": [\n    {\n    \"name\": \"EngineName\",\n    \"initialState\": any,\n    \"messageHandlers\": [\n        {\n        \"stateEffect\": \"return state + 1;\",\n        \"guard\": \"return messageType === 'messageType1';\",\n        \"generateMessages\": [\n            {\n            \"to\": \"TargetEngineName\",\n            \"type\": \"responseMessageType\",\n            \"payload\": null\n            }\n        ]\n        }\n    ],\n    \"initialMessages\": [\n        {\n        \"to\": \"TargetEngineName\",\n        \"type\": \"initialMessageType\",\n        \"payload\": null\n        }\n    ]\n    }\n]\n}\n</code></pre> Field Reference","tags":["tutorial","example","interactive"]},{"location":"tutorial/engines/interactive_timelines.html#engine-configuration","title":"Engine configuration","text":"Field Type Description <code>name</code> string Unique engine identifier <code>initialState</code> any Starting state value <code>messageHandlers</code> array Message processing rules <code>initialMessages</code> array Initial outgoing messages","tags":["tutorial","example","interactive"]},{"location":"tutorial/engines/interactive_timelines.html#handler-configuration","title":"Handler configuration","text":"Field Context Variables Description <code>stateEffect</code> <code>state</code>, <code>payload</code> JS code returning new state <code>guard</code> <code>state</code>, <code>payload</code>, <code>messageType</code> JS condition for handler activation <code>generateMessages</code> <code>state</code>, <code>payload</code> Messages to send if guard passes","tags":["tutorial","example","interactive"]},{"location":"tutorial/engines/interactive_timelines.html#advanced-features","title":"Advanced Features","text":"<p>Special Message Handling</p> <ul> <li>Loopback Messages: Use <code>\"to\": \"from\"</code> to return messages to sender</li> <li>Dynamic Payloads: Include JS code in payload strings:   <pre><code>\"payload\": \"return {timestamp: Date.now(), value: state}\"\n</code></pre></li> <li>State Access: Handlers can access:<ul> <li><code>state</code>: Current engine state</li> <li><code>payload</code>: Received message data</li> <li><code>from</code>: Sender engine name</li> <li><code>messageType</code>: Type of received message</li> </ul> </li> </ul>","tags":["tutorial","example","interactive"]},{"location":"tutorial/engines/template.html","title":"Template Engine","text":"Juvix imports <p><pre><code><pre>module tutorial.engines.template;import tutorial.engines.template_messages open public;import tutorial.engines.template_config open public;import tutorial.engines.template_environment open public;import tutorial.engines.template_behaviour open public;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;open template_config_example;open template_environment_example;open template_behaviour_example;</pre></code></pre></p>","tags":["node-architecture","example"]},{"location":"tutorial/engines/template.html#template-engine","title":"Template Engine","text":"","tags":["node-architecture","example"]},{"location":"tutorial/engines/template.html#purpose","title":"Purpose","text":"<p>Brief summary of the purpose of the engine.</p>","tags":["node-architecture","example"]},{"location":"tutorial/engines/template.html#subsystems","title":"Subsystems","text":"<ul> <li>Template Messages</li> <li>Template Configuration</li> <li>Template Environment</li> <li>Template Behaviour</li> </ul>","tags":["node-architecture","example"]},{"location":"tutorial/engines/template.html#useful-links","title":"Useful links","text":"<ul> <li>Some</li> <li>Useful</li> <li>Links</li> </ul>","tags":["node-architecture","example"]},{"location":"tutorial/engines/template.html#type","title":"Type","text":"<pre><code><pre>TemplateEngine : Type :=  Engine    TemplateLocalCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["node-architecture","example"]},{"location":"tutorial/engines/template.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exTemplateEngine : TemplateEngine :=  Engine.mk@{    cfg := exTemplateCfg;    env := exTemplateEnv;    behaviour := exTemplateBehaviour;  };</pre></code></pre> <p>Where <code>exTemplateCfg</code> is defined as follows:</p> <pre><code><pre>exTemplateCfg : TemplateCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"template\";    cfg :=      TemplateLocalCfg.mk@{        example := 1;        value := \"hello world\";      };  };</pre></code></pre> <p><code>exTemplateEnv</code> is defined as follows:</p> <pre><code><pre>exTemplateEnv : TemplateEnv :=  EngineEnv.mk@{    localState :=      TemplateLocalState.mk@{        taskQueue :=          CustomData.mkCustomData@{            word := \"taskQueue\";          };      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>exTemplateBehaviour</code> is defined as follows:</p> <pre><code><pre>module template_behaviour_example;  exTemplateBehaviour : TemplateBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [justHiGuard; exampleReplyGuard];    };end;</pre></code></pre>","tags":["node-architecture","example"]},{"location":"tutorial/engines/template_behaviour.html","title":"Template Behaviour","text":"Juvix imports <p><pre><code><pre>module tutorial.engines.template_behaviour;import tutorial.engines.template_messages open;import tutorial.engines.template_config open;import tutorial.engines.template_environment open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#template-behaviour","title":"Template Behaviour","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#overview","title":"Overview","text":"<p>A template engine acts in the ways described on this page. The action labels correspond to the actions that can be performed by the engine. Using the action labels, we describe the effects of the actions.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#action-arguments","title":"Action arguments","text":"<p>The action arguments are set by a guard and passed to the action function as part of the <code>GuardOutput</code>.</p> Auxiliary Juvix code <p> <pre><code><pre>syntax alias Val := Nat;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#one-firstargument","title":"<code>One FirstArgument</code>","text":"<pre><code><pre>type FirstArgument :=  mk@{    data : Val;  };</pre></code></pre> Arguments <code>data</code>: is the value of the action argument.","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#two-secondargument","title":"<code>Two SecondArgument</code>","text":"<pre><code><pre>type SecondArgument :=  mk@{    data : String;  };</pre></code></pre> Arguments <code>data</code>: is the value of the action argument.","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#templateactionargument","title":"<code>TemplateActionArgument</code>","text":"<pre><code><pre>type TemplateActionArgument :=  | One FirstArgument  | Two SecondArgument;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#templateactionarguments","title":"<code>TemplateActionArguments</code>","text":"<pre><code><pre>TemplateActionArguments : Type := List TemplateActionArgument;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#templateaction","title":"<code>TemplateAction</code>","text":"<p> <pre><code><pre>TemplateAction : Type :=  Action    TemplateLocalCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#templateactioninput","title":"<code>TemplateActionInput</code>","text":"<p> <pre><code><pre>TemplateActionInput : Type :=  ActionInput    TemplateLocalCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#templateactioneffect","title":"<code>TemplateActionEffect</code>","text":"<p> <pre><code><pre>TemplateActionEffect : Type :=  ActionEffect    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#templateactionexec","title":"<code>TemplateActionExec</code>","text":"<p> <pre><code><pre>TemplateActionExec : Type :=  ActionExec    TemplateLocalCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#justhiaction","title":"<code>justHiAction</code>","text":"<p>Action description.</p> State update Update state with the data set by <code>justHiGuard</code>. Messages to be sent No messages are added to the send queue. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. Acquaintance updates None. <pre><code><pre>justHiAction (input : TemplateActionInput) : Option TemplateActionEffect :=  let    env := ActionInput.env input;    args := ActionInput.args input;  in case args of       | TemplateActionArgument.Two SecondArgument.mk@{data := data} :: _ :=         some           ActionEffect.mk@{             env :=               env@EngineEnv{localState := TemplateLocalState.mk@{                                             taskQueue :=                                               CustomData.mkCustomData@{                                                 word := data;                                               };                                           }};             msgs := [];             timers := [];             engines := [];           }       | _ := none;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#examplereplyaction","title":"<code>exampleReplyAction</code>","text":"<p>Respond with a <code>TemplateMsgExampleReply</code>.</p> State update The state remains unchanged. Messages to be sent A <code>TemplateMsgExampleReply</code> message with the data set by <code>exampleReplyGuard</code>. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>exampleReplyAction  (input : TemplateActionInput) : Option TemplateActionEffect :=  let    cfg := ActionInput.cfg input;    env := ActionInput.env input;    trigger := ActionInput.trigger input;    args := ActionInput.args input;  in case getEngineMsgFromTimestampedTrigger trigger of       | some EngineMsg.mk@{                msg := Anoma.Msg.Template (TemplateMsg.ExampleRequest req);                sender := sender;                target := target;                mailbox := mailbox;              } :=         some           ActionEffect.mk@{             env := env;             msgs :=               [                 EngineMsg.mk@{                   sender := getEngineIDFromEngineCfg cfg;                   target := sender;                   mailbox := some 0;                   msg :=                     Anoma.Msg.Template                       (TemplateMsg.ExampleReply                         (ok                           ExampleReplyOk.mkExampleReplyOk@{                             argOne := ExampleRequest.argOne req;                           }));                 };               ];             timers := [];             engines := [];           }       | _ := none;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#justhiactionlabel","title":"<code>justHiActionLabel</code>","text":"<pre><code><pre>justHiActionLabel : TemplateActionExec := ActionExec.Seq [justHiAction];</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#examplereplyactionlabel","title":"<code>exampleReplyActionLabel</code>","text":"<pre><code><pre>exampleReplyActionLabel : TemplateActionExec :=  ActionExec.Seq [exampleReplyAction];</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#dobothactionlabel","title":"<code>doBothActionLabel</code>","text":"<pre><code><pre>doBothActionLabel : TemplateActionExec :=  ActionExec.Seq [justHiAction; exampleReplyAction];</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#templateguard","title":"<code>TemplateGuard</code>","text":"<p> <pre><code><pre>TemplateGuard : Type :=  Guard    TemplateLocalCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#templateguardoutput","title":"<code>TemplateGuardOutput</code>","text":"<p> <pre><code><pre>TemplateGuardOutput : Type :=  GuardOutput    TemplateLocalCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#templateguardeval","title":"<code>TemplateGuardEval</code>","text":"<p> <pre><code><pre>TemplateGuardEval : Type :=  GuardEval    TemplateLocalCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#justhiguard","title":"<code>justHiGuard</code>","text":"<p>Guard description (optional).</p> Condition Message type is <code>TemplateMsgJustHi</code>. <pre><code><pre>justHiGuard  (trigger : TemplateTimestampedTrigger)  (cfg : TemplateCfg)  (env : TemplateEnv)  : Option TemplateGuardOutput :=  let    emsg := getEngineMsgFromTimestampedTrigger trigger;  in case emsg of       | some EngineMsg.mk@{msg := Anoma.Msg.Template TemplateMsg.JustHi} :=         some           GuardOutput.mk@{             action := justHiActionLabel;             args :=               [                 TemplateActionArgument.Two                   SecondArgument.mk@{                     data := \"Hello World!\";                   };               ];           }       | _ := none;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#examplereplyguard","title":"<code>exampleReplyGuard</code>","text":"<p>Guard description (optional).</p> Condition Message type is <code>TemplateMsgExampleRequest</code>. <pre><code><pre>exampleReplyGuard  (trigger : TemplateTimestampedTrigger)  (cfg : TemplateCfg)  (env : TemplateEnv)  : Option TemplateGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{             msg := Anoma.Msg.Template (TemplateMsg.ExampleRequest req);             sender := mkPair none _;           } :=      some        GuardOutput.mk@{          action := exampleReplyActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#engine-behaviour","title":"Engine behaviour","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#templatebehaviour","title":"<code>TemplateBehaviour</code>","text":"<pre><code><pre>TemplateBehaviour : Type :=  EngineBehaviour    TemplateLocalCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>module template_behaviour_example;  exTemplateBehaviour : TemplateBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [justHiGuard; exampleReplyGuard];    };end;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#template-action-flowchart","title":"Template Action Flowchart","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#justhi-flowchart","title":"<code>justHi</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;TemplateMsgJustHi]\n  end\n\n  G(justHiGuard)\n  A(justHiAction)\n\n  C --&gt; G -- *justHiActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(Env update)]\n  end</code></pre> <code>justHi</code> flowchart","tags":["tutorial","example"]},{"location":"tutorial/engines/template_behaviour.html#examplereply-flowchart","title":"<code>exampleReply</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;TemplateMsgExampleRequest&lt;br/&gt;from local engine]\n    CEnv[(exampleValue &lt; 10)]\n  end\n\n  G(exampleReplyGuard)\n  A(exampleReplyAction)\n\n  C --&gt; G -- *exampleReplyActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(exampleValue := exampleValue + 1)]\n    EMsg&gt;TemplateMsgExampleReply&lt;br/&gt;argOne]\n  end</code></pre> <code>exampleReply</code> flowchart","tags":["tutorial","example"]},{"location":"tutorial/engines/template_config.html","title":"Template Configuration","text":"Juvix imports <p><pre><code><pre>module tutorial.engines.template_config;import tutorial.engines.template_messages open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_config.html#template-configuration","title":"Template Configuration","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_config.html#overview","title":"Overview","text":"<p>The static configuration of the engine.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_config.html#local-configuration","title":"Local Configuration","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_config.html#templatelocalcfg","title":"<code>TemplateLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type TemplateLocalCfg :=  mk@{    example : Nat;    value : String;  };</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_config.html#engine-configuration","title":"Engine Configuration","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_config.html#templatecfg","title":"<code>TemplateCfg</code>","text":"<pre><code><pre>TemplateCfg : Type := EngineCfg TemplateLocalCfg;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exTemplateCfg : TemplateCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"template\";    cfg :=      TemplateLocalCfg.mk@{        example := 1;        value := \"hello world\";      };  };</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html","title":"Template Environment","text":"Juvix imports <p><pre><code><pre>module tutorial.engines.template_environment;import tutorial.engines.template_messages open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#template-environment","title":"Template Environment","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#overview","title":"Overview","text":"<p>The Engine environment of the engine.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#mailbox-state","title":"Mailbox state","text":"Auxiliary Juvix code <p><pre><code><pre>syntax alias MailboxOneOne := Nat;syntax alias MailboxTwoOne := String;syntax alias MailboxTwoTwo := Bool;</pre></code></pre></p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#templatemailboxstatefirstkind-firstkindmailboxstate","title":"<code>TemplateMailboxStateFirstKind FirstKindMailboxState</code>","text":"<pre><code><pre>type FirstKindMailboxState :=  mkFirstKindMailboxState@{    fieldOne : MailboxOneOne;  };</pre></code></pre> <p>This is one family of mailbox states without much complexity.</p> Arguments <code>fieldOne</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#templatemailboxstatesecondkind-secondkindmailboxstate","title":"<code>TemplateMailboxStateSecondKind SecondKindMailboxState</code>","text":"<pre><code><pre>type SecondKindMailboxState :=  mkSecondKindMailboxState@{    fieldOne : MailboxTwoOne;    fieldTwo : MailboxTwoTwo;  };</pre></code></pre> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p> Arguments <code>fieldOne</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p> <code>fieldTwo</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#templatemailboxstate","title":"<code>TemplateMailboxState</code>","text":"<pre><code><pre>type TemplateMailboxState :=  | TemplateMailboxStateFirstKind FirstKindMailboxState  | TemplateMailboxStateSecondKind SecondKindMailboxState;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#local-state","title":"Local state","text":"Auxiliary Juvix code <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p> <p> <pre><code><pre>type CustomData :=  mkCustomData@{    word : String;  };</pre></code></pre> </p> Arguments <code>word</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#templatelocalstate","title":"<code>TemplateLocalState</code>","text":"<pre><code><pre>type TemplateLocalState :=  mk@{    taskQueue : CustomData;  };</pre></code></pre> Arguments <code>taskQueue</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#timer-handles","title":"Timer handles","text":"Auxiliary Juvix code <p> <pre><code><pre>syntax alias ArgOne := Nat;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#templatetimerhandlefirstoption-firstoptiontimerhandle","title":"<code>TemplateTimerHandleFirstOption FirstOptionTimerHandle</code>","text":"<pre><code><pre>type FirstOptionTimerHandle :=  mkFirstOptionTimerHandle@{    argOne : ArgOne;  };</pre></code></pre> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. The following code is an example of this case.</p> Arguments <code>argOne</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#templatetimerhandlesecondoption-secondoptiontimerhandle","title":"<code>TemplateTimerHandleSecondOption SecondOptionTimerHandle</code>","text":"<pre><code><pre>type SecondOptionTimerHandle :=  mkSecondOptionTimerHandle@{    argOne : String;    argTwo : Bool;  };</pre></code></pre> Arguments <code>argOne</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p> <code>argTwo</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#templatetimerhandle","title":"<code>TemplateTimerHandle</code>","text":"<pre><code><pre>type TemplateTimerHandle :=  | TemplateTimerHandleFirstOption FirstOptionTimerHandle  | TemplateTimerHandleSecondOption SecondOptionTimerHandle;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#templatetimestampedtrigger","title":"<code>TemplateTimestampedTrigger</code>","text":"<pre><code><pre>TemplateTimestampedTrigger : Type :=  TimestampedTrigger TemplateTimerHandle Anoma.Msg;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#engine-environment","title":"Engine Environment","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#templateenv","title":"<code>TemplateEnv</code>","text":"<pre><code><pre>TemplateEnv : Type :=  EngineEnv    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exTemplateEnv : TemplateEnv :=  EngineEnv.mk@{    localState :=      TemplateLocalState.mk@{        taskQueue :=          CustomData.mkCustomData@{            word := \"taskQueue\";          };      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_messages.html","title":"Template Messages","text":"Juvix imports <p><pre><code><pre>module tutorial.engines.template_messages;import prelude open;</pre></code></pre></p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_messages.html#template-messages","title":"Template Messages","text":"<p>These are the messages that the Template engine can receive/respond to.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type TemplateMsg :=  | JustHi  | ExampleRequest ExampleRequest  | ExampleReply ExampleReply;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_messages.html#examplerequest-and-examplereply","title":"<code>ExampleRequest</code> and <code>ExampleReply</code>","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ut purus eget sapien. Nulla facilisi.</p> <pre><code>sequenceDiagram\n    participant TemplateClient\n    participant Template\n\n    TemplateClient -&gt;&gt; Template: ExampleRequest\n    Template -&gt;&gt; TemplateClient: ExampleReplyOk\n\n    TemplateClient -&gt;&gt; Template: ExampleRequest\n    Template -&gt;&gt; TemplateClient: ExampleReplyErrorOne</code></pre>  Sequence Diagram: <code>ExampleRequest</code> &amp; <code>ExampleReply</code>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_messages.html#message-types","title":"Message types","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_messages.html#templatemsgjusthi","title":"<code>TemplateMsgJustHi</code>","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_messages.html#examplerequest","title":"<code>ExampleRequest</code>","text":"<p>Example request.</p> <pre><code><pre>type ExampleRequest :=  mk@{    argOne : Nat;    argTwo : Nat;  };</pre></code></pre> Arguments <code>argOne</code> Lorem ipsum dolor sit amet, consectetur adipiscing elit. <code>argTwo</code> Lorem ipsum dolor sit amet, consectetur adipiscing elit.","tags":["tutorial","example"]},{"location":"tutorial/engines/template_messages.html#examplereply","title":"<code>ExampleReply</code>","text":"<p>Reply to an <code>ExampleRequest</code>.</p> Auxiliary Juvix code <pre><code><pre>ExampleReply : Type := Result ExampleReplyError ExampleReplyOk;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_messages.html#examplereplyok","title":"<code>ExampleReplyOk</code>","text":"<p>Example OK reply.</p> <p> <pre><code><pre>type ExampleReplyOk :=  mkExampleReplyOk@{    argOne : Nat;  };</pre></code></pre> </p> Arguments <code>argOne</code> Lorem ipsum dolor sit amet, consectetur adipiscing elit.","tags":["tutorial","example"]},{"location":"tutorial/engines/template_messages.html#examplereplyerror","title":"<code>ExampleReplyError</code>","text":"<p>Example error reply.</p> <p><pre><code><pre>type ExampleReplyError :=  | ExampleErrorOne  | ExampleErrorTwo;</pre></code></pre></p> Error types <code>ExampleErrorOne</code> Lorem ipsum dolor sit amet, consectetur adipiscing elit. <code>ExampleErrorTwo</code> Lorem ipsum dolor sit amet, consectetur adipiscing elit.","tags":["tutorial","example"]},{"location":"tutorial/engines/template_messages.html#templatemsg","title":"<code>TemplateMsg</code>","text":"<pre><code><pre>type TemplateMsg :=  | JustHi  | ExampleRequest ExampleRequest  | ExampleReply ExampleReply;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Template Configuration</li> <li>Template Environment</li> <li>Template Behaviour</li> </ul>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum.html","title":"Template minimum","text":"Juvix imports <p><pre><code><pre>module tutorial.engines.template_minimum;import tutorial.engines.template_minimum_messages open public;import tutorial.engines.template_minimum_config open public;import tutorial.engines.template_minimum_environment open public;import tutorial.engines.template_minimum_behaviour open public;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;open template_minimum_config_example;open template_minimum_environment_example;open template_minimum_behaviour_example;</pre></code></pre></p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum.html#template-minimum-engine","title":"Template Minimum Engine","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum.html#purpose","title":"Purpose","text":"<p>Brief summary of the purpose of the engine.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum.html#subsystems","title":"Subsystems","text":"<ul> <li>Template Minimum Messages</li> <li>Template Minimum Configuration</li> <li>Template Minimum Environment</li> <li>Template Minimum Behaviour</li> </ul>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum.html#useful-links","title":"Useful links","text":"<ul> <li>Some</li> <li>Useful</li> <li>Links</li> </ul>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum.html#type","title":"Type","text":"<pre><code><pre>TemplateMinimumEngine : Type :=  Engine    TemplateMinimumLocalCfg    TemplateMinimumLocalState    TemplateMinimumMailboxState    TemplateMinimumTimerHandle    TemplateMinimumActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exTemplateMinimumEngine : TemplateMinimumEngine :=  Engine.mk@{    cfg := exTemplateMinimumCfg;    env := exTemplateMinimumEnv;    behaviour := exTemplateMinimumBehaviour;  };</pre></code></pre> <p>Where <code>exTemplateMinimumCfg</code> is defined as follows:</p> <pre><code><pre>exTemplateMinimumCfg : TemplateMinimumCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"template-minimum\";    cfg := TemplateMinimumLocalCfg.mk;  };</pre></code></pre> <p><code>exTemplateMinimumEnv</code> is defined as follows:</p> <pre><code><pre>exTemplateMinimumEnv : TemplateMinimumEnv :=  EngineEnv.mk@{    localState := TemplateMinimumLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>exTemplateMinimumBehaviour</code> is defined as follows:</p> <pre><code><pre>module template_minimum_behaviour_example;  exTemplateMinimumBehaviour : TemplateMinimumBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [exampleReplyGuard];    };end;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html","title":"Template minimum behaviour","text":"Juvix imports <p><pre><code><pre>module tutorial.engines.template_minimum_behaviour;import tutorial.engines.template_minimum_messages open;import tutorial.engines.template_minimum_config open;import tutorial.engines.template_minimum_environment open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#template-minimum-behaviour","title":"Template Minimum Behaviour","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#overview","title":"Overview","text":"<p>A Template Minimum engine acts in the ways described on this page. The action labels correspond to the actions that can be performed by the engine. Using the action labels, we describe the effects of the actions.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#action-arguments","title":"Action arguments","text":"<p>The action arguments are set by a guard and passed to the action function as part of the <code>GuardOutput</code>.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#templateminimumactionarguments","title":"<code>TemplateMinimumActionArguments</code>","text":"<pre><code><pre>TemplateMinimumActionArguments : Type := Unit;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#templateminimumaction","title":"<code>TemplateMinimumAction</code>","text":"<p> <pre><code><pre>TemplateMinimumAction : Type :=  Action    TemplateMinimumLocalCfg    TemplateMinimumLocalState    TemplateMinimumMailboxState    TemplateMinimumTimerHandle    TemplateMinimumActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#templateminimumactioninput","title":"<code>TemplateMinimumActionInput</code>","text":"<p> <pre><code><pre>TemplateMinimumActionInput : Type :=  ActionInput    TemplateMinimumLocalCfg    TemplateMinimumLocalState    TemplateMinimumMailboxState    TemplateMinimumTimerHandle    TemplateMinimumActionArguments    Anoma.Msg;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#templateminimumactioneffect","title":"<code>TemplateMinimumActionEffect</code>","text":"<p> <pre><code><pre>TemplateMinimumActionEffect : Type :=  ActionEffect    TemplateMinimumLocalState    TemplateMinimumMailboxState    TemplateMinimumTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#templateminimumactionexec","title":"<code>TemplateMinimumActionExec</code>","text":"<p> <pre><code><pre>TemplateMinimumActionExec : Type :=  ActionExec    TemplateMinimumLocalCfg    TemplateMinimumLocalState    TemplateMinimumMailboxState    TemplateMinimumTimerHandle    TemplateMinimumActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#examplereplyaction","title":"<code>exampleReplyAction</code>","text":"<p>Respond with a <code>TemplateMinimumMsgExampleReply</code>.</p> State update The state remains unchanged. Messages to be sent A <code>TemplateMinimumMsgExampleReply</code> message with the data set by <code>exampleReplyGuard</code>. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>exampleReplyAction  (input : TemplateMinimumActionInput) : Option TemplateMinimumActionEffect :=  TODO;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#examplereplyactionlabel","title":"<code>exampleReplyActionLabel</code>","text":"<pre><code><pre>exampleReplyActionLabel : TemplateMinimumActionExec :=  ActionExec.Seq [exampleReplyAction];</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#templateminimumguard","title":"<code>TemplateMinimumGuard</code>","text":"<p> <pre><code><pre>TemplateMinimumGuard : Type :=  Guard    TemplateMinimumLocalCfg    TemplateMinimumLocalState    TemplateMinimumMailboxState    TemplateMinimumTimerHandle    TemplateMinimumActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#templateminimumguardoutput","title":"<code>TemplateMinimumGuardOutput</code>","text":"<p> <pre><code><pre>TemplateMinimumGuardOutput : Type :=  GuardOutput    TemplateMinimumLocalCfg    TemplateMinimumLocalState    TemplateMinimumMailboxState    TemplateMinimumTimerHandle    TemplateMinimumActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#templateminimumguardeval","title":"<code>TemplateMinimumGuardEval</code>","text":"<p> <pre><code><pre>TemplateMinimumGuardEval : Type :=  GuardEval    TemplateMinimumLocalCfg    TemplateMinimumLocalState    TemplateMinimumMailboxState    TemplateMinimumTimerHandle    TemplateMinimumActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#examplereplyguard","title":"<code>exampleReplyGuard</code>","text":"<p>Guard description (optional).</p> Condition Message type is <code>TemplateMinimumMsgExampleRequest</code>. <pre><code><pre>exampleReplyGuard  (trigger : TemplateMinimumTimestampedTrigger)  (cfg : TemplateMinimumCfg)  (env : TemplateMinimumEnv)  : Option TemplateMinimumGuardOutput :=  case getEngineMsgFromTimestampedTrigger trigger of    | some EngineMsg.mk@{             msg := Anoma.Msg.TemplateMinimum (TemplateMinimumMsg.ExampleRequest req);             sender := mkPair none _;           } :=      some        GuardOutput.mk@{          action := exampleReplyActionLabel;          args := unit;        }    | _ := none;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#engine-behaviour","title":"Engine behaviour","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#templateminimumbehaviour","title":"<code>TemplateMinimumBehaviour</code>","text":"<pre><code><pre>TemplateMinimumBehaviour : Type :=  EngineBehaviour    TemplateMinimumLocalCfg    TemplateMinimumLocalState    TemplateMinimumMailboxState    TemplateMinimumTimerHandle    TemplateMinimumActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>module template_minimum_behaviour_example;  exTemplateMinimumBehaviour : TemplateMinimumBehaviour :=    EngineBehaviour.mk@{      guards := GuardEval.First [exampleReplyGuard];    };end;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#action-flowchart","title":"Action Flowchart","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_behaviour.html#examplereply-flowchart","title":"<code>exampleReply</code> Flowchart","text":"<pre><code>flowchart TD\n  subgraph C[Conditions]\n    CMsg&gt;TemplateMinimumMsgExampleRequest&lt;br/&gt;from local engine]\n    CEnv[(exampleValue &lt; 10)]\n  end\n\n  G(exampleReplyGuard)\n  A(exampleReplyAction)\n\n  C --&gt; G -- *exampleReplyActionLabel* --&gt; A --&gt; E\n\n  subgraph E[Effects]\n    EEnv[(exampleValue := exampleValue + 1)]\n    EMsg&gt;TemplateMinimumMsgExampleReply&lt;br/&gt;argOne]\n  end</code></pre> <code>exampleReply</code> flowchart","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_config.html","title":"Template minimum config","text":"Juvix imports <p><pre><code><pre>module tutorial.engines.template_minimum_config;import tutorial.engines.template_minimum_messages open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_config.html#template-minimum-configuration","title":"Template Minimum Configuration","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_config.html#overview","title":"Overview","text":"<p>The static configuration of the engine.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_config.html#local-configuration","title":"Local Configuration","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_config.html#templateminimumlocalcfg","title":"<code>TemplateMinimumLocalCfg</code>","text":"<p>The type for engine-specific local configuration.</p> <pre><code><pre>type TemplateMinimumLocalCfg := mk;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_config.html#engine-configuration","title":"Engine Configuration","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_config.html#templateminimumcfg","title":"<code>TemplateMinimumCfg</code>","text":"<pre><code><pre>TemplateMinimumCfg : Type := EngineCfg TemplateMinimumLocalCfg;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exTemplateMinimumCfg : TemplateMinimumCfg :=  EngineCfg.mk@{    node := PublicKey.Curve25519PubKey \"0xabcd1234\";    name := \"template-minimum\";    cfg := TemplateMinimumLocalCfg.mk;  };</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_environment.html","title":"Template minimum environment","text":"Juvix imports <p><pre><code><pre>module tutorial.engines.template_minimum_environment;import tutorial.engines.template_minimum_messages open;import arch.node.types.basics open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_environment.html#template-minimum-environment","title":"Template Minimum Environment","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_environment.html#overview","title":"Overview","text":"<p>The Engine environment of the engine.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_environment.html#mailbox-state","title":"Mailbox state","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_environment.html#templateminimummailboxstate","title":"<code>TemplateMinimumMailboxState</code>","text":"<pre><code><pre>TemplateMinimumMailboxState : Type := Unit;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_environment.html#local-state","title":"Local state","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_environment.html#templateminimumlocalstate","title":"<code>TemplateMinimumLocalState</code>","text":"<pre><code><pre>type TemplateMinimumLocalState := mk;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_environment.html#timer-handles","title":"Timer handles","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_environment.html#templateminimumtimerhandle","title":"<code>TemplateMinimumTimerHandle</code>","text":"<pre><code><pre>TemplateMinimumTimerHandle : Type := Unit;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_environment.html#templateminimumtimestampedtrigger","title":"<code>TemplateMinimumTimestampedTrigger</code>","text":"<pre><code><pre>TemplateMinimumTimestampedTrigger : Type :=  TimestampedTrigger TemplateMinimumTimerHandle Anoma.Msg;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_environment.html#engine-environment","title":"Engine Environment","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_environment.html#templateminimumenv","title":"<code>TemplateMinimumEnv</code>","text":"<pre><code><pre>TemplateMinimumEnv : Type :=  EngineEnv    TemplateMinimumLocalState    TemplateMinimumMailboxState    TemplateMinimumTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>exTemplateMinimumEnv : TemplateMinimumEnv :=  EngineEnv.mk@{    localState := TemplateMinimumLocalState.mk;    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_messages.html","title":"Template minimum messages","text":"Juvix imports <p><pre><code><pre>module tutorial.engines.template_minimum_messages;import prelude open;</pre></code></pre></p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_messages.html#template-minimum-messages","title":"Template Minimum Messages","text":"<p>These are the messages that the Template Minimum engine can receive/respond to.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type TemplateMinimumMsg :=  | JustHi  | ExampleRequest ExampleRequest  | ExampleReply ExampleReply;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_messages.html#examplerequest-and-examplereply","title":"<code>ExampleRequest</code> and <code>ExampleReply</code>","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ut purus eget sapien. Nulla facilisi.</p> <pre><code>sequenceDiagram\n    participant TemplateMinimumClient\n    participant TemplateMinimum\n\n    TemplateMinimumClient -&gt;&gt; TemplateMinimum: ExampleRequest\n    TemplateMinimum -&gt;&gt; TemplateMinimumClient: ExampleReplyOk\n\n    TemplateMinimumClient -&gt;&gt; TemplateMinimum: ExampleRequest\n    TemplateMinimum -&gt;&gt; TemplateMinimumClient: ExampleReplyErrorOne</code></pre>  Sequence Diagram: <code>ExampleRequest</code> &amp; <code>ExampleReply</code>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_messages.html#message-types","title":"Message types","text":"","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_messages.html#templateminimummsgjusthi","title":"<code>TemplateMinimumMsgJustHi</code>","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_messages.html#examplerequest","title":"<code>ExampleRequest</code>","text":"<p>Example request.</p> <pre><code><pre>type ExampleRequest :=  mk@{    argOne : Nat;    argTwo : Nat;  };</pre></code></pre> Arguments <code>argOne</code> Lorem ipsum dolor sit amet, consectetur adipiscing elit. <code>argTwo</code> Lorem ipsum dolor sit amet, consectetur adipiscing elit.","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_messages.html#examplereply","title":"<code>ExampleReply</code>","text":"Auxiliary types <pre><code><pre>ExampleReply : Type := Result ReplyError ReplyPayload;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_messages.html#replypayload","title":"<code>ReplyPayload</code>","text":"<p><pre><code><pre>type ReplyPayload :=  mkReplyPayload@{    payload : String;  };</pre></code></pre></p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_messages.html#replyerror","title":"<code>ReplyError</code>","text":"<p><pre><code><pre>type ReplyError :=  mkReplyError@{    error : String;  };</pre></code></pre></p>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_messages.html#templateminimummsg","title":"<code>TemplateMinimumMsg</code>","text":"<pre><code><pre>type TemplateMinimumMsg :=  | JustHi  | ExampleRequest ExampleRequest  | ExampleReply ExampleReply;</pre></code></pre>","tags":["tutorial","example"]},{"location":"tutorial/engines/template_minimum_messages.html#engine-components","title":"Engine components","text":"<ul> <li>Template Minimum Configuration</li> <li>Template Minimum Environment</li> <li>Template Minimum Behaviour</li> </ul>","tags":["tutorial","example"]},{"location":"tutorial/engines/writing_conventions.html","title":"Engine Writing Conventions","text":"","tags":["tutorial","conventions"]},{"location":"tutorial/engines/writing_conventions.html#naming-standards","title":"Naming standards","text":"<ul> <li>Engine files and folders: Named in lowercase using <code>snake_case</code> format.   See File naming conventions.</li> </ul> <ul> <li>File extension: Files must be written in Juvix Markdown when applicable,   that is, the file must end with the extension <code>.juvix.md</code>. See Juvix Markdown and include Juvix code blocks.</li> </ul> <ul> <li> <p>File naming prefix: The engine's name is used as a prefix for all files   related to the engine in use. For example, the Ticker Engine would have   the following files, all prefixed with <code>ticker</code>:</p> <ul> <li><code>ticker_messages.juvix.md</code> where the message interface is defined.</li> <li><code>ticker_config.juvix.md</code> where the type for the configuration is defined.</li> <li><code>ticker_environment.juvix.md</code> where the type for the environment is defined.</li> <li><code>ticker_behaviour.juvix.md</code> where the behaviour is defined (guards and actions).</li> <li><code>ticker.juvix.md</code> where the engine is defined, importing all the other files.</li> </ul> </li> </ul> <p>Warning</p> <p>Juvix Markdown files have always need to define the corresponding module at the first Juvix code block. See the Juvix Markdown and include Juvix code blocks's tutorial. For example if the file is <code>ticker.juvix.md</code>, it must have the following code block:</p> <pre><code>module arch.node.engines.ticker;\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/engines/writing_conventions.html#file-structure-within-the-engines-directory","title":"File structure within the <code>engines</code> directory","text":"<p>The files as listed above must be stored in the <code>engines</code> directory of the <code>docs/arch/node</code> directory. For example, the <code>ticker</code> engine would have the following directory structure:</p> <pre><code>docs/arch/node/\n\u2514\u2500\u2500 ...\n\u2514\u2500\u2500 engines/\n    \u251c\u2500\u2500 ...\n    \u251c\u2500\u2500 ticker_messages.juvix.md\n    \u251c\u2500\u2500 ticker_config.juvix.md\n    \u251c\u2500\u2500 ticker_environment.juvix.md\n    \u251c\u2500\u2500 ticker_behaviour.juvix.md\n    \u2514\u2500\u2500 ticker.juvix.md\n</code></pre> <p>The <code>ticker.juvix.md</code> file then would contain a brief overview and list of all its components. Check out Ticker Engine as an example for the expected structure.</p> <p>So next time, if you want to use the <code>ticker</code> engine, then you can import the <code>arch.node.engines.ticker</code> module, adding only one line at the top of the Juvix file where the imports are declared:</p> <pre><code>...\n+ import arch.node.engines.ticker open;\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/engines/writing_conventions.html#front-matter","title":"Front matter","text":"<p>The front matter of the related files to an engine must contain tags. Please check other engine files for examples. Most of the cases, the front matter has the following tags:</p> <pre><code>tags:\n  - node-architecture\n  - x-subsystem\n  - engine\n  - name-of-the-engine\n  - message-types|configuration|environment|behaviour|engine-definition\n</code></pre> <p>Tags are used to categorise the pages in the documentation.</p>","tags":["tutorial","conventions"]},{"location":"tutorial/engines/writing_conventions.html#update-indexes","title":"Update indexes","text":"<p>As part of defining an engine type, you must update a few files that act as indexes.</p>","tags":["tutorial","conventions"]},{"location":"tutorial/engines/writing_conventions.html#juvix-everything-index","title":"Juvix Everything Index","text":"<p>Add import statements of all the modules related to the new engine to the <code>docs/everything.juvix.md</code> file. The new lines must be added in the \"Engines\" section. That is, if the engine is the <code>ticker</code>, we expect the following lines, assuming the engine is part of the <code>X</code> subsystem:</p> docs/everything.juvix.md<pre><code>module everything;\n...\n# Engines\n\n## X Subsystem\n\n+ import arch.node.engines.ticker_messages;\n+ import arch.node.engines.ticker_config;\n+ import arch.node.engines.ticker_environment;\n+ import arch.node.engines.ticker_behaviour;\n+ import arch.node.engines.ticker;\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/engines/writing_conventions.html#anoma-message","title":"Anoma Message","text":"<p>All message types must be added to the <code>arch/node/types/anoma_message.juvix.md</code> file. Use the same pattern as the existing message types. For example, if the engine is the <code>ticker</code>, the new type constructor should be <code>Msg.Ticker</code> along with the corresponding type for the messages, that is, <code>TickerMsg</code>.</p> arch/node/types/anoma_message.juvix.md<pre><code>...\nmodule arch.node.types.anoma_message;\n+ import arch.node.engines.ticker_messages open;\n\ntype Msg KVSKey KVSDatum Executable :=\n+  | Msg.Ticker TickerMsg\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/engines/writing_conventions.html#anoma-configuration-index","title":"Anoma Configuration Index","text":"<p>All configuration types must be added to the <code>arch/node/types/anoma_config.juvix.md</code> file. Similarly to the message types, the new type constructor should be <code>CfgTicker</code> along with the corresponding type for the configuration, that is, <code>TickerCfg</code>. Do not forget to import the environment type in the <code>Env</code> type.</p> arch/node/types/anoma_config.juvix.md<pre><code>module arch.node.types.anoma_config;\n...\n+ import arch.node.engines.ticker_config open;\n...\ntype Cfg KVSKey KVSDatum Executable :=\n+  | CfgTicker TickerCfg\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/engines/writing_conventions.html#anoma-environment-index","title":"Anoma Environment Index","text":"<p>All environment types must be added to the <code>arch/node/types/anoma_environment.juvix.md</code> file. Similarly to the message types, the new type constructor should be <code>EnvTicker</code> along with the corresponding type for the environment, that is, <code>TickerEnv</code>. Do not forget to import the environment type in the <code>Env</code> type.</p> arch/node/types/anoma_environment.juvix.md<pre><code>module arch.node.types.anoma_environment;\n...\n+ import arch.node.engines.ticker_environment open;\n...\ntype Env KVSKey KVSDatum Executable :=\n+  | EnvTicker TickerEnv\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/engines/writing_conventions.html#update-the-table-of-contents","title":"Update the \"Table of Contents\"","text":"<p>Locate the navigation section in the <code>mkdocs.yml</code> file, <code>nav</code> section, and include the new engine</p> mkdocs.yml<pre><code>...\nnav:\n  - Protocol Architecture:\n    - Node Architecture:\n       ...\n       - X Subsystem:\n+         - Ticker Engine:\n+           - Ticker Engine: ./arch/node/engines/ticker.juvix.md\n+           - Ticker Messages: ./arch/node/engines/ticker_messages.juvix.md\n+           - Ticker Configuration: ./arch/node/engines/ticker_config.juvix.md\n+           - Ticker Environment: ./arch/node/engines/ticker_environment.juvix.md\n+           - Ticker Behaviour: ./arch/node/engines/ticker_behaviour.juvix.md\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/engines/writing_conventions.html#using-the-template-engine-as-a-starting-point","title":"Using the Template engine as a starting point","text":"<p>The Template Engine can be used as a starting point for writing new engines.</p> <p>To use it, run the following command:</p> <pre><code>nspec new engine\n</code></pre> <p>This will prompt some questions and create a new engine with the name provided by the user and update the indexes along with the corresponding files, based on the minimal template.</p>","tags":["tutorial","conventions"]},{"location":"tutorial/install/index.html","title":"Preparing the local environment for writing documentation","text":"","tags":["tutorial","install"]},{"location":"tutorial/install/index.html#getting-started","title":"Getting Started","text":"<ul> <li>Contribute: Tutorial</li> <li>Markdown: Uses Material for MkDocs</li> </ul>","tags":["tutorial","install"]},{"location":"tutorial/install/index.html#setup","title":"Setup","text":"<ol> <li> <p>Prerequisites:</p> <ul> <li> <p><code>uv</code>: Install via:</p> <p><pre><code># macOS/Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n# Windows\npowershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre>    - <code>graphviz</code> for local deployment,</p> </li> </ul> <ul> <li> <p><code>juvix</code> for local deployment,</p> <p><pre><code>curl --proto '=https' --tlsv1.2 -sSfL https://get.juvix.org | sh\n</code></pre>    - <code>just</code> for local development (although you can use <code>uv run</code> for most commands)</p> </li> </ul> </li> <li> <p>Setup Commands:</p> <pre><code>just setup-repo\n</code></pre> </li> </ol>","tags":["tutorial","install"]},{"location":"tutorial/install/index.html#documentation","title":"Documentation","text":"<ul> <li>Build: <code>just build</code></li> <li>Serve Locally: <code>just serve</code></li> </ul>","tags":["tutorial","install"]},{"location":"tutorial/install/index.html#development-with-nix","title":"Development with Nix","text":"<ol> <li>Install Nix: Download</li> <li>Enable Flakes: Guide</li> <li>Enter Shell: <code>nix develop</code></li> </ol>","tags":["tutorial","install"]},{"location":"tutorial/md/index.html","title":"Markdown Basics for Anoma Documentation","text":"<p>Our theme and main Markdown reference is Material for MkDocs. You may use anything found in this reference, including all possible Markdown extensions.</p> <p>This guide provides an overview of the key markdown features we use in the documentation. Please note that this guide is a work-in-progress.</p>","tags":["tutorial","conventions"]},{"location":"tutorial/md/index.html#front-matter","title":"Front Matter","text":"<p>Each markdown file should begin with a front matter section. It typically includes metadata such as <code>icon</code>, <code>tags</code>, <code>categories</code>. For more examples, refer to other files within the documentation. For example, the icons name can be found here.</p>","tags":["tutorial","conventions"]},{"location":"tutorial/md/index.html#example-front-matter","title":"Example Front Matter","text":"<pre><code>---\nicon: material/auto-download\nsearch:\n  exclude: false\n  boost: 3\ntags:\n  - node-architecture\n  - harware-subsystem\n  - engine\n  - logging\n  - message-types\n---\n</code></pre> <p>Warning</p> <p>Any new markdown file added to the <code>docs</code> directory must, in principle, have an entry in the <code>mkdocs.yml</code> file, specifically in the <code>nav</code> section.</p> <p>The filename may be relevant depending on where it is placed in the navigation. For example, any file intended to be the landing page of a section, say Section X, must be named <code>index.md</code> and placed right below the <code>Section X</code> item. Children of <code>Section X</code> do not need to follow any specific naming convention.</p> <pre><code>...\n- Section X:\n    - ./path-to/index.md\n    - NameRef Child1 : ./path-to/child1.md\n    - NameRef Child2 : ./path-to/child2.md\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/md/citations.html","title":"Bibliography","text":"<p>Place your <code>.bib</code> files within the <code>docs/references</code> directory. For convenience, we have included all the ART published papers in the <code>docs/references/art.bib</code> file.</p> <p>Any new <code>.bib</code> file added to this folder will automatically be processed.</p>","tags":["tutorial","conventions"]},{"location":"tutorial/md/citations.html#citing-in-markdown","title":"Citing in Markdown","text":"<p>Use the citation key from your <code>.bib</code> files to cite references in your markdown files. The syntax is as follows:</p> <pre><code>This statement requires a citation .\n</code></pre> <p>Info</p> <p>We have <code>docs/references/update_repo_bibtexs.py</code> script that can be used to update the <code>docs/references/anoma_repos.bib</code> file to cite Anoma repositories in the documentation.</p>","tags":["tutorial","conventions"]},{"location":"tutorial/md/citations.html#references-available","title":"References available","text":"Anoma Research Topics (ART) papers <pre><code>% https://art.anoma.net\n\n\n@article{ art-2025-optimising-shielded-state-synchronization,\n    author    = { Larraia, Enrique and Khalniyazova, Yulia },\n    title     = { {Optimising Shielded State Synchronization with FMD and TEEs} },\n    journal   = { Anoma Research Topics },\n    month     = { Apr },\n    year      = { 2025 },\n    publisher = { Zenodo },\n    version   = { April 10, 2025 },\n    doi       = { 10.5281/zenodo.15186457 },\n    url       = { https://doi.org/10.5281/zenodo.15186456 }\n}\n\n\n@article{ art-2025-dynamic-effective-timed-communication-systems,\n    author    = { Heindel, Tobias and Prieto-Cubides, Jonathan and Hart, Anthony },\n    title     = { {Dynamic Effective Timed Communication Systems} },\n    journal   = { Anoma Research Topics },\n    month     = { Mar },\n    year      = { 2025 },\n    publisher = { Zenodo },\n    version   = { March 06, 2025 },\n    doi       = { 10.5281/zenodo.14984148 },\n    url       = { https://doi.org/10.5281/zenodo.14984147 }\n}\n\n\n@article{ art-2024-nock-functional-programmers,\n    author    = { Czajka, Lukasz },\n    title     = { {Nock for Functional Programmers} },\n    journal   = { Anoma Research Topics },\n    month     = { Dec },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { December 18, 2024 },\n    doi       = { 10.5281/zenodo.14511714 },\n    url       = { https://doi.org/10.5281/zenodo.14511713 }\n}\n\n\n@article{ art-2024-message-logic,\n    author    = { Gabbay, Murdoch J. and Zarin, Naqib },\n    title     = { {Message Logic} },\n    journal   = { Anoma Research Topics },\n    month     = { Dec },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { December 04, 2024 },\n    doi       = { 10.5281/zenodo.14251398 },\n    url       = { https://doi.org/10.5281/zenodo.14251397 }\n}\n\n\n@article{ art-2024-anoma-state-architecture,\n    author    = { Sheff, Isaac },\n    title     = { {Anoma State Architecture} },\n    journal   = { Anoma Research Topics },\n    month     = { Dec },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { December 04, 2024 },\n    doi       = { 10.5281/zenodo.14265827 },\n    url       = { https://doi.org/10.5281/zenodo.14265826 }\n}\n\n\n@article{ art-2024-heterogeneous-paxos-20-specs,\n    author    = { Karbyshev, Aleksandr and Sheff, Isaac },\n    title     = { {Heterogeneous Paxos 2.0: the Specs} },\n    journal   = { Anoma Research Topics },\n    month     = { Dec },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { December 04, 2024 },\n    doi       = { 10.5281/zenodo.14276903 },\n    url       = { https://doi.org/10.5281/zenodo.12572557 }\n}\n\n\n@article{ art-2024-slow-games-policy-enforcement-under,\n    author    = { Reusche, D and Goes, Christopher and Della Penna, Nicolas },\n    title     = { {Slow Games: Policy Enforcement under Uncertainty} },\n    journal   = { Anoma Research Topics },\n    month     = { Sep },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { September 15, 2024 },\n    doi       = { 10.5281/zenodo.13765214 },\n    url       = { https://doi.org/10.5281/zenodo.13765213 }\n}\n\n\n@article{ art-2024-compiling-juvix-cairo-assembly,\n    author    = { Czajka, \u0141ukasz },\n    title     = { {Compiling Juvix to Cairo Assembly} },\n    journal   = { Anoma Research Topics },\n    month     = { Sep },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { September 10, 2024 },\n    doi       = { 10.5281/zenodo.13739344 },\n    url       = { https://doi.org/10.5281/zenodo.13739343 }\n}\n\n\n@article{ art-2024-comparing-two-hash-functions,\n    author    = { Y\u0131ld\u0131z, Burcu and Maller, Mary },\n    title     = { {Comparing Two Hash Functions for Multi-Party Computation and Zero-Knowledge} },\n    journal   = { Anoma Research Topics },\n    month     = { Sep },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { September 10, 2024 },\n    doi       = { 10.5281/zenodo.13739511 },\n    url       = { https://doi.org/10.5281/zenodo.13739510 }\n}\n\n\n@article{ art-2024-intentcentric-applications-anoma,\n    author    = { Heuer, Michael and Reusche, D },\n    title     = { {Intent-centric Applications for the Anoma Resource Machine} },\n    journal   = { Anoma Research Topics },\n    month     = { Aug },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { August 26, 2024 },\n    doi       = { 10.5281/zenodo.13340448 },\n    url       = { https://doi.org/10.5281/zenodo.13340447 }\n}\n\n\n@article{ art-2024-heterogeneous-narwhal-paxos,\n    author    = { Heindel, Tobias and Karbyshev, Aleksandr and Sheff, Isaac },\n    title     = { {Heterogeneous Narwhal and Paxos} },\n    journal   = { Anoma Research Topics },\n    month     = { Jun },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { June 27, 2024 },\n    doi       = { 10.5281/zenodo.10498999 },\n    url       = { https://doi.org/10.5281/zenodo.10498998 }\n}\n\n\n@article{ art-2024-crosschain-integrity-controller-labels,\n    author    = { Isaac, Sheff },\n    title     = { {Cross-Chain Integrity with Controller Labels and Endorsement} },\n    journal   = { Anoma Research Topics },\n    month     = { Jun },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { June 25, 2024 },\n    doi       = { 10.5281/zenodo.10498997 },\n    url       = { https://doi.org/10.5281/zenodo.10498996 }\n}\n\n\n@article{ art-2024-anoma-resource-machine-specification,\n    author    = { Khalniyazova, Yulia and Goes, Christopher },\n    title     = { {Anoma Resource Machine Specification} },\n    journal   = { Anoma Research Topics },\n    month     = { Jun },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { June 25, 2024 },\n    doi       = { 10.5281/zenodo.10689620 },\n    url       = { https://doi.org/10.5281/zenodo.10498990 }\n}\n\n\n@article{ art-2024-compiling-zkvms,\n    author    = { Centelles, Alberto },\n    title     = { {Compiling to ZKVMs} },\n    journal   = { Anoma Research Topics },\n    month     = { Apr },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { April 19, 2024 },\n    doi       = { 10.5281/zenodo.10998758 },\n    url       = { https://doi.org/10.5281/zenodo.10498994 }\n}\n\n\n@article{ art-2024-intent-machines,\n    author    = { Hart, Anthony and Reusche, D },\n    title     = { {Intent Machines} },\n    journal   = { Anoma Research Topics },\n    month     = { Feb },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { February 21, 2024 },\n    doi       = { 10.5281/zenodo.10654543 },\n    url       = { https://doi.org/10.5281/zenodo.10498992 }\n}\n\n\n@article{ art-2023-vampir-bestiary,\n    author    = { Fitzgerald, Joshua and Centelles, Alberto },\n    title     = { {VampIR Bestiary} },\n    journal   = { Anoma Research Topics },\n    month     = { Nov },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { November 13, 2023 },\n    doi       = { 10.5281/zenodo.10118865 },\n    url       = { https://doi.org/10.5281/zenodo.10118864 }\n}\n\n\n@article{ art-2023-constraint-satisfaction-problems-survey,\n    author    = { Hart, Anthony },\n    title     = { {Constraint Satisfaction Problems: A Survey for Anoma} },\n    journal   = { Anoma Research Topics },\n    month     = { Oct },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { October 18, 2023 },\n    doi       = { 10.5281/zenodo.10019113 },\n    url       = { https://doi.org/10.5281/zenodo.10019112 }\n}\n\n\n@article{ art-2023-exploring-cryptographic-approaches-enhance,\n    author    = { Khalniyazova, Yulia },\n    title     = { {Exploring Cryptographic Approaches to Enhance Privacy in Intent Solving} },\n    journal   = { Anoma Research Topics },\n    month     = { Oct },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { October 02, 2023 },\n    doi       = { 10.5281/zenodo.8321167 },\n    url       = { https://doi.org/10.5281/zenodo.8321166 }\n}\n\n\n@article{ art-2023-core-language-juvix,\n    author    = { Lukasz Czajka },\n    title     = { {The Core language of Juvix} },\n    journal   = { Anoma Research Topics },\n    month     = { Aug },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { August 29, 2023 },\n    doi       = { 10.5281/zenodo.8268850 },\n    url       = { https://doi.org/10.5281/zenodo.8268849 }\n}\n\n\n@article{ art-2023-rethinking-vampir,\n    author    = { Anthony Hart },\n    title     = { {Rethinking VampIR} },\n    journal   = { Anoma Research Topics },\n    month     = { Aug },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { August 29, 2023 },\n    doi       = { 10.5281/zenodo.8262815 },\n    url       = { https://doi.org/10.5281/zenodo.8262814 }\n}\n\n\n@article{ art-2023-anoma-unified-architecture,\n    author    = { Christopher Goes and Awa Sun Yin and Adrian Brink },\n    title     = { {Anoma: a unified architecture for full-stack decentralised applications} },\n    journal   = { Anoma Research Topics },\n    month     = { Aug },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { August 24, 2023 },\n    doi       = { 10.5281/zenodo.8279842 },\n    url       = { https://doi.org/10.5281/zenodo.8279841 }\n}\n\n\n@article{ art-2023-geb-pipeline,\n    author    = { Artem Gureev and Jonathan Prieto-Cubides },\n    title     = { {Geb Pipeline} },\n    journal   = { Anoma Research Topics },\n    month     = { Aug },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { August 21, 2023 },\n    doi       = { 10.5281/zenodo.8262747 },\n    url       = { https://doi.org/10.5281/zenodo.8262746 }\n}\n\n\n@article{ art-2023-juvix-vampir-pipeline,\n    author    = { Lukasz Czajka },\n    title     = { {Juvix to VampIR Pipeline} },\n    journal   = { Anoma Research Topics },\n    month     = { Aug },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { August 14, 2023 },\n    doi       = { 10.5281/zenodo.8252903 },\n    url       = { https://doi.org/10.5281/zenodo.8246535 }\n}\n</code></pre> Anoma Public GitHub repositories <pre><code>  author = {anoma},\n  title = {juvix},\n  year = {2017},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/juvix}\n}\n\n@misc{github-masp-mpc,\n  author = {anoma},\n  title = {masp-mpc},\n  year = {2020},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/masp-mpc}\n}\n\n@misc{github-masp,\n  author = {anoma},\n  title = {masp},\n  year = {2020},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/masp}\n}\n\n@misc{github-ferveo,\n  author = {anoma},\n  title = {ferveo},\n  year = {2020},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/ferveo}\n}\n\n@misc{github-anoma,\n  author = {anoma},\n  title = {anoma},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/anoma}\n}\n\n@misc{github-group-threshold-crypto,\n  author = {anoma},\n  title = {group-threshold-crypto},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/group-threshold-crypto}\n}\n\n@misc{github-research,\n  author = {anoma},\n  title = {research},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/research}\n}\n\n@misc{github-plonkup-hash,\n  author = {anoma},\n  title = {plonkup-hash},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/plonkup-hash}\n}\n\n@misc{github-plonkup,\n  author = {anoma},\n  title = {plonkup},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/plonkup}\n}\n\n@misc{github-typhon,\n  author = {anoma},\n  title = {typhon},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/typhon}\n}\n\n@misc{github-exhibit_plonkup,\n  author = {anoma},\n  title = {exhibit_plonkup},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/exhibit_plonkup}\n}\n\n@misc{github-taiga,\n  author = {anoma},\n  title = {taiga},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/taiga}\n}\n\n@misc{github-juvix-stdlib,\n  author = {anoma},\n  title = {juvix-stdlib},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/juvix-stdlib}\n}\n\n@misc{github-namada-trusted-setup,\n  author = {anoma},\n  title = {namada-trusted-setup},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/namada-trusted-setup}\n}\n\n@misc{github-alucard,\n  author = {anoma},\n  title = {alucard},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/alucard}\n}\n\n@misc{github-masp-phase2,\n  author = {anoma},\n  title = {masp-phase2},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/masp-phase2}\n}\n\n@misc{github-vamp-ir,\n  author = {anoma},\n  title = {vamp-ir},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/vamp-ir}\n}\n\n@misc{github-namada-testnets,\n  author = {anoma},\n  title = {namada-testnets},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/namada-testnets}\n}\n\n@misc{github-ethereum-bridge,\n  author = {anoma},\n  title = {ethereum-bridge},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/ethereum-bridge}\n}\n\n@misc{github-vscode-juvix,\n  author = {anoma},\n  title = {vscode-juvix},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/vscode-juvix}\n}\n\n@misc{github-whitepaper,\n  author = {anoma},\n  title = {whitepaper},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/whitepaper}\n}\n\n@misc{github-devchain-container,\n  author = {anoma},\n  title = {devchain-container},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/devchain-container}\n}\n\n@misc{github-wasm-workspace,\n  author = {anoma},\n  title = {wasm-workspace},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/wasm-workspace}\n}\n\n@misc{github-devtool,\n  author = {anoma},\n  title = {devtool},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/devtool}\n}\n\n@misc{github-anoma-wasm-multitoken,\n  author = {anoma},\n  title = {anoma-wasm-multitoken},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/anoma-wasm-multitoken}\n}\n\n@misc{github-dev-utils,\n  author = {anoma},\n  title = {dev-utils},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/dev-utils}\n}\n\n@misc{github-namada,\n  author = {anoma},\n  title = {namada},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/namada}\n}\n\n@misc{github-namada-interface,\n  author = {anoma},\n  title = {namada-interface},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/namada-interface}\n}\n\n@misc{github-zkp-compiler-shootout,\n  author = {anoma},\n  title = {zkp-compiler-shootout},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/zkp-compiler-shootout}\n}\n\n@misc{github-homebrew-juvix,\n  author = {anoma},\n  title = {homebrew-juvix},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/homebrew-juvix}\n}\n</code></pre> Other literature <pre><code>  title={Heterogeneous Paxos: Technical Report},\n  author={Isaac Sheff and Xinwen Wang and Robbert van Renesse and Andrew C. Myers},\n  year={2020},\n  eprint={2011.08253},\n  archivePrefix={arXiv},\n  primaryClass={cs.DC}\n}\n\n@misc{karbyshevsheff2024heterogeneous,\n  title={Heterogeneous Paxos 2.0: the Specs},\n  author={Aleksandr Karbyshev and Isaac Sheff},\n  year={2024},\n  url={https://pomf2.lain.la/f/owqf7ws.pdf},\n}\n\n@misc{goes2024anoma,\n  author = {Christopher Goes},\n  title = {Anoma as the Universal Intent Machine for Ethereum},\n  year = {2024},\n  howpublished = {{Ethereum Research}},\n  note = {Draft},\n  url = {https://ethresear.ch/t/rfc-draft-anoma-as-the-universal-intent-machine-for-ethereum/19109},\n  urldate = {2024-06-17}\n}\n\n@inproceedings{Hewitt2006,\n  title     = {What Is Commitment? Physical, Organizational, and Social (Revised)},\n  author    = {Hewitt, Carl},\n  year      = 2007,\n  publisher = {Springer Berlin Heidelberg},\n  address   = {Berlin, Heidelberg},\n  pages     = {293--307}\n}\n\n@phdthesis{clinger1981,\n  title     = {Foundations of Actor Semantics},\n  author    = {William Douglas Clinger},\n  year      = 1981,\n  url       = {https://dspace.mit.edu/handle/1721.1/6935},\n  school    = {Massachusetts Institute of Technology (MIT)}\n}\n\n@inproceedings{Hewitt1973,\n  title     = {A Universal Modular Actor Formalism for Artificial Intelligence},\n  author    = {Carl Hewitt and Peter Bishop and Richard Steiger},\n  year      = 1973,\n  location  = {San Francisco, CA, USA},\n  publisher = {Morgan Kaufmann Publishers Inc.},\n  pages     = {235--245}\n}\n\n@book{Scott1976,\n  title     = {Toward a Mathematical Semantics for Computer Languages},\n  author    = {Dana Scott and Christopher Strachey},\n  year      = 1976,\n  publisher = {Prentice-Hall}\n}\n\n@book{Agha1986,\n  title     = {Actors: A Model of Concurrent Computation in Distributed Systems},\n  author    = {Gul A. Agha},\n  year      = 1986,\n  publisher = {MIT Press}\n}\n\n@article{agha-overview-actor-languages,\n  title     = {An overview of actor languages},\n  author    = {Agha, Gul},\n  year      = 1986,\n  month     = {jun},\n  journal   = {SIGPLAN Not.},\n  publisher = {Association for Computing Machinery},\n  address   = {New York, NY, USA},\n  volume    = 21,\n  number    = 10,\n  pages     = {58\u201367},\n  doi       = {10.1145/323648.323743},\n  url       = {https://doi.org/10.1145/323648.323743},\n}\n\n@article{erlang,\n  title     = {The development of Erlang},\n  author    = {Armstrong, Joe},\n  year      = 1997,\n  month     = {aug},\n  journal   = {SIGPLAN Not.},\n  publisher = {Association for Computing Machinery},\n  address   = {New York, NY, USA},\n  volume    = 32,\n  number    = 8,\n  pages     = {196\u2013203},\n  doi       = {10.1145/258949.258967},\n  url       = {https://doi.org/10.1145/258949.258967}\n}\n\n@book{milner-concurrency,\n  title     = {Communication and Concurrency},\n  author    = {Milner, R.},\n  year      = 1989,\n  publisher = {Prentice-Hall, Inc.},\n  address   = {USA}\n}\n\n@article{behavioural-timed-systems,\n  title     = {{Behavioural equivalences for timed systems}},\n  author    = {Tomasz Brengos and Marco Peressotti},\n  year      = 2019,\n  month     = Feb,\n  journal   = {{Logical Methods in Computer Science}},\n  volume    = {{Volume 15, Issue 1}},\n  doi       = {10.23638/LMCS-15(1:17)2019},\n  url       = {https://lmcs.episciences.org/5220}\n}\n\n@inproceedings{actario,\n  title     = {Actario: A framework for reasoning about actor systems},\n  author    = {Yasutake, Shohei and Watanabe, Takuo},\n  year      = 2015\n}\n\n@article{Talcott1998,\n  title     = {Composable Semantic Models for Actor Theories},\n  author    = {Talcott,  Carolyn L.},\n  year      = 1998,\n  journal   = {Higher Order Symbolic Computation},\n  publisher = {Springer Science and Business Media LLC},\n  volume    = 11,\n  number    = 3,\n  pages     = {281\u2013343},\n  doi       = {10.1023/a:1010042915896},\n  url       = {http://dx.doi.org/10.1023/A:1010042915896}\n}\n\n@article{lamport-global-states,\n  title     = {Distributed snapshots: determining global states of distributed systems},\n  author    = {Chandy, K. Mani and Lamport, Leslie},\n  year      = 1985,\n  month     = {feb},\n  journal   = {ACM Transactions on Computer Systems},\n  publisher = {Association for Computing Machinery},\n  address   = {New York, NY, USA},\n  volume    = 3,\n  number    = 1,\n  pages     = {63\u201375},\n  doi       = {10.1145/214451.214456},\n  url       = {https://doi.org/10.1145/214451.214456},\n}\n\n@article{selectors-actors-2014,\n  title     = {Selectors: Actors with Multiple Guarded Mailboxes},\n  author    = {Imam,  Shams M. and Sarkar,  Vivek},\n  year      = 2014,\n  month     = oct,\n  publisher = {ACM},\n  journal   = {AGERE! '14: Proceedings of the 4th International Workshop on Programming based on Actors Agents and Decentralized Control},\n  series    = {SPLASH '14},\n  doi       = {10.1145/2687357.2687360},\n  url       = {http://dx.doi.org/10.1145/2687357.2687360},\n  collection = {SPLASH '14}\n}\n\n@article{special-delivery-mailbox-types-2023,\n  title     = {Special Delivery: Programming with Mailbox Types},\n  author    = {Fowler,  Simon and Attard,  Duncan Paul and Sowul,  Franciszek and Gay,  Simon J. and Trinder,  Phil},\n  year      = 2023,\n  month     = aug,\n  journal   = {Proceedings of the ACM on Programming Languages},\n  publisher = {Association for Computing Machinery (ACM)},\n  volume    = 7,\n  number    = {ICFP},\n  pages     = {78\u2013107},\n  doi       = {10.1145/3607832},\n  url       = {http://dx.doi.org/10.1145/3607832}\n}\n\n@article{there-is-no-now-2015,\n  title     = {There is No Now: Problems with simultaneity in distributed systems},\n  author    = {Sheehy, Justin},\n  year      = 2015,\n  month     = {mar},\n  journal   = {Queue},\n  publisher = {Association for Computing Machinery},\n  address   = {New York, NY, USA},\n  volume    = 13,\n  number    = 3,\n  pages     = {20\u201327},\n  doi       = {10.1145/2742694.2745385},\n  url       = {https://doi.org/10.1145/2742694.2745385}\n}\n\n@article{why-local-clocks-are-easy-2016,\n  title     = {Why Logical Clocks are Easy: Sometimes all you need is the right language.},\n  author    = {Baquero, Carlos and Pregui\\c{c}a, Nuno},\n  year      = 2016,\n  month     = {feb},\n  journal   = {Queue},\n  publisher = {Association for Computing Machinery},\n  address   = {New York, NY, USA},\n  volume    = 14,\n  number    = 1,\n  pages     = {53\u201369},\n  doi       = {10.1145/2898442.2917756},\n  url       = {https://doi.org/10.1145/2898442.2917756}\n}\n\n@article{lamport-time-clocks-1978,\n  title     = {Time, clocks, and the ordering of events in a distributed system},\n  author    = {Lamport, Leslie},\n  year      = 1978,\n  month     = {jul},\n  journal   = {Commun. ACM},\n  publisher = {Association for Computing Machinery},\n  address   = {New York, NY, USA},\n  volume    = 21,\n  number    = 7,\n  pages     = {558\u2013565},\n  doi       = {10.1145/359545.359563},\n  url       = {https://doi.org/10.1145/359545.359563},\n}\n\n@inproceedings{taxonomy-of-actor-models-2016,\n  title     = {43 years of actors: a taxonomy of actor models and their key properties},\n  author    = {De Koster, Joeri and Van Cutsem, Tom and De Meuter, Wolfgang},\n  year      = 2016,\n  location  = {Amsterdam, Netherlands},\n  publisher = {Association for Computing Machinery},\n  address   = {New York, NY, USA},\n  series    = {AGERE 2016},\n  pages     = {31\u201340},\n  doi       = {10.1145/3001886.3001890},\n  url       = {https://doi.org/10.1145/3001886.3001890},\n  booktitle = {Proceedings of the 6th International Workshop on Programming Based on Actors, Agents, and Decentralized Control}\n}\n\n@book{Nissanke1999,\n  title = {Formal Specification},\n  ISBN = {9781447107910},\n  url = {http://dx.doi.org/10.1007/978-1-4471-0791-0},\n  DOI = {10.1007/978-1-4471-0791-0},\n  publisher = {Springer London},\n  author = {Nissanke,  Nimal},\n  year = {1999}\n}\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/md/headers_and_other_conventions.html","title":"Headers and other Markdown conventions","text":"<ul> <li> <p>Use semantic headers to structure your content.</p> <ul> <li>Use <code>#</code> for the main title, <code>##</code> for the first-level header, <code>###</code> for the   second-level header.</li> <li>Only use up to the third level of headers. If you need more levels, consider   restructuring your content.</li> </ul> </li> </ul> <ul> <li> <p>Use sentence case for headers. For example,</p> <ul> <li>use \"How to use this glossary\" instead of \"How to Use This Glossary\", or,</li> <li>use \"Anoma protocol\" instead of  \"Anoma Protocol\", or</li> <li>use \"On engine systems for the Anoma Specification\" instead of \"On Engine   Systems For The Anoma Specification\".</li> </ul> </li> </ul> <ul> <li>Always add a front matter as described in Write using Markdown.</li> </ul> <ul> <li>The (Juvix) Markdown filenames should follow the convention as described in File naming conventions.</li> </ul>","tags":["tutorial","conventions"]},{"location":"tutorial/md/images.html","title":"Support for including images","text":"<p>Images should be stored in the <code>docs/images</code> folder. Use the File Naming Conventions also for naming images.</p> <p>Image handling in Markdown</p> <p>Use standard Markdown image syntax (<code>![Alt text](image.png)</code>) rather than HTML image tags. HTML image tags are not processed by MkDocs, are not validated, and may not work as expected. In particular, their <code>src</code> attribute is not processed by our image processing script.</p>","tags":["tutorial","conventions"]},{"location":"tutorial/md/images.html#syntax","title":"Syntax","text":"<p>To add an image, apply the following syntax:</p> <pre><code>![Alt Text](logo.svg){: width=\"200\"}\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/md/images.html#displayed-image-example","title":"Displayed Image Example","text":"<p>The syntax above will render the image in your document like so:</p> <p></p> <p>Enhanced Image Display</p> <p>Use an HTML <code>&lt;figure&gt;</code> element with a <code>&lt;figcaption&gt;</code> for a refined presentation with captions. Markdown can also be used within the caption:</p> <pre><code>&lt;figure markdown=\"1\"&gt;\n\n  ![Alt Text](image-name.png)\n\n  &lt;figcaption markdown=\"span\"&gt;Image caption text can include *Markdown*!&lt;/figcaption&gt;\n&lt;/figure&gt;\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/md/links.html","title":"Support for Wiki Links","text":"<p>Wiki links offer a simple method for citing and referencing other pages in the documentation without lengthy URLs. Wiki links are the preferred method for linking to other pages in the documentation, so please use them whenever possible.</p>","tags":["tutorial","conventions"]},{"location":"tutorial/md/links.html#basic-syntax","title":"Basic Syntax","text":"<p>The basic syntax for a wiki link is:</p> <pre><code>page\n</code></pre> <p>Where:</p> <ul> <li><code>page</code> is the title of the target page</li> </ul>","tags":["tutorial","conventions"]},{"location":"tutorial/md/links.html#full-syntax","title":"Full Syntax","text":"<p>The full syntax for a wiki link is: Wiki Link Syntax<pre><code>  Custom caption\n</code></pre></p> <p>When resolving a wiki link, the system follows these rules:</p>","tags":["tutorial","conventions"]},{"location":"tutorial/md/links.html#page-title","title":"Page Title","text":"<p>(Mandatory) The 'page' in a wiki link refers to the title specified in the <code>nav</code> attribute of the <code>mkdocs.yml</code> file. For example,</p> mkdocs.yml<pre><code>nav:\n  - Home: index.md\n  - MyRef X: reference.md\n</code></pre> <p>provides the following wiki link:</p> <pre><code>MyRef X\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/md/links.html#path-hints","title":"Path Hints","text":"<p>(Optional) You can use path hints to specify the location of the file. The syntax is:</p> Path Hints<pre><code>page\n</code></pre> <p>Where:</p> <ul> <li><code>hintpath/to</code> is the path (or prefix) to the file</li> <li><code>page</code> is the title of the target page</li> </ul>","tags":["tutorial","conventions"]},{"location":"tutorial/md/links.html#anchors","title":"Anchors","text":"<p>(Optional) Use anchors to link to specific sections within a page. If the page does not have an anchor, the link would render as the caption provided, and you'll find a warning in the build process.</p> Anchors<pre><code>page\n</code></pre> <p>Where:</p> <ul> <li><code>page</code> is the title of the target page</li> <li><code>anchor</code> is a specific section within the page</li> </ul>","tags":["tutorial","conventions"]},{"location":"tutorial/md/links.html#custom-captions","title":"Custom captions","text":"<p>(Optional) Provide custom text to display for the link instead of the page title.</p> Custom Captions<pre><code>Custom caption\n</code></pre> <p>Where:</p> <ul> <li><code>page</code> is the title of the target page</li> <li><code>anchor</code> is a specific section within the page</li> </ul> <p>Captions can include icons, for example:</p> MarkdownPreview <pre><code>[:material-link: this is a caption with an icon](https://specs.anoma.net/pr-347/index.html)\n</code></pre> <p> this is a caption with an icon</p>","tags":["tutorial","conventions"]},{"location":"tutorial/md/snippets.html","title":"Include code snippets","text":"","tags":["tutorial","conventions"]},{"location":"tutorial/md/snippets.html#code-snippets","title":"Code Snippets","text":"<p>Include excerpts from other files using the Snippet extension detailed here: PyMdown Extensions - Snippets.</p>","tags":["tutorial","conventions"]},{"location":"tutorial/md/snippets.html#excerpt-wrapping-syntax","title":"Excerpt Wrapping Syntax","text":"<p>Enclose the excerpt with the following tags:</p> <pre><code>&lt;!-- Start snippet --&gt;\n;--8&lt;-- [start:TAG]\n...\n;--8&lt;-- [end:TAG]\n&lt;!-- End snippet --&gt;\n</code></pre>","tags":["tutorial","conventions"]},{"location":"tutorial/md/snippets.html#snippet-inclusion-syntax","title":"Snippet Inclusion Syntax","text":"<p>To incorporate the excerpt elsewhere, specify its path and tag:</p> <pre><code>;--8&lt;-- \"path/to/file.ext:TAG\"\n</code></pre> <p>Following these practices ensures consistency, navigability, and professionalism in the Anoma documentation.</p>","tags":["tutorial","conventions"]},{"location":"tutorial/md/todos.html","title":"Add pending tasks with Todos admonition","text":"","tags":["tutorial","conventions"]},{"location":"tutorial/md/todos.html#todos","title":"Todos","text":"<p>Incorporate todos with the following syntax:</p> <pre><code>!!! todo\n\n    Content of the todo\n</code></pre> <p>The above renders as:</p> <p>Todo</p> <p>Content of the todo</p> <p>Info</p> <p>Be aware that todos are automatically removed from the online version. If you want to keep them, set <code>todos: True</code> in the front matter.</p>","tags":["tutorial","conventions"]}]}