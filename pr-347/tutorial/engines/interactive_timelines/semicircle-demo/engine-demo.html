<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Engine Interaction Demo</title>

  <!-- React and ReactDOM -->
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>

  <!-- Babel for JSX transpilation -->
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.22.20/babel.min.js"></script>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    html, body, #root {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    /* Custom icons styles */
    .mail-icon {
      width: 12px;
      height: 12px;
      margin-right: 4px;
    }
  </style>
</head>
<body>
  <div id="root" class="h-full"></div>

  <!-- Import the engine-demo.tsx file as a Babel script -->
  <script type="text/babel" data-type="module">
    // Create a simple mail icon component instead of using Lucide
    const MailIcon = ({ size = 12, className = "" }) => (
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width={size}
        height={size}
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        className={`mail-icon ${className}`}
      >
        <rect width="20" height="16" x="2" y="4" rx="2"></rect>
        <path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"></path>
      </svg>
    );

    // Define the fake @/components/ui/card imports that might be in your TSX
    const Card = ({ children, className }) => (
      <div className={`bg-white rounded-lg shadow ${className || ''}`}>{children}</div>
    );

    const CardHeader = ({ children }) => (
      <div className="p-4 border-b">{children}</div>
    );

    const CardTitle = ({ children }) => (
      <h3 className="text-lg font-semibold">{children}</h3>
    );

    const CardContent = ({ children }) => (
      <div className="p-4">{children}</div>
    );

    // Import the contents of engine-demo.tsx here
    const EngineDemoComponent = () => {
      // Message types as defined in the spec
      const MessageTypes = {
        INCREMENT: 'TickerMsgIncrement',
        COUNT_REQUEST: 'TickerMsgCountRequest',
        COUNT_REPLY: 'TickerMsgCountReply'
      };

      // Engine state
      const [counter, setCounter] = React.useState(0);
      const [messageQueue, setMessageQueue] = React.useState([]);
      const [userHistory, setUserHistory] = React.useState([]);
      const [engineHistory, setEngineHistory] = React.useState([]);

      // UI state
      const [selectedMessageType, setSelectedMessageType] = React.useState(MessageTypes.INCREMENT);
      const [pipPosition, setPipPosition] = React.useState({ x: 120, y: 150 });
      const [animatingMessage, setAnimatingMessage] = React.useState(null);
      const [processingInterval, setProcessingInterval] = React.useState(Math.floor(Math.random() * 9) + 1);
      const [timeLeft, setTimeLeft] = React.useState(processingInterval);

      const semicircleRef = React.useRef(null);

      // Handle mouse movement on the semicircle
      const handleMouseMove = (e) => {
        if (semicircleRef.current) {
          const rect = semicircleRef.current.getBoundingClientRect();
          const centerX = 200; // Center X of the semicircle
          const centerY = 150; // Center Y of the semicircle
          const radius = 80;

          // Get mouse position relative to the center
          const mouseX = e.clientX - rect.left - centerX;
          const mouseY = e.clientY - rect.top - centerY;

          // Only update if in the left half of the circle (mouseX < 0)
          if (mouseX < 0) {
            // Calculate distance from center
            const distance = Math.sqrt(mouseX * mouseX + mouseY * mouseY);

            // Normalize to radius
            const normalizedX = mouseX * (radius / distance);
            const normalizedY = mouseY * (radius / distance);

            setPipPosition({
              x: centerX + normalizedX,
              y: centerY + normalizedY
            });
          }
        }
      };

      // Handle message sending
      const handleSendMessage = () => {
        const newMessage = {
          id: Date.now(),
          type: selectedMessageType,
          from: 'user',
          to: 'engine',
          data: selectedMessageType === MessageTypes.COUNT_REPLY ? { counter } : null,
          position: { ...pipPosition }
        };

        // Add to message queue
        setMessageQueue(prev => [...prev, newMessage]);

        // Add to user history
        setUserHistory(prev => [newMessage, ...prev].slice(0, 5));

        // Animate the message
        setAnimatingMessage({
          ...newMessage,
          startX: pipPosition.x,
          startY: pipPosition.y,
          endX: 320, // Engine orb X position
          endY: 150, // Engine orb Y position
          progress: 0
        });
      };

      // Process a message from the queue
      const processNextMessage = () => {
        if (messageQueue.length > 0) {
          const [nextMessage, ...remainingMessages] = messageQueue;
          setMessageQueue(remainingMessages);

          // Process the message based on its type
          if (nextMessage.type === MessageTypes.INCREMENT) {
            setCounter(prev => prev + 1);
          } else if (nextMessage.type === MessageTypes.COUNT_REQUEST) {
            // Create a reply message
            const replyMessage = {
              id: Date.now(),
              type: MessageTypes.COUNT_REPLY,
              from: 'engine',
              to: 'user',
              data: { counter }
            };

            // Add to engine history
            setEngineHistory(prev => [replyMessage, ...prev].slice(0, 5));

            // Animate reply message from engine to user
            setAnimatingMessage({
              ...replyMessage,
              startX: 320, // Engine orb X position
              startY: 150, // Engine orb Y position
              endX: 200,   // Semicircle center X
              endY: 150,   // Semicircle center Y
              progress: 0
            });

            // Add to user history after animation completes
            setTimeout(() => {
              setUserHistory(prev => [replyMessage, ...prev].slice(0, 5));
            }, 1000);
          }

          // Add to engine history
          setEngineHistory(prev => [nextMessage, ...prev].slice(0, 5));

          // Set a new random interval
          setProcessingInterval(Math.floor(Math.random() * 9) + 1);
          setTimeLeft(Math.floor(Math.random() * 9) + 1);
        }
      };

      // Animation effect for the message
      React.useEffect(() => {
        if (animatingMessage) {
          const animationInterval = setInterval(() => {
            setAnimatingMessage(prev => {
              if (!prev) return null;
              if (prev.progress >= 1) {
                clearInterval(animationInterval);
                return null;
              }
              return { ...prev, progress: prev.progress + 0.05 };
            });
          }, 20);

          return () => clearInterval(animationInterval);
        }
      }, [animatingMessage]);

      // Engine processing timer
      React.useEffect(() => {
        const timer = setInterval(() => {
          setTimeLeft(prev => {
            if (prev <= 0) {
              processNextMessage();
              return processingInterval;
            }
            return prev - 1;
          });
        }, 1000);

        return () => clearInterval(timer);
      }, [messageQueue, processingInterval]);

      // Calculate message animation position
      const getMessagePosition = () => {
        if (!animatingMessage) return null;

        const { startX, startY, endX, endY, progress } = animatingMessage;
        const x = startX + (endX - startX) * progress;
        const y = startY + (endY - startY) * progress;

        return { x, y };
      };

      const messagePosition = getMessagePosition();

      return (
        <div className="w-full h-full flex flex-col">
          {/* Main interaction area with controls on left, visualization in center, queue on right */}
          <div className="flex-grow flex justify-center items-center mt-8">
            {/* Message type selection buttons on left */}
            <div className="flex flex-col space-y-2 mr-8" style={{ width: '140px' }}>
              <button
                className={`px-4 py-2 rounded ${selectedMessageType === MessageTypes.INCREMENT ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setSelectedMessageType(MessageTypes.INCREMENT)}
              >
                Increment
              </button>
              <button
                className={`px-4 py-2 rounded ${selectedMessageType === MessageTypes.COUNT_REQUEST ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setSelectedMessageType(MessageTypes.COUNT_REQUEST)}
              >
                Request Count
              </button>
            </div>

            {/* Semicircle and Engine Orb container in center */}
            <div className="relative">
              {/* Semicircle and pip */}
              <svg
                width="400"
                height="300"
                viewBox="0 0 400 300"
                onMouseMove={handleMouseMove}
                onClick={handleSendMessage}
                ref={semicircleRef}
              >
                {/* Left semicircle */}
                <path
                  d="M 200 70 A 80 80 0 0 0 200 230"
                  fill="none"
                  stroke="#ccc"
                  strokeWidth="2"
                />

                {/* Active pip */}
                <circle
                  cx={pipPosition.x}
                  cy={pipPosition.y}
                  r="5"
                  fill="#3B82F6"
                />

                {/* Engine orb */}
                <circle cx="320" cy="150" r="40" fill="#4FD1C5" />

                {/* Animating message */}
                {messagePosition && (
                  <g>
                    <circle
                      cx={messagePosition.x}
                      cy={messagePosition.y}
                      r="8"
                      fill={animatingMessage?.from === 'user' ? '#3B82F6' : '#FFA500'}
                    />
                    <svg
                      x={messagePosition.x - 6}
                      y={messagePosition.y - 6}
                      width="12"
                      height="12"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke={animatingMessage?.from === 'user' ? 'white' : 'black'}
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    >
                      <rect width="20" height="16" x="2" y="4" rx="2"></rect>
                      <path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"></path>
                    </svg>
                  </g>
                )}
              </svg>

              {/* Counter display */}
              <div className="absolute" style={{ left: '320px', top: '200px', transform: 'translateX(-50%)' }}>
                <div className="text-center font-mono text-lg">
                  Count: {counter}
                </div>
              </div>
            </div>

            {/* Message queue and processing timer on right */}
            <div className="ml-8" style={{ width: '200px' }}>
              {/* Processing timer above queue */}
              <div className="text-center mb-2">
                <div className="text-sm text-gray-500">
                  Processing in: {timeLeft}s
                </div>
              </div>

              {/* Message queue */}
              <div className="p-4 border rounded w-full h-64 overflow-y-auto">
                <h3 className="text-sm font-bold mb-2">Message Queue ({messageQueue.length})</h3>
                <div className="space-y-2">
                  {messageQueue.slice(0, 3).map(msg => (
                    <div key={msg.id} className="flex items-center p-2 bg-gray-100 rounded text-xs">
                      <MailIcon size={12} />
                      <span>{msg.type}</span>
                    </div>
                  ))}
                  {messageQueue.length > 3 && (
                    <div className="text-xs text-gray-500">+ {messageQueue.length - 3} more</div>
                  )}
                </div>
              </div>
            </div>
          </div>

          {/* Message history (bottom) - clear separation */}
          <div className="border-t mt-auto">
            <div className="flex">
              {/* User received history */}
              <div className="w-1/2 p-4">
                <h3 className="text-sm font-bold mb-2">User Received Messages</h3>
                <div className="space-y-2 h-32 overflow-y-auto">
                  {userHistory.filter(msg => msg.from === 'engine').length === 0 ? (
                    <div className="text-xs text-gray-500">No messages received yet</div>
                  ) : (
                    userHistory.filter(msg => msg.from === 'engine').map(msg => (
                      <div key={msg.id} className="flex items-center p-2 bg-gray-100 rounded text-xs">
                        <MailIcon size={12} />
                        <span>{msg.type}</span>
                        {msg.data && <span className="ml-2 text-gray-500">Counter: {msg.data.counter}</span>}
                      </div>
                    ))
                  )}
                </div>
              </div>

              {/* Engine received history */}
              <div className="w-1/2 p-4">
                <h3 className="text-sm font-bold mb-2">Engine Received Messages</h3>
                <div className="space-y-2 h-32 overflow-y-auto">
                  {engineHistory.filter(msg => msg.from === 'user').length === 0 ? (
                    <div className="text-xs text-gray-500">No messages received yet</div>
                  ) : (
                    engineHistory.filter(msg => msg.from === 'user').map(msg => (
                      <div key={msg.id} className="flex items-center p-2 bg-gray-100 rounded text-xs">
                        <MailIcon size={12} />
                        <span>{msg.type}</span>
                      </div>
                    ))
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    // Render the app
    const App = () => {
      return <EngineDemoComponent />;
    };

    // Use the appropriate React version for the render call
    if (ReactDOM.createRoot) {
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    } else {
      ReactDOM.render(<App />, document.getElementById('root'));
    }
  </script>
</body>
</html>