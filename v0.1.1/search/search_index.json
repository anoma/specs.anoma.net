{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"changelog.html","title":"Change Log","text":""},{"location":"changelog.html#v011","title":"v0.1.1","text":"<p>Major revision of the engine definitions, the template, and the ticker engine.</p>"},{"location":"changelog.html#features","title":"FEATURES","text":"<ul> <li>Repository maintenance and CI<ul> <li>#217: Update template engine   files to be more consistent, use backticks for Juvix terms/types in   headlines, uncollapsed sections for type constructors arguments in template   engine files, and auxiliary sections of Juvix code are always collapsed.</li> </ul> </li> </ul>"},{"location":"changelog.html#fixes","title":"FIXES","text":"<ul> <li>Node architecture<ul> <li>#219: Revisit Commitment Engine. Changes to the messages, environment, and behaviour types to conform the recent template changes.</li> <li>#253: Integration PR that   combines multiple engine-related changes: Engines: Use <code>ByteString</code> in   crypto types #242, Engines:   ByteString type definition #255,   Engines: <code>EngineMsg</code> revision #241,   EngineID: make <code>EngineName</code> compulsory #256, Engines: Engine type revision #244,  <code>EngineMsg</code>: add type param #258, Engines: add <code>GuardEval</code> and <code>ActionExec</code> #260, and Engines: Behaviour template revision #226.</li> <li>#256: Make <code>EngineName</code>   compulsory in <code>EngineID</code>.</li> </ul> </li> <li>Repository maintenance and CI<ul> <li>#218: Rename <code>EngineMessage</code> type to <code>EngineMsg</code> and <code>mkEngineMessage</code> to <code>mkEngineMsg</code>.</li> <li>#220: Fix the deployment of the latest version by deploying the website if the branch name is <code>main</code> or matches the semver pattern, and add information about the version and the commit hash to the title for reference.</li> <li>#222: Remove SML codebase as   not used any more and any other reference in the markdown files</li> <li>#225: Fix navigation table for the identity component</li> <li>#227: Update Juvix version in Nix flake due to breaking changes, and   also the input packages while at it.</li> <li>#250: Update policy on Juvix typechecking. The whole codebase in a   PR should typecheck before merging</li> </ul> </li> <li>Tutorial and documentation<ul> <li>#257: Refactor the Git strategy: introduce integration PRs for   better overview of complex changes</li> </ul> </li> <li>Juvix types and updates<ul> <li>#221: Update the prelude to   incorporate the latest changes in the <code>Stdlib</code>, including the addition of   applicative and monad traits, and the integration of the <code>containers</code> library.   This update also includes changes to data type definitions, with the <code>@</code>   syntax now used for declaration, creation, and matching on records, and other   removals like <code>: Type</code> for implicit arguments and function-style declarations.</li> <li>#226: Update Template &amp; Ticker Behaviour according to the engine &amp; message type changes. The examples have been improved with better clarity. The documentation now uses headlines instead of collapsible boxes and definition lists instead of tables. A new diagram template has been added that illustrates conditions and effects of actions.</li> <li>#241: <code>EngineMsg</code>-related changes: rename <code>MessageID</code> to <code>EngineMsgID</code>, add <code>getEngineMsgFrom(Timestamped)Trigger</code>, and rename <code>getMessageFrom(Timestamped)Trigger</code> to <code>getMsgFrom(Timestamped)Trigger</code>.</li> <li>#242: Use <code>ByteString</code> in crypto types.</li> <li>#244: Major refactoring of   engine-related types. The <code>Engine</code> type now includes a <code>cfg</code> field of type   <code>EngineConfig</code> containing static configuration (engine name and local node   ID). For consistency, <code>EngineEnvironment</code> has been renamed to <code>EngineEnv</code>. The   <code>EngineBehaviour</code> type has undergone several changes: the conflict solver has   been removed (to be replaced by new mechanism in   #246), precomputation results are   now passed directly as action arguments, and the <code>action</code> field has been   replaced with action labels defined by label type.</li> <li>#249: Remove <code>name</code> field in Engine instances due to PR 242</li> <li>#255: Make ByteString <code>String</code> instead of <code>Nat</code></li> <li>#258: Engine-related changes: add type parameter to parameterized the type of message and rename <code>EngineConfig</code> to <code>EngineCfg</code></li> <li>#260: Revise engine behaviour type: add <code>GuardEval (Seq)</code> and <code>ActionExec (First &amp; Any)</code>, <code>EngineCfg</code>: add <code>getEngineIDFromEngineCfg</code>. Partially addresses #246.</li> </ul> </li> </ul>"},{"location":"changelog.html#v010","title":"v0.1.0","text":"<p>This is the first release of Anoma's Spec project, following the semantic-versioning scheme. This version includes all the changes from the creation of this repository. From here on, we will keep a changelog of all the changes that are made to the project per version, with better documentation and descriptions of the changes.</p>"},{"location":"changelog.html#breaking-changes","title":"BREAKING CHANGES","text":"<ul> <li>Node architecture<ul> <li>#179: Reorganize node architecture   documentation structure</li> </ul> </li> <li>Repository maintenance and CI<ul> <li>#29: Remove unused libraries</li> <li>#30: Remove juvix hook in pro of mkdos Juvix   plugin</li> <li>#53: Setup: require only python 3.9</li> <li>#60: Restructure for v2</li> <li>#64: Change KV Storage Deletion Documentation</li> <li>#65: Delete Compute and Randomness Engines</li> <li>#69: Remove outdates files from arch1 and fix   formatting</li> <li>#104: Refactor scope, basic types, and   application architecture sections</li> <li>#115: Refactor file and folder names: add   snake_case convention</li> </ul> </li> <li>General specification changes<ul> <li>#192: Port identity engines to v2 template</li> </ul> </li> <li>System and node architecture<ul> <li>#210: Fix engine message, environment and   behavior layout</li> </ul> </li> </ul>"},{"location":"changelog.html#bug-fixes","title":"BUG FIXES","text":"<ul> <li>Repository maintenance and CI<ul> <li>#4: Fix mike</li> <li>#9: Add batch of fixes</li> <li>#10: Fix Index: quick links and remove empty types   pages</li> <li>#18: Fix TODO, add todos.py script, and more   formatting issues</li> <li>#19: Remove todos on deploy, fix wikilinks warnings</li> <li>#21: Fix whitespaces</li> <li>#22: Fix indexes generation with macros and optimize   caching</li> <li>#24: Fix minors</li> <li>#25: CI fixes</li> <li>#74: Fix broken links in navigation bar and a few   pages</li> <li>#77: Fix CI: deploy website by PRs against main, v1,   and v2</li> <li>#78: Fix: CI doesnt trigger on edits</li> <li>#91: Fix default views and deploys in the CI</li> <li>#96: Fix navigation bar and more broken links due #60</li> <li>#101: Fix typos and small improve wording</li> <li>#105: Fix warnings messages due to recent refactors</li> <li>#122: Fix support for Juvix Markdown snippets</li> <li>#123: Fix merging conflicts chris-update-basic-types</li> <li>#124: Fix tutorial nav structure and broken links in   the footer</li> <li>#132: Fix minor issues with directories and filenames</li> </ul> </li> </ul>"},{"location":"changelog.html#features_1","title":"FEATURES","text":"<ul> <li>Application documentation<ul> <li>#198: Add transparent RM implementation documentation</li> </ul> </li> <li>Python-related changes<ul> <li>#133: Add support for multi-line wiki-style links</li> </ul> </li> <li>Repository maintenance and CI<ul> <li>#2: Add better support for WikiLinks and other goodies</li> <li>#3: Update README and run pre-commit</li> <li>#5: Add Ubuntu dependencies to the CI</li> <li>#6: Use site_url for link generation</li> <li>#7: Add new hook for images</li> <li>#8: Add lightboxes to images, fix local image loading</li> <li>#11: Improve link resolution for urls outside nav</li> <li>#14: Add Last updated time to the footer and other   fixes</li> <li>#15: Add a more explicit MathJax config</li> <li>#17: Revised macros configuration</li> <li>#20: Refactor hooks</li> <li>#23: Add previews for PRs</li> <li>#27: Fix url indexes and improve PR previews</li> <li>#28: Add tutorial basic instructions</li> <li>#31: Translate Haskell snippets to Juvix and fix typos</li> <li>#51: Configuration Engine</li> <li>#52: Add nix flake</li> <li>#56: Add page on dynamic code loading</li> <li>#58: Homogeneous consensus for V2</li> <li>#59: Readme: tighten up install instructions</li> <li>#61: Updates kudos spec</li> <li>#63: Counter example</li> <li>#68: Add New Engine Specifications from Anoma Elixir   Database</li> <li>#75: Add proof-of-stake example</li> <li>#80: Re-introduced full execution machine for V2</li> <li>#81: Add BibTeX entries and fix configuration</li> <li>#84: Add templates for defining engine systems</li> <li>#92: Add global table of contents</li> <li>#95: Continue v2 updates</li> <li>#97: Add git branching strategy</li> <li>#98: Add citation instructions and restructure markdown   tutorials</li> <li>#99: Delete previews for closed PRs on gh-pages branch</li> <li>#100: Split CI workflows: deploy, pull-request, clean-   ups</li> <li>#103: Additional reorganization &amp; updates</li> <li>#117: Tweaks to message types in basics</li> <li>#120: Refactor tutorial organization and add a few   more on conventions</li> <li>#121: Improve look&amp;feel, organized nav, hide extra   links and move them to the footer</li> <li>#127: Update basic abstractions</li> <li>#131: Add RMv3 content</li> <li>#135: Show PR number in the site name</li> <li>#209: Add changelog management system</li> <li>#214: Add GitHub template for creating PRs</li> </ul> </li> <li>Tutorial and documentation<ul> <li>#134: Refactor tutorial for wiki-style links</li> </ul> </li> <li>Juvix types and updates<ul> <li>#128: Add new Juvix definitions from PR-84</li> <li>#130: Translate SML Identity definitions to Juvix</li> </ul> </li> </ul>"},{"location":"dynamic_code_loading.html","title":"Dynamic code loading","text":""},{"location":"dynamic_code_loading.html#dynamic-code-loading","title":"Dynamic code loading","text":"<p>In general, code can be stored in the standard content-addressed storage. In order to retrieve code whose identity is known ahead of time (e.g. a standard library), this should be sufficient. In order to retrieve code dynamically (likely with rules on how it can be changed), a resource index lookup is necessary. A particular denomination can be associated with a series of resources, each representing successive versions of code and containing a reference to the code hash, with rules as desired governing how the code associated with this name can be changed.</p> <p>Code which is looked up may be evaluated in the transaction function or verified in a resource logic.</p>"},{"location":"dynamic_code_loading.html#dynamic-code-evaluation-in-a-transaction-function","title":"Dynamic code evaluation in a transaction function","text":"<p>Simply read the code (statically, or by looking up a resource) and call <code>eval</code> or equivalent.</p> <p>This system, while simple, automatically provides many nice properties: for example, different versions of the standard library addressed statically will automatically be deduplicated, code-pinned, and cached.</p>"},{"location":"dynamic_code_loading.html#dynamic-code-verification-in-a-resource-logic","title":"Dynamic code verification in a resource logic","text":"<p>Here, we want a slightly different behaviour: namely, to verify that the code looked up was executed correctly. In the case of a transparent proof, this functions similarly. In the case of a shielded proof, the code reference will need to be a verifying key, and an extra proof will need to be provided in the transaction. The inputs which must correspond to the inputs used in the proof must themselves be specified. This should be provided by a <code>verify</code> syscall of sorts.</p>"},{"location":"everything.html","title":"Everything","text":"<pre><code><pre>module everything;import prelude;import arch.system.identity.index;import arch.system.identity.identity;import arch.node.types;import arch.node.types.basics;import arch.node.types.crypto;import arch.node.types.messages;import arch.node.types.identities;import arch.node.types.anoma;import arch.node.types.anoma_message;import arch.node.types.anoma_environment;import arch.node.types.engine;import arch.node.types.engine_behaviour;import arch.node.types.engine_environment;import arch.node.engines.ticker;import arch.node.engines.ticker_messages;import arch.node.engines.ticker_environment;import arch.node.engines.ticker_behaviour;import arch.node.engines.template;import arch.node.engines.template_messages;import arch.node.engines.template_environment;import arch.node.engines.template_behaviour;</pre></code></pre>","boost":2},{"location":"prelude.html","title":"Juvix Base Prelude","text":"Juvix imports <p><pre><code><pre>module prelude;import Stdlib.Trait open public;import Stdlib.Trait.Ord open using {Ordering; mkOrd; Equal; isEqual} public;import Stdlib.Trait.Eq open using {==} public;</pre></code></pre></p>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#common-types-juvix-base-prelude","title":"Common Types - Juvix Base Prelude","text":"<p>The following are frequent and basic abstractions used in the Anoma specification. Most of them are defined in the Juvix standard library and are used to define more complex types in the Anoma Specification.</p>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#nat","title":"Nat","text":"<p>The type <code>Nat</code> represents natural numbers (non-negative integers). Used for counting and indexing.</p> <pre><code><pre>import Stdlib.Data.Nat as Nat open using {  Nat;  zero;  suc;  natToString;  +;  *;  &lt;=;} public;</pre></code></pre> <p>For example,</p> <pre><code><pre>ten : Nat := 10;</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#bool","title":"Bool","text":"<p>The type <code>Bool</code> represents boolean values (<code>true</code> or <code>false</code>). Used for logical operations and conditions.</p> <pre><code><pre>import Stdlib.Data.Bool as Bool open using {  Bool;  true;  false;  ite;  &amp;&amp;;  ||;  not;  or;  and;} public;</pre></code></pre> <p>For example,</p> <pre><code><pre>verdad : Bool := true;</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#string","title":"String","text":"<p>The type <code>String</code> represents sequences of characters. Used for text and communication.</p> <pre><code><pre>import Stdlib.Data.String as String open using {String; ++str} public;</pre></code></pre> <p>For example,</p> <pre><code><pre>hello : String := \"Hello, World!\";</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#bytestring","title":"ByteString","text":"<pre><code><pre>ByteString : Type := String;</pre></code></pre> <p>A basic type for representing binary data.</p> <pre><code><pre>emptyByteString : ByteString := \"\";</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#unit","title":"Unit","text":"<p>The type <code>Unit</code> represents a type with a single value. Often used when a function does not return any meaningful value.</p> <pre><code><pre>import Stdlib.Data.Unit as Unit open using {Unit; unit} public;</pre></code></pre> <p>For example,</p> <pre><code><pre>unitValue : Unit := unit;</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#pair-a-b","title":"Pair A B","text":"<p>The type <code>Pair A B</code> represents a tuple containing two elements of types <code>A</code> and <code>B</code>. Useful for grouping related values together.</p> <pre><code><pre>import Stdlib.Data.Pair as Pair;open Pair using {Pair} public;open Pair using {,};</pre></code></pre> <pre><code><pre>import Stdlib.Data.Fixity open;syntax operator mkPair none;syntax alias mkPair := ,;</pre></code></pre> <p>For example,</p> <pre><code><pre>pair : Pair Nat Bool := mkPair 42 true;</pre></code></pre> <p>Projections</p> <pre><code><pre>fst {A B} : Pair A B -&gt; A  | (mkPair a _) := a;</pre></code></pre> <pre><code><pre>snd {A B} : Pair A B -&gt; B  | (mkPair _ b) := b;</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#result-a-b","title":"Result A B","text":"<p>The <code>Result A B</code> type represents either a success with a value of <code>ok x</code> with <code>x</code> of type <code>A</code> or an error with value <code>error e</code> with <code>e</code> of type <code>B</code>.</p> <pre><code><pre>import Stdlib.Data.Result.Base as Result;open Result using {Result; ok; error} public;</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#either-a-b","title":"Either A B","text":"<p>The type <code>Either A B</code>, or sum type of <code>A</code> and <code>B</code>, represents a value of type <code>A</code> or <code>B</code>. It is equivalent to <code>Result A B</code>, however, the meaning of the values is different. There is no such thing as an error or success value in the <code>Either</code> type, instead the values are either <code>left A</code> or <code>right B</code>. either <code>left A</code> or <code>right B</code>.</p> <pre><code><pre>syntax alias Either := Result;syntax alias left := error;syntax alias right := ok;</pre></code></pre> <p>For example,</p> <pre><code><pre>thisString : Either String Nat := left \"Error!\";thisNumber : Either String Nat := right 42;</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#list-a","title":"List A","text":"<p>The type <code>List A</code> represents a sequence of elements of type <code>A</code>. Used for collections and ordered data.</p> <pre><code><pre>import Stdlib.Data.List as List open using {List; nil; ::; isElement; ++} public;</pre></code></pre> <p>For example,</p> <pre><code><pre>numbers : List Nat := 1 :: 2 :: 3 :: nil;niceNumbers : List Nat := [1; 2; 3];</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#option-a","title":"Option A","text":"<p>The type <code>Option A</code> represents an optional value of type <code>A</code>. It can be either <code>Some A</code> (containing a value) or <code>None</code> (no value). This type is an alias for <code>Maybe A</code> from the standard library.</p> <pre><code><pre>import Stdlib.Data.Maybe as Maybe;open Maybe using {Maybe; just; nothing};</pre></code></pre> <pre><code><pre>syntax alias Option := Maybe;syntax alias some := just;syntax alias none := nothing;</pre></code></pre> <ul> <li>Check if an optional value is <code>none</code>:<p><pre><code><pre>isNone {A} (x : Option A) : Bool :=  case x of    | none := true    | some _ := false;</pre></code></pre></p> </li> </ul> <ul> <li>Check if an optional value is <code>some</code>:<p><pre><code><pre>isSome {A} (x : Option A) : Bool := not (isNone x);</pre></code></pre></p> </li> </ul> <ul> <li>Extract the value from an <code>Option</code> term:<p><pre><code><pre>fromOption {A} (x : Option A) (default : A) : A :=  case x of    | none := default    | some x := x;</pre></code></pre></p> </li> </ul>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#map-k-v","title":"Map K V","text":"<p>The type <code>Map K V</code> represents a collection of key-value pairs, sometimes called a dictionary, where keys are of type <code>K</code> and values are of type <code>V</code>.</p> <pre><code><pre>import Stdlib.Data.Map as Map public;open Map using {Map} public;</pre></code></pre> <p>For example,</p> <pre><code><pre>codeToken : Map Nat String := Map.fromList [1, \"BTC\"; 2, \"ETH\"; 3, \"ANM\"];</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#set-a","title":"Set A","text":"<p>The type <code>Set A</code> represents a collection of unique elements of type <code>A</code>. Used for sets of values.</p> <pre><code><pre>import Stdlib.Data.Set as Set public;open Set using {Set} public;</pre></code></pre> <p>For example,</p> <pre><code><pre>uniqueNumbers : Set Nat := Set.fromList [1; 2; 2; 2; 3];</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#undefined-values","title":"Undefined values","text":"<p>The term <code>undef</code> is a placeholder for unspecified values.</p> <pre><code><pre>axiom undef : {A : Type} -&gt; A;axiom TODO : {A : Type} -&gt; A;</pre></code></pre> <p>For example,</p> <pre><code><pre>undefinedNat : Nat := undef;</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#functor","title":"Functor","text":"<pre><code><pre>import Stdlib.Trait.Functor.Polymorphic as Functor;</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#applicative","title":"Applicative","text":"<pre><code><pre>import Stdlib.Data.Fixity open public;import Stdlib.Trait.Applicative open using {Applicative; mkApplicative} public;open Applicative public;</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#monad","title":"Monad","text":"<pre><code><pre>import Stdlib.Trait.Monad open using {Monad; mkMonad} public;open Monad public;</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"prelude.html#avltree","title":"AVLTree","text":"<pre><code><pre>import Stdlib.Data.Set.AVL as AVLTree public;open AVLTree using {AVLTree} public;</pre></code></pre>","tags":["Juvix-Types","Juvix-Prelude"]},{"location":"application_architecture/index.html","title":"Applications","text":"<p>Applications consist of a set of related resource logics. The state of any particular application is sharded across the system, and may be under many different controllers. Applications, of course, can restrict themselves to specific sets or paths of controllers with appropriate checks in the predicates, but by default Anoma's architecture is designed to provide a clean separation of application design and security choices, such that application developers can choose the data model and predicate logic, but users can choose the security assumptions.</p> <p>It is important to note that the abstraction of an \"Application\" is virtual - applications are not deployed or tracked in any sort of global registry - rather, they are content-addressed by the specific logics involved. An \"Application\" can be said to exist by virtue of the existence resources referencing it, and if those resources are completely consumed it no longer exists (except in history). In order to interact with applications, users must know the relevant logics, which could be distributed to them through any communications channel (including the Anoma P2P network). Applications are also composable, in that state transitions for multiple applications can be combined (atomically, if desired). Interfaces may support any combination of applications, and no interface need to have any special permissioning.</p> <p>In contrast to many blockchain systems which have separate software packages for interfaces (wallets) and node software, Anoma is designed as a unified system, which all nodes run - validators, gossip nodes, solvers, edge clients, etc. - just with separate configurations to enable or disable processing, storage, signing, etc. The Anoma node software internally handles P2P network connections, fetching &amp; caching state, verifying signatures (e.g. of validators, running light clients), etc. - no interface should need to implement these, they should just use the local API provided by the node software package.</p> <p>The applications section in this specification document describes a set of common primitives and classes of example applications suitable for different kinds of coordination. This section is neither exhaustive nor intended to describe particular applications in exact detail, but rather to provide an overview and guidance for how to think about developing applications on Anoma.</p> <ul> <li>Definitions</li> <li>Techniques</li> <li>Primitives</li> <li>System applications</li> <li>Archetypal applications</li> </ul>","boost":2},{"location":"application_architecture/definitions.html","title":"Definitions","text":"","boost":2},{"location":"application_architecture/archetypal_applications/index.html","title":"Archetypal Applications","text":"<p>This section includes key applications which demonstrate essential affordances of the protocol and are likely to be fundamental building blocks for more complex ones.</p> <ul> <li>Kudos</li> </ul>","boost":2},{"location":"application_architecture/archetypal_applications/kudos.html","title":"Kudos","text":"","boost":2},{"location":"application_architecture/archetypal_applications/kudos.html#cryptographic-kudos","title":"Cryptographic Kudos","text":"<p>Cryptographic kudos are a resource class in which every resource is associated with the identity of the initial creator of a resource, called the instantiator. They come in fungible/non-fungible as well as transferable/non-transferable varieties with optional additional constraints.</p> <p>Kudos enable a rich set of applications and mechanism design approaches and are one of the core primitives of Anoma.</p> <p>Example use cases:</p> <ul> <li>For each packet \\(A\\) routes for \\(B\\), \\(B\\) instantiates and transfers one kudo of the   kind <code>B_routing</code> and transfers it to \\(A\\), with the promise to route one packet   for whoever offers one <code>B_routing</code> kudo.</li> </ul>","boost":2},{"location":"application_architecture/archetypal_applications/kudos.html#kudo-kind","title":"Kudo Kind","text":"<p>The kind of kudo is determined by its resource logic and label. Different logic components exist for fungible or non-fungible, as well as transferable or non-transferable, leading to six different kudo logics. The label contains the external identity of the instantiator (the initial creator of any single kudo) and an optional suffix for the creation of different subkinds.</p>","boost":2},{"location":"application_architecture/archetypal_applications/kudos.html#ownership","title":"Ownership","text":"<p>Each kudo has a current owner set in the value field denoted by an external identity, which is the only identity that can authorize a transfer (see below).</p>","boost":2},{"location":"application_architecture/archetypal_applications/kudos.html#instantiation","title":"Instantiation","text":"<p>Any identity can act as an instantiator for all kudo kinds bound to their identity. To instantiate a kudo, a transaction must be generated which consumes a special resource (TBD: marked by a bitfield) that is created out of nothing, creating a kudo with the owner set to the instantiator.</p> <p>For a kudo to be valid, the logic must check for a proof of this TX to be present.</p>","boost":2},{"location":"application_architecture/archetypal_applications/kudos.html#transfer","title":"Transfer","text":"<p>To transfer a kudo, the current owner of a kudo sets up a transaction consuming the kudo and creating a new one of the same kind, placing the recipients external identity in the owner field and signing over the resource.</p> <p>During validation of a TX we check that for each resource of a certain kind that gets created, a resource of the same kind was consumed and a signature of the former owner exists.</p>","boost":2},{"location":"application_architecture/archetypal_applications/kudos.html#non-transferable-kudos","title":"Non-Transferable Kudos","text":"<p>Non-transferable kudos can only be transferred a single time by the instantiator, who is the initial owner.</p>","boost":2},{"location":"application_architecture/archetypal_applications/kudos.html#kudo-swaps","title":"Kudo Swaps","text":"<p>In the case of transferable kudos, swap intents can be formulated. To enable solving, this can also be done with unbalanced TXs.</p> <p>Example</p> <p>\\(A\\) wants to route packets via \\(C\\), but \\(C\\) only accepts <code>B_routing</code> kudos.   \\(A\\) can then formulate an intent swapping any \\(A\\)-kudos, e.g. <code>A_routing</code> or   <code>A_storage</code> kudos for <code>B_routing</code> or <code>C_routing</code> kudos.</p>","boost":2},{"location":"application_architecture/archetypal_applications/kudos.html#solving","title":"Solving","text":"<p>Solving could be performed by for example, cycle finding algorithm or SAT solvers.</p>","boost":2},{"location":"application_architecture/definitions/index.html","title":"Definitions","text":"<p>Applications are characterised by a set of resource logics and a set of transaction functions.</p> <p>\\(Application = (ApplicationLogic, ApplicationInterface)\\), where</p> <ul> <li>\\(ApplicationLogic \\subseteq \\mathbb{F}_l\\) is a set of resource logics.</li> <li>\\(ApplicationInterface = \\{t: TransactionFunction\\}\\) is a set of transaction functions.</li> </ul> <p>As any abstract action can be represented as a transaction consuming and creating resources of certain kinds (or a transaction function that evaluates to such a transaction), the transaction functions associated with the application represent the set of actions that the application can provide to its users. Each transaction function would require a subset of the application resource logics to approve the transaction in order to realise the desired action. The transaction function evaluated with the exact resources to be created and consumed forms a transaction.</p> <p>The resources that are bound with the application resource logics are said to belong to the application and constitute the application state. When the application does not have any resources that were created but not consumed yet, the application only exists virtually but not tangibly.</p> <p>The abstraction of an application is virtual - applications are not deployed or tracked in any sort of global registry, and the ARM is unaware of the existence of applications.</p> <p>We define \\(AppKinds \\subseteq \\mathbb{F}_{kind}\\) as a union of all resource kinds that are involved in the transaction functions that comprise the application interface.</p> <p>\\subsection{Composition}</p> <p>Applications are composable. The composition of two (or more applications would be a composition of the corresponding logics and interfaces.</p> <p>\\(App_12 = App_1 \\circ App_2\\):</p> <ul> <li>\\(AppLogic_{12} = AppLogic_1 \\cup AppLogic_2\\)</li> <li>\\(AppInterface_{12} = AppInterface_1 \\cup AppInterface_2\\)</li> <li>\\(AppKinds_{12} = AppKinds_1 \\cup AppKinds_2\\)</li> </ul>","boost":2},{"location":"application_architecture/primitives/index.html","title":"Primitives","text":"<p>This section includes primitive application building blocks likely to be used by many applications.</p> <ul> <li>Tokens</li> <li>Attestation</li> <li>Authorization</li> <li>Counter</li> </ul>","boost":2},{"location":"application_architecture/primitives/attestation.html","title":"Attestation","text":"<p>Attestations are non-transferable credentials associated with an issuing party (making the attestation) and a party about which they attest something (the receiver of the credential). Attestations can include arbitrary data, which may be meaningful (e.g. the details of a specific degree earned), and can be verified by other parties in a transaction.</p> <p>Attestations can be used as a form of representation for soulbound tokens.</p>","boost":2},{"location":"application_architecture/primitives/authorization.html","title":"Authorization","text":"<p>Authorisation is performed by user-defined resource logics. Users can send a message by creating a resource that can only be created by a valid partial transaction including their account resource and the creation of the message resource. Typically, users will use stateful authorisation (carried by a non-fungible token, essentially) which they can upgrade over time.</p> <ul> <li>Stateful user accounts are identified by a resource, which can be consumed   and recreated, and may include dynamic data (such that e.g. users could change   keys or authorisation logic over time).</li> </ul> <ul> <li>Stateless user accounts are identified by a fixed predicate, which cannot   change its logic. This can be useful where users want to prove to an   application or third party that they cannot change their logic in some way.</li> </ul>","boost":2},{"location":"application_architecture/primitives/counter.html","title":"Counter","text":"<p>This example describes the mechanics of counters associated with a specific controller, implemented in a resource model.</p>","boost":2},{"location":"application_architecture/primitives/counter.html#counterid-resource-application","title":"<code>CounterId</code> resource (application)","text":"<p><code>CounterId</code> resource represents a counter tied to a specific controller that is used to initialise other counters. In a sense, it can be seen as a counter of counters. <code>CounterId</code> resource can be seen as an atomic counter (in a broad sense) application. For that reason, we describe it in the application terms.</p>","boost":2},{"location":"application_architecture/primitives/counter.html#counterid-application-interface","title":"<code>CounterId</code> application interface","text":"<ul> <li>Init: creates a new <code>CounterId</code> resource with a zero value.</li> <li>Update: updates an existing <code>CounterId</code> resource from value \\(n\\) to value \\(n + 1\\).</li> </ul>","boost":2},{"location":"application_architecture/primitives/counter.html#counterid-application-logic-constraints","title":"<code>CounterId</code> application logic constraints","text":"<ul> <li>The quantity of each <code>CounterId</code> resource must be the same, set to a non-zero constant value \\(q\\).</li> <li>Each <code>CounterId</code> resource must have the controller's public key in the label.</li> <li>A signature from the controller authorising the transaction must be provided (verified with the key stored in the label).</li> <li>Init case: The value (representing the current count) must be set to 0. The transaction must be balanced by a consumed ephemeral resource of the same kind.</li> <li>Update case: The value of the created resource must be set to \\(n + 1\\) where \\(n\\) is the value of the consumed resource of the same kind.</li> </ul>","boost":2},{"location":"application_architecture/primitives/counter.html#counter-application","title":"Counter application","text":"<p>Counter resource represents a simple counter.</p>","boost":2},{"location":"application_architecture/primitives/counter.html#counter-application-interface","title":"<code>Counter</code> application interface","text":"<ul> <li>Init: a new counter is initialised from the current counterId resource (the counterId value goes to the counter resource label). When a new counter is created, the <code>CounterId</code> resource is updated to ensure there are no counters that have the same label.</li> <li>Update: An existing <code>Counter</code> resource can be updated from value \\(n\\) to value \\(n + 1\\).</li> </ul>","boost":2},{"location":"application_architecture/primitives/counter.html#counter-application-logic-constraints","title":"<code>Counter</code> application logic constraints","text":"<ul> <li>The quantity of each counterId resource must be the same, set to a non-zero constant value \\(q\\).</li> <li>Each <code>Counter</code> resource must have the controller's public key in the label and a value of the <code>CounterId</code> resource from the moment the <code>Counter</code> resource was initialised.</li> <li>Init case:      - The label and the value are set to the value of the <code>CounterId</code> resource updated in the same transaction function. The transaction must be balanced by a consumed ephemeral resource of the same kind.      - The resource kind of the <code>CounterId</code> resource must be verified to ensure that this is indeed the <code>CounterId</code> resource's value is used to derive the <code>Counter</code> resource label.</li> <li>Update case:     - The value of the created resource must be set to \\(n + 1\\) where \\(n\\) is the value of the consumed resource of the same kind.</li> </ul> <p>In this simple version, updating the counter requires no special permissions but the counter resource logic can be modified to be more complex and have more restricted counter update rules.</p>  CounterId and Counter applications interfaces","boost":2},{"location":"application_architecture/primitives/tokens.html","title":"Tokens","text":"<p>Tokens are transferrable units of accounting.</p> <p>The resource logic of tokens enforces two properties:</p> <ul> <li>Supply conservation (implicitly) - in any transaction, tokens must be   conserved. This is enforced using the balance check.</li> </ul> <ul> <li>Ownership - any transaction which consumes tokens owned by resource <code>R</code> must   be authorized by <code>R</code>. This is checked by requiring the presence of a message   from <code>R</code> that authorises the consumption of tokens subject to an arbitrary   predicate being satisfied in the partial transaction in which the tokens are   consumed.</li> </ul> <ul> <li>Minting - tokens may reference a particular resource <code>R</code> which is allowed to   mint new tokens of the denomination (ex nihilo).</li> </ul> <p>Tokens can include arbitrary properties (as data), which may be meaningful to other applications. Properties in static data affect fungibility (determine different tokens), while properties in dynamic data do not (and, absent other restrictions, can be altered by the transaction creator, so could be used for some kind of memo).</p> <p>Fungible tokens are those with a supply of more than 1, while non-fungible tokens have a supply of only 1 (such that there is only 1 valid copy in existence at any point in logical time).</p>","boost":2},{"location":"application_architecture/system_applications/index.html","title":"System Applications","text":"<p>This section includes system applications which play a special role in the operation of the protocol: namely, their state will be read by a node in order to make decisions such as what validator set to authorize next for a particular controller; whether or not to accept a particular storage, compute, or ordering request; who to send intents to in the future, etc.</p> <ul> <li>Proof-of-stake</li> </ul>","boost":2},{"location":"application_architecture/system_applications/proof_of_stake.html","title":"Proof-of-stake","text":"<p>This section describes an example of a simplified version of the Proof-of-Stake application. The goal of the PoS protocol is to assign voting power in the BFT consensus algorithm: users delegate their tokens to validators, the voting power of each validator is determined from the amount of tokens delegated to them. The delegated tokens are locked for a period of time, so that if the validator misbehaves, this behaviour could be tracked and reacted on by burning a part of the delegated tokens. This application can be a useful building block for other applications or, more generally, for the contexts that require a decision-making mechanism.</p>","boost":2},{"location":"application_architecture/system_applications/proof_of_stake.html#roles","title":"Roles","text":"Role Description User The party that delegates tokens to validators, expressing a certain degree of agreement with the decisions the validator makes on the user's behalf. Pool The account that stores (owns) delegated tokens. Can be implemented with a generic account resource kind Validator The party that participates in the consensus algorithm, voting for decisions. The voting power is determined by how much token the users delegate to the validator.","boost":2},{"location":"application_architecture/system_applications/proof_of_stake.html#resource-kinds","title":"Resource kinds","text":"Resource kind Description Create Consume Token Governance token used to distribute the voting power Generic token logic Generic token logic Pool Special type of the token owner account that owns all bonds Generic account logic Generic account logic Bond Represents a bonded token delegated to a validator. Always owned by the pool Requires the user to send their assets to the pool Can be consumed to create a withdrawal. Withdrawal Represents the asset in the process of undelegation Created from a bond Can be consumed when the portion of assets remaining after the slashing is performed is sent from the pool to the user, strictly after \\(W_{unlock}\\) Infraction Represents a proof of misbehaviour of a certain validator Created provided a proof of misbehaviour Never consumed Voting power Contains the distribution of voting power among the validators Can be created provided a proof of correct computation of voting power from the existing bonds Never consumed","boost":2},{"location":"application_architecture/system_applications/proof_of_stake.html#bond","title":"Bond","text":"Field Description \\(B_{quantity}\\) How much token is bonded. Used to determine the voting power \\(B_{validator}\\) Refers to the validator the token is delegated to \\(B_{owner}\\) Refers to the delegator","boost":2},{"location":"application_architecture/system_applications/proof_of_stake.html#bond-logic","title":"Bond logic","text":"<ul> <li>Create:     - Verify \\(T\\) kind to be the governance token kind (for both the created and consumed resource)     - A token resource \\(T\\) was transferred from \\(T_{owner}\\) to the pool:         - Consumed token resource belonged to \\(T_{owner}\\)         - Created token resource belongs to the pool         - \\(T_{quantity}^{consumed} = T_{quantity}^{created}\\)     - \\(B_{quantity}\\) = \\(T_{quantity}\\)     - \\(B_{owner}\\) = \\(T_{owner}\\)</li> </ul> <ul> <li>Consume:     - A withdrawal of kind \\(W\\) is consumed         - Verify \\(W\\) kind</li> </ul>","boost":2},{"location":"application_architecture/system_applications/proof_of_stake.html#withdrawal","title":"Withdrawal","text":"Field Description \\(W_{validator}\\) refers to the validator the token is delegated to \\(W_{owner}\\) refers to the delegator \\(W_{unlock}\\) defines the time after which the resource can be consumed","boost":2},{"location":"application_architecture/system_applications/proof_of_stake.html#withdrawal-logic","title":"Withdrawal logic","text":"<ul> <li>Create:     - A bond of kind \\(B\\) is consumed         - Verify \\(B\\) kind     - \\(W_{quantity} = B_{quantity}\\)     - \\(W_{validator} = B_{validator}\\)     - \\(W_{owner}\\) = \\(B_{owner}\\)     - \\(W_{unlock} = now + U\\), where \\(U\\) is a constant value</li> </ul> <ul> <li>Consume:     - Verify \\(T\\) kind to be the governance token kind (for both the created and consumed resource)     - A token resource \\(T\\) was transferred from the pool to \\(W_{owner}\\):         - Consumed token resource belonged to the pool         - Created token resource belongs to \\(W_{owner}\\)         - \\(T_{quantity}^{consumed} = T_{quantity}^{created}\\)     - \\(T_{quantity}\\) = \\(W_{quantity}*\\Pi{(1 - I_{rate})}\\), where \\(I_{rate}\\) is the infraction rate of infraction \\(I\\) associated with this validator (iterate over all infractions created between the delegation and \\(W_{unlock}\\) time)     - \\(W_{owner}\\) = \\(T_{owner}\\)</li> </ul>","boost":2},{"location":"application_architecture/system_applications/proof_of_stake.html#infraction","title":"Infraction","text":"Field Description \\(I_{validator}\\) committed the misbehaviour \\(I_{rate}\\) infraction rate determines how much to slash \\(I_{timestamp}\\) defines when the misbehaviour was committed","boost":2},{"location":"application_architecture/system_applications/proof_of_stake.html#infraction-logic","title":"Infraction logic","text":"<ul> <li>Create:     - Verify a proof of misbehaviour of the validator \\(I_{validator}\\) at \\(I_{timestamp}\\)</li> <li>Consume:     - Never</li> </ul>","boost":2},{"location":"application_architecture/system_applications/proof_of_stake.html#votingpower","title":"VotingPower","text":"Field Description \\(VP_{map}\\) contains a map between validators and their current voting power \\(VP_{timestamp}\\) defines the time period for which the voting power is computed","boost":2},{"location":"application_architecture/system_applications/proof_of_stake.html#votingpower-logic","title":"VotingPower logic","text":"<ul> <li>Create:     - Provided with all bonds (read data, not consumed), iterate over them and compute the voting power for each validator: \\(VP_{map}[V] = \\Sigma_{B_{validator} = V}{B_{quantity}}\\)</li> <li>Consume:     - Never</li> </ul>","boost":2},{"location":"application_architecture/system_applications/proof_of_stake.html#pos-application","title":"PoS application","text":"","boost":2},{"location":"application_architecture/system_applications/proof_of_stake.html#application-logic","title":"Application logic","text":"<p>\\(l_{PoS} = \\{l_{Token}, l_{Pool}, l_{Bond}, l_{Withdrawal}, l_{Infraction}, l_{VotingPower}\\}\\)</p>","boost":2},{"location":"application_architecture/system_applications/proof_of_stake.html#application-interface","title":"Application interface","text":"<ol> <li>Delegate: Transfer the token from \\(T_{owner}\\) to the pool, create a <code>Bond</code> resource.</li> <li>Undelegate: Consume a <code>Bond</code> resource, create a <code>Withdrawal</code> resource.</li> <li>Withdraw: Consume a <code>Withdrawal</code> resource, transfer the corresponding token (accounting for the relevant infractions) from the pool to \\(W_{owner}\\).</li> <li>Slash: Create an <code>Infraction</code> resource provided a proof of misbehaviour.</li> <li>Calculate voting power: Create a <code>VotingPower</code> resource with \\(VP_{timestamp} = now\\).</li> </ol>  The interface provided by the proof-of-stake application","boost":2},{"location":"application_architecture/techniques/index.html","title":"Techniques","text":"<p>This section includes techniques which can be used by any application.</p> <ul> <li>Dynamic code loading</li> <li>Schelling tests</li> </ul>","boost":2},{"location":"application_architecture/techniques/dynamic_code_loading.html","title":"Dynamic code loading","text":"<p>In general, code can be stored in the standard content-addressed storage. In order to retrieve code whose identity is known ahead of time (e.g. a standard library), this should be sufficient. In order to retrieve code dynamically (likely with rules on how it can be changed), a resource index lookup is necessary. A particular denomination can be associated with a series of resources, each representing successive versions of code and containing a reference to the code hash, with rules as desired governing how the code associated with this name can be changed.</p> <p>Code which is looked up may be evaluated in the transaction function or verified in a resource logic.</p>","boost":2},{"location":"application_architecture/techniques/dynamic_code_loading.html#dynamic-code-evaluation-in-a-transaction-function","title":"Dynamic code evaluation in a transaction function","text":"<p>Simply read the code (statically, or by looking up a resource) and call <code>eval</code> or equivalent.</p> <p>This system, while simple, automatically provides many nice properties: for example, different versions of the standard library addressed statically will automatically be deduplicated, code-pinned, and cached.</p>","boost":2},{"location":"application_architecture/techniques/dynamic_code_loading.html#dynamic-code-verification-in-a-resource-logic","title":"Dynamic code verification in a resource logic","text":"<p>Here, we want a slightly different behaviour: namely, to verify that the code looked up was executed correctly. In the case of a transparent proof, this functions similarly. In the case of a shielded proof, the code reference will need to be a verifying key, and an extra proof will need to be provided in the transaction. The inputs which must correspond to the inputs used in the proof must themselves be specified. This should be provided by a <code>verify</code> syscall of sorts.</p>","boost":2},{"location":"application_architecture/techniques/schelling_tests.html","title":"Schelling tests","text":"<ul> <li>Data input: outside semantics (relation <code>R</code>).</li> <li>Assumptions     - Some agreement on relation semantics     - Iff I assert <code>a R b</code>, 2/3 of others (my connections?) will also</li> <li>Random graph walks.     - e.g. at the very least we can test at least 1/3 of nodes in between?</li> </ul>","boost":2},{"location":"arch/index.html","title":"Protocol Architecture","text":"<p>This section describes the architecture of the protocol. The architecture is split into two subsections:</p> <ul> <li>System Architecture describes the structure of the   distributed network, distributed state, important types, and properties.</li> </ul> <ul> <li>Node Architecture describes how a node is internally   composed of various engines and how precisely each engine works.</li> </ul> (Wiki) links on this page<ul><li>System Architecture</li><li>Node Architecture</li></ul>","boost":2},{"location":"arch/node/index.html","title":"Introduction","text":"<p>\u200b The operational architecture specification concerns the state evolution of Anoma instances, broken into smaller steps: which messages are exchanged, how computation is performed on the level of function calls, and which intermediate states are reachable. The specification is organized into the following sections:</p> <ul> <li>Hardware Machine</li> </ul> <ul> <li>Identity Machine</li> </ul> <ul> <li>Networking Machine</li> </ul> <ul> <li>Ordering Machine</li> </ul>","boost":2},{"location":"arch/node/index.html#engine-models","title":"Engine models","text":"<p>All engines communicate via message passing, following the paradigm of message passing concurrency. Thus, the only direct state manipulations that engine instances can perform are local state changes.</p> <p>All instances of a specific kind of engine share their behaviour, which is defined as a function that</p> <ul> <li>takes a message and the current local state of an engine instance as input and</li> </ul> <ul> <li>computes the set of new messages (to be sent to other engine instances as   reaction to the received message) and, optionally, a state update.</li> </ul> <p>By default, the local state of an engine instance is a (subset of) all messages that are sent and received.</p> <p>On Engine Models</p> <p>Engines communicate via message passing. Each message consists of a header and a body. The header gives information about the sender and the intended destination, e.g., in the form of \u026a\u1d05s or addresses. The type of the body almost always depends on the specific type of message. For each engine, we provide the following.</p> <ul> <li>A list of type names. Each type name is a string that specifies    the type of message bodies that the engine has to be able to process    (with the additional context that the header provides).         Optionally,    each type name in this list is mapped to a set of protocols to which it belongs.</li> </ul> <ul> <li>A list of pairs of type names and engines for message reactions.  Each type    name has a \u201cstatic\u201d approximation of all message reactions that a received    message might trigger. Typically, there is no need to add identities or    addresses of engine instance here.</li> </ul> <ul> <li>A type for each type name. The type of the message body is called message    type as short hand for message body type. The message type does not need    to re-iterate information of the message header. It is allowed that several    type names refer to the message type.</li> </ul> <ul> <li> <p>The types and behaviour for each message body type.  Using links to GitHub,    Message types should be specified as SML types/datatypes (eventually matching    the restrictions of colorsets    of CPN Tools, i.e., only datatypes without proper recursion / induction). The    behaviour also has to give some information about headers, and define the    behaviour, using SML functions. This amounts to one function    <code>ReactionTypeName_</code>\\(p_{i,j,1}\\) as below.</p> </li> </ul> <p>Todo</p> <p>Even when the following renders, it is not really clear what the structure of the description is.</p> <p> occurrences</p> (Wiki) links on this page<ul><li>Networking Machine</li><li>Ordering Machine</li></ul>","boost":2},{"location":"arch/node/engine_models.html","title":"Engine Models","text":"<p>Engines communicate via message passing. Each message consists of a header and a body. The header gives information about the sender and the intended destination, e.g., in the form of IDs or addresses. The type of the body almost always depends on the specific type of message. For each engine, we provide the following.</p> <ol> <li>A list of type names    Each type name is a string that specifies    the type of message bodies that the engine has to be able to process    (with the additional context that the header provides).     Optionally,    each type name in this list is mapped to a set of protocols to which it belongs.</li> <li>A list of pairs of type names and engines for message reactions    Each type name has a \u201cstatic\u201d approximation of all message reactions    that a received message might trigger.    Typically, there is no need to add identities or addresses of engine instance here.</li> <li> <p>A type for each type name    The type of the message body is called message type as shorthand for message body type.    The message type does not need to re-iterate information of the message header.    It is allowed that several type names refer to the message type.</p> </li> <li> <p>The types and behaviour for each message body type    Using links to GitHub,    Message types should be specified as    colour sets    or as rust types as a fallback option,    ideally both.    The behaviour also has to give some information about headers,    and define the behaviour,    using SML functions.</p> </li> </ol> <p>Thus, the structure of the description of engine models is as follows.</p> <ul> <li>Engine 1   [\u2026]</li> <li>Engine 2   [\u2026]</li> <li>\u22ee</li> <li>Engine \\(i\\)<ul> <li>MessageTypeName_\\(i_1\\) [\\(\\scriptscriptstyle\\{&lt;\\mathrm{protocols}(i,1)&gt;\\}\\)]   &lt;\u2191link to GitHub repo<code>MessageType_i_1</code>&gt; [\u2026]</li> <li>\u22ee</li> <li>MessageTypeName_\\(i_j\\) [\\(\\scriptscriptstyle\\{&lt;\\mathrm{protocols}(i,j)&gt;\\}\\)]   &lt;\u2191link to GitHub repo<code>MessageType_i_j</code>&gt;<ul> <li>ReactionTypeName_\\(p_{i,j,1}\\) \u2192 Engine_\\(q_{i,j,1}\\) <li>ReactionTypeName_\\(p_{i,j,2}\\) \u2192 Engine_\\(q_{i,j,2}\\) <li>\u22ee</li> <li>ReactionTypeName_\\(p_{i,j,k}\\) \u2192 Engine_\\(q_{i,j,k}\\) <li>\u22ee</li> <li>ReactionTypeName_\\(p_{i,j,m_{i,j}}\\) \u2192 Engine_\\(q_{i,j,m_{i,j}}\\) <li>\u22ee</li> <li>MessageTypeName_\\(i_{m_i}\\) [\\(\\scriptscriptstyle\\{&lt;\\mathrm{protocols}(i,m_i)&gt;\\}\\)]   &lt;\u2191link to GitHub repo<code>MessageType_i_{m_i}</code>&gt; [\u2026]</li> <li>\u22ee</li> <li>engine \\(N\\)</li>","boost":2},{"location":"arch/node/engines.html","title":"Engines","text":"<p>Anoma's implementation is structured as a set of communication engines. An engine can be understood as a deterministic logical process operating within a trusted domain, and can be characterised as a function, parameterised over a state type, input message type, and output message type, taking a tuple of the current state and a set of input messages, and returning a tuple of a new state and a set of output messages.</p> <p>This interface is compositional, where two engines can be combined by routing specific messages to and from each other, to form a third engine which is a specific composition of the two.</p> <p>Todo</p> <p>Specify this further.</p> <p>Structuring the implementation as a composition of engines has many benefits:</p> <ul> <li>A clean separation of concerns between different areas of concern in the protocol (e.g. network layer interfacing, consensus message processing, signature generation).</li> </ul> <ul> <li>Easier upgrades, as engine implementations can be independently upgraded as long as interface properties (at the level of the engine function as above) are still satisfied.</li> </ul> <ul> <li>The possibility of hot reloading. Typiucally, engines can be hot reloaded as long as interface properties are still satisfied and state is appropriately transferred - messages are just queued.</li> </ul> <ul> <li>Different engines can be property tested and formally verified independently, since they have independently articulated properties. Testing and verification of engine compositions can build on these efforts.</li> </ul> <ul> <li>A natural mapping to separate physical processors or machines. Engines are assumed to operate within a single trust domain, but can otherwise be separated and run in parallel, in the form of separate cores on the same physical machine, multiple physical machines across a network boundary, etc.</li> </ul> <p>Important notes:</p> <ul> <li>Engines are logical processes, not physical ones. Any mapping of logical to physical processes is possible as long as the logical properties are adhered to.</li> </ul> <p>Engines:</p> <ul> <li>P2P</li> <li>Mempool</li> <li>Consensus</li> <li>Execution</li> <li>Storage</li> <li>Compute</li> <li>Solver</li> <li>Commitment</li> <li>Decryption</li> <li>Strategy</li> <li>Interaction</li> <li>Pinger</li> <li>Dumper</li> </ul> <p>note: typhon and taiga</p>","boost":2},{"location":"arch/node/engines.html#summary","title":"Summary","text":"<p>Typhon stores, orders, and executes transactions on Anoma blockchains. It is intended as a replacement for Tendermint. We have a brief overview presentation of some of the features of Typhon here.</p> <p>Typhon can be broken down into three engines:</p> <ul> <li>a mempool, which receives transaction requests and stores them</li> </ul> <ul> <li>a consensus, which orders transaction requests collected by the mempool, and</li> </ul> <ul> <li>an execution engine, which executes the transactions on the state machine.</li> </ul> <p>We expect each Anoma participant (validator) will run processes for all three engines.  Above, a client can be a solver, ferveo, or anyone else who generates transactions to be ordered. The critical path of the protocol is shown in thicker arrows, with other crucial messages shown in narrower arrows.</p> <ul> <li>Mempool: Validators receive transactions from clients, store them, and make them available for the execution engine to read. The mempool protocol, which is based on Narwhal also produces a DAG of headers, which reference batches of transactions (via hash), and contain certificates of availability of transaction data. These headers are ultimately what the consensus decides on, in order to establish a total order of transactions for the execution engine. Read more here.</li> </ul> <ul> <li>Consensus: Our consensus is based on Heterogeneous Paxos. Validators choose a totally ordered sequence of headers from the mempool DAG. This establishes a total order of transactions for the execution engine to execute. Read more here.</li> </ul> <ul> <li>Execution Engine: Given a total order of transactions, the execution engine updates and stores the \"current\" state , using as much concurrency as possible.</li> </ul> <p>Proofs from the execution engine allow light clients to read the current state. When the execution engine has processed a transaction, it communicates to the mempool that the transaction can data can be garbage-collected from storage. Read more here.</p>","boost":2},{"location":"arch/node/types.html","title":"Types","text":"<pre><code><pre>module arch.node.types;import arch.node.types.basics open public;import arch.node.types.crypto open public;import arch.node.types.identities open public;import arch.node.types.messages open public;import arch.node.types.anoma open public;import arch.node.types.engine open public;</pre></code></pre>","tags":["Juvix-types","Types"],"boost":2},{"location":"arch/node/engines/index.html","title":"Engines","text":"","tags":["engine","Juvix"]},{"location":"arch/node/engines/index.html#overview","title":"Overview","text":"<p>The Anoma Specification revolves around the concept of an engine, an actor-like entity encapsulating the engine environment and behaviour of a computational process. In Anoma, every engine is of a specific type. Engines of the same type share the same behaviour. However, two engines of the same type may have different execution context.</p>","tags":["engine","Juvix"]},{"location":"arch/node/engines/index.html#engine-components","title":"Engine components","text":"Environment <p>The execution context of an engine. It consists of:</p> <ul> <li>a local state for storing engine-specific data,</li> <li>a mailbox cluster for receiving and sending messages,</li> <li>a set of acquaintances (other engines that can interact with this engine), and</li> <li>a set of active timers.</li> </ul> <p>The complete definition of an engine environment can be found in the Juvix engine environment definition.</p> Behaviour <p>The function that describes all possible ways in which engines can act. This includes:</p> <ul> <li>modifying their environment,</li> <li>sending messages to other engines,</li> <li>spawning new engine instances, and</li> <li>managing their active timers.</li> </ul> <p>The complete definition of an engine behaviour can be found in the Juvix engine behaviour definition.</p> Guards <p>The finite set of guard functions that describe the conditions under which the local state of the engine's instance should change by invoking the action function.</p> Conflict Solver <p>The function that resolves conflicts between actions to maximize their concurrency.</p>","tags":["engine","Juvix"]},{"location":"arch/node/engines/index.html#anoma-engine-definitions","title":"Anoma engine definitions","text":"<p>All required types and functions to define these engines can be found in the module engine. To understand how we have structured the Tutorials on WritingEngine Families</p>","tags":["engine","Juvix"]},{"location":"arch/node/engines/index.html#anoma-engine-messages","title":"Anoma engine messages","text":"<pre><code><pre>type Msg :=  | MsgTemplate TemplateMsg  | MsgTicker TickerMsg;</pre></code></pre>","tags":["engine","Juvix"]},{"location":"arch/node/engines/index.html#anoma-engine-environments","title":"Anoma engine environments","text":"<pre><code><pre>type Env :=  | EnvTemplate TemplateEnv  | EnvTicker TickerEnv;</pre></code></pre>","tags":["engine","Juvix"]},{"location":"arch/node/engines/index.html#useful-links","title":"Useful Links","text":"<ul> <li>Tutorials on Writing Engine Families</li> <li>Example Engine</li> </ul>","tags":["engine","Juvix"]},{"location":"arch/node/engines/commitment.html","title":"Commitment Engine","text":"<p>Failure</p> <p>[10 of 17] Compiling arch.node.engines.commitment [11 of 17] Compiling arch.node.engines.commitment_behaviour [15 of 17] Compiling arch.node.engines.commitment_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/commitment_environment.juvix.md:99:7-11: error: Unexpected argument node</p> <p>icon: octicons/gear-16 search:   exclude: false categories: - engine tags: - commitment-engine - engine-definition</p> Juvix imports <pre><code>module arch.node.engines.commitment;\n\nimport prelude open;\nimport arch.node.types.engine open;\n\nimport arch.node.engines.commitment_messages open public;\nimport arch.node.engines.commitment_environment open public;\nimport arch.node.engines.commitment_behaviour open public;\nopen commitment_environment_example;\n</code></pre>"},{"location":"arch/node/engines/commitment.html#commitment-engine","title":"Commitment Engine","text":"<p>The Commitment engine is responsible for generating commitments (signatures) by a particular identity. Commitment engine instances are generated by the Identity Management Engine when an identity is generated or connected.</p>"},{"location":"arch/node/engines/commitment.html#purpose","title":"Purpose","text":"<p>The Commitment Engine maintains signing capabilities for a specific identity and handles commitment (signature) requests for that identity. Only the original caller and anyone to whom they pass the engine instance reference can send messages to the instance and generate commitments by the corresponding identity.</p>"},{"location":"arch/node/engines/commitment.html#components","title":"Components","text":"<ul> <li>Commitment Messages</li> <li>Commitment Environment</li> <li>Commitment Behaviour</li> </ul>"},{"location":"arch/node/engines/commitment.html#type","title":"Type","text":"<pre><code>CommitmentEngine : Type := Engine\n  CommitmentLocalState\n  CommitmentMailboxState\n  CommitmentTimerHandle\n  CommitmentMatchableArgument\n  CommitmentActionLabel\n  CommitmentPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/commitment.html#example-of-a-commitment-engine","title":"Example of a commitment engine","text":"<pre><code>exampleCommitmentEngine : CommitmentEngine :=\n  mkEngine@{\n    initEnv := commitmentEnvironment;\n    behaviour := commitmentBehaviour;\n  };\n</code></pre> <p>where <code>commitmentEnvironment</code> is defined as follows:</p> <pre><code><pre>axiom dummyExternalIdentity : ExternalIdentity;axiom dummyIDBackend : Backend;axiom dummySigningKey : SigningKey;commitmentEnvironment : CommitmentEnvironment :=  mkEngineEnvironment@{    name := \"commitment\";    localState :=      mkCommitmentLocalState@{        signer :=          mkSigner@{            sign := \\{_ x := Ed25519Signature};          };        backend := BackendLocalMemory;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>commitmentBehaviour</code> is defined as follows:</p> <pre><code><pre>commitmentBehaviour : CommitmentBehaviour :=  mkEngineBehaviour@{    guards := [commitGuard];    action := commitmentAction;    conflictSolver := commitmentConflictSolver;  };</pre></code></pre> (Wiki) links on this page<ul><li>Identity Management Engine</li><li>Commitment Messages</li><li>Commitment Environment</li><li>Commitment Behaviour</li></ul>"},{"location":"arch/node/engines/commitment_behaviour.html","title":"Commitment Behaviour","text":"<p>Failure</p> <p>[12 of 15] Compiling arch.node.engines.commitment_behaviour [14 of 15] Compiling arch.node.engines.commitment_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/commitment_environment.juvix.md:99:7-11: error: Unexpected argument node</p> <p>icon: octicons/gear-16 search:   exclude: false categories: - engine-behaviour - juvix-module tags: - commitment - engine-behavior</p> Juvix imports <pre><code>module arch.node.engines.commitment_behaviour;\nimport prelude open;\nimport arch.system.identity.identity open;\nimport arch.node.engines.commitment_messages open;\nimport arch.node.engines.commitment_environment open;\nimport arch.node.types.anoma_message open;\nimport arch.node.types.engine_behaviour open;\nimport arch.node.types.engine_environment open;\nimport arch.node.types.identities open;\nimport arch.node.types.messages open;\n</code></pre>"},{"location":"arch/node/engines/commitment_behaviour.html#commitment-behaviour","title":"Commitment Behaviour","text":""},{"location":"arch/node/engines/commitment_behaviour.html#overview","title":"Overview","text":"<p>The behavior of the Commitment Engine defines how it processes incoming commitment requests and produces the corresponding responses.</p>"},{"location":"arch/node/engines/commitment_behaviour.html#action-labels","title":"Action labels","text":""},{"location":"arch/node/engines/commitment_behaviour.html#commitmentactionlabeldocommit-docommit","title":"<code>CommitmentActionLabelDoCommit DoCommit</code>","text":"<pre><code>type DoCommit := mkDoCommit {\n  data : Signable\n};\n</code></pre> <p>This action label corresponds to generating a commitment (signature) for the given request.</p> Arguments <code>data</code>: The data to sign. <code>DoCommit</code> action effect <p>This action does the following:</p> Aspect Description State update The state remains unchanged. Messages to be sent A <code>ResponseCommitment</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/commitment_behaviour.html#commitmentactionlabel","title":"<code>CommitmentActionLabel</code>","text":"<pre><code>type CommitmentActionLabel :=\n  | CommitmentActionLabelDoCommit DoCommit\n  ;\n</code></pre>"},{"location":"arch/node/engines/commitment_behaviour.html#matchable-arguments","title":"Matchable arguments","text":""},{"location":"arch/node/engines/commitment_behaviour.html#commitmentmatchableargumentreplyto-replyto","title":"<code>CommitmentMatchableArgumentReplyTo ReplyTo</code>","text":"<pre><code>type ReplyTo := mkReplyTo {\n  whoAsked : Option EngineID;\n  mailbox : Option MailboxID;\n};\n</code></pre> Arguments <code>whoAsked</code>: The engine ID of the requester. <code>mailbox</code>: The mailbox ID where the response should be sent."},{"location":"arch/node/engines/commitment_behaviour.html#commitmentmatchableargument","title":"<code>CommitmentMatchableArgument</code>","text":"<pre><code>type CommitmentMatchableArgument :=\n  | CommitmentMatchableArgumentReplyTo ReplyTo\n;\n</code></pre>"},{"location":"arch/node/engines/commitment_behaviour.html#precomputation-results","title":"Precomputation results","text":"<p>The Commitment Engine does not require any non-trivial pre-computations.</p> <pre><code>syntax alias CommitmentPrecomputation := Unit;\n</code></pre>"},{"location":"arch/node/engines/commitment_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code <p>Type alias for the guard.</p> <pre><code>CommitmentGuard : Type :=\n  Guard\n    CommitmentLocalState\n    CommitmentMailboxState\n    CommitmentTimerHandle\n    CommitmentMatchableArgument\n    CommitmentActionLabel\n    CommitmentPrecomputation;\n</code></pre> <pre><code>CommitmentGuardOutput : Type :=\n  GuardOutput\n    CommitmentMatchableArgument\n    CommitmentActionLabel\n    CommitmentPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/commitment_behaviour.html#commitguard","title":"<code>commitGuard</code>","text":"<pre><code>flowchart TD\n    C{CommitRequest&lt;br&gt;received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoCommit])</code></pre> commitGuard flowchart <pre><code>commitGuard\n  (t : TimestampedTrigger CommitmentTimerHandle)\n  (env : CommitmentEnvironment) : Option CommitmentGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgCommitment (MsgCommitmentRequest request)) := do {\n        -- TODO: fix this, the compiler is not able to see this is correct.\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n                  matchedArgs := [CommitmentMatchableArgumentReplyTo (mkReplyTo (some sender) none)] ;\n                  actionLabel := CommitmentActionLabelDoCommit (mkDoCommit (RequestCommitment.data request));\n                  precomputationTasks := unit\n                });\n        }\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/commitment_behaviour.html#action-function","title":"Action function","text":"Auxiliary Juvix code <p>Type alias for the action function.</p> <pre><code>CommitmentActionInput : Type :=\n  ActionInput\n    CommitmentLocalState\n    CommitmentMailboxState\n    CommitmentTimerHandle\n    CommitmentMatchableArgument\n    CommitmentActionLabel\n    CommitmentPrecomputation;\n\nCommitmentActionEffect : Type :=\n  ActionEffect\n    CommitmentLocalState\n    CommitmentMailboxState\n    CommitmentTimerHandle\n    CommitmentMatchableArgument\n    CommitmentActionLabel\n    CommitmentPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/commitment_behaviour.html#commitmentaction","title":"<code>commitmentAction</code>","text":"<pre><code>commitmentAction (input : CommitmentActionInput) : CommitmentActionEffect :=\n  let env := ActionInput.env input;\n      out := ActionInput.guardOutput input;\n      localState := EngineEnv.localState env;\n  in\n  case GuardOutput.actionLabel out of {\n    | CommitmentActionLabelDoCommit (mkDoCommit data) :=\n      case GuardOutput.matchedArgs out of {\n        | CommitmentMatchableArgumentReplyTo (mkReplyTo (some whoAsked) _) :: _ := let\n            signedData :=\n              Signer.sign (CommitmentLocalState.signer localState)\n                (CommitmentLocalState.backend localState)\n                data;\n            responseMsg := mkResponseCommitment@{\n                  commitment := signedData;\n                  err := none\n                };\n          in mkActionEffect@{\n            newEnv := env; -- No state change\n            producedMessages := [mkEngineMsg@{\n              sender := mkPair none (some (EngineEnv.name env));\n              target := whoAsked;\n              mailbox := some 0;\n              msg := MsgCommitment (MsgCommitmentResponse responseMsg)\n            }];\n            timers := [];\n            spawnedEngines := []\n          }\n        | _ := mkActionEffect@{newEnv := env; producedMessages := []; timers := []; spawnedEngines := []}\n      }\n  };\n</code></pre>"},{"location":"arch/node/engines/commitment_behaviour.html#conflict-solver","title":"Conflict solver","text":""},{"location":"arch/node/engines/commitment_behaviour.html#commitmentconflictsolver","title":"<code>commitmentConflictSolver</code>","text":"<pre><code>commitmentConflictSolver : Set CommitmentMatchableArgument -&gt; List (Set CommitmentMatchableArgument)\n  | _ := [];\n</code></pre>"},{"location":"arch/node/engines/commitment_behaviour.html#the-commitment-behaviour","title":"The Commitment Behaviour","text":""},{"location":"arch/node/engines/commitment_behaviour.html#commitmentbehaviour","title":"<code>CommitmentBehaviour</code>","text":"<pre><code>CommitmentBehaviour : Type :=\n  EngineBehaviour\n    CommitmentLocalState\n    CommitmentMailboxState\n    CommitmentTimerHandle\n    CommitmentMatchableArgument\n    CommitmentActionLabel\n    CommitmentPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/commitment_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code>commitmentBehaviour : CommitmentBehaviour :=\n  mkEngineBehaviour@{\n    guards := [commitGuard];\n    action := commitmentAction;\n    conflictSolver := commitmentConflictSolver;\n  };\n</code></pre>"},{"location":"arch/node/engines/commitment_environment.html","title":"Commitment Environment","text":"<p>Failure</p> <p>[9 of 9] Compiling arch.node.engines.commitment_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/commitment_environment.juvix.md:99:7-11: error: Unexpected argument node</p> <p>icon: octicons/container-24 search:   exclude: false categories: - engine-behaviour tags: - commitment - engine-environment</p> Juvix imports <pre><code>module arch.node.engines.commitment_environment;\nimport prelude open;\nimport arch.system.identity.identity open using {Signer; mkSigner};\nimport arch.node.engines.commitment_messages open;\nimport arch.node.types.crypto open;\nimport arch.node.types.engine_environment open;\nimport arch.node.types.identities open;\nimport arch.node.types.messages open;\n</code></pre>"},{"location":"arch/node/engines/commitment_environment.html#commitment-environment","title":"Commitment Environment","text":""},{"location":"arch/node/engines/commitment_environment.html#overview","title":"Overview","text":"<p>The Commitment Engine environment maintains the state necessary for generating commitments (signatures) for a specific identity. It includes the identity's signing capabilities and any necessary signing keys or handles.</p>"},{"location":"arch/node/engines/commitment_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The Commitment Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p>"},{"location":"arch/node/engines/commitment_environment.html#commitmentmailboxstate","title":"<code>CommitmentMailboxState</code>","text":"<pre><code>syntax alias CommitmentMailboxState := Unit;\n</code></pre>"},{"location":"arch/node/engines/commitment_environment.html#local-state","title":"Local state","text":"<p>The local state of a Commitment Engine instance includes the identity's signing capabilities.</p>"},{"location":"arch/node/engines/commitment_environment.html#commitmentlocalstate","title":"<code>CommitmentLocalState</code>","text":"<pre><code>type CommitmentLocalState := mkCommitmentLocalState@{\n  signer : Signer Backend Signable Commitment;\n  backend : Backend;\n};\n</code></pre> Arguments <code>signer</code>: The signer for the identity. <code>backend</code>: The backend to use for signing."},{"location":"arch/node/engines/commitment_environment.html#timer-handle","title":"Timer Handle","text":"<p>The Commitment Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>"},{"location":"arch/node/engines/commitment_environment.html#commitmenttimerhandle","title":"<code>CommitmentTimerHandle</code>","text":"<pre><code>syntax alias CommitmentTimerHandle := Unit;\n</code></pre>"},{"location":"arch/node/engines/commitment_environment.html#the-commitment-environment","title":"The Commitment Environment","text":""},{"location":"arch/node/engines/commitment_environment.html#commitmentenvironment","title":"<code>CommitmentEnvironment</code>","text":"<pre><code>CommitmentEnvironment : Type :=\n  EngineEnv\n    CommitmentLocalState\n    CommitmentMailboxState\n    CommitmentTimerHandle;\n</code></pre>"},{"location":"arch/node/engines/commitment_environment.html#instantiation","title":"Instantiation","text":"<pre><code>module commitment_environment_example;\n\naxiom dummyExternalIdentity : ExternalIdentity;\naxiom dummyIDBackend : Backend;\naxiom dummySigningKey : SigningKey;\n\ncommitmentEnvironment : CommitmentEnvironment :=\n    mkEngineEnv@{\n      node := Curve25519PubKey \"0xabcd1234\";\n      name := \"commitment\";\n      localState := mkCommitmentLocalState@{\n        signer := mkSigner@{\n          sign := \\{_ x := Ed25519Signature \"0xabcd1234\"};\n        };\n        backend := BackendLocalMemory;\n      };\n      mailboxCluster := Map.empty;\n      acquaintances := Set.empty;\n      timers := []\n    }\n  ;\nend;\n</code></pre>"},{"location":"arch/node/engines/commitment_messages.html","title":"Commitment Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.commitment_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["commitment","engine-messages"]},{"location":"arch/node/engines/commitment_messages.html#commitment-messages","title":"Commitment Messages","text":"","tags":["commitment","engine-messages"]},{"location":"arch/node/engines/commitment_messages.html#message-interface","title":"Message interface","text":"","tags":["commitment","engine-messages"]},{"location":"arch/node/engines/commitment_messages.html#msgcommitmentrequest-requestcommitment","title":"<code>MsgCommitmentRequest RequestCommitment</code>","text":"<pre><code><pre>type RequestCommitment := mkRequestCommitment@{data : Signable};</pre></code></pre> <p>A <code>RequestCommitment</code> instructs a commitment engine instance to produce a commitment (signature) over the provided data.</p> Arguments <code>data</code>: The data to sign.","tags":["commitment","engine-messages"]},{"location":"arch/node/engines/commitment_messages.html#msgcommitmentresponse-responsecommitment","title":"<code>MsgCommitmentResponse ResponseCommitment</code>","text":"<pre><code><pre>type ResponseCommitment :=  mkResponseCommitment@{    commitment : Commitment;    err : Option String;  };</pre></code></pre> <p>A <code>ResponseCommitment</code> contains the commitment (signature) generated by the commitment engine instance in response to a <code>RequestCommitment</code>.</p> Arguments <code>commitment</code>: The generated commitment (signature). <code>err</code>: An error message if commitment generation failed.","tags":["commitment","engine-messages"]},{"location":"arch/node/engines/commitment_messages.html#commitmentmsg","title":"<code>CommitmentMsg</code>","text":"<pre><code><pre>type CommitmentMsg :=  | MsgCommitmentRequest RequestCommitment  | MsgCommitmentResponse ResponseCommitment;</pre></code></pre>","tags":["commitment","engine-messages"]},{"location":"arch/node/engines/commitment_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["commitment","engine-messages"]},{"location":"arch/node/engines/commitment_messages.html#commitment-generation-sequence","title":"Commitment Generation Sequence","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant CE as Commitment Engine\n\n    C-&gt;&gt;CE: RequestCommitment(data)\n    Note over CE: Generate commitment using internal signer\n    CE--&gt;&gt;C: ResponseCommitment(commitment)</code></pre>  Sequence diagram for commitment generation.","tags":["commitment","engine-messages"]},{"location":"arch/node/engines/commitment_messages.html#engine-components","title":"Engine Components","text":"<ul> <li>Commitment Environment</li> <li>Commitment Behaviour</li> </ul> (Wiki) links on this page<ul><li>Commitment Environment</li><li>Commitment Behaviour</li></ul>","tags":["commitment","engine-messages"]},{"location":"arch/node/engines/compute.html","title":"Compute","text":"<pre><code><pre>module arch.node.engines.compute;</pre></code></pre>","boost":2},{"location":"arch/node/engines/compute.html#compute","title":"Compute","text":"<ul> <li>Inputs     - Computational searches to perform</li> </ul> <ul> <li>Outputs<p>- Results of computational searches</p> </li> </ul> <ul> <li>Preferences<p>- Who to delegate computational search to</p> </li> </ul> <ul> <li>Accounting     - Computational searches actually performed, time taken</li> </ul> <p>The compute engine is responsible for performing expensive computation, i.e. searching for witnesses to predicates which are (in general) in the complexity class NP. Frequently, however, more efficient search algorithms will be known for particular predicates. The compute engine is designed so that local and network-accessible compute resources may be automatically balanced between based on costs and trust assumptions.</p>","boost":2},{"location":"arch/node/engines/compute.html#state","title":"State","text":"<p>The compute engine keeps in state:</p> <ul> <li>A local cache of solutions satisfying particular predicates</li> </ul> <ul> <li>A local cache of algorithms to use to solve particular predicates</li> </ul> <pre><code><pre>type ComputeEngineState := mkComputeEngineState@{};</pre></code></pre>","boost":2},{"location":"arch/node/engines/compute.html#input-messages","title":"Input messages","text":"<p>Input messages to the compute engine specify:</p> <ul> <li>A predicate (by hash) which a valid solution must satisfy</li> </ul> <ul> <li>An optional algorithm (by hash) to use in searching</li> </ul> <ul> <li>A maximum search cost in time and space usage (after which the compute engine will stop searching), including precision requested</li> </ul> <p>Todo</p> <p>Figure exact units for time and space bounds.</p> <pre><code><pre>axiom Hash : Type;axiom Option : Type -&gt; Type;axiom Integer : Type;axiom Rational : Type;axiom Pair : Type -&gt; Type -&gt; Type;type ComputeRequest :=  mkComputeRequest@{    predicate : Hash;    algorithm : Option Hash;    max_cost_time : Pair Integer Rational;    max_cost_space : Pair Integer Rational;  };</pre></code></pre>","boost":2},{"location":"arch/node/engines/compute.html#output-messages","title":"Output messages","text":"<p>Output messages from the compute engine specify:</p> <ul> <li>The predicate (by hash)</li> </ul> <ul> <li>The algorithm used, if specific (by hash)</li> </ul> <ul> <li>The solution found, if one was found (by hash)</li> </ul> <ul> <li>Cost (in time and space) actually incurred, and precision of cost estimates</li> </ul> <pre><code><pre>type ComputeResult :=  mkComputeResult@{    predicate : Hash;    algorithm : Option Hash;    solution : Option Hash;    actual_cost_time : Pair Integer Rational;    actual_cost_space : Pair Integer Rational;  };</pre></code></pre>","boost":2},{"location":"arch/node/engines/compute.html#internal-accounting","title":"Internal accounting","text":"<p>The compute engine internally tracks available resources (time and space) available.</p> <p>Todo</p> <ul> <li>Queue compute requests (perhaps priority queue) to avoid overloading available resources</li> <li>Define some message types for querying available resources</li> <li>Think about boundaries of networked compute abstraction layer vs local compute abstraction layer</li> </ul>","boost":2},{"location":"arch/node/engines/configurator.html","title":"Configurator","text":"<pre><code><pre>module arch.node.engines.configurator;</pre></code></pre>","boost":2},{"location":"arch/node/engines/configurator.html#configuration-engine","title":"Configuration Engine","text":"","boost":2},{"location":"arch/node/engines/configurator.html#general-philosophy","title":"General Philosophy","text":"<p>This engine is responsible for keeping track of the settings in the user's configuration file. The general purpose is to read the user's configuration once and cache the information within.</p>","boost":2},{"location":"arch/node/engines/configurator.html#user-configuration-format","title":"User Configuration Format","text":"<p>The configuration format is a TOML file with the exact fields left up to the implementation. However, there should be a field that the user specifies where any state snapshotting happens</p> <p>Below is an example of a valid configuration file.</p> <pre><code>[dump]\ndump = 'anoma_iex.dmp'\n[node]\nname = 'anoma'\n</code></pre>","boost":2},{"location":"arch/node/engines/configurator.html#initialization","title":"Initialization","text":"<p>The engine just records information on the contents of the user's configuration.</p>","boost":2},{"location":"arch/node/engines/configurator.html#state","title":"State","text":"<pre><code>typedstruct do\n  field(:configuration, Configuration.configuration_map(), enforce: true)\n  field(:logger, Router.Addr.t(), enforce: false)\nend\n</code></pre>","boost":2},{"location":"arch/node/engines/configurator.html#public-api","title":"Public API","text":"<pre><code>@spec snapshot(Router.addr()) :: :ok\n</code></pre> <p>The snapshot method is responsible for saving the current state of all current machines and persisting it to the configured dump location.</p> <pre><code>@spec delete_dump(Router.addr()) :: :ok\n</code></pre> <p>Deleting the dump is a convenience for deleting the persisted dump. This is useful for when state updates may be incompatible, or if the user wishes to restart all state to the genesis state.</p>","boost":2},{"location":"arch/node/engines/consensus.html","title":"Consensus (Old)","text":"<ul> <li>Inputs     Consensus requests, consensus messages</li> <li>Outputs     Consensus messages, consensus outputs (finalized)</li> <li>Preferences     Whether to run a particular consensus round</li> <li>Accounting     Consensi actually performed</li> </ul>","boost":2},{"location":"arch/node/engines/consensus.html#heterogeneous-paxos","title":"Heterogeneous Paxos","text":"","boost":2},{"location":"arch/node/engines/consensus.html#summary","title":"Summary","text":"<p>This specification intends to describe how Heterogeneous Paxos can be realized in the blockchain context. Given well-defined quorums, the protocol allows a known set \\(S\\) \\((|S|\\geq1)\\) of chains to construct and carry out atomic transactions on a so-called chimera chain, subject to certain conditions.  The chimera chain guarantees safety and liveness subject to the usual assumption: at most a third of the stake belongs to Byzantine participants.</p> <p>The protocol involves three kinds of agents: proposers, acceptors and learners. A node may play the role of any combination of the three kinds of agents.</p> <p>Blocks are agreed upon in rounds.</p> <p>Proposer initiates a round by a proposing a block. Each block contains atomic batches of transactions (or even a single transaction). An atomic batch of transactions means that either all transactions in the batch are executed or none of them are executed.</p> <p>Acceptors are agents who agree on the proposed blocks and an agent may be acceptor for more than one chain. No correct acceptor acts on any invalid block. This requires checking the validation of blocks or state transition function.</p> <p>Learners are set of agents where this set is interested in a particular (combination of?) chain(s) meaning what the voting process decides for these chain(s). The definition of learners is based on the quorums and defined by the protocol, meaning that agents are not free to choose their own quorum setups.  Acceptors need to be aware of the different definitions of learners in order to be able to know what correct behaviour is defined as. This set of the agents for learners, might empty or have overlaps, the acceptors have to follow the definition regardless. </p> <p>We briefly describe how the communication for a consensus round works. Suppose we have two learners \\(l_x\\) and \\(l_y\\) which refer to agents that are interested in blockchain \\(x\\) and blockchain \\(y\\). Proposers propose a chimera block, by sending \\(1a\\) messages, each carrying a value and unique ballot number (round identifier), to acceptors. All acceptors in all involved chains (\\(S\\)) send \\(1b\\) messages to each other to communicate that they\u2019ve received a \\(1a\\) message. When an acceptor receives a \\(1b\\) message for the highest ballot number it has seen from a learner \\(l_x\\)\u2019s quorum of acceptors, it sends a \\(2a\\) message labelled with \\(l_x\\) and that ballot number. There is one exception: once a safe acceptor sends a \\(2a\\) message \\(m\\) for a learner \\(l_x\\), it never sends a \\(2a\\) message with a different value for a learner \\(l_y\\), unless one of the following is true:</p> <ul> <li>It knows that a quorum of acceptors has seen \\(2a\\) messages with learner \\(l_x\\) and ballot number higher than \\(m\\).</li> </ul> <ul> <li>It has seen Byzantine behaviour that proves \\(l_x\\) and \\(l_y\\) do not have to agree.</li> </ul> <p>A learner \\(l_x\\) decides on a block when it receives \\(2a\\) messages with the same proposed block and ballot number from one of its quorums of acceptors.</p>","boost":2},{"location":"arch/node/engines/consensus.html#preliminaries","title":"Preliminaries","text":"<ul> <li>Base chains are two or more independent chains between which we would like to carry out atomic transactions. The chains must protocol-wise adhere to some  specific set of requirements to be compatible. For example, IBC support.</li> </ul> <ul> <li>A chimera chain is a chain that allows atomic transactions to be carried out on objects from the base chains. It carries an additional consensus mechanism, that is dependent on the consensus of the base chains.</li> </ul> <ul> <li>A learner is a client that is interested in the value decided by the voting process. Learners might be full nodes, light client nodes, or nodes from other chains.</li> </ul> <ul> <li>An acceptor is an agent participating in the voting process of the consensus protocol. Non-byzantine acceptors are called real acceptors.</li> </ul> <ul> <li>A quorum is a subset of acceptors sufficient to make a learner decide on a value. For a learner to maintain consistency (avoid deciding on two contradictory values), any two of its quorums must have a common real acceptor. Most chains achieve this practically by making the intersection of the quorums big enough, i.e. the acceptors in the intersection being backed by more than &gt;1/3 stake of each chain under &lt;1/3 Byzantine assumption. For example, suppose:     - Base chain A has a total stake of \\(60 Astake\\).     - Base chain B has a total stake of \\(300Bstake\\).     - Any set of acceptors backed by \\(&gt;40Astake\\) is a quorum of chain A. This means \\(&gt;20 Astake\\) would have to back unsafe acceptors for chain A to fork.     - Any set of acceptors backed by \\(&gt;200Bstake\\) is a quorum of chain B. This means \\(&gt;100Bstake\\) woudl have to back unsafe acceptors for chain B to fork.     - Suppose that, for every quorum \\(q_a\\) of chain A, and every quorum \\(q_b\\) of chain B, the acceptors in \\(q_a\\cap q_b\\) are backed by \\(&gt;10Astake\\), and \\(&gt;50 Bstake\\). This would mean that, in order for atomic batches on the chimera chain to lose atomicity, \\(&gt;10Astake\\) and \\(&gt;50Bstake\\) would have to back unsafe acceptors.         - When a batch loses atomicity, the transactions on one state machine (say, A) are executed, but not the transactions on the other state machine (say, B). However, each state machine itself remains consistent: neither A nor B forks.         - This means some chimera chains offer atomicity with lower (yet well-defined) levels of integrity than their base chains' no-fork guarantees.</li> </ul> <ul> <li>A proposer is an acceptor that may propose a new block according to the rules of the blockchain. For Typhon, the \"blocks\" of the consensus protocol are the headers produced by the mempool. A potential proposer would need (a) data availability, (b) the ability to sign messages, ( c) something at stake (to prevent spam) and (d) the ability to communicate with the acceptors. Acceptors that are in the overlaps of quorums may especially well suited to be proposers, but other Acceptors (or even other machines) might be proposers as well. The Heterogeneous Paxos technical report effectively uses weighted voting for select proposer, but perhaps there are interesting tricks with VRFs that would improve efficiency.</li> </ul>","boost":2},{"location":"arch/node/engines/consensus.html#assumptions","title":"Assumptions","text":"<ol> <li>Acceptors are staked:  An acceptor has a certain amount of stake backing them. This stake is either fully their own stake or is partly delegated to them by other token holders.</li> <li>Quorums are known: Quorums are defined implicitly by the internal logic of each chain. For most proof-of-stake chains, a quorum is a subset of acceptor that have \\(&gt;\\frac23\\) of stake backing them.</li> <li>Large Overlap of Quorums: A practical way to ensure a safe acceptors in the overlap between quorums. To guarantee atomicity with the same integrity as base chains, each quorum overlap must be backed by \\(&gt;\\frac13\\) of the stake of each base chain.</li> <li>Connectivity: All acceptors in a chimera chain communicate with each other (even if that means talking to acceptors who are not on the same base chain). This communication can be indirect (i.e. gossiping through other acceptors), so long as all pairs of honest acceptors can always communicate.</li> <li>Only one learner per main chain: We model the learner graph as one learner per main chain, and then full nodes can instantiate their base chain's learner to make decisions. The reason is that in Heterogeneous Paxos the learner graph is a closed graph with known nodes, while in the blockchain context we have a open network where we don't know who all the learners are.</li> </ol>","boost":2},{"location":"arch/node/engines/consensus.html#chimera-chain","title":"Chimera Chain","text":"<p>In this section we describe how chimera chains operate.</p> <p>Upon wanting to include an atomic batch of transactions from the transaction pool into a block, a block proposer either creates a genesis block if there is no existing chimera chain or builds on top of an existing chimera chain.</p>","boost":2},{"location":"arch/node/engines/consensus.html#genesis-block","title":"Genesis block","text":"<p>In order to be safe, the guarantee we want here is that future quorum updates on the main chains are guaranteed to be received before voting happens on chimera chains.</p> <ol> <li>Create a genesis block that claims to be a \"chimera chain\" and allocate some unique name or index.</li> <li>Register (in a transaction) that genesis block on all base chains and allocate it some unique name, so they know to involve it in any future quorum updates. The guarantee we want here is that future quorum updates are guaranteed to be received before votes happen.</li> <li>The first block append on the chimera chain requires IBC messages from all base chains explaining that they have registered this genesis block.</li> </ol>","boost":2},{"location":"arch/node/engines/consensus.html#producing-blocks","title":"Producing Blocks","text":"<p>The block consists of transactions from both chains or just on of the chains. The transaction can be bundled together to make sure they are carried out atomically.</p> <p>It is possible that more than one block may be finalized like in Grandpa (from Polkadot project) decoupling block prduction from finalization. In thi scase, Heterogeneous Paxos would serve the roll of a \"finality gadget\" in Grandpa's terms, but blocks could be produced at any rate.</p>","boost":2},{"location":"arch/node/engines/consensus.html#moving-objects","title":"Moving Objects","text":"<p>Suppose state in each state machine is expressed in terms of objects (think object-oriented programming) with state and methods, and a location (each is located on a chain).  Our ideas about \"movable objects\" should be applicable to any program entities which feature: * a unique identifier * a permanent set of public methods (an API) callable by users, or other methods on other objects in the same state machine, which can compute and return values * a set of private methods callable only by other methods on this object * mutable state (which only methods can mutate)</p> <p>These are much like \"smart contracts,\" which also carry internal mutable state and public APIs much like methods. An example of an \"object\" is any sort of account: multisignature account or single user account: * accounts usually have a unique identifier * public methods include \"send money,\" which takes as input some signed authorization and deducts money from the account. * mutable state includes some value representing the amount of money in the account.</p> <p>One might want to move an object to another state machine. For simplicity, let's suppose it's a state machine with the same quorums (on a different, possibly chimera, chain). This is not so very different from various chains trying to get a lock on an account (objects) and then perform atomic operations on them.</p> <p>This \"move\" operation should require an IBC send, and then deleting the original object. Or instead of deleting the original object the original object can be made a pointer to the object which now lives primarily on the destination chain. On the destination state machine, an IBC receive should be followed by creating a new copy of the object. Any \"object identifiers\" found in pointers from other objects will have to be preserved, which could be tricky.</p>","boost":2},{"location":"arch/node/engines/consensus.html#permissions-for-moving-objects","title":"Permissions for moving Objects","text":"<p>We have to consider who is allowed to move which objects where. One way to do this is to have \"move\" simply be a \"private method\" of any object: the programmer has to specifically program in any methods that the transactions or other objects can call to move the object. The most straightforward private method definition would allow anyone (e.g.,owners) who can control the object be able to give permission for moving. </p> <p>We may want to allow chains to specify limits on what objects can move onto that chain. For example, they may require that objects have a method that can move them back to a base chain.</p>","boost":2},{"location":"arch/node/engines/consensus.html#epoch-change","title":"Epoch Change","text":"<p>If new quorums for each base chain do not overlap on a real acceptor, atomicity cannot be guaranteed. We can no longer meaningfully commit atomic batches to the chimera chain. However, extensions to the chimera chain are consistent from the point of view of each base chain (but different base chains may \"perceive\" different extensions). This allows us to, for example, move objects to base chains even after the chimera chain loses atomic guarantees.</p>","boost":2},{"location":"arch/node/engines/consensus.html#kill-chains","title":"Kill Chains","text":"<p>Likewise, it's probably useful to kill chimera chains no one is using anymore. If we don't kill them, when quorums change all of chimera chains need to get an update, and that can become infeasible. One possibility is to allow chains with no objects on them (everything has moved out) to execute a special \"kill\" transaction that prohibits any future transactions, and sends an IBC message to all parent chains. On receipt, parent chains could remove that chimera chain from their registry.</p>","boost":2},{"location":"arch/node/engines/consensus.html#protocol-description","title":"Protocol Description","text":"<p>This section describes how a chimera block is appended to the existing chimera chain assuming all the setup has taken place.</p> <p>For simplicity, this protocol is written as if we're deciding on one thing: the specific block that belongs on a specific blockchain at a specific height. All state and references are specific to this blockchain / height pair. We do not care about messages before this height. This height may be defined using the last finalized block in the blockchain.</p>","boost":2},{"location":"arch/node/engines/consensus.html#learner-graph","title":"Learner Graph","text":"<p>For each learner \\(\\red{a}\\), we call its set of quorums \\(\\red{Q_a}\\).</p> <p>For each pair of learners \\(\\red{a}\\) and \\(\\blue{b}\\), there are a specific set of conditions under which they require agreement. We enumerate these as \\(\\edge{\\red{a}}{\\blue{b}}\\), a set of \"safe sets\" of acceptors: whenever at least one set in \\(\\edge{\\red{a}}{\\blue{b}}\\) is composed entirely of safe (non-byzantine, but possibly crashed) acceptors, \\(\\red{a}\\) and \\(\\blue{b}\\) must not decide different things.</p> <p>We designate the set of acceptors who are actually safe \\(\\reallysafe\\). This is of course determined at runtime, and unknown to anyone.</p>","boost":2},{"location":"arch/node/engines/consensus.html#messages","title":"Messages","text":"<p>The protocol is carried out by sending and receiving messsages. The table below describes the structure of a typical heteregenous paxos message.</p> Field Type Description chainId <code>Id</code> Identifies this Chimera Chain height <code>uint64</code> Current height of the chimera chain pktType <code>enum PktType {1A, 1B, 2A}</code> ballot <code>Ballot</code> = <code>(Timestamp, Hash)</code> This consists of the hash of the proposed block and the timestamp of the initiated ballot. There is a total lexicographical order on <code>Ballot</code>. learner <code>Id</code> sig <code>Sig</code> The signature field <code>sig</code> unforgeably identifying its sender, e.g., the message is signed, and the sender has a known PK in some PKI. refs <code>Vec&lt;Hash&gt;</code> The list of hashes of messages received previously. <p>In general, acceptor relay all sent or received messages to all learners and other acceptors. This ensures that any message received by a real acceptor is received by all real acceptors and learners.</p>","boost":2},{"location":"arch/node/engines/consensus.html#definition-message-signer","title":"Definition: Message Signer","text":"\\[   \\sig{\\green x : Message} \\triangleq   \\textrm{the acceptor or proposer that signed }\\green x \\]","boost":2},{"location":"arch/node/engines/consensus.html#definition-message-set-signers","title":"Definition: Message Set Signers","text":"<p>We can define \\(\\sig{}\\) over sets of messages, to mean the set of signers of those messages: $$   \\sig{\\green s : set(Message)}   \\triangleq \\cb{\\tallpipe{\\sig{\\blue m}}{\\blue m \\in \\green s}} $$</p> <p>Messages also contain a field <code>refs</code>, which includes chained hashes of every message the sender has sent or received since (and including) the last message it sent. As a result, we can define the transitive references of a message, which should include every message the sender has ever sent or received:</p>","boost":2},{"location":"arch/node/engines/consensus.html#definition-transitive-references","title":"Definition: Transitive References","text":"\\[   \\tran{\\green x}   \\triangleq     \\cb{\\green x}   \\cup     \\bigcup_{\\blue m \\in \\green{x.\\mathit{refs}}} \\tran{\\blue m} \\] <p>To ensure that acceptors and learners fully understand each message they receive, they delay doing any computation on it (sometimes called delivery) until they have received all the messages in <code>refs</code>. As a result, acceptors and learners will always process messages from any given sender in the order they were sent, but also from any messages that sender received, and recursively.</p>","boost":2},{"location":"arch/node/engines/consensus.html#consensus-round-ballot","title":"Consensus Round: Ballot","text":"<p>Next, we briefly describe how the communication for a consensus round works. Consensus is reached in four steps: proposing the chimera block, acknowledging receipt of proposals,  establishing consensus, and termination.</p> <p>Suppose we have two learners \\(l_1\\) and \\(l_2\\) from two different blockchains.</p>","boost":2},{"location":"arch/node/engines/consensus.html#1a-message-proposing-blocks","title":"\\(1a\\) message: proposing blocks","text":"<p>A proposer proposes a new block by sending a \\(1a\\) message to all acceptors, which includes</p> <ul> <li>a value (the atomic transaction for example)</li> </ul> <ul> <li>a unique ballot number (round identifier)</li> </ul> <ul> <li>a message containing the hash of the proposed block along with a time stamp of   the ballot initiation.</li> </ul> <p>If there is an existing chimera chain, the proposer can built upon that chain and if the proposer is starting a new chimera chain it needs to lock some funds for that.</p> <p>Also, the acceptor needs to check validity as soon as possible: don't even \"receive\" an invalid proposal (or at least don't send a \"1b\" message in response).</p>","boost":2},{"location":"arch/node/engines/consensus.html#1b-message-acknowledging-receiving-proposals","title":"\\(1b\\) message: acknowledging receiving proposals","text":"<p>On receipt of a \\(1a\\) message, an acceptor sends an ackowledgement of its receipt to all other acceptors and learners in the form of \\(1b\\) message.</p>","boost":2},{"location":"arch/node/engines/consensus.html#2a-message-establishing-consensus","title":"\\(2a\\) message: establishing consensus","text":"<p>When an acceptor receives a \\(1b\\) message for the highest ballot number it has seen from a learner \\(l_1\\)\u2019s quorum of acceptors, it sends a \\(2a\\) message labeled with \\(l_1\\) and that ballot number.</p> <p>There is one exception: once a safe acceptor sends a \\(2a\\) message \\(m\\) for a learner \\(l_1\\), it never sends a \\(2a\\) message with a different value for a learner \\(l_2\\), unless one of the following is true:</p> <ul> <li>It knows that a quorum of acceptors has seen \\(2a\\) messages with learner \\(l_1\\)   and ballot number higher than \\(m\\).</li> </ul> <ul> <li>It has seen Byzantine behaviour that proves \\(l_1\\) and \\(l_2\\) do not have to   agree.</li> </ul>","boost":2},{"location":"arch/node/engines/consensus.html#specifics-of-establishing-consensus","title":"Specifics of establishing Consensus","text":"<p>In order to make a learner decide, we need to show that another, Entangled learner could not already have decided.</p>","boost":2},{"location":"arch/node/engines/consensus.html#definition-entangled","title":"Definition: Entangled","text":"<p>In an execution, two learners are entangled if their failure assumptions matched the failures that actually happen:</p> \\[ \\entangled{\\red a}{\\blue b} \\triangleq \\reallysafe \\in \\edge{\\red a}{\\blue b} \\] <p>If some learner \\(l_1\\) does not agree with some other learner \\(l_3\\), then learner \\(l_2\\) cannot possibly agree with both \\(l_1\\) and \\(l_3\\).</p>","boost":2},{"location":"arch/node/engines/consensus.html#definition-heterogeneous-agreement","title":"Definition: Heterogeneous Agreement","text":"<ul> <li>Within an execution, two learners have agreement if all decisions for either learner have the same value.</li> <li>A heterogeneous consensus protocol has agreement if, for all possible executions of that protocol, all entangled pairs of learners have agreement.</li> </ul>","boost":2},{"location":"arch/node/engines/consensus.html#definition-accurate-learner","title":"Definition: Accurate Learner","text":"<p>An accurate learner is entangled with itself:</p> \\[ \\accurate{\\red a} \\triangleq \\entangled{\\red a}{\\red a} \\] <p>A learner whose quorums contain too many failures is inaccurate. This is the equivalent of a chain that can fork.</p> <p>In order to prevent entangled disagreement, we must define the conditions that will ultimately make learners decide:</p>","boost":2},{"location":"arch/node/engines/consensus.html#definition-get1a","title":"Definition: Get1a","text":"<p>It is useful to refer to the \\(1a\\) that started the ballot of a message: the highest ballot number \\(1a\\) in its transitive references.</p> \\[ \\geta{\\green x} \\triangleq \\argmax_{\\blue m:\\textit{1a}\\in\\tran{\\green x}}{\\blue{m.ballot}} \\]","boost":2},{"location":"arch/node/engines/consensus.html#definition-ballot-numbers","title":"Definition: Ballot Numbers","text":"<p>The ballot number of a \\(1a\\) is part of the message, and the ballot number of anything else is the highest ballot number among the \\(1a\\)s it (transitively) references.</p> \\[   \\ba{\\green x} \\triangleq \\geta{\\green x}.ballot \\]","boost":2},{"location":"arch/node/engines/consensus.html#definition-value-of-a-message","title":"Definition: Value of a Message","text":"<p>The value of a \\(1a\\) is part of the message, and the value of anything else is the value of the highest ballot \\(1a\\)  among the messages it (transitively)   references. $$ \\va{\\green x} \\triangleq \\geta{\\green x}.value $$</p>","boost":2},{"location":"arch/node/engines/consensus.html#terminate-finalizing-blocks","title":"Terminate: Finalizing blocks","text":"<p>A learner \\(l_1\\) decides when it receives \\(2a\\) messages with the same ballot number from one of its quorums of acceptors.</p> <p>If no decision can be reached within a certain time, proposers must begin a new round (with a higher timestamp, and thus a higher Ballot). Proposers can start a new round by proposing a new block or by trying to finalize the same block again (in case there was no consensus).</p>","boost":2},{"location":"arch/node/engines/consensus.html#definition-decision","title":"Definition: Decision","text":"<p>A learner decides when it has observed a set of \\(2a\\) messages with the same ballot, sent by a quorum of acceptors. This will allow the learner to decide on the value of the \\(2a\\) messages in the set. We call such a set a decision:</p> \\[ \\decision{\\red a}{\\red{q_a}} \\triangleq \\sig{\\red{q_a}} \\in \\red{Q_a}   \\ \\land\\   \\forall \\cb{\\green x,\\blue y} \\subseteq \\red{q_a} . \\ \\p{\\andlinesThree     {\\ba{\\green x}=\\ba{\\blue y}}     {\\green{x.lrn}=\\red a}     {\\green x:\\textit{2a}}} \\] <p>Now we are ready to discuss what makes a Well-Formed \\(2a\\) message. This requires considering whether two learners might be entangled, and (unless we can prove they are not engangled), whether one of them might have already decided:</p>","boost":2},{"location":"arch/node/engines/consensus.html#definition-caught","title":"Definition: Caught","text":"<p>Some behaviour can create proof that an acceptor is Byzantine. Unlike Byzantine Paxos, our acceptors and learners must adapt to Byzantine behaviour.  We say that an acceptor \\(\\purple p\\) is Caught in a message \\(\\green x\\) if the transitive references of the messages include evidence such as two messages, \\(\\red m\\) and \\(\\blue{m^\\prime}\\), both signed by \\(\\purple p\\), in which neither is featured in the other's transitive references (safe acceptors transitively reference all prior messages).</p> \\[   \\caught{\\green x} \\triangleq   \\cb{\\tallpipe{\\sig{\\red m}}{\\andlinesFour         { \\cb{\\red m, \\blue{ m^\\prime}} \\subseteq \\tran{\\green x} }         {  \\sig{\\red m} = \\sig{\\blue{ m^\\prime}}}         { \\red m \\not\\in \\tran{\\blue{m^\\prime}}}         { \\blue{m^\\prime} \\not\\in \\tran{\\red m}}    }} \\] <p>Slashing: Caught proofs can be used for slashing.</p>","boost":2},{"location":"arch/node/engines/consensus.html#definition-connected","title":"Definition: Connected","text":"<p>When some acceptors are proved Byzantine, clearly some learners need not agree, meaning that \\(\\reallysafe\\) isn't in the edge between them in the CLG: at least one acceptor in each safe set in the edge is proven Byzantine. Homogeneous learners are always connected unless there are so many failures no consensus is required. $$   \\con{\\red a}{\\green x} \\triangleq   \\cb{\\tallpipe{\\blue b}{\\andlinesTwo         {\\purple s \\in \\edge{\\red a }{ \\blue b} \\in \\clg}         {\\purple s \\cap \\caught{\\green x} = \\emptyset }       }      } $$</p>","boost":2},{"location":"arch/node/engines/consensus.html#definition-buried","title":"Definition: Buried","text":"<p>A \\(2a\\) message can become irrelevant if, after a time, an entire quorum of acceptors has seen \\(2a\\)s with different values, &lt;span style=\"background-color:</p>","boost":2},{"location":"arch/node/engines/consensus.html#e2e2ffthe-same-learner-and-higher-ballot-numbers-we-call-such-a-2a","title":"E2E2FF\"&gt;the same learner, and higher ballot numbers. We call such a \\(2a\\)","text":"<p>buried (in the context of some later message \\(\\purple y\\)):</p> \\[   \\buried{\\green x : \\textit{2a}}{ \\purple y} \\triangleq   \\cb{\\tallpipe{\\sig{\\red m}}{\\andlinesSix       {\\red m \\in \\tran{\\purple y}}       {\\blue z : \\textit{2a}}       {\\cb{\\green x, \\blue z} \\subseteq \\tran{\\red m}}       {\\va{\\blue z} \\ne \\va{\\green x}}       {\\ba{\\blue z} &gt; \\ba{\\green x}}       {\\hetdiff{\\blue{z.lrn} = \\green{x.lrn}}}   }}   \\in \\green{Q_{\\hetdiff{x.lrn}}} \\]","boost":2},{"location":"arch/node/engines/consensus.html#definition-connected-2a-messages","title":"Definition: Connected 2a Messages","text":"<p>Entangled learners must agree, but learners that are not connected are not entangled, so they need not agree. Intuitively, a \\(1b\\) message references a \\(2a\\) message to demonstrate that some learner may have decided some value. For learner \\(\\red a\\), it can be useful to find the set of \\(2a\\) messages from the same sender as a message \\({\\green x}\\) (and sent earlier) which are still unburied and for learners connected to \\(\\red a\\). The \\(1b\\) cannot be used to make any new \\(2a\\) messages for learner \\(\\red a\\) that have values different from these \\(2a\\) messages.</p> \\[       \\cona{\\hetdiff{\\red a}}{\\green x} \\triangleq       \\cb{\\tallpipe{\\blue m}{\\andlinesFive           {\\blue m : \\textit{2a}}           {\\blue m \\in \\tran{\\green{x}}}           {\\sig{\\blue m} = \\sig{\\green x}}           {\\lnot \\buried{\\blue m}{\\green x}}           {\\hetdiff{\\blue{m.lrn} \\in \\con{\\red a}{\\green x}}}       }} \\]","boost":2},{"location":"arch/node/engines/consensus.html#definition-fresh","title":"Definition: Fresh","text":"<p>Acceptors send a \\(1b\\) message whenever they receive a \\(1a\\) message with a ballot number higher than they have yet seen. However, this does not mean that the \\(1b\\)'s value (which is the same as the \\(1a\\)'s) agrees with that of \\(2a\\) messages the acceptor has already sent. We call a \\(1b\\) message fresh (with respect to a learner)  when its value agrees with that of unburied \\(2a\\) messages the acceptor has sent. $$     \\fresh{\\hetdiff{\\red a}}{\\green x : \\textit{1b}} \\triangleq     \\forall \\blue m \\in \\cona{\\hetdiff{\\red a}}{\\green x} . \\       \\va{\\green x} = \\va{\\blue m} $$</p>","boost":2},{"location":"arch/node/engines/consensus.html#definition-quorums-in-messages","title":"Definition: Quorums in Messages","text":"<p>\\(2a\\) messages reference quorums of messages with the same  value and ballot. A \\(2a\\)'s quorums are formed from fresh \\(1b\\) messages with the same ballot and value. $$   \\qa{\\green x : \\textit{2a}} \\triangleq \\cb{\\tallpipe{\\red m}{\\andlinesFour   {\\red m : \\textit{1b}}   {\\fresh{\\hetdiff{\\green{x.lrn}}}{\\red m}}   {\\red m \\in \\tran{\\green x}}   {\\ba{\\red m} = \\ba{\\green x}} }} $$</p>","boost":2},{"location":"arch/node/engines/consensus.html#definition-well-formed","title":"Definition: Well-Formed","text":"<p>We define what it means for a message to be well-formed.</p> \\[   \\begin{array}{l} WellFormed(\\purple u : \\textit{1a}) \\triangleq   \\ {\\purple u}.\\mathit{refs} = \\emptyset \\\\ WellFormed(\\green x : \\textit{1b}) \\triangleq   \\ {\\green x}.\\mathit{refs} \\ne \\emptyset   \\ \\land\\ \\forall\\,\\blue y \\in \\tran{\\green x} .   \\ \\green x \\ne \\blue y   \\ \\land\\ \\blue y \\ne \\geta{\\green x}   \\ \\Rightarrow\\ \\ba{\\blue y} \\ne \\ba{\\green x} \\\\ WellFormed(\\red z : \\textit{2a}) \\triangleq   \\ {\\red z}.\\mathit{refs} \\ne \\emptyset   \\ \\land\\ \\sig{\\qa{\\red z}} \\in \\red{Q_{\\hetdiff{z.lrn}}} \\end{array} \\] <p>An acceptor who has received a \\(1b\\) sends a \\(2a\\) for every learner for which it can produce a Well-formed \\(2a\\).</p> <p>Before processing a received message, acceptors and learners check if the message is well-formed. Non-wellformed messages are rejected.</p>","boost":2},{"location":"arch/node/engines/consensus.html#incentive-model","title":"Incentive Model","text":"<p>Goal:</p> <ul> <li>Incentivizing token holders to put down their stake for security</li> </ul> <ul> <li>Disincentivizing byzantine behaviour</li> </ul> <p>Rewards:</p> <ul> <li>Participating in consensus based on backing stake: this includes validating and voting</li> </ul> <ul> <li>Producing blocks</li> </ul> <p>Slashing: there are a number of offenses</p> <ul> <li>Invalid blocks</li> </ul> <ul> <li>Equivocation (caught)</li> </ul>","boost":2},{"location":"arch/node/engines/consensus.html#fees","title":"Fees","text":"<p>Quote</p> <p>The first question is once there is no demand for atomic batches of transactions, do we keep the chimera chain alive?</p> <p>We need to figure out whether killing the chimera chain (and potentially requiring a new genesis later) is not too expensive.</p> <p>Quote</p> <p>The second question is whether we update the quroum changes whenever they happen or when we have a transaction?</p> <p>The first option is expensive and can lead to attack if not handled well. We need to figure out whether the latter option is safe.</p> <ul> <li>If the answer is yes for first question and we pick the first option for the   second question:</li> </ul> <p>Since all chimera chains need to be updated when the quorums on the base chains change, we need to figure out who pays for these updates. For example, a chimera chain might have had a block produced last week, but since the has been updated 200 times that is 200 blocks that do not have any transactions with transaction fees. If this is not paid by anyone, it becomes a burden for acceptors and an attack vector for the adversary.</p> <p>We may need to add a \"locked\" fee for making new chimera chains. In particular, we don't want an attacker to make a lot of chains, forcing base chains to update all of them with each quorum change.</p> <p>Alternatively, each \"chimera chain\" could keep an account on each base chain that is funded by a portion of transaction fees, from which a small fee is extracted with each validator update. When the account runs dry, the (parent)base chains are allowed to kill the chimera chain (even if there are still objects on there). We could allow anyone to contribute to these accounts. We could even prohibit anyone who did not contribute from sending IBC messages between chimera and parent chains.</p>","boost":2},{"location":"arch/node/engines/consensus.html#security-discussion","title":"Security Discussion","text":"<p>Note that the chimera cannot guarantee atomicty under the same adversary assumption as the base chains. For example, if we assume the adversary to control less than 1/3 of the stake to assure safety on the base chains, atomicity is not guaranteed for such an adversary but only a weaker one. This is important for users so they can decide whether for their transaction chimera chians would be secure enough.</p> <p>By setting the quorums of each learner to be the same as the quorums of the corresponding base chain, we ensure that each learner's view is as consistent as the base chain. Specifically, two instantiations of the learner for some base chain \\(A\\) should decide on the same blocks in any chimera chain, unless the adversary is powerful enough to fork chain \\(A\\).</p> <p>\"Accurate\" (or \"self-engangled\") learners (defined above) correspond to base chains where the adversary is in fact powerful enough to fork the chain. Proving that a learner is accurate is equivalent to proving that its base chain cannot fork.</p> <p>Two learners \\(\\red{a}\\) and \\(\\blue{b}\\) corresponding to different base chains will decide on the same blocks (which is what makes atomic batches useful), so long as one of the safe sets in \\(\\edge{\\red{a}}{\\blue{b}}\\) is composed entirely of safe acceptors. The stake backing these safe sets represents the \"assurance\" that atomic batches remain atomic, as well as the maximum slashing punishment should they lose atomicity.</p> <p>Loss of atomicity is a bit like a \"trusted bridge\" that turns out not to be trustworthy: each state machine within the chimera chain has as much integrity as its base chain, but atomicity properties of multi-state-machine atomic batches have a lesser, but still well-defined, guarantee. Loss of atomicty allows double spending on the chimera chain. And while misbehaviour has happened in such an attack it is not trivial to slash the misbehaving acceptor since according to each chain everything has been carried out correctly.</p>","boost":2},{"location":"arch/node/engines/consensus.html#open-challenges","title":"Open Challenges","text":"","boost":2},{"location":"arch/node/engines/consensus.html#programming-model","title":"Programming Model","text":"","boost":2},{"location":"arch/node/engines/consensus.html#atomic-batches","title":"Atomic Batches","text":"<p>We'll need a way to specify that a batch of transactions should be committed together or not at all. Ideally, this should communicate to the programmer how reliably this atomicity is (see \"practical considerations\" below). On an chimera chain, batches can include transactions from any of their \"main chains\". If we want to have match-making, transactions will need to be able to say something like \"if I'm in an atomic batch that matches these criteria, then do this...\".</p> <p>Each atomic batch should be scheduled within one block.</p> <p>(We encode transactions with Portobuff and Borsht.) We need define structures such that transactions can be bundled and cannot be carried out separately.</p>","boost":2},{"location":"arch/node/engines/consensus.html#atomic-communication","title":"Atomic Communication","text":"<p>Transactions within an atomic batch need to be able to send information to each other (and back). For example, in a market with a fluctuating exchange rate, a market transaction could send a message to an account, which transfers money, and sends a message to another account, which transfers goods. We need a language in which this communication takes place with minimal constraints on the state machines involved, so we should probably adapt the IBC communication language.</p> <p>We need to figure out inter-chain communication works for transactions communicating with each other within an atomic batch.</p>","boost":2},{"location":"arch/node/engines/consensus.html#can-we-have-synchronous-in-terms-of-blocks-ibc","title":"Can we have synchronous (in terms of blocks) IBC?","text":"<p>Yes: when the quorums involved in two chains are the same, then we can guarantee that (unless there are sufficient failures to fork the chain) an IBC message sent in one chain will arrive at the other chain (in a transaction) within a specific number (perhaps as few as 1?) of blocks. This is because some of the machines in the quorum that approved the \"send\" transaction must be in the quorum that decides the next block, so they can refuse to decide on blocks that lack the \"receive\" transaction.</p> <p>Note that we may need to rate-limit sends to ensure that all sends can be received in time (availability).</p> <p>Note also that blinding transactions makes this hard.</p>","boost":2},{"location":"arch/node/engines/consensus.html#match-making","title":"Match Making","text":"<p>We can in priciple do cross-chain match-making. If we want an on-chain market, an chimera chain might be a good place to do it. However, full nodes in the gossip layer might be able to gather sets of transactions that match the transactions' \"If I'm in an atomic batch ...\" criteria, bundle them into atomic batches, and then send those off to be committed.</p> <p>We may want to incorporate some incentive scheme for good match-making. Matchmakers include nodes who are full nodes on both chains, and in principle could include any node who sees the request transactions.</p>","boost":2},{"location":"arch/node/engines/consensus.html#changing-quorums","title":"Changing Quorums?","text":"","boost":2},{"location":"arch/node/engines/consensus.html#2-phase-commit","title":"2 Phase Commit","text":"<p>We could require that any quorum-chainging transaction has to be 2-phase committed. Essentially, the \"main chain\" announces that it won't progress beyond a certain block until everyone has appended a new block that sets the (same) new quorums, and sends a response by IBC. It can then progress only with IBC responses from all the other chains that use these quorums.</p>","boost":2},{"location":"arch/node/engines/consensus.html#synchronous-ibc","title":"Synchronous IBC","text":"<p>We may be able to leverage our \"synchronous\" IBC idea above for faster quorum changes. The difficulty is that it allows a finite number of blocks to be appended to the chimera chains before they receive the quorum change method. These chains can be arbitrarily slow, so that could take arbitrarily long.</p> <p>Need to figure out inter-machine communication for acceptors, since they might run many machines.</p>","boost":2},{"location":"arch/node/engines/consensus.html#discussion-questions-practical-considerations","title":"Discussion Questions /Practical Considerations","text":"<ul> <li>Optimizing messgaing: Pipelining (from Hotstuff), Kauri, BFTree</li> </ul> <ul> <li>Replicating state machines</li> </ul> <ul> <li>Probems Tendermint has:<p>* Doesnt allow many validators</p> <p>* Lightclient design</p> </li> </ul> <ul> <li>Optimizing recoveryfrom slow finalization: Separating block prosuction from finalizing, finalzing more than one block</li> </ul> <ul> <li>ABCI ++? Another version of it</li> </ul> <ul> <li>Look into other papers of Dalia Malkhi / Fast HotStuff?</li> </ul>","boost":2},{"location":"arch/node/engines/decryption.html","title":"Decryption Engine","text":"<p>Failure</p> <p>[11 of 17] Compiling arch.node.engines.decryption_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/decryption_environment.juvix.md:79:7-11: error: Unexpected argument node</p> <p>icon: octicons/project-template-24 search:   exclude: false tags: - decryption - engines</p> Juvix imports <pre><code>module arch.node.engines.decryption;\n\nimport prelude open;\nimport arch.node.types.engine open;\n\nimport arch.node.engines.decryption_messages open public;\nimport arch.node.engines.decryption_environment open public;\nimport arch.node.engines.decryption_behaviour open public;\nopen decryption_environment_example;\n</code></pre>"},{"location":"arch/node/engines/decryption.html#decryption-engine","title":"Decryption Engine","text":"<p>The Decryption engine handles decryption of data encrypted to a specific identity. Decryption engine instances are generated by the Identity Management Engine when an identity is generated or connected.</p>"},{"location":"arch/node/engines/decryption.html#purpose","title":"Purpose","text":"<p>The Decryption Engine maintains decryption capabilities for a specific identity and handles decryption requests for that identity. Only the original caller and anyone to whom they pass the engine instance reference can send messages to the instance and decrypt data encrypted to the corresponding identity.</p>"},{"location":"arch/node/engines/decryption.html#components","title":"Components","text":"<ul> <li>Decryption Messages</li> <li>Decryption Environment</li> <li>Decryption Behaviour</li> </ul>"},{"location":"arch/node/engines/decryption.html#useful-links","title":"Useful links","text":"<p>???</p>"},{"location":"arch/node/engines/decryption.html#type","title":"Type","text":"<pre><code>DecryptionEngine : Type := Engine\n  DecryptionLocalState\n  DecryptionMailboxState\n  DecryptionTimerHandle\n  DecryptionMatchableArgument\n  DecryptionActionLabel\n  DecryptionPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/decryption.html#example-of-a-decryption-engine","title":"Example of a decryption engine","text":"<pre><code>exampleDecryptionEngine : DecryptionEngine :=\n  mkEngine@{\n    behaviour := decryptionBehaviour;\n    initEnv := decryptionEnvironmentExample;\n  };\n</code></pre> <p>where <code>decryptionEnvironmentExample</code> is defined as follows:</p> <pre><code><pre>decryptionEnvironmentExample : DecryptionEnvironment :=  mkEngineEnvironment@{    name := \"decryption\";    localState :=      mkDecryptionLocalState@{        decryptor :=          mkDecryptor@{            decrypt := \\{_ x := some x};          };        backend := BackendLocalMemory;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>"},{"location":"arch/node/engines/decryption_behaviour.html","title":"Decryption Engine Behaviour","text":"<p>Failure</p> <p>[10 of 15] Compiling arch.node.engines.decryption_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/decryption_environment.juvix.md:79:7-11: error: Unexpected argument node</p> <p>icon: octicons/gear-16 search:   exclude: false categories: - engine-behaviour - juvix-module tags: - decryption - engine-behavior</p> Juvix imports <pre><code>module arch.node.engines.decryption_behaviour;\nimport prelude open;\nimport arch.node.types.messages open;\nimport arch.system.identity.identity open;\nimport arch.node.types.engine_behaviour open;\nimport arch.node.types.engine_environment open;\nimport arch.node.engines.decryption_environment open;\nimport arch.node.engines.decryption_messages open;\nimport arch.node.types.identities open;\nimport arch.node.types.anoma_message open;\n</code></pre>"},{"location":"arch/node/engines/decryption_behaviour.html#decryption-dynamics","title":"<code>Decryption</code> Dynamics","text":""},{"location":"arch/node/engines/decryption_behaviour.html#overview","title":"Overview","text":"<p>The behavior of the Decryption Engine define how it processes incoming decryption requests and produces the corresponding responses.</p>"},{"location":"arch/node/engines/decryption_behaviour.html#action-labels","title":"Action labels","text":"<pre><code>type DecryptionActionLabel :=\n  | -- --8&lt;-- [start:DoDecrypt]\n    DoDecrypt {\n      data : ByteString\n    }\n    -- --8&lt;-- [end:DoDecrypt]\n;\n</code></pre>"},{"location":"arch/node/engines/decryption_behaviour.html#dodecrypt","title":"<code>DoDecrypt</code>","text":"<p>DoDecrypt {   data : ByteString }</p> <p>This action label corresponds to decrypting the data in the given request.</p> <code>DoDecrypt</code> action effect <p>This action does the following:</p> Aspect Description State update The state remains unchanged. Messages to be sent A <code>DecryptResponse</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/decryption_behaviour.html#matchable-arguments","title":"Matchable arguments","text":"<pre><code>type DecryptionMatchableArgument :=\n  | -- --8&lt;-- [start:ReplyTo]\n  ReplyTo (Option EngineID) (Option MailboxID)\n  -- --8&lt;-- [end:ReplyTo]\n;\n</code></pre>"},{"location":"arch/node/engines/decryption_behaviour.html#replyto","title":"<code>ReplyTo</code>","text":"<pre><code>ReplyTo (Option EngineID) (Option MailboxID)\n</code></pre> <p>This matchable argument contains the address and mailbox ID of where the response message should be sent.</p>"},{"location":"arch/node/engines/decryption_behaviour.html#precomputation-results","title":"Precomputation results","text":"<p>The Decryption Engine does not require any non-trivial pre-computations.</p> <pre><code>syntax alias DecryptionPrecomputation := Unit;\n</code></pre>"},{"location":"arch/node/engines/decryption_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code <p>Type alias for the guard.</p> <pre><code>-- --8&lt;-- [start:decryption-guard]\nDecryptionGuard : Type :=\n  Guard\n    DecryptionLocalState\n    DecryptionMailboxState\n    DecryptionTimerHandle\n    DecryptionMatchableArgument\n    DecryptionActionLabel\n    DecryptionPrecomputation;\n-- --8&lt;-- [end:decryption-guard]\n\n-- --8&lt;-- [start:decryption-guard-output]\nDecryptionGuardOutput : Type :=\n  GuardOutput DecryptionMatchableArgument DecryptionActionLabel DecryptionPrecomputation;\n-- --8&lt;-- [end:decryption-guard-output]\n</code></pre>"},{"location":"arch/node/engines/decryption_behaviour.html#decryptguard","title":"<code>decryptGuard</code>","text":"<pre><code>flowchart TD\n    C{DecryptRequest&lt;br&gt;received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoDecrypt])</code></pre> decryptGuard flowchart <pre><code>decryptGuard\n  (t : TimestampedTrigger DecryptionTimerHandle)\n  (env : DecryptionEnvironment) : Option DecryptionGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgDecryption (DecryptRequest data)) := do {\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n                  matchedArgs := [ReplyTo (some sender) none] ;\n                  actionLabel := DoDecrypt data;\n                  precomputationTasks := unit\n                });\n        }\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/decryption_behaviour.html#action-function","title":"Action function","text":"Auxiliary Juvix code <p>Type alias for the action function.</p> <pre><code>DecryptionActionInput : Type :=\n  ActionInput\n    DecryptionLocalState\n    DecryptionMailboxState\n    DecryptionTimerHandle\n    DecryptionMatchableArgument\n    DecryptionActionLabel\n    DecryptionPrecomputation;\n\nDecryptionActionEffect : Type :=\n  ActionEffect\n    DecryptionLocalState\n    DecryptionMailboxState\n    DecryptionTimerHandle\n    DecryptionMatchableArgument\n    DecryptionActionLabel\n    DecryptionPrecomputation;\n</code></pre> <pre><code>decryptionAction (input : DecryptionActionInput) : DecryptionActionEffect :=\n  let env := ActionInput.env input;\n      out := ActionInput.guardOutput input;\n      localState := EngineEnv.localState env;\n  in\n  case GuardOutput.actionLabel out of {\n    | DoDecrypt data :=\n      case GuardOutput.matchedArgs out of {\n        | (ReplyTo (some whoAsked) _) :: _ := let\n            decryptedData :=\n              Decryptor.decrypt (DecryptionLocalState.decryptor localState)\n                (DecryptionLocalState.backend localState)\n                data;\n            responseMsg := case decryptedData of {\n              | none := DecryptResponse@{\n                  data := emptyByteString;\n                  err := some \"Decryption Failed\"\n                }\n              | some plaintext := DecryptResponse@{\n                  data := plaintext;\n                  err := none\n                }\n            };\n          in mkActionEffect@{\n            newEnv := env; -- No state change\n            producedMessages := [mkEngineMsg@{\n              sender := mkPair none (some (EngineEnv.name env));\n              target := whoAsked;\n              mailbox := some 0;\n              msg := MsgDecryption responseMsg\n            }];\n            timers := [];\n            spawnedEngines := []\n          }\n        | _ := mkActionEffect@{newEnv := env; producedMessages := []; timers := []; spawnedEngines := []}\n      }\n  };\n</code></pre>"},{"location":"arch/node/engines/decryption_behaviour.html#conflict-solver","title":"Conflict solver","text":"<pre><code>decryptionConflictSolver : Set DecryptionMatchableArgument -&gt; List (Set DecryptionMatchableArgument)\n  | _ := [];\n</code></pre>"},{"location":"arch/node/engines/decryption_behaviour.html#decryptionbehaviour-type","title":"DecryptionBehaviour type","text":"<pre><code>DecryptionBehaviour : Type :=\n  EngineBehaviour\n    DecryptionLocalState\n    DecryptionMailboxState\n    DecryptionTimerHandle\n    DecryptionMatchableArgument\n    DecryptionActionLabel\n    DecryptionPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/decryption_behaviour.html#decryptionbehaviour-instance","title":"DecryptionBehaviour instance","text":"<pre><code>decryptionBehaviour : DecryptionBehaviour :=\n  mkEngineBehaviour@{\n    guards := [decryptGuard];\n    action := decryptionAction;\n    conflictSolver := decryptionConflictSolver;\n  };\n</code></pre>"},{"location":"arch/node/engines/decryption_environment.html","title":"Decryption Engine Environment","text":"<p>Failure</p> <p>[6 of 9] Compiling arch.node.engines.decryption_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/decryption_environment.juvix.md:79:7-11: error: Unexpected argument node</p> <p>icon: octicons/container-24 search:   exclude: false categories: - engine-behaviour tags: - decryption - engine-environment</p> Juvix imports <pre><code>module arch.node.engines.decryption_environment;\nimport prelude open;\nimport arch.node.engines.decryption_messages open;\nimport arch.node.types.engine_environment open;\nimport arch.node.types.identities open;\nimport arch.node.types.messages open;\nimport arch.system.identity.identity open using {Decryptor; mkDecryptor};\n</code></pre>"},{"location":"arch/node/engines/decryption_environment.html#decryption-environment","title":"Decryption Environment","text":""},{"location":"arch/node/engines/decryption_environment.html#overview","title":"Overview","text":"<p>Each Decryption Engine instance is associated with a specific identity and handles decryption requests for that identity. The environment maintains the necessary state for decryption operations.</p>"},{"location":"arch/node/engines/decryption_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The Decryption Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p> <pre><code>syntax alias DecryptionMailboxState := Unit;\n</code></pre>"},{"location":"arch/node/engines/decryption_environment.html#local-state","title":"Local state","text":"<p>The local state of a Decryption Engine instance includes the identity's decryption capabilities.</p> <pre><code>type DecryptionLocalState := mkDecryptionLocalState@{\n  decryptor : Decryptor Backend Plaintext Ciphertext;\n  backend : Backend;\n};\n</code></pre>"},{"location":"arch/node/engines/decryption_environment.html#timer-handle","title":"Timer Handle","text":"<pre><code>syntax alias DecryptionTimerHandle := Unit;\n</code></pre> <p>The Decryption Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>"},{"location":"arch/node/engines/decryption_environment.html#environment-summary","title":"Environment summary","text":"<pre><code>DecryptionEnvironment : Type := EngineEnv\n  DecryptionLocalState\n  DecryptionMailboxState\n  DecryptionTimerHandle;\n</code></pre>"},{"location":"arch/node/engines/decryption_environment.html#example-of-a-decryption-environment","title":"Example of a <code>Decryption</code> environment","text":"<pre><code>module decryption_environment_example;\n\ndecryptionEnvironmentExample : DecryptionEnvironment :=\n    mkEngineEnv@{\n      node := Curve25519PubKey \"0xabcd1234\";\n      name := \"decryption\";\n      localState := mkDecryptionLocalState@{\n        decryptor := mkDecryptor@{\n          decrypt := \\{_ x := some x};\n        };\n        backend := BackendLocalMemory;\n      };\n      mailboxCluster := Map.empty;\n      acquaintances := Set.empty;\n      timers := []\n    }\n  ;\nend;\n</code></pre>"},{"location":"arch/node/engines/decryption_messages.html","title":"Decryption Engine Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.decryption_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["decryption","engine-messages"]},{"location":"arch/node/engines/decryption_messages.html#decryption-messages","title":"<code>Decryption</code> Messages","text":"","tags":["decryption","engine-messages"]},{"location":"arch/node/engines/decryption_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type DecryptionMsg :=  | DecryptRequest {data : Ciphertext}  | DecryptResponse {      data : Plaintext;      err : Option String    };</pre></code></pre>","tags":["decryption","engine-messages"]},{"location":"arch/node/engines/decryption_messages.html#decryptrequest-message","title":"<code>DecryptRequest</code> message","text":"<p>DecryptRequest</p> <pre><code>DecryptRequest {\n  data : Ciphertext\n}\n</code></pre> <p>A <code>DecryptRequest</code> instructs a decryption engine instance to decrypt data as the internal identity corresponding to that engine instance.</p> <ul> <li><code>data</code>: The encrypted ciphertext to decrypt.</li> </ul>","tags":["decryption","engine-messages"]},{"location":"arch/node/engines/decryption_messages.html#decryptresponse-message","title":"<code>DecryptResponse</code> message","text":"<p>DecryptResponse</p> <pre><code>DecryptResponse {\n  data : Plaintext;\n  err : Option String\n}\n</code></pre> <p>A <code>DecryptResponse</code> contains the data decrypted by a decryption engine instance in response to a <code>DecryptRequest</code>.</p> <ul> <li><code>data</code>: The decrypted data.</li> <li><code>err</code>: An error message if decryption failed.</li> </ul>","tags":["decryption","engine-messages"]},{"location":"arch/node/engines/decryption_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["decryption","engine-messages"]},{"location":"arch/node/engines/decryption_messages.html#decryption-sequence","title":"Decryption Sequence","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant DE as Decryption Engine\n\n    C-&gt;&gt;DE: DecryptRequest(encryptedData)\n    Note over DE: Attempt to decrypt data\n    alt Decryption Successful\n        DE--&gt;&gt;C: DecryptResponse(decryptedData, err=none)\n    else Decryption Failed\n        DE--&gt;&gt;C: DecryptResponse(emptyByteString, err=\"Decryption Failed\")\n    end</code></pre>  Sequence diagram for decryption.","tags":["decryption","engine-messages"]},{"location":"arch/node/engines/decryption_messages.html#engine-components","title":"Engine Components","text":"<ul> <li><code>Decryption</code> Engine Environment</li> <li><code>Decryption</code> Engine Dynamics</li> </ul>","tags":["decryption","engine-messages"]},{"location":"arch/node/engines/decryption_messages.html#useful-links","title":"Useful links","text":"","tags":["decryption","engine-messages"]},{"location":"arch/node/engines/dumper.html","title":"Dumper Engine","text":"","boost":2},{"location":"arch/node/engines/dumper.html#overall-philosophy","title":"Overall Philosophy","text":"<p>Snapshotting is an important functionality for Anoma. To ensure that the snapshotting is done systematically, we introduce a robust Dumper engine. The Engine asks for the system to dump all of its core data to snapshot the system once a certain number of blocks are executed.</p> <p>That is, the user can set the system to snapshot on every n-th block creation.</p>","boost":2},{"location":"arch/node/engines/dumper.html#initialization","title":"Initialization","text":"<p>To initialize the engine, we need to specify a non-negative integer. Given such an integer, <code>n</code>, we will then ask to dump the state once an executed block has a number divisible by <code>n</code> (assuming the first block created bears number 1).</p> <p>Other than that, we need access to the configuration engine in order to ask it for the path where to store the snapshot, the task field, which tracks the current asynchronous process keeping track of block execution.</p>","boost":2},{"location":"arch/node/engines/dumper.html#state","title":"State","text":"<p>The state types are provided as follows:</p> <ul> <li><code>field(:count, non_neg_integer(), enforce: false)</code> Specify how many blocks pass between snapshotting</li> <li><code>field(:configuration, Router.Addr.t())</code> The address of the configuration engine</li> <li><code>field(:task, Task.t(), enforce: false)</code> The task engaged in waiting for the appropriate block execution and directly asking for a system snapshot</li> </ul>","boost":2},{"location":"arch/node/engines/dumper.html#public-api","title":"Public API","text":"","boost":2},{"location":"arch/node/engines/dumper.html#start","title":"Start","text":"","boost":2},{"location":"arch/node/engines/dumper.html#purpose","title":"Purpose","text":"<p>Starts a dumping loop based on the count supplied. If an old task was present before the sturt, it gets killed. If no count is provided, return a state with empty count and task.</p>","boost":2},{"location":"arch/node/engines/dumper.html#type","title":"Type","text":"<p>Input</p> <ul> <li><code>Router.Addr.t()</code> Dumper Address</li> </ul> <p>Output</p> <p>No user-visible output on success.</p>","boost":2},{"location":"arch/node/engines/dumper.html#stop","title":"Stop","text":"<p>I shut down the dumper task given in the Engine field.</p> <p>Input</p> <ul> <li><code>Router.Addr.t()</code> Dumper Engine Address</li> </ul> <p>Output</p> <p>No user-visible output on success.</p>","boost":2},{"location":"arch/node/engines/dumper.html#set_count","title":"Set_Count","text":"","boost":2},{"location":"arch/node/engines/dumper.html#purpose_1","title":"Purpose","text":"<p>The <code>Set_Count</code> function changes the count field of the given dumper engine. It shuts down the task in the initially given state, starting a new one with the changed count parameter, registering both new task and the new count settings in the state.</p> <p>If the count is a non-positive integer, the function does nothing while if the fed count is nil, then it sets both the count and task to nil.</p> <p>Input</p> <ul> <li><code>Router.Addr.t()</code> Address of the Dumper Engine</li> <li><code>non_neg_integer() | nil</code> New count</li> </ul> <p>Output</p> <p>No use-observable output on success.</p>","boost":2},{"location":"arch/node/engines/dumper.html#message-flow","title":"Message Flow","text":"<p><pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Pinger Engine: Start\nAny Local Engine -&gt;&gt;+ Pinger Engine: Stop\nAny Local Engine -&gt;&gt;+ Pinger Engine: Set_Timer\n%% --8&lt;-- [end:sequence]</code></pre> </p>","boost":2},{"location":"arch/node/engines/encryption.html","title":"Encryption Engine","text":"<p>Failure</p> <p>[13 of 18] Compiling arch.node.engines.encryption [14 of 18] Compiling arch.node.engines.encryption_behaviour [17 of 18] Compiling arch.node.engines.encryption_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/encryption_environment.juvix.md:84:7-11: error: Unexpected argument node</p> <p>icon: octicons/project-template-24 search:   exclude: false tags: - encryption - engines</p> Juvix imports <pre><code>module arch.node.engines.encryption;\n\nimport prelude open;\nimport arch.node.types.engine open;\n\nimport arch.node.engines.encryption_messages open public;\nimport arch.node.engines.encryption_environment open public;\nimport arch.node.engines.encryption_behaviour open public;\nopen encryption_environment_example;\n</code></pre>"},{"location":"arch/node/engines/encryption.html#encryption-engine","title":"Encryption Engine","text":"<p>The <code>Encryption</code> engine is responsible for encrypting data to external identities, possibly using known <code>reads_for</code> relationships. It automatically utilizes \"reads_for\" relationship information from the Reads For Engine along with caller preference information to choose which identity to encrypt to.</p>"},{"location":"arch/node/engines/encryption.html#purpose","title":"Purpose","text":"<p>The <code>Encryption</code> Engine encrypts data to external identities, optionally using known <code>reads_for</code> relationships. It is a stateless function, and calls to it do not need to be ordered. The runtime should implement this intelligently for efficiency.</p>"},{"location":"arch/node/engines/encryption.html#components","title":"Components","text":"<ul> <li>Encryption Messages</li> <li>Encryption Environment</li> <li>Encryption Behaviour</li> </ul>"},{"location":"arch/node/engines/encryption.html#useful-links","title":"Useful links","text":"<p>???</p>"},{"location":"arch/node/engines/encryption.html#type","title":"Type","text":"<pre><code>EncryptionEngine : Type := Engine\n  EncryptionLocalState\n  EncryptionMailboxState\n  EncryptionTimerHandle\n  EncryptionMatchableArgument\n  EncryptionActionLabel\n  EncryptionPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/encryption.html#example-of-a-encryption-engine","title":"Example of a encryption engine","text":"<pre><code>exampleEncryptionEngine : EncryptionEngine :=\n  mkEngine@{\n    behaviour := encryptionBehaviour;\n    initEnv := encryptionEnvironmentExample;\n  };\n</code></pre> <p>where <code>encryptionEnvironmentExample</code> is defined as follows:</p> <pre><code><pre>encryptionEnvironmentExample : EncryptionEnvironment :=  mkEngineEnvironment@{    name := \"encryption\";    localState :=      mkEncryptionLocalState@{        encryptor :=          \\{_ _ :=            mkEncryptor@{              encrypt := \\{_ x := x};              encryptorHash :=                mkHASH@{                  ordKey :=                    mkOrdkey@{                      compare := Ord.cmp;                    };                  hash := \\{x := 0};                };            }};        backend := BackendLocalMemory;        readsForEngineAddress := mkPair none (some \"Blah\");        pendingRequests := Map.empty;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>"},{"location":"arch/node/engines/encryption_behaviour.html","title":"Encryption Engine Behaviour","text":"<p>Failure</p> <p>[12 of 16] Compiling arch.node.engines.encryption_behaviour [15 of 16] Compiling arch.node.engines.encryption_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/encryption_environment.juvix.md:84:7-11: error: Unexpected argument node</p> <p>icon: octicons/gear-16 search:   exclude: false categories: - engine-behaviour - juvix-module tags: - encryption - engine-behavior</p> Juvix imports <pre><code>module arch.node.engines.encryption_behaviour;\nimport prelude open;\nimport arch.system.identity.identity open hiding {ExternalIdentity};\nimport arch.node.engines.encryption_environment open;\nimport arch.node.engines.encryption_messages open;\nimport arch.node.engines.reads_for_messages open;\nimport arch.node.types.anoma_message open;\nimport arch.node.types.engine_behaviour open;\nimport arch.node.types.engine_environment open;\nimport arch.node.types.identities open;\nimport arch.node.types.messages open;\n</code></pre>"},{"location":"arch/node/engines/encryption_behaviour.html#encryption-dynamics","title":"<code>Encryption</code> Dynamics","text":""},{"location":"arch/node/engines/encryption_behaviour.html#overview","title":"Overview","text":"<p>The behavior of the <code>Encryption</code> Engine define how it processes incoming encryption requests and produces the corresponding responses.</p>"},{"location":"arch/node/engines/encryption_behaviour.html#action-labels","title":"Action labels","text":"<pre><code>type EncryptionActionLabel :=\n  | -- --8&lt;-- [start:DoEncrypt]\n    DoEncrypt {\n      data : Plaintext;\n      externalIdentity : ExternalIdentity;\n      useReadsFor : Bool\n    }\n    -- --8&lt;-- [end:DoEncrypt]\n  | -- --8&lt;-- [start:DoHandleReadsForResponse]\n    DoHandleReadsForResponse {\n      externalIdentity : ExternalIdentity;\n      readsForEvidence : Set ReadsForEvidence\n    };\n    -- --8&lt;-- [end:DoHandleReadsForResponse]\n;\n</code></pre>"},{"location":"arch/node/engines/encryption_behaviour.html#doencrypt","title":"<code>DoEncrypt</code>","text":"<p>DoEncrypt {   data : Plaintext;   externalIdentity : ExternalIdentity;   useReadsFor : Bool }</p> <p>This action label corresponds to encrypting the data in the given request.</p> <code>DoEncrypt</code> action effect <p>This action does the following:</p> Aspect Description State update If <code>useReadsFor</code> is true, the state is updated to store pending requests. Otherwise, the state remains unchanged. Messages to be sent If <code>useReadsFor</code> is false, an <code>EncryptResponse</code> message is sent back to the requester. If <code>useReadsFor</code> is true and it's the first request for this identity, a <code>QueryReadsForEvidenceRequest</code> is sent to the ReadsFor Engine. Engines to be spawned No engines are created by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/encryption_behaviour.html#dohandlereadsforresponse","title":"<code>DoHandleReadsForResponse</code>","text":"<p>DoHandleReadsForResponse {   externalIdentity : ExternalIdentity;   readsForEvidence : Set ReadsForEvidence };</p> <p>This action label corresponds to receiving reads for evidence and using it to address relevant pending requests.</p> <code>DoHandleReadsForResponse</code> action effect <p>This action does the following:</p> Aspect Description State update The state is updated to remove the processed pending requests for the given external identity. Messages to be sent <code>EncryptResponse</code> messages are sent to all requesters who were waiting for this ReadsFor evidence. Engines to be spawned No engines are created by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/encryption_behaviour.html#matchable-arguments","title":"Matchable arguments","text":"<pre><code>type EncryptionMatchableArgument :=\n  | -- --8&lt;-- [start:ReplyTo]\n  ReplyTo (Option EngineID) (Option MailboxID)\n  -- --8&lt;-- [end:ReplyTo]\n;\n</code></pre>"},{"location":"arch/node/engines/encryption_behaviour.html#replyto","title":"<code>ReplyTo</code>","text":"<pre><code>ReplyTo (Option EngineID) (Option MailboxID)\n</code></pre> <p>This matchable argument contains the address and mailbox ID of where the response message should be sent.</p>"},{"location":"arch/node/engines/encryption_behaviour.html#precomputation-results","title":"Precomputation results","text":"<p>The <code>Encryption</code> Engine does not require any non-trivial pre-computations.</p> <pre><code>syntax alias EncryptionPrecomputation := Unit;\n</code></pre>"},{"location":"arch/node/engines/encryption_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code <p>Type alias for the guard.</p> <pre><code>-- --8&lt;-- [start:encryption-guard]\nEncryptionGuard : Type :=\n  Guard\n    EncryptionLocalState\n    EncryptionMailboxState\n    EncryptionTimerHandle\n    EncryptionMatchableArgument\n    EncryptionActionLabel\n    EncryptionPrecomputation;\n-- --8&lt;-- [end:encryption-guard]\n\n-- --8&lt;-- [start:encryption-guard-output]\nEncryptionGuardOutput : Type :=\n  GuardOutput EncryptionMatchableArgument EncryptionActionLabel EncryptionPrecomputation;\n-- --8&lt;-- [end:encryption-guard-output]\n</code></pre>"},{"location":"arch/node/engines/encryption_behaviour.html#encryptguard","title":"<code>encryptGuard</code>","text":"<pre><code>flowchart TD\n    C{EncryptRequest&lt;br&gt;received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoEncrypt])</code></pre> encryptGuard flowchart <pre><code>encryptGuard\n  (t : TimestampedTrigger EncryptionTimerHandle)\n  (env : EncryptionEnvironment) : Option EncryptionGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgEncryption (EncryptRequest data externalIdentity useReadsFor)) := do {\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n                  matchedArgs := [ReplyTo (some sender) none] ;\n                  actionLabel := DoEncrypt data externalIdentity useReadsFor;\n                  precomputationTasks := unit\n                });\n        }\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/encryption_behaviour.html#readsforresponseguard","title":"<code>readsForResponseGuard</code>","text":"<pre><code>readsForResponseGuard\n  (t : TimestampedTrigger EncryptionTimerHandle)\n  (env : EncryptionEnvironment) : Option EncryptionGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgReadsFor (QueryReadsForEvidenceResponse externalIdentity evidence err)) :=\n          case getSenderFromTimestampedTrigger t of {\n            | some sender :=\n                case isEqual (Ord.cmp sender (EncryptionLocalState.readsForEngineAddress (EngineEnv.localState env))) of {\n                  | true := some (mkGuardOutput@{\n                      matchedArgs := [];\n                      actionLabel := DoHandleReadsForResponse externalIdentity evidence;\n                      precomputationTasks := unit\n                    })\n                  | false := none\n                }\n            | none := none\n          }\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/encryption_behaviour.html#action-function","title":"Action function","text":"Auxiliary Juvix code <p>Type alias for the action function.</p> <pre><code>EncryptionActionInput : Type :=\n  ActionInput\n    EncryptionLocalState\n    EncryptionMailboxState\n    EncryptionTimerHandle\n    EncryptionMatchableArgument\n    EncryptionActionLabel\n    EncryptionPrecomputation;\n\nEncryptionActionEffect : Type :=\n  ActionEffect\n    EncryptionLocalState\n    EncryptionMailboxState\n    EncryptionTimerHandle\n    EncryptionMatchableArgument\n    EncryptionActionLabel\n    EncryptionPrecomputation;\n</code></pre> <pre><code>encryptResponse\n  (externalIdentity : ExternalIdentity)\n  (env : EncryptionEnvironment)\n  (evidence : Set ReadsForEvidence)\n  (req : Pair EngineID Plaintext)\n  : EngineMsg\n  := let localState := EngineEnv.localState env;\n      whoAsked := fst req;\n      data := snd req;\n      encryptedData :=\n        Encryptor.encrypt\n          (EncryptionLocalState.encryptor localState evidence externalIdentity)\n          (EncryptionLocalState.backend localState)\n          data;\n      responseMsg := EncryptResponse@{\n        ciphertext := encryptedData;\n        err := none\n      };\n      envelope := mkEngineMsg@{\n        sender := mkPair none (some (EngineEnv.name env));\n        target := whoAsked;\n        mailbox := some 0;\n        msg := MsgEncryption responseMsg\n      };\n      in envelope;\n\nencryptionAction (input : EncryptionActionInput) : EncryptionActionEffect :=\n  let env := ActionInput.env input;\n      out := ActionInput.guardOutput input;\n      localState := EngineEnv.localState env;\n  in\n  case GuardOutput.actionLabel out of {\n    | DoEncrypt data externalIdentity' useReadsFor :=\n        case GuardOutput.matchedArgs out of {\n          | (ReplyTo (some whoAsked) _) :: _ :=\n              case useReadsFor of {\n                | false :=\n                    let envelope := encryptResponse externalIdentity' env Set.empty (mkPair whoAsked data)\n                    in mkActionEffect@{\n                      newEnv := env; -- No state change\n                      producedMessages := [envelope];\n                      timers := [];\n                      spawnedEngines := []\n                    }\n                | true :=\n                    -- Need to request ReadsForEvidence from ReadsFor Engine\n                    let existingRequests := Map.lookup externalIdentity' (EncryptionLocalState.pendingRequests localState);\n                        newPendingList := case existingRequests of {\n                          | some reqs := reqs ++ [mkPair whoAsked data]\n                          | none := [mkPair whoAsked data]\n                        };\n                        newPendingRequests := Map.insert externalIdentity' newPendingList (EncryptionLocalState.pendingRequests localState);\n                        newLocalState := localState@EncryptionLocalState{\n                          pendingRequests := newPendingRequests\n                        };\n                        newEnv' := env@EngineEnv{\n                          localState := newLocalState\n                        };\n                        -- Only send request to ReadsFor Engine if this is the first pending request for this identity\n                        messagesToSend := case existingRequests of {\n                          | some _ := [] -- Request already sent, do none\n                          | none := let requestMsg := QueryReadsForEvidenceRequest@{\n                                          externalIdentity := externalIdentity'\n                                        };\n                                        envelope := mkEngineMsg@{\n                                          sender := mkPair none (some (EngineEnv.name env));\n                                          target := EncryptionLocalState.readsForEngineAddress localState;\n                                          mailbox := some 0;\n                                          msg := MsgReadsFor requestMsg\n                                        };\n                                        in [envelope]\n                        };\n                    in mkActionEffect@{\n                      newEnv := newEnv';\n                      producedMessages := messagesToSend;\n                      timers := [];\n                      spawnedEngines := []\n                    }\n              }\n          | _ := mkActionEffect@{newEnv := env; producedMessages := []; timers := []; spawnedEngines := []}\n      }\n    | DoHandleReadsForResponse externalIdentity evidence :=\n        -- Retrieve pending requests\n        case Map.lookup externalIdentity (EncryptionLocalState.pendingRequests localState) of {\n          | some reqs :=\n              let messages := map (encryptResponse externalIdentity env evidence) reqs;\n                  newPendingRequests := Map.delete externalIdentity (EncryptionLocalState.pendingRequests localState);\n                  newLocalState := localState@EncryptionLocalState{\n                    pendingRequests := newPendingRequests\n                  };\n                  newEnv' := env@EngineEnv{\n                    localState := newLocalState\n                  };\n              in mkActionEffect@{\n                newEnv := newEnv';\n                producedMessages := messages;\n                timers := [];\n                spawnedEngines := []\n              }\n          | none :=\n              -- No pending requests, do none\n              mkActionEffect@{\n                newEnv := env;\n                producedMessages := [];\n                timers := [];\n                spawnedEngines := []\n              }\n        }\n  };\n</code></pre>"},{"location":"arch/node/engines/encryption_behaviour.html#conflict-solver","title":"Conflict solver","text":"<pre><code>encryptionConflictSolver : Set EncryptionMatchableArgument -&gt; List (Set EncryptionMatchableArgument)\n  | _ := [];\n</code></pre>"},{"location":"arch/node/engines/encryption_behaviour.html#encryptionbehaviour-type","title":"EncryptionBehaviour type","text":"<pre><code>EncryptionBehaviour : Type :=\n  EngineBehaviour\n    EncryptionLocalState\n    EncryptionMailboxState\n    EncryptionTimerHandle\n    EncryptionMatchableArgument\n    EncryptionActionLabel\n    EncryptionPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/encryption_behaviour.html#encryptionbehaviour-instance","title":"EncryptionBehaviour instance","text":"<pre><code>encryptionBehaviour : EncryptionBehaviour :=\n  mkEngineBehaviour@{\n    guards := [encryptGuard; readsForResponseGuard];\n    action := encryptionAction;\n    conflictSolver := encryptionConflictSolver;\n  };\n</code></pre>"},{"location":"arch/node/engines/encryption_environment.html","title":"Encryption Engine Environment","text":"<p>Failure</p> <p>[7 of 9] Compiling arch.node.engines.encryption_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/encryption_environment.juvix.md:84:7-11: error: Unexpected argument node</p> <p>icon: octicons/container-24 search:   exclude: false categories: - engine-behaviour tags: - encryption - engine-environment</p> Juvix imports <pre><code>module arch.node.engines.encryption_environment;\n\nimport prelude open;\nimport arch.node.engines.encryption_messages open;\nimport arch.node.types.engine_environment open;\nimport arch.node.types.identities open;\nimport arch.node.types.messages open;\nimport arch.system.identity.identity open hiding {ExternalIdentity};\n</code></pre>"},{"location":"arch/node/engines/encryption_environment.html#encryption-engine-environment","title":"<code>Encryption</code> Engine Environment","text":""},{"location":"arch/node/engines/encryption_environment.html#overview","title":"Overview","text":"<p>The <code>Encryption</code> Engine is stateless and does not maintain any internal state between requests. It relies on external information (like the <code>reads_for</code> relationships) for its operations.</p>"},{"location":"arch/node/engines/encryption_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The <code>Encryption</code> Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p> <pre><code>syntax alias EncryptionMailboxState := Unit;\n</code></pre>"},{"location":"arch/node/engines/encryption_environment.html#local-state","title":"Local state","text":"<p>The local state of an <code>Encryption</code> Engine instance includes the identity's encryption capabilities, the address of an associated <code>ReadsFor</code> engine, and a specific backend. It also contains a map to a list of pending requests which require <code>ReadsFor</code> information which is requested from the associated <code>ReadsFor</code> engine.</p> <pre><code>type EncryptionLocalState := mkEncryptionLocalState@{\n  encryptor : Set ReadsForEvidence -&gt; ExternalIdentity -&gt; Encryptor ByteString Backend Plaintext Ciphertext;\n  backend : Backend;\n  readsForEngineAddress : EngineID;\n  pendingRequests : Map ExternalIdentity (List (Pair EngineID Plaintext));\n};\n</code></pre>"},{"location":"arch/node/engines/encryption_environment.html#timer-handle","title":"Timer Handle","text":"<pre><code>syntax alias EncryptionTimerHandle := Unit;\n</code></pre> <p>The Encryption Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>"},{"location":"arch/node/engines/encryption_environment.html#environment-summary","title":"Environment summary","text":"<pre><code>EncryptionEnvironment : Type := EngineEnv\n  EncryptionLocalState\n  EncryptionMailboxState\n  EncryptionTimerHandle;\n</code></pre>"},{"location":"arch/node/engines/encryption_environment.html#example-of-an-encryption-environment","title":"Example of an <code>Encryption</code> environment","text":"<pre><code>module encryption_environment_example;\n\nencryptionEnvironmentExample : EncryptionEnvironment :=\n    mkEngineEnv@{\n      node := Curve25519PubKey \"0xabcd1234\";\n      name := \"encryption\";\n      localState := mkEncryptionLocalState@{\n        encryptor := \\{_ _ := mkEncryptor@{\n          encrypt := \\{_ x := x};\n          encryptorHash := mkHASH@{\n            ordKey := mkOrdkey@{\n                compare := Ord.cmp\n            };\n            hash := \\{x := \"0x1234abcd\"};\n          };\n        }};\n        backend := BackendLocalMemory;\n        readsForEngineAddress := mkPair none (some \"Blah\");\n        pendingRequests := Map.empty\n      };\n      mailboxCluster := Map.empty;\n      acquaintances := Set.empty;\n      timers := []\n    }\n  ;\nend;\n</code></pre>"},{"location":"arch/node/engines/encryption_messages.html","title":"Encryption Engine Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.encryption_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["encryption","engine-messages"]},{"location":"arch/node/engines/encryption_messages.html#encryption-messages","title":"<code>Encryption</code> Messages","text":"","tags":["encryption","engine-messages"]},{"location":"arch/node/engines/encryption_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type EncryptionMsg :=  | EncryptRequest {      data : Plaintext;      externalIdentity : ExternalIdentity;      useReadsFor : Bool    }  | EncryptResponse {      ciphertext : Ciphertext;      err : Option String    };</pre></code></pre>","tags":["encryption","engine-messages"]},{"location":"arch/node/engines/encryption_messages.html#encryptrequest-message","title":"<code>EncryptRequest</code> message","text":"<p><code>EncryptRequest</code></p> <pre><code>EncryptRequest {\n  data : Plaintext;\n  externalIdentity : ExternalIdentity;\n  useReadsFor : Bool\n}\n</code></pre> <p>An <code>EncryptRequest</code> instructs the Encryption Engine to encrypt data to a particular external identity, possibly using known reads_for relationships.</p> <ul> <li><code>data</code>: The data to encrypt.</li> <li><code>externalIdentity</code>: The external identity to encrypt to.</li> <li><code>useReadsFor</code>: Whether to use known <code>reads_for</code> relationships or not.</li> </ul>","tags":["encryption","engine-messages"]},{"location":"arch/node/engines/encryption_messages.html#encryptresponse-message","title":"<code>EncryptResponse</code> message","text":"<p><code>EncryptResponse</code></p> <pre><code>EncryptResponse {\n  ciphertext : Ciphertext;\n  err : Option String\n}\n</code></pre> <p>An <code>EncryptResponse</code> contains the data encrypted by the <code>Encryption</code> Engine in response to an <code>EncryptRequest</code>.</p> <ul> <li><code>ciphertext</code>: The encrypted data.</li> <li><code>err</code>: An error message if encryption failed.</li> </ul>","tags":["encryption","engine-messages"]},{"location":"arch/node/engines/encryption_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["encryption","engine-messages"]},{"location":"arch/node/engines/encryption_messages.html#encryption-sequence-without-readsfor-evidence","title":"Encryption Sequence (Without <code>ReadsFor</code> evidence)","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant EncryptionEngine\n\n    Client-&gt;&gt;EncryptionEngine: EncryptRequest (useReadsFor: false)\n    Note over EncryptionEngine: Encrypt commitment\n    EncryptionEngine-&gt;&gt;Client: EncryptResponse</code></pre>  Sequence diagram for verification (no reads for).","tags":["encryption","engine-messages"]},{"location":"arch/node/engines/encryption_messages.html#encryption-sequence-with-readsfor-evidence","title":"Encryption Sequence (With <code>ReadsFor</code> evidence)","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant EncryptionEngine\n    participant ReadsForEngine\n\n    Client-&gt;&gt;EncryptionEngine: EncryptRequest (useReadsFor: true)\n    EncryptionEngine-&gt;&gt;ReadsForEngine: QueryReadsForEvidenceRequest\n    Note over ReadsForEngine: Retrieve evidence\n    ReadsForEngine-&gt;&gt;EncryptionEngine: QueryReadsForEvidenceResponse\n    Note over EncryptionEngine: Encrypt commitment using ReadsFor evidence\n    EncryptionEngine-&gt;&gt;Client: EncryptResponse</code></pre>  Sequence diagram for verification (reads for).","tags":["encryption","engine-messages"]},{"location":"arch/node/engines/encryption_messages.html#engine-components","title":"Engine Components","text":"<ul> <li><code>Encryption</code> Engine Environment</li> <li><code>Encryption</code> Engine Dynamics</li> </ul>","tags":["encryption","engine-messages"]},{"location":"arch/node/engines/encryption_messages.html#useful-links","title":"Useful links","text":"","tags":["encryption","engine-messages"]},{"location":"arch/node/engines/execution.html","title":"Execution","text":"<p>Inputs:</p> <ul> <li>transactions (from Mempool)</li> </ul> <ul> <li>partial transaction ordering information (from Mempool)</li> </ul> <ul> <li>total transaction ordering information (from   Consensus)</li> </ul> <p>Outputs:</p> <ul> <li>execution results, including state reads (for clients)</li> </ul> <ul> <li>garbage collection information (for Mempool)</li> </ul> <p>Preferences: ?</p> <p>Accounting: executions actually performed, parallelization (perhaps)</p>","boost":2},{"location":"arch/node/engines/execution.html#execution-engine","title":"Execution Engine","text":"","boost":2},{"location":"arch/node/engines/execution.html#summary","title":"Summary","text":"<p>Given a total order (from the consensus) of transactions (from the mempool), the execution engine updates and stores the \"current\" state of the replicated state machine, using as much concurrency as possible. Outputs from the execution engine allow light clients to read the current state. When the execution engine has finished with a transaction, it communicates to the mempool that the transaction can be garbage-collected from storage.</p>","boost":2},{"location":"arch/node/engines/execution.html#state","title":"State","text":"<p>State is stored as mutable Data (unlimited size blobs of binary), each of which is identified with an immutable Key. If you want to mutate a Key associated with specific Data, that's equivalent to deleting the Data associated with the old Key, and writing it to the new Key. Keys that have never had Data written to them are mapped to an empty value.</p> <p>Keys can have structure. For example, we can arrange them in a forest, to allow us to easily express sub-trees using prefixes. This would allow labels to express potentially infinite sets of keys in a compact way. This makes Re-Sharding challenging.</p>","boost":2},{"location":"arch/node/engines/execution.html#state-machine-api","title":"State Machine API","text":"","boost":2},{"location":"arch/node/engines/execution.html#transaction-labels","title":"Transaction Labels","text":"<p>For each Learner, transactions are labelled with a set of keys they can read, and a set of keys they can write.</p> <p>\\(read :  \\left\\langle Learner, Transaction \\right\\rangle \\rightarrow \\left\\{Key\\right\\}\\)</p> <p>\\(write : \\left\\langle Learner, Transaction \\right\\rangle \\rightarrow \\left\\{Key\\right\\}\\)</p>","boost":2},{"location":"arch/node/engines/execution.html#executor-function","title":"Executor Function","text":"<p>In order to define a state machine for use with Typhon, we require an Executor Function:</p> <p>\\(executor\\_function : \\left\\langle\\left(Key \\rightarrow Data\\right), Transaction\\right\\rangle \\rightarrow \\left( \\left\\{\\left\\langle Key , Data \\right\\rangle\\right\\}, IO \\right)\\)</p> <p>Inputs:</p> <ul> <li>the previous state, represented as a function from Keys to Data</li> </ul> <ul> <li>the Transaction text itself</li> </ul> <p>Outputs:</p> <ul> <li> <p>the new \\(\\left\\langle Key, Data\\right\\rangle\\) pairs to be written to state.</p> <ul> <li>Naively, these must include all the Keys in \\(write(L,T)\\), but perhaps we can   make a special optimization for \"don't actually update this Key,\" even if we   can only do it for keys in \\(read(L,T)\\cap write(L,T)\\).</li> </ul> <ul> <li>This new state must be a deterministic result of the inputs</li> </ul> </li> </ul> <ul> <li>Some IO side-effects, including sending messages to clients or whatever.</li> </ul>","boost":2},{"location":"arch/node/engines/execution.html#execution-engine-architecture","title":"Execution Engine Architecture","text":"<p>Our architecture is heavily inspired by Calvin: Fast Distributed Transactions for Partitioned Database Systems. It facilitates concurrency while maintaining serializability using the mempool and consensus components as a sequencer.</p>","boost":2},{"location":"arch/node/engines/execution.html#timestamps","title":"Timestamps","text":"<p>Each Transaction has a Timestamp which conveys ordering information relative to other transactions. Timestamps, and thus transactions, are partially ordered. As shards learn more information from consensus or the mempool, they are able to refine this partial order until it is a total order. For Heterogeneous Narwhal, these timestamps may be tuples of \\(\\left\\langle validator\\_id, block\\_header\\_height, transaction\\_hash\\right\\rangle\\)</p>","boost":2},{"location":"arch/node/engines/execution.html#shards","title":"Shards","text":"<p>Shards are processes that store and update state. Different shards may be on different machines. Redistributing state between shards is called Re-Sharding. Each Shard is specific to 1 learner. However, as an optimization, an implementation could conceivably use 1 process to do the work of multiple shards with different learners so long as those shards are identical, and fork that process if / when the learners diverge.</p> <p>For each Key, each Shard maintains a (partially-ordered) timeline of Timestamps of Transactions that read or write to that Key. Shards also store the data written by each transaction that writes to that Key. This is multi-version concurrent storage.</p>","boost":2},{"location":"arch/node/engines/execution.html#executor-processes","title":"Executor Processes","text":"<p>Executor Processes are processes that actually run the Executor Function and compute updates. Executor Processes can be co-located with shards. The Execution Engine might keep a pool of Executor Processes, or spin a new one up with each transaction.</p>","boost":2},{"location":"arch/node/engines/execution.html#life-of-a-transaction","title":"Life of a Transaction","text":"<ul> <li>When the mempool stores a transaction, the execution   engine assigns an executor process, using that transaction's text.</li> </ul> <ul> <li>Once the mempool has assigned a timestamp to a transaction, it communicates that timestamp to each of the shards in the transaction's label, and establishes communication channels between the shards and teh transaction's executor process. Each shard then stores that timestamp in its timeline.</li> </ul> <ul> <li> <p>For each key read, when the relevant Shard learns the precise data to be read   at that time (identifies a unique previous transaction and learns the data   written by that transaction), it communicates that data to the Executor   process.</p> <ul> <li>As an optimization, we may want to allow \"lazy\" reads</li> </ul> </li> </ul> <ul> <li> <p>When it receives all the data it needs to read, the executor process runs the   executor function in order to learn the values written. It then communicates   these values to the relevant shards.</p> <ul> <li>As an optimization, we may allow executor processes to start computing   before all reads are available, if possible.</li> </ul> <ul> <li>As an optimization, we may consider special writes such as \"don't change   this data,\" (which would only work for keys the transaction both reads and   writes)</li> <li>For each key written, the shard waits to receive data written from the executor process, and stores it.</li> </ul> </li> </ul>","boost":2},{"location":"arch/node/engines/execution.html#serializable-transaction-execution","title":"Serializable Transaction Execution","text":"<p>We want to execute each transaction (evaluate the executor function in order to compute the data written) while preserving serializability: each transaction's reads and writes should be as if the transactions were executed in the order determined by consensus. We can imagine the simplest system as executing each transaction, after they're ordered by consensus, sequentially, using the executor function. However, we want to compute concurrently as possible, for minimum latency. We do this using a set of optimizaitons.</p>","boost":2},{"location":"arch/node/engines/execution.html#optimization-per-key-ordering","title":"Optimization: Per-Key Ordering","text":"<p>Mempool and consensus provide ordering information for the timestamps, so within each key, transactions can be totally ordered by a \"Happens Before\" relationship. With a total ordering of transactions, keys can send read information to executors as soon as the previous transaction is complete. However, transactions that don't touch the same keys can be run simultaneously. In the diagram above, for example, transactions <code>c</code> and <code>d</code> can run concurrently, as can transactions <code>e</code> and <code>f</code>, and transactions <code>h</code> and <code>j</code>.</p>","boost":2},{"location":"arch/node/engines/execution.html#optimization-order-with-respect-to-writes","title":"Optimization: Order With Respect To Writes","text":"<p>In fact, shards can send read information to an executor process as soon as the previous write has completed. All shards really need to keep track of is a total order of writes, and how each read is ordered with respect to writes (which write it happens before and which write happens before it). As soon as the preceding write is complete, the reads that depend on it can run concurrently. There are no \"read/read\" conflicts. In the diagram above, for example, transactions <code>a</code> and <code>b</code> can run concurrently.</p>","boost":2},{"location":"arch/node/engines/execution.html#optimization-only-wait-to-read","title":"Optimization: Only Wait to Read","text":"<p>Because we store each version written (multi-version concurrent storage), we do not have to execute writes in order. A shard does not have to wait to write a later data version to a key just because previous reads have not finished executing yet. In the diagram above, for example, only green \"Happens Before\" arrows require waiting. Transactions <code>a</code>, <code>b</code>, <code>c</code>, and <code>j</code> can all be executed concurrently, as can transactions <code>d</code>, <code>e</code>, and <code>i</code>.</p>","boost":2},{"location":"arch/node/engines/execution.html#optimization-execute-with-partial-order","title":"Optimization: Execute With Partial Order","text":"<p>Some mempools, including Narwhal can provide partial order information on transactions even before consensus has determined a total order. This allows Typhon to execute some transactions before a total ordering is known. In general, for a given key, a shard can send read information to an executor when it knows precisely which write happens most recently before the read, and that write has executed.</p>","boost":2},{"location":"arch/node/engines/execution.html#heardallwrites","title":"heardAllWrites","text":"<p>In order to known which write happens most recently before a given read, Typhon must know that no further writes will be added to the timeline before the read. Mempool and consensus should communicate a lower bound timestamp to the execution engine, called \\(heardAllWrites\\), before which no more transactions containing any write operations will be sent to the execution engine. This can be on a per-key basis or simply a global lower bound. Occasionally, \\(heardAllWrites\\) should be updated with later timestamps. Each round of consensus should produce a lower bound for \\(heardAllWrites\\), but the mempool may already have sent better bounds. Each Shard must keep track of \\(heardAllWrites\\) on each key's multi-version timeline.</p> <p>Transactions (like transaction <code>j</code> in the diagram below) containing only write operations can execute with a timestamp after \\(heardAllWrites\\), but this simply means calculating the data they will write. Since that doesn't depend on state, this can of course be done at any time.</p>","boost":2},{"location":"arch/node/engines/execution.html#heardallreads","title":"heardAllReads","text":"<p>We want to allow Typhon to eventually garbage-collect old state. Mempool and consensus should communicate a lower bound timestamp to the execution engine, called \\(heardAllReads\\), before which there will be no more read transactions send to the execution engine. Occasionally, \\(heardAllReads\\) should be updated with later timestamps. Each Shard must keep track of \\(heardAllReads\\) on each key's multi-version timeline, so it can garbage collect old values.</p> <p></p> <p>In the example above, our \"Happens Before\" arrows have been replaced with \"May Happen Before\" arrows, representing partial ordering information from the mempool. Note that not all transactions can be executed with this partial order information.</p>","boost":2},{"location":"arch/node/engines/execution.html#conflicts","title":"Conflicts","text":"<p>There are 3 types of conflicts that can prevent a transaction from being executable without more ordering information.</p> <ul> <li>Write/Write Conflicts occur when a shard cannot identify the most recent   write before a given read. In the diagram above, transaction <code>e</code> cannot   execute because it's not clear whether transaction <code>b</code> or transaction <code>c</code>   wrote most recently to the yellow key.</li> </ul> <ul> <li>Read/Write Conflicts occur when shard cannot identify whether a read   operation occurs before or after a write, so it's not clear if it should read   the value from that write or from a previous write. In the diagram above,   transaction <code>g</code> cannot execute because it's not clear whether it would read   the data written to the blue key by transaction <code>d</code> or transaction <code>i</code>.</li> </ul> <ul> <li>Transitive Conflicts occur when a shard cannot get the data for a read   because the relevant write is conflicted. In the diagram above, transaction <code>h</code> cannot execute because it cannot read the data written to the yellow key by transaction <code>g</code>, since transaction <code>g</code> is conflicted. As the mempool and consensus provide the execution engine with more and more ordering information, and the partial order of timestamps is refined, all conflicts eventually resolve. In the diagram above, suppose consensus orders transaction <code>g</code> before transaction <code>i</code>. The Read/Write conflict is resolved: transaction <code>g</code> reads the data transaction <code>d</code> writes to the blue key. Then the transitive conflict is also resolved: transaction <code>h</code> will be able to execute.</li> </ul>","boost":2},{"location":"arch/node/engines/execution.html#optimization-client-reads-as-read-only-transactions","title":"Optimization: Client Reads as Read-Only Transactions","text":"<p>With the above optimizations, transactions containing only read operations do not affect other transactions (or scheduling) at all. Therefore, they can bypass mempool and consensus altogether. Clients can simply send read-only transactions directly to the execution engine (with a label and a timestamp), and if the timestamp is after \\(heardAllReads\\), the execution engine can simply place the transaction in the timeline of the relevant shards and execute it when possible. In the diagram above, transaction <code>f</code> is read-only.</p> <p>If client reads produce signed responses, then signed responses from a weak quorum of validators would form a light client proof.</p>","boost":2},{"location":"arch/node/engines/identity_management.html","title":"Identity Management Engine","text":"<p>Failure</p> <p>[15 of 24] Compiling arch.node.engines.identity_management_behaviour [19 of 24] Compiling arch.node.engines.identity_management_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/identity_management_environment.juvix.md:84:7-11: error: Unexpected argument node</p> <p>icon: octicons/project-template-24 search:   exclude: false tags: - identity_management - engines</p> Juvix imports <pre><code>module arch.node.engines.identity_management;\n\nimport prelude open;\nimport arch.node.types.engine open;\n\nimport arch.node.engines.identity_management_messages open public;\nimport arch.node.engines.identity_management_environment open public;\nimport arch.node.engines.identity_management_behaviour open public;\nopen identity_management_environment_example;\n</code></pre>"},{"location":"arch/node/engines/identity_management.html#identitymanagement-engine","title":"IdentityManagement Engine","text":"<p>The Identity Management Engine is responsible for generating, connecting, and deleting identities using various backends. It provides a unified interface over different identity backends, including internal identities stored in local memory, identities stored in hardware devices, identities accessed via browser extensions, and identities stored on remote machines accessible over the network.</p>"},{"location":"arch/node/engines/identity_management.html#purpose","title":"Purpose","text":"<p>The Identity Management Engine manages identities across various backends. When an identity is generated or connected, it returns handles to the corresponding commitment and decryption engine instances. These handles can be used to generate commitments or decrypt data associated with the identity.</p>"},{"location":"arch/node/engines/identity_management.html#components","title":"Components","text":"<ul> <li>IdentityManagement Messages</li> <li>IdentityManagement Environment</li> <li>IdentityManagement Behaviour</li> </ul>"},{"location":"arch/node/engines/identity_management.html#useful-links","title":"Useful links","text":"<p>???</p>"},{"location":"arch/node/engines/identity_management.html#type","title":"Type","text":"<pre><code>IdentityManagementEngine : Type := Engine\n  IdentityManagementLocalState\n  IdentityManagementMailboxState\n  IdentityManagementTimerHandle\n  IdentityManagementMatchableArgument\n  IdentityManagementActionLabel\n  IdentityManagementPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/identity_management.html#example-of-a-identitymanagement-engine","title":"Example of a identityManagement engine","text":"<pre><code>exampleIdentityManagementEngine : IdentityManagementEngine :=\n  mkEngine@{\n    behaviour := identityManagementBehaviour;\n    initEnv := identityManagementEnvironmentExample;\n  };\n</code></pre> <p>where <code>identityManagementEnvironmentExample</code> is defined as follows:</p> <pre><code><pre>identityManagementEnvironmentExample : IdentityManagementEnvironment :=  mkEngineEnvironment@{    name := \"identity_management\";    localState :=      mkIdentityManagementLocalState@{        identities := Map.empty;        genDecryptor :=          \\{_ :=            mkDecryptor@{              decrypt := \\{_ x := some x};            }};        genSigner :=          \\{_ :=            mkSigner@{              sign := \\{_ x := Ed25519Signature};            }};      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>"},{"location":"arch/node/engines/identity_management_behaviour.html","title":"Identity Management Engine Behaviour","text":"<p>Failure</p> <p>[15 of 23] Compiling arch.node.engines.identity_management_behaviour [19 of 23] Compiling arch.node.engines.identity_management_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/identity_management_environment.juvix.md:84:7-11: error: Unexpected argument node</p> <p>icon: octicons/gear-16 search:   exclude: false categories: - engine-behaviour - juvix-module tags: - identity_management - engine-behavior</p> Juvix imports <pre><code>module arch.node.engines.identity_management_behaviour;\nimport prelude open;\nimport arch.node.engines.commitment_environment open;\nimport arch.node.engines.decryption_environment open;\nimport arch.node.engines.identity_management_environment open;\nimport arch.node.engines.identity_management_messages open;\nimport arch.node.types.anoma_environment open;\nimport arch.node.types.anoma_message open;\nimport arch.node.types.engine_behaviour open;\nimport arch.node.types.engine_environment open;\nimport arch.node.types.identities open;\nimport arch.node.types.messages open;\nimport arch.system.identity.identity open hiding {ExternalIdentity};\n</code></pre>"},{"location":"arch/node/engines/identity_management_behaviour.html#identity-management-dynamics","title":"<code>Identity Management</code> Dynamics","text":""},{"location":"arch/node/engines/identity_management_behaviour.html#overview","title":"Overview","text":"<p>The behavior of the <code>Identity Management</code> Engine define how it processes incoming messages (requests) and produces the corresponding responses and actions.</p>"},{"location":"arch/node/engines/identity_management_behaviour.html#action-labels","title":"Action labels","text":"<pre><code>type IdentityManagementActionLabel :=\n  | -- --8&lt;-- [start:DoGenerateIdentity]\n    DoGenerateIdentity {\n      backend : Backend;\n      params : IDParams;\n      capabilities : Capabilities\n    }\n    -- --8&lt;-- [end:DoGenerateIdentity]\n  | -- --8&lt;-- [start:DoConnectIdentity]\n    DoConnectIdentity {\n      externalIdentity : EngineID;\n      backend : Backend;\n      capabilities : Capabilities\n    }\n    -- --8&lt;-- [end:DoConnectIdentity]\n  | -- --8&lt;-- [start:DoDeleteIdentity]\n    DoDeleteIdentity {\n      externalIdentity : EngineID;\n      backend : Backend\n    }\n    -- --8&lt;-- [end:DoDeleteIdentity]\n;\n</code></pre>"},{"location":"arch/node/engines/identity_management_behaviour.html#dogenerateidentity","title":"<code>DoGenerateIdentity</code>","text":"<p>DoGenerateIdentity {   backend : Backend;   params : IDParams;   capabilities : Capabilities }</p> <p>This action label corresponds to generating a new identity.</p> <code>DoGenerateIdentity</code> action effect <p>This action does the following:</p> Aspect Description State update A new identity is created and added to the <code>identities</code> map in the local state. The identity includes information about backend, capabilities, and potentially spawned engine references. Messages to be sent A <code>GenerateIdentityResponse</code> message is sent to the requester, containing the new identity information including references to spawned engines (if any) or an error message if the identity already exists. Engines to be spawned Depending on the requested capabilities, Commitment and/or Decryption engines may be spawned. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/identity_management_behaviour.html#doconnectidentity","title":"<code>DoConnectIdentity</code>","text":"<p>DoConnectIdentity {   externalIdentity : EngineID;   backend : Backend;   capabilities : Capabilities }</p> <p>This action label corresponds to connecting to an existing identity.</p> <code>DoConnectIdentity</code> action effect <p>This action does the following:</p> Aspect Description State update If successful, a new entry is added to the <code>identities</code> map in the local state, copying the the external identity's information to the requesting identity, filtered by the requested capabilities. Messages to be sent A <code>ConnectIdentityResponse</code> message is sent to the requester, confirming the connection and providing references to relevant engines, or an error message if the connection fails (e.g., identity already exists, external identity not found, or requested capabilities not available). Engines to be spawned No new engines are spawned. The action reuses existing engine references from the external identity. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/identity_management_behaviour.html#dodeleteidentity","title":"<code>DoDeleteIdentity</code>","text":"<p>DoDeleteIdentity {   externalIdentity : EngineID;   backend : Backend }</p> <p>This action label corresponds to deleting an existing identity.</p> <code>DoDeleteIdentity</code> action effect <p>This action does the following:</p> Aspect Description State update The specified identity is removed from the <code>identities</code> map in the local state if it exists. Messages to be sent A <code>DeleteIdentityResponse</code> message is sent to the requester, confirming the deletion or providing an error message if the identity doesn't exist. Engines to be spawned No engines are spawned by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/identity_management_behaviour.html#matchable-arguments","title":"Matchable arguments","text":"<pre><code>type IdentityManagementMatchableArgument :=\n  | -- --8&lt;-- [start:MessageFrom]\n  MessageFrom (Option EngineID) (Option MailboxID)\n  -- --8&lt;-- [end:MessageFrom]\n;\n</code></pre>"},{"location":"arch/node/engines/identity_management_behaviour.html#messagefrom","title":"<code>MessageFrom</code>","text":"<pre><code>MessageFrom (Option EngineID) (Option MailboxID)\n</code></pre> <p>This matchable argument contains the address and mailbox ID of where the response message should be sent.</p>"},{"location":"arch/node/engines/identity_management_behaviour.html#precomputation-results","title":"Precomputation results","text":"<p>The Identity Management Engine does not require any non-trivial pre-computations.</p> <pre><code>syntax alias IdentityManagementPrecomputation := Unit;\n</code></pre>"},{"location":"arch/node/engines/identity_management_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code <p>Type alias for the guard.</p> <pre><code>-- --8&lt;-- [start:identity-management-guard]\nIdentityManagementGuard : Type :=\n  Guard\n    IdentityManagementLocalState\n    IdentityManagementMailboxState\n    IdentityManagementTimerHandle\n    IdentityManagementMatchableArgument\n    IdentityManagementActionLabel\n    IdentityManagementPrecomputation;\n-- --8&lt;-- [end:identity-management-guard]\n\n-- --8&lt;-- [start:identity-management-guard-output]\nIdentityManagementGuardOutput : Type :=\n  GuardOutput IdentityManagementMatchableArgument IdentityManagementActionLabel IdentityManagementPrecomputation;\n-- --8&lt;-- [end:identity-management-guard-output]\n</code></pre>"},{"location":"arch/node/engines/identity_management_behaviour.html#generateidentityguard","title":"<code>generateIdentityGuard</code>","text":"<pre><code>flowchart TD\n    C{GenerateIdentityRequest&lt;br&gt;received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoGenerateIdentity])</code></pre> generateIdentityGuard flowchart <pre><code>generateIdentityGuard\n  (t : TimestampedTrigger IdentityManagementTimerHandle)\n  (env : IdentityManagementEnvironment) : Option IdentityManagementGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgIdentityManagement (GenerateIdentityRequest x y z)) := do {\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n                  matchedArgs := [MessageFrom (some sender) none];\n                  actionLabel := DoGenerateIdentity x y z;\n                  precomputationTasks := unit\n                });\n      }\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/identity_management_behaviour.html#connectidentityguard","title":"<code>connectIdentityGuard</code>","text":"<pre><code>flowchart TD\n    C{ConnectIdentityRequest&lt;br&gt;received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoConnectIdentity])</code></pre> connectIdentityGuard flowchart <pre><code>connectIdentityGuard\n  (t : TimestampedTrigger IdentityManagementTimerHandle)\n  (env : IdentityManagementEnvironment) : Option IdentityManagementGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgIdentityManagement (ConnectIdentityRequest x y z)) := do {\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n                  matchedArgs := [MessageFrom (some sender) none];\n                  actionLabel := DoConnectIdentity x y z;\n                  precomputationTasks := unit\n                });\n        }\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/identity_management_behaviour.html#deleteidentityguard","title":"<code>deleteIdentityGuard</code>","text":"<pre><code>flowchart TD\n    C{DeleteIdentityRequest&lt;br&gt;received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoDeleteIdentity])</code></pre> deleteIdentityGuard flowchart <pre><code>deleteIdentityGuard\n  (t : TimestampedTrigger IdentityManagementTimerHandle)\n  (env : IdentityManagementEnvironment) : Option IdentityManagementGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgIdentityManagement (DeleteIdentityRequest x y)) := do {\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n                  matchedArgs := [MessageFrom (some sender) none];\n                  actionLabel := DoDeleteIdentity x y;\n                  precomputationTasks := unit\n                });\n        }\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/identity_management_behaviour.html#action-function","title":"Action function","text":"Auxiliary Juvix code <p>Type alias for the action function.</p> <pre><code>IdentityManagementActionInput : Type :=\n  ActionInput\n    IdentityManagementLocalState\n    IdentityManagementMailboxState\n    IdentityManagementTimerHandle\n    IdentityManagementMatchableArgument\n    IdentityManagementActionLabel\n    IdentityManagementPrecomputation;\n\nIdentityManagementActionEffect : Type :=\n  ActionEffect\n    IdentityManagementLocalState\n    IdentityManagementMailboxState\n    IdentityManagementTimerHandle\n    IdentityManagementMatchableArgument\n    IdentityManagementActionLabel\n    IdentityManagementPrecomputation;\n</code></pre> <pre><code>makeDecryptEnv\n  (env : IdentityManagementEnvironment)\n  (backend' : Backend)\n  (addr : EngineID)\n  : DecryptionEnvironment\n  := let\n      local := EngineEnv.localState env;\n  in mkEngineEnv@{\n      name := nameGen \"decryptor\" (EngineEnv.name env) addr;\n      localState := mkDecryptionLocalState@{\n        decryptor := IdentityManagementLocalState.genDecryptor local backend';\n        backend := backend';\n      };\n      -- The Decryption engine has one empty mailbox.\n      mailboxCluster := Map.fromList [(mkPair 0 (mkMailbox@{\n        messages := [];\n        mailboxState := none;\n      }))];\n      acquaintances := Set.fromList [nameStr addr];\n      timers := []\n    };\n</code></pre> <pre><code>makeCommitmentEnv\n  (env : IdentityManagementEnvironment)\n  (backend' : Backend)\n  (addr : EngineID)\n  : CommitmentEnvironment\n  := let\n      local := EngineEnv.localState env;\n    in mkEngineEnv@{\n      name := nameGen \"committer\" (EngineEnv.name env) addr;\n      localState := mkCommitmentLocalState@{\n        signer := IdentityManagementLocalState.genSigner local backend';\n        backend := backend';\n      };\n      -- The Commitment engine has one empty mailbox.\n      mailboxCluster := Map.fromList [(mkPair 0 (mkMailbox@{\n        messages := [];\n        mailboxState := none;\n      }))];\n      acquaintances := Set.fromList [nameStr addr];\n      timers := []\n    };\n</code></pre> <pre><code>hasCommitCapability (capabilities : Capabilities) : Bool :=\n  case capabilities of {\n    | CapabilityCommit := true\n    | CapabilityCommitAndDecrypt := true\n    | _ := false\n  };\n</code></pre> <pre><code>hasDecryptCapability (capabilities : Capabilities) : Bool :=\n  case capabilities of {\n    | CapabilityDecrypt := true\n    | CapabilityCommitAndDecrypt := true\n    | _ := false\n  };\n</code></pre> <pre><code>isSubsetCapabilities\n  (requested : Capabilities)\n  (available : Capabilities)\n  : Bool\n  := (not (hasCommitCapability requested) || hasCommitCapability available)\n  &amp;&amp; (not (hasDecryptCapability requested) || hasDecryptCapability available);\n</code></pre> <pre><code>updateIdentityAndSpawnEngines\n  (env : IdentityManagementEnvironment)\n  (backend' : Backend)\n  (whoAsked : EngineID)\n  (identityInfo : IdentityInfo)\n  (capabilities' : Capabilities)\n  : Pair IdentityInfo (List Env)\n  := case capabilities' of {\n    | CapabilityCommitAndDecrypt :=\n        let commitmentEnv := makeCommitmentEnv env backend' whoAsked;\n            commitmentEngineName := EngineEnv.name commitmentEnv;\n            decryptionEnv := makeDecryptEnv env backend' whoAsked;\n            decryptionEngineName := EngineEnv.name decryptionEnv;\n            spawnedEngines := [EnvCommitment commitmentEnv; EnvDecryption decryptionEnv];\n            updatedIdentityInfo1 := identityInfo@IdentityInfo{\n              commitmentEngine := some (mkPair none (some commitmentEngineName));\n              decryptionEngine := some (mkPair none (some decryptionEngineName))\n            };\n        in mkPair updatedIdentityInfo1 spawnedEngines\n    | CapabilityCommit :=\n        let commitmentEnv := makeCommitmentEnv env backend' whoAsked;\n            commitmentEngineName := EngineEnv.name commitmentEnv;\n            spawnedEngines := [EnvCommitment commitmentEnv];\n            updatedIdentityInfo1 := identityInfo@IdentityInfo{\n              commitmentEngine := some (mkPair none (some commitmentEngineName))\n            };\n        in mkPair updatedIdentityInfo1 spawnedEngines\n    | CapabilityDecrypt :=\n        let decryptionEnv := makeDecryptEnv env backend' whoAsked;\n            decryptionEngineName := EngineEnv.name decryptionEnv;\n            spawnedEngines := [EnvDecryption decryptionEnv];\n            updatedIdentityInfo1 := identityInfo@IdentityInfo{\n              decryptionEngine := some (mkPair none (some decryptionEngineName))\n            };\n        in mkPair updatedIdentityInfo1 spawnedEngines\n  };\n</code></pre> <pre><code>copyEnginesForCapabilities\n  (env : IdentityManagementEnvironment)\n  (whoAsked : EngineID)\n  (externalIdentityInfo : IdentityInfo)\n  (requestedCapabilities : Capabilities)\n  : IdentityInfo\n  :=\n  let newIdentityInfo := mkIdentityInfo@{\n        backend := IdentityInfo.backend externalIdentityInfo;\n        capabilities := requestedCapabilities;\n        commitmentEngine :=\n          case hasCommitCapability requestedCapabilities of {\n            | true := IdentityInfo.commitmentEngine externalIdentityInfo\n            | false := none\n          };\n        decryptionEngine :=\n          case hasDecryptCapability requestedCapabilities of {\n            | true := IdentityInfo.decryptionEngine externalIdentityInfo\n            | false := none\n          }\n      };\n  in newIdentityInfo;\n</code></pre> <pre><code>identityManagementAction\n  (input : IdentityManagementActionInput)\n  : IdentityManagementActionEffect\n  := let env := ActionInput.env input;\n      out := ActionInput.guardOutput input;\n      local := EngineEnv.localState env;\n      identities := IdentityManagementLocalState.identities local;\n  in\n  case GuardOutput.actionLabel out of {\n    | DoGenerateIdentity backend' params' capabilities' :=\n      case GuardOutput.matchedArgs out of {\n        | (MessageFrom (some whoAsked) _) :: _ :=\n            case Map.lookup whoAsked identities of {\n              | some _ :=\n                  -- Identity already exists, return error\n                  let responseMsg := GenerateIdentityResponse@{\n                    commitmentEngine := none;\n                    decryptionEngine := none;\n                    externalIdentity := whoAsked;\n                    err := some \"Identity already exists\"\n                  };\n                  in mkActionEffect@{\n                    newEnv := env;\n                    producedMessages := [mkEngineMsg@{\n                      sender := mkPair none (some (EngineEnv.name env));\n                      target := whoAsked;\n                      mailbox := some 0;\n                      msg := MsgIdentityManagement responseMsg\n                    }];\n                    timers := [];\n                    spawnedEngines := []\n                  }\n              | none :=\n                  -- Proceed to create identity\n                  let identityInfo := mkIdentityInfo@{\n                        backend := backend';\n                        capabilities := capabilities';\n                        commitmentEngine := none;\n                        decryptionEngine := none\n                      };\n                      -- Update identityInfo and spawnedEngines based on capabilities\n                      pair' := updateIdentityAndSpawnEngines env backend' whoAsked identityInfo capabilities';\n                      updatedIdentityInfo := fst pair';\n                      spawnedEnginesFinal := snd pair';\n                      updatedIdentities := Map.insert whoAsked updatedIdentityInfo identities;\n                      newLocalState := local@IdentityManagementLocalState{\n                        identities := updatedIdentities\n                      };\n                      newEnv' := env@EngineEnv{\n                        localState := newLocalState\n                      };\n                      responseMsg := GenerateIdentityResponse@{\n                        commitmentEngine := IdentityInfo.commitmentEngine updatedIdentityInfo;\n                        decryptionEngine := IdentityInfo.decryptionEngine updatedIdentityInfo;\n                        externalIdentity := whoAsked;\n                        err := none\n                      };\n                  in mkActionEffect@{\n                    newEnv := newEnv';\n                    producedMessages := [mkEngineMsg@{\n                      sender := mkPair none (some (EngineEnv.name env));\n                      target := whoAsked;\n                      mailbox := some 0;\n                      msg := MsgIdentityManagement responseMsg\n                    }];\n                    timers := [];\n                    spawnedEngines := spawnedEnginesFinal\n                  }\n            }\n        | _ := mkActionEffect@{newEnv := env; producedMessages := []; timers := []; spawnedEngines := []}\n      }\n\n    | DoConnectIdentity externalIdentity' backend' capabilities' :=\n      case GuardOutput.matchedArgs out of {\n        | (MessageFrom (some whoAsked) _) :: _ :=\n            -- Check if whoAsked already exists\n            case Map.lookup whoAsked identities of {\n              | some _ :=\n                  -- whoAsked already exists, return error\n                  let responseMsg := ConnectIdentityResponse@{\n                    commitmentEngine := none;\n                    decryptionEngine := none;\n                    err := some \"Identity already exists\"\n                  };\n                  in mkActionEffect@{\n                    newEnv := env;\n                    producedMessages := [mkEngineMsg@{\n                      sender := mkPair none (some (EngineEnv.name env));\n                      target := whoAsked;\n                      mailbox := some 0;\n                      msg := MsgIdentityManagement responseMsg\n                    }];\n                    timers := [];\n                    spawnedEngines := []\n                  }\n              | none :=\n                  -- whoAsked does not exist, proceed\n                  case Map.lookup externalIdentity' identities of {\n                    | none :=\n                        -- externalIdentity' does not exist, return error\n                        let responseMsg := ConnectIdentityResponse@{\n                          commitmentEngine := none;\n                          decryptionEngine := none;\n                          err := some \"External identity not found\"\n                        };\n                        in mkActionEffect@{\n                          newEnv := env;\n                          producedMessages := [mkEngineMsg@{\n                            sender := mkPair none (some (EngineEnv.name env));\n                            target := whoAsked;\n                            mailbox := some 0;\n                            msg := MsgIdentityManagement responseMsg\n                          }];\n                          timers := [];\n                          spawnedEngines := []\n                        }\n                    | some externalIdentityInfo :=\n                        -- Compare capabilities\n                        let externalCapabilities := IdentityInfo.capabilities externalIdentityInfo;\n                            requestedCapabilities := capabilities';\n                            isSubset := isSubsetCapabilities requestedCapabilities externalCapabilities;\n                        in\n                        case isSubset of {\n                          | true :=\n                              -- Capabilities are a subset, proceed\n                              -- Copy the engine information for the requested capabilities\n                              let newIdentityInfo := copyEnginesForCapabilities env whoAsked externalIdentityInfo requestedCapabilities;\n                                  updatedIdentities := Map.insert whoAsked newIdentityInfo identities;\n                                  newLocalState := local@IdentityManagementLocalState{\n                                    identities := updatedIdentities\n                                  };\n                                  newEnv' := env@EngineEnv{\n                                    localState := newLocalState\n                                  };\n                                  responseMsg := ConnectIdentityResponse@{\n                                    commitmentEngine := IdentityInfo.commitmentEngine newIdentityInfo;\n                                    decryptionEngine := IdentityInfo.decryptionEngine newIdentityInfo;\n                                    err := none\n                                  };\n                              in mkActionEffect@{\n                                newEnv := newEnv';\n                                producedMessages := [mkEngineMsg@{\n                                  sender := mkPair none (some (EngineEnv.name env));\n                                  target := whoAsked;\n                                  mailbox := some 0;\n                                  msg := MsgIdentityManagement responseMsg;\n                                }];\n                                timers := [];\n                                spawnedEngines := []\n                              }\n                          | false :=\n                              -- Capabilities not a subset, return error\n                              let responseMsg := ConnectIdentityResponse@{\n                                commitmentEngine := none;\n                                decryptionEngine := none;\n                                err := some \"Requested capabilities not available\"\n                              };\n                              in mkActionEffect@{\n                                newEnv := env;\n                                producedMessages := [mkEngineMsg@{\n                                  sender := mkPair none (some (EngineEnv.name env));\n                                  target := whoAsked;\n                                  mailbox := some 0;\n                                  msg := MsgIdentityManagement responseMsg\n                                }];\n                                timers := [];\n                                spawnedEngines := []\n                              }\n                        }\n                  }\n            }\n        | _ := mkActionEffect@{newEnv := env; producedMessages := []; timers := []; spawnedEngines := []}\n      }\n\n    | DoDeleteIdentity externalIdentity backend' :=\n      case GuardOutput.matchedArgs out of {\n        | (MessageFrom (some whoAsked) _) :: _ :=\n            -- Check if the identity exists\n            case Map.lookup externalIdentity identities of {\n              | none :=\n                  -- Identity does not exist, return error\n                  let responseMsg := DeleteIdentityResponse@{\n                    err := some \"Identity does not exist\"\n                  };\n                  in mkActionEffect@{\n                    newEnv := env;\n                    producedMessages := [mkEngineMsg@{\n                      sender := mkPair none (some (EngineEnv.name env));\n                      target := whoAsked;\n                      mailbox := some 0;\n                      msg := MsgIdentityManagement responseMsg\n                    }];\n                    timers := [];\n                    spawnedEngines := []\n                  }\n              | some _ :=\n                  -- Identity exists, proceed to delete\n                  let updatedIdentities := Map.delete externalIdentity identities;\n                      newLocalState := local@IdentityManagementLocalState{\n                        identities := updatedIdentities\n                      };\n                      newEnv' := env@EngineEnv{\n                        localState := newLocalState\n                      };\n                      responseMsg := DeleteIdentityResponse@{\n                        err := none\n                      };\n                  in mkActionEffect@{\n                    newEnv := newEnv';\n                    producedMessages := [mkEngineMsg@{\n                      sender := mkPair none (some (EngineEnv.name env));\n                      target := whoAsked;\n                      mailbox := some 0;\n                      msg := MsgIdentityManagement responseMsg\n                    }];\n                    timers := [];\n                    spawnedEngines := []\n                  }\n            }\n        | _ := mkActionEffect@{newEnv := env; producedMessages := []; timers := []; spawnedEngines := []}\n      }\n  };\n</code></pre>"},{"location":"arch/node/engines/identity_management_behaviour.html#conflict-solver","title":"Conflict solver","text":"<pre><code>identityManagementConflictSolver : Set IdentityManagementMatchableArgument -&gt; List (Set IdentityManagementMatchableArgument)\n  | _ := [];\n</code></pre>"},{"location":"arch/node/engines/identity_management_behaviour.html#identitymanagementbehaviour-type","title":"IdentityManagementBehaviour type","text":"<pre><code>IdentityManagementBehaviour : Type :=\n  EngineBehaviour\n    IdentityManagementLocalState\n    IdentityManagementMailboxState\n    IdentityManagementTimerHandle\n    IdentityManagementMatchableArgument\n    IdentityManagementActionLabel\n    IdentityManagementPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/identity_management_behaviour.html#identitymanagementbehaviour-instance","title":"IdentityManagementBehaviour instance","text":"<pre><code>identityManagementBehaviour : IdentityManagementBehaviour :=\n  mkEngineBehaviour@{\n    guards := [generateIdentityGuard; connectIdentityGuard; deleteIdentityGuard];\n    action := identityManagementAction;\n    conflictSolver := identityManagementConflictSolver;\n  }\n</code></pre>"},{"location":"arch/node/engines/identity_management_environment.html","title":"Identity Management Engine Environment","text":"<p>Failure</p> <p>[7 of 9] Compiling arch.node.engines.identity_management_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/identity_management_environment.juvix.md:84:7-11: error: Unexpected argument node</p> <p>icon: octicons/container-24 search:   exclude: false categories: - engine-behaviour tags: - identity_management - engine-environment</p> Juvix imports <pre><code>module arch.node.engines.identity_management_environment;\nimport prelude open;\nimport arch.node.types.messages open;\nimport arch.node.types.crypto open;\nimport arch.node.types.identities open;\nimport arch.node.types.engine_environment open;\nimport arch.node.engines.identity_management_messages open;\n\nimport arch.system.identity.identity open hiding {ExternalIdentity};\n</code></pre>"},{"location":"arch/node/engines/identity_management_environment.html#identity-management-environment","title":"Identity Management Environment","text":""},{"location":"arch/node/engines/identity_management_environment.html#overview","title":"Overview","text":"<p>The Identity Management Engine's environment maintains the state necessary for managing identities, including information about connected identities, backends, and capabilities.</p>"},{"location":"arch/node/engines/identity_management_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The Identity Management Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p> <pre><code>syntax alias IdentityManagementMailboxState := Unit;\n</code></pre>"},{"location":"arch/node/engines/identity_management_environment.html#local-state","title":"Local state","text":"<p>The local state of the Identity Management Engine includes information about the identities it manages.</p> <pre><code>type IdentityInfo := mkIdentityInfo@{\n  backend : Backend;\n  capabilities : Capabilities;\n  commitmentEngine : Option EngineID;\n  decryptionEngine : Option EngineID;\n};\n\ntype IdentityManagementLocalState := mkIdentityManagementLocalState {\n  identities : Map EngineID IdentityInfo;\n  genDecryptor : Backend -&gt; Decryptor Backend Plaintext Ciphertext;\n  genSigner : Backend -&gt; Signer Backend Signable Commitment\n};\n</code></pre>"},{"location":"arch/node/engines/identity_management_environment.html#timer-handle","title":"Timer Handle","text":"<pre><code>syntax alias IdentityManagementTimerHandle := Unit;\n</code></pre> <p>The Identity Management Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>"},{"location":"arch/node/engines/identity_management_environment.html#environment-summary","title":"Environment summary","text":"<pre><code>IdentityManagementEnvironment : Type := EngineEnv\n  IdentityManagementLocalState\n  IdentityManagementMailboxState\n  IdentityManagementTimerHandle;\n</code></pre>"},{"location":"arch/node/engines/identity_management_environment.html#example-of-an-identity-management-environment","title":"Example of an <code>Identity Management</code> environment","text":"<pre><code>module identity_management_environment_example;\n\nidentityManagementEnvironmentExample : IdentityManagementEnvironment :=\n    mkEngineEnv@{\n      node := Curve25519PubKey \"0xabcd1234\";\n      name := \"identity_management\";\n      localState := mkIdentityManagementLocalState@{\n        identities := Map.empty;\n        genDecryptor := \\{_ := mkDecryptor@{\n          decrypt := \\{_ x := some x};\n        }};\n        genSigner := \\{_ := mkSigner@{\n          sign := \\{_ x := Ed25519Signature \"0xabcd1234\"};\n        }};\n      };\n      mailboxCluster := Map.empty;\n      acquaintances := Set.empty;\n      timers := []\n    }\n  ;\nend;\n</code></pre>"},{"location":"arch/node/engines/identity_management_messages.html","title":"Identity Management Engine Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.identity_management_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["identity_management","engine-messages"]},{"location":"arch/node/engines/identity_management_messages.html#identity-management-messages","title":"<code>Identity Management</code> Messages","text":"","tags":["identity_management","engine-messages"]},{"location":"arch/node/engines/identity_management_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type IdentityManagementMsg :=  | GenerateIdentityRequest {      backend : Backend;      params : IDParams;      capabilities : Capabilities    }  | GenerateIdentityResponse {      commitmentEngine : Option EngineID;      decryptionEngine : Option EngineID;      externalIdentity : EngineID;      err : Option String    }  | ConnectIdentityRequest {      externalIdentity : EngineID;      backend : Backend;      capabilities : Capabilities    }  | ConnectIdentityResponse {      commitmentEngine : Option EngineID;      decryptionEngine : Option EngineID;      err : Option String    }  | DeleteIdentityRequest {      externalIdentity : EngineID;      backend : Backend    }  | DeleteIdentityResponse {err : Option String};</pre></code></pre>","tags":["identity_management","engine-messages"]},{"location":"arch/node/engines/identity_management_messages.html#generateidentityrequest-message","title":"<code>GenerateIdentityRequest</code> message","text":"<p>GenerateIdentityRequest</p> <pre><code>GenerateIdentityRequest {\n  backend : Backend;\n  params : IDParams;\n  capabilities : Capabilities\n}\n</code></pre> <p>A <code>GenerateIdentityRequest</code> instructs the Identity Management Engine to generate a new identity using the specified backend, parameters, and capabilities.</p> <ul> <li><code>backend</code>: The backend to use for identity generation.</li> <li><code>params</code>: Parameters to pass to the backend (e.g., cryptosystem, security level).</li> <li><code>capabilities</code>: Capabilities to request (e.g., commitment, decryption, or both).</li> </ul>","tags":["identity_management","engine-messages"]},{"location":"arch/node/engines/identity_management_messages.html#generateidentityresponse-message","title":"<code>GenerateIdentityResponse</code> message","text":"<p>GenerateIdentityResponse</p> <pre><code>GenerateIdentityResponse {\n  commitmentEngine : Option EngineID;\n  decryptionEngine : Option EngineID;\n  externalIdentity : EngineID;\n  err : Option String\n}\n</code></pre> <p>A <code>GenerateIdentityResponse</code> provides the handles to the decryption and commitment engine instances for the newly generated identity, or an error if a failure occurred.</p> <ul> <li><code>commitmentEngine</code>: Reference to the newly instantiated commitment engine.</li> <li><code>decryptionEngine</code>: Reference to the newly instantiated decryption engine.</li> <li><code>externalIdentity</code>: The external identity of the newly created identity.</li> <li><code>err</code>: An error message if identity generation failed.</li> </ul>","tags":["identity_management","engine-messages"]},{"location":"arch/node/engines/identity_management_messages.html#connectidentityrequest-message","title":"<code>ConnectIdentityRequest</code> message","text":"<p>ConnectIdentityRequest</p> <pre><code>ConnectIdentityRequest {\n  externalIdentity : EngineID;\n  backend : Backend;\n  capabilities : Capabilities\n}\n</code></pre> <p>A <code>ConnectIdentityRequest</code> instructs the Identity Management Engine to connect to an existing identity using the specified backend.</p> <ul> <li><code>externalIdentity</code>: The external identity to connect.</li> <li><code>backend</code>: The backend to use for the connection.</li> <li><code>capabilities</code>: Capabilities to request (e.g., commitment, decryption, or both).</li> </ul>","tags":["identity_management","engine-messages"]},{"location":"arch/node/engines/identity_management_messages.html#connectidentityresponse-message","title":"<code>ConnectIdentityResponse</code> message","text":"<p>ConnectIdentityResponse</p> <pre><code>ConnectIdentityResponse {\n  commitmentEngine : Option EngineID;\n  decryptionEngine : Option EngineID;\n  err : Option String\n}\n</code></pre> <p>A <code>ConnectIdentityResponse</code> provides the handles to the decryption and commitment engine instances for the connected identity, or an error if a failure occurred.</p> <ul> <li><code>commitmentEngine</code>: Reference to the newly instantiated commitment engine.</li> <li><code>decryptionEngine</code>: Reference to the newly instantiated decryption engine.</li> <li><code>err</code>: An error message if identity connection failed.</li> </ul>","tags":["identity_management","engine-messages"]},{"location":"arch/node/engines/identity_management_messages.html#deleteidentityrequest-message","title":"<code>DeleteIdentityRequest</code> message","text":"<p>DeleteIdentityRequest</p> <pre><code>DeleteIdentityRequest {\n  externalIdentity : EngineID;\n  backend : Backend\n}\n</code></pre> <p>A <code>DeleteIdentityRequest</code> instructs the Identity Management Engine to delete an existing identity using the specified backend.</p> <ul> <li><code>externalIdentity</code>: The external identity to delete.</li> <li><code>backend</code>: The backend to use for deletion.</li> </ul>","tags":["identity_management","engine-messages"]},{"location":"arch/node/engines/identity_management_messages.html#deleteidentityresponse-message","title":"<code>DeleteIdentityResponse</code> message","text":"<p>DeleteIdentityResponse</p> <pre><code>DeleteIdentityResponse {\n  err : Option String\n}\n</code></pre> <p>A <code>DeleteIdentityResponse</code> provides the response from an attempt to delete an identity.</p> <ul> <li><code>err</code>: An error message if identity deletion failed.</li> </ul>","tags":["identity_management","engine-messages"]},{"location":"arch/node/engines/identity_management_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["identity_management","engine-messages"]},{"location":"arch/node/engines/identity_management_messages.html#generating-an-identity","title":"Generating an Identity","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant IdentityManagementEngine\n    participant CommitmentEngine\n    participant DecryptionEngine\n\n    Client-&gt;&gt;IdentityManagementEngine: GenerateIdentityRequest\n    Note over IdentityManagementEngine: Create new identity\n    IdentityManagementEngine-&gt;&gt;CommitmentEngine: Spawn (if requested)\n    IdentityManagementEngine-&gt;&gt;DecryptionEngine: Spawn (if requested)\n    IdentityManagementEngine-&gt;&gt;Client: GenerateIdentityResponse</code></pre>  Generating an identity","tags":["identity_management","engine-messages"]},{"location":"arch/node/engines/identity_management_messages.html#connecting-to-an-existing-identity","title":"Connecting to an Existing Identity","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant IdentityManagementEngine\n\n    Client-&gt;&gt;IdentityManagementEngine: ConnectIdentityRequest\n    Note over IdentityManagementEngine: Check external identity\n    Note over IdentityManagementEngine: Verify capabilities\n    Note over IdentityManagementEngine: Copy engine references\n    IdentityManagementEngine-&gt;&gt;Client: ConnectIdentityResponse</code></pre>  Connecting to an existing identity","tags":["identity_management","engine-messages"]},{"location":"arch/node/engines/identity_management_messages.html#deleting-an-identity","title":"Deleting an Identity","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant IdentityManagementEngine\n\n    Client-&gt;&gt;IdentityManagementEngine: DeleteIdentityRequest\n    Note over IdentityManagementEngine: Check if identity exists\n    Note over IdentityManagementEngine: Delete identity if exists\n    IdentityManagementEngine-&gt;&gt;Client: DeleteIdentityResponse</code></pre>  Deleting an identity","tags":["identity_management","engine-messages"]},{"location":"arch/node/engines/identity_management_messages.html#engine-components","title":"Engine Components","text":"<ul> <li><code>Identity Management</code> Engine Environment</li> <li><code>Identity Management</code> Engine Dynamics</li> </ul>","tags":["identity_management","engine-messages"]},{"location":"arch/node/engines/identity_management_messages.html#useful-links","title":"Useful links","text":"","tags":["identity_management","engine-messages"]},{"location":"arch/node/engines/interaction.html","title":"Interaction","text":"<ul> <li>Inputs     User instructions (trusted) incl. intents (abstract?), queries, sub/unsub to subsets of state changes</li> <li>Outputs     Query results, intent execution results, relevant state changes,</li> <li>Preferences</li> <li>Accounting</li> </ul> <p>~</p> <p>interaction engine is responsible for interfacing with physical local system local randomness, local input even local storage? only part that does I/O</p> <ul> <li>randomness     - should come from interaction engine only     - whole system should be deterministic otherwise     - time should also come from interaction engine</li> </ul>","boost":2},{"location":"arch/node/engines/mempool.html","title":"Mempool","text":"","boost":2},{"location":"arch/node/engines/mempool.html#summary","title":"Summary","text":"<p>Validators run the mempool protocol. They receive transactions from clients, store them, and make them available for the execution engine to read. The mempool protocol, which is based on Narwhal also produces a DAG of headers, which reference batches of transactions (via hash), and prove that those transactions are available for the execution engine. These headers are ultimately what the consensus decides on, in order to establish a total order of transactions.</p>","boost":2},{"location":"arch/node/engines/mempool.html#heterogeneous-narwhal","title":"Heterogeneous Narwhal","text":"<p>The core idea here is that we run an instance of Narwhal for each learner. For chimera chains, an \"atomic batch\" of transactions can be stored in any involved learner's Narwhal.</p> <p>We also make 2 key changes:</p> <ul> <li>The availability proofs must show that any transaction is sufficiently available for all learners. This should not be a problem, since in Heterogeneous Paxos, for any connected learner graph, any learner's quorum is a weak quorum for all learners.</li> <li>Whenever a validator's Narwhal primary produces a batch, it must link in that batch not only to a quorum of that learner's block headers from the prior round, but also to the most recent batch this validator has produced for any learner. This ensures that, within a finite number of rounds (3, I think), any transaction batch referenced by a weak quorum of batches in its own Narwhal will be (transitively) referenced by all batches in all Narwhals for entangled learners.</li> </ul>","boost":2},{"location":"arch/node/engines/mempool.html#overview","title":"Overview","text":"<p>Like Narwhal, Heterogeneous Narwhal Validators have multiple concurrent processes (which can even run on separate machines). Each validator has one primary process and many worker processes. When a client submits a transaction, they first send it to a worker process.</p>","boost":2},{"location":"arch/node/engines/mempool.html#workers","title":"Workers","text":"<p>Worker processes ensure transactions are available. Transactions are batched, and erasure-coded (possibly simply replicated) across a weak quorum for every learner of workers, and only signed hashes of those batches are sent to primaries. This separates the high-bandwidth work of replicating transactions from the ordering work of the primaries.</p>","boost":2},{"location":"arch/node/engines/mempool.html#primaries","title":"Primaries","text":"<p>Primary processes establish a partial order of transaction batches (and by extension transactions), in the form of a structured DAG. The DAG proceeds in rounds for each learner: each primary produces at most one block for each (correct) learner in each round. That block references blocks from prior rounds.</p> <p>Primaries assemble headers (both their own and for other primaries) from collections of worker hashes, and references to prior blocks. They then sign votes, stating that they will not vote for conflicting headers, and (optionally) that their workers have indeed stored the referenced transactions. Primaries collect votes concerning their own headers, producing blocks: aggregated signatures showing a header is unique.</p> <p>More formally, we present the Heterogeneous Narwhal protocol as the composition of two crucial pieces: the Heterogeneous Narwhal Availability protocol, and the Heterogeneous Narwhal Integrity protocol.</p>","boost":2},{"location":"arch/node/engines/mempool.html#vocabulary","title":"Vocabulary","text":"<ul> <li>Learners dictate trust decisions: just like in Heterogeneous Paxos, we use a Learner Graph. In diagrams, we usually represent learners with colors (red and blue).</li> <li> Quorum: a set of validators sufficient for a Learner to make blocks. Each Learner has a set of quorums.</li> <li>Intact Learner: any 2 quorums for an Intact Learner have a correct validator in their intersection. Most of our guarantees apply only to Intact Learners.</li> <li>Entangled Learners: a pair of learners A and B are entangled if, for any quorum Qa of A, and any quorum Qb of B, the intersection of Qa and Qb contains a correct validator. Some guarantees apply pairwise to Entangled Learners: they are, in a sense, guaranteed to agree on stuff.</li> <li> Weak Quorum: a set of validators that intersects every quorum. Weak Quorums are Learner-specific, so when we say weak quorum for every learner we mean a set of validators that intersects every quorum of every Learner.</li> <li> Transaction: data from clients to be ordered. We do not specify how it's formatted.</li> <li>Batch: a set of transactions collected by a Worker.</li> <li> Erasure Share: data transmitted to a weak quorum of listening workers, such that any Quorum of validators can re-construct the original data (Transaction or Batch of Transactions).</li> <li> Worker Hash: a signed digest of a batch of transactions collected by (and signed) by a worker.</li> <li> Headers have:<ul> <li>an associated Primary (who \"created\" this header)</li> <li>a set of Worker Hashes (from workers on the same validator as this primary)</li> <li>an Availability Certificate for the previous Header issued by this primary</li> <li>at most one Signed Quorum for each Learner</li> </ul> </li> <li> Availability Certificate: an aggregation of signatures from a Weak Quorum attesting that everything referenced by a particular Header is available. Must include a signature from the Header's primary.</li> <li> Block: an aggregation of Header signatures from a quorum of a specific learner attesting that they will not attest to any conflicting header. Also includes an Availability Certificate. Should include all signatures a primary has gathered for that header at the time (signatures in the Availability Certificate count).</li> <li> Signed Quorum: a quorum of blocks with the same learner and round, signed by a primary. These are referenced in headers.</li> </ul>","boost":2},{"location":"arch/node/engines/mempool.html#heterogeneous-narwhal-availability-protocol","title":"Heterogeneous Narwhal Availability Protocol","text":"<p> (note the giant curly-brace represents a Weak Quorum of validators)</p>","boost":2},{"location":"arch/node/engines/mempool.html#batches-and-worker-hashes","title":"Batches and Worker Hashes","text":"<p>When a worker has collected a batch of transactions, it transmits erasure shares (possibly full copies) of those transactions to other workers on a weak quorum for every learner of validators. What's important about this erasure coding is that any Quorum of any Learner can reconstruct every transaction. Furthermore, workers must be able to verify that they are in fact storing the correct Erasure Share of the data referenced in the Worker Hash. One way to accomplish this is to transmit a complete copy of all the data to an entire Weak Quorum for every Learner.</p> <p>In fact, rather than wait until a batch is complete to start transmitting, workers can stream erasure shares as they receive transactions. When it has completed a batch, a worker also transmits a signed Worker Hash to those other workers, and its own primary. We do not specify when workers should complete batches, but perhaps it should be after some timeout, or perhaps primaries should signal workers to complete batches. Batches should not be empty.</p>","boost":2},{"location":"arch/node/engines/mempool.html#signed-quorums-and-headers","title":"Signed Quorums and Headers","text":"<p>Primaries ultimately produce blocks for each round, for each Learner, and send those blocks to other Primaries. When a primary for validator <code>V</code> has received blocks for learner <code>L</code> and round <code>R</code> from an entire quorum of validators for learner <code>L</code>, it signs that collection, producing a Signed Quorum object, which identifies the validator <code>V</code>, the learner <code>L</code>, and the round <code>R</code>. The Signed Quorum is then broadcast (or erasure coded) to primaries on a weak quorum for every learner of validators. Much like batches, it is important that any Quorum for any Learner can re-construct the entire Signed Quorum.</p> <p>Periodically, each primary <code>P</code> produces Headers. Each Header contains:</p> <ul> <li>a set of signed Worker Hashes, all signed by <code>P</code>'s validator</li> <li>a hash referencing at most one Signed Quorum per Learner, all signed  by <code>P</code></li> <li>an Availability Certificate (we'll get to how those are made shortly) for the previous Header <code>P</code> issued. Headers should be relatively small. Each primary then sends the header to all the other primaries.</li> </ul> <p>When a Primary receives a Header, it can produce an Availability Vote (which is a digital signature) iff - the primary has stored its share of all Signed Quorums referenced, - the primary has received messages from its workers indicating that they have stored their shares of all the Batches referenced The Availability Votes are then transmitted to the Header's Primary.</p> <p>When a primary receives Availability Votes for a Header from a weak quorum for every learner, it can aggregate those signatures to produce an Availability Certificate, which proves that the Header (and its contents) are available to any Quorum. Availability Certificates should be small. Note that, if primaries broadcast Availability Certificates as soon as they produce them, other primaries may have all the components necessary to \"receive\" a Header even before the Header's Primary actually sends it. Specifically, they may have:</p> <ul> <li>Signed Batch Headers from their listening Workers</li> <li>Signed Quorum shares received earlier from the Primary</li> <li>Availability Certificate received earlier from the Primary</li> </ul>","boost":2},{"location":"arch/node/engines/mempool.html#heterogeneous-narwhal-integrity-protocol","title":"Heterogeneous Narwhal Integrity Protocol","text":"<p>So far, only Signed Quorums have been Learner-specific: everything else requires a weak quorum for every learner. However, in the Integrity Protocol, almost everything is Learner-specific. Furthermore, Workers are not involved in the Integrity Protocol: only Primaries.  Each Header <code>H</code> features a predecessor <code>H'</code>: the availability certificate in <code>H</code> references the header <code>H'</code>. When a Primary receives a Header <code>H</code>, it can produce an Integrity Vote iff it has not produced an Integrity vote for any other Header with the same predecessor as <code>H</code> In essence, this means that each correct Primary signs, for each other (even incorrect) Primary, a unique chain of Headers. This will ensure that no primary can produce conflicting blocks for entangled Learners. Integrity Votes are transmitted back to the Primary associated with the Header. In practice, a Integrity and Availability votes may be combined for Primaries who can cast both.</p> <p>For each Header it produces, a Primary can calculate its Learner Vector: this represents, for each Learner, the highest round number of any quorum referenced in this Header or its ancestors (its predecessor, of its predecessor's predecessor, etc.). If, for some Learner <code>L</code>, a header <code>H</code> has a greater round number <code>R</code> in its Learner Vector for <code>L</code> than did <code>H</code>'s predecessor, then the Primary can produce a Block for learner <code>R</code> and round <code>L</code>. Intuitively, a Primary produces a block whenever it gets a quorum for a Learner in a latest round.</p> <p>A block for learner <code>L</code> includes an Availability Certificate, as well as an aggregated signature formed from the Integrity Votes of (at least) a quorum (for learner <code>L</code>) for the same Header. Blocks are transmitted to all other Primaries, who use them to form Signed Quorums.</p> <p>If a Primary uses the same Header to make blocks for multiple Learners, each block it produces must use a superset of signatures as the previous. This ensures that if the Primary produces a block for Learner A and then a block for learner B, the Block for learner B effectively includes the block for learner A. We can use this when we later establish a total ordering: any reference to the learner B block also effectively references the learner A block.</p> <p>Here is an example timeline of a Primary producing headers, availability certificates, and blocks. Blocks are colour coded by learner and include a round number. Headers display Learner Vectors. </p>","boost":2},{"location":"arch/node/engines/mempool.html#dag-properties","title":"DAG Properties","text":"<p>Independently, the blocks for each Learner form a DAG with the same properties as in the original Narwhal:  (In these diagrams, blocks reference prior blocks from the same Primary; I just didn't draw those arrows)</p> <p>Note that blocks reference a quorum of blocks from the previous round. This does not require that the same primary produced a block for the previous round. In round 5, Primary 3 can produce a block if it has received a quorum of round 4 blocks from other Primaries.</p> <p>Of course, primaries do not necessarily produce blocks for the same round at the same literal time. Here we see primaries producing blocks for round 3 for red learner at different times, depending on when they finish batches, or receive a round 2 quorum, or enough votes:  In Heterogeneous Narwhal, these two DAGs are being created simultaneously (using the same sequence of Headers from each Primary, and many of the same Votes):  Note that round numbers for different learners do not have to be close to each other. Red round 3 blocks are produced after blue round 5 blocks, and that's ok.</p> <p>Furthermore, rounds of different learners are not totally ordered. Red round 3 cannot really be said to happen before, or after, blue round 4.</p>","boost":2},{"location":"arch/node/engines/mempool.html#fair-broadcast","title":"Fair Broadcast","text":"<p>In Homogeneous Narwhal, any block which is referenced by a weak quorum in the following round will be (transitively) referenced by all blocks thereafter. Heterogeneous Narwhal has analogous guarantees:</p>","boost":2},{"location":"arch/node/engines/mempool.html#any-block-for-learner-a-referenced-by-a-weak-quorum-for-learner-a-will-after-3-rounds-be-transitively-referenced-by-all-future-blocks-of-learners-entangled-with-a","title":"Any block for learner <code>A</code>  referenced by a weak quorum for learner <code>A</code> will, after 3 rounds, be (transitively) referenced by all future blocks of learners entangled with <code>A</code>.","text":"<p>Specifically, such a block <code>B</code> in round <code>R</code>, will be (transitively) referenced by all <code>A</code>-blocks in round <code>R+2</code>.</p> <p>Consider the first round for learner <code>B</code> using at least a quorum of headers either used in <code>A</code> round <code>R+2</code> or after their primaries' headers for <code>A</code> round <code>R+2</code>. Given that Learner <code>B</code> is entangled with <code>A</code>, any <code>B</code>-quorum for this round will be a descendant of an <code>A</code>-block from round <code>R+2</code>, and therefore, of <code>B</code>.</p>","boost":2},{"location":"arch/node/engines/mempool.html#consensus","title":"Consensus","text":"<p>In order to establish a total order of transactions, we use Heterogeneous Paxos to decide on an ever-growing path through the DAG (for each Learner). Heterogeneous Paxos guarantees that, if two Learners are entangled, they will decide on the same path. In order to guarantee liveness (and fairness) for each Learner's transactions, we require that:</p> <p>For any accurate learner <code>L</code>, if one of <code>L</code>'s quorums remains live, and an entire quorum of <code>L</code> issues blocks for round <code>R</code>, consensus will eventually append one of <code>L</code>'s round-<code>R</code> blocks, or one of its descendants, to <code>L</code>'s path.</p> <p>Crucially, if two learners are not entangled, and their blocks never reference each other, consensus should not forever choose blocks exclusively from one learner. This does require a minimal amount of fairness from consensus itself: as long as blocks for learner <code>L</code> keep getting proposed (indefinitely), consensus should eventually append one of them to the path.</p>","boost":2},{"location":"arch/node/engines/mempool.html#choosing-a-total-order","title":"Choosing a total order","text":"<p>Given a consensus-defined path, we can impose a total order on all transactions which are ancestors of any block in the path. We require only that, given some block <code>B</code> in the path, all transactions which are ancestors of <code>B</code> are ordered before all transactions which are not ancestors of <code>B</code>. Among the transactiosn which are ancestors of <code>B</code> but not of its predecessor in the path, total order can be imposed by some arbitrary deterministic function.</p>","boost":2},{"location":"arch/node/engines/naming.html","title":"Naming Engine","text":"<p>Failure</p> <p>[11 of 16] Compiling arch.node.engines.naming_behaviour [14 of 16] Compiling arch.node.engines.naming_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/naming_environment.juvix.md:73:7-11: error: Unexpected argument node</p> <p>icon: octicons/project-template-24 search:   exclude: false tags: - naming - engines</p> Juvix imports <pre><code>module arch.node.engines.naming;\n\nimport prelude open;\nimport arch.node.types.engine open;\n\nimport arch.node.engines.naming_messages open public;\nimport arch.node.engines.naming_environment open public;\nimport arch.node.engines.naming_behaviour open public;\nopen naming_environment_example;\n</code></pre>"},{"location":"arch/node/engines/naming.html#naming-engine","title":"Naming Engine","text":"<p>The Naming Engine is responsible for tracking naming information as described in Identity Names. It supports name resolution, submitting name evidence, and querying name evidence.</p>"},{"location":"arch/node/engines/naming.html#purpose","title":"Purpose","text":"<p>The Naming Engine tracks which <code>IdentityName</code>s correspond with which <code>ExternalIdentity</code>s using <code>IdentityNameEvidence</code>. It provides functionality for resolving names, submitting name evidence, and querying name evidence.</p>"},{"location":"arch/node/engines/naming.html#components","title":"Components","text":"<ul> <li>Naming Messages</li> <li>Naming Environment</li> <li>Naming Behaviour</li> </ul>"},{"location":"arch/node/engines/naming.html#useful-links","title":"Useful links","text":"<p>???</p>"},{"location":"arch/node/engines/naming.html#type","title":"Type","text":"<pre><code>NamingEngine : Type := Engine\n  NamingLocalState\n  NamingMailboxState\n  NamingTimerHandle\n  NamingMatchableArgument\n  NamingActionLabel\n  NamingPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/naming.html#example-of-a-naming-engine","title":"Example of a naming engine","text":"<pre><code>exampleNamingEngine : NamingEngine :=\n  mkEngine@{\n    behaviour := namingBehaviour;\n    initEnv := namingEnvironmentExample;\n  };\n</code></pre> <p>where <code>namingEnvironmentExample</code> is defined as follows:</p> <pre><code><pre>namingEnvironmentExample : NamingEnvironment :=  mkEngineEnvironment@{    name := \"naming\";    localState :=      mkNamingLocalState@{        evidenceStore := Set.empty;        verifyEvidence := \\{_ := true};      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>"},{"location":"arch/node/engines/naming_behaviour.html","title":"Naming Engine Behaviour","text":"<p>Failure</p> <p>[10 of 14] Compiling arch.node.engines.naming_behaviour [13 of 14] Compiling arch.node.engines.naming_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/naming_environment.juvix.md:73:7-11: error: Unexpected argument node</p> <p>icon: octicons/gear-16 search:   exclude: false categories: - engine-behaviour - juvix-module tags: - naming - engine-behavior</p> Juvix imports <pre><code>module arch.node.engines.naming_behaviour;\n\nimport prelude open;\nimport arch.node.types.messages open;\nimport arch.node.types.engine_behaviour open;\nimport arch.node.types.engine_environment open;\nimport arch.node.types.identities open;\nimport arch.node.engines.naming_messages open;\nimport arch.node.engines.naming_environment open;\nimport arch.node.types.anoma_message open;\n</code></pre>"},{"location":"arch/node/engines/naming_behaviour.html#naming-dynamics","title":"<code>Naming</code> Dynamics","text":""},{"location":"arch/node/engines/naming_behaviour.html#overview","title":"Overview","text":"<p>The behavior of the Naming Engine define how it processes incoming messages and updates its state accordingly.</p>"},{"location":"arch/node/engines/naming_behaviour.html#action-labels","title":"Action labels","text":"<pre><code>type NamingActionLabel :=\n  | -- --8&lt;-- [start:DoResolveName]\n    DoResolveName {\n      identityName : IdentityName\n    }\n    -- --8&lt;-- [end:DoResolveName]\n  | -- --8&lt;-- [start:DoSubmitNameEvidence]\n    DoSubmitNameEvidence {\n      evidence : IdentityNameEvidence\n    }\n    -- --8&lt;-- [end:DoSubmitNameEvidence]\n  | -- --8&lt;-- [start:DoQueryNameEvidence]\n    DoQueryNameEvidence {\n      externalIdentity : ExternalIdentity\n    }\n    -- --8&lt;-- [end:DoQueryNameEvidence]\n;\n</code></pre>"},{"location":"arch/node/engines/naming_behaviour.html#doresolvename","title":"<code>DoResolveName</code>","text":"<p>DoResolveName {   identityName : IdentityName }</p> <p>This action label corresponds to resolving a name to associated external identities.</p> <code>DoResolveName</code> action effect <p>This action does the following:</p> Aspect Description State update No change to the local state. Messages to be sent A <code>ResolveNameResponse</code> message is sent to the requester, containing matching external identities. Engines to be spawned No engines are spawned by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/naming_behaviour.html#dosubmitnameevidence","title":"<code>DoSubmitNameEvidence</code>","text":"<p>DoSubmitNameEvidence {   evidence : IdentityNameEvidence }</p> <p>This action label corresponds to submitting new name evidence.</p> DoSubmitNameEvidence action effect <p>This action does the following:</p> Aspect Description State update If the evidence doesn't already exist and is valid, it's added to the <code>evidenceStore</code> in the local state. Messages to be sent A <code>SubmitNameEvidenceResponse</code> message is sent to the requester, confirming the submission or indicating an error if the evidence already exists. Engines to be spawned No engines are spawned by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/naming_behaviour.html#doquerynameevidence","title":"<code>DoQueryNameEvidence</code>","text":"<p>DoQueryNameEvidence {   externalIdentity : ExternalIdentity }</p> <p>This action label corresponds to querying name evidence for a specific external identity.</p> DoQueryNameEvidence action effect <p>This action does the following:</p> Aspect Description State update No change to the local state. Messages to be sent A <code>QueryNameEvidenceResponse</code> message is sent to the requester, containing relevant evidence for the specified external identity. Engines to be spawned No engines are spawned by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/naming_behaviour.html#matchable-arguments","title":"Matchable arguments","text":"<pre><code>type NamingMatchableArgument :=\n  | -- --8&lt;-- [start:ReplyTo]\n  ReplyTo (Option EngineID) (Option MailboxID)\n  -- --8&lt;-- [end:ReplyTo]\n;\n</code></pre>"},{"location":"arch/node/engines/naming_behaviour.html#replyto","title":"<code>ReplyTo</code>","text":"<pre><code>ReplyTo (Option EngineID) (Option MailboxID)\n</code></pre> <p>This matchable argument contains the address and mailbox ID of where the response message should be sent.</p>"},{"location":"arch/node/engines/naming_behaviour.html#precomputation-results","title":"Precomputation results","text":"<p>The Naming Engine does not require any non-trivial pre-computations.</p> <pre><code>syntax alias NamingPrecomputation := Unit;\n</code></pre>"},{"location":"arch/node/engines/naming_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code <p>Type alias for the guard.</p> <pre><code>-- --8&lt;-- [start:ticker-guard]\nNamingGuard : Type :=\n  Guard\n    NamingLocalState\n    NamingMailboxState\n    NamingTimerHandle\n    NamingMatchableArgument\n    NamingActionLabel\n    NamingPrecomputation;\n-- --8&lt;-- [end:ticker-guard]\n\n-- --8&lt;-- [start:ticker-guard-output]\nNamingGuardOutput : Type :=\n  GuardOutput NamingMatchableArgument NamingActionLabel NamingPrecomputation;\n-- --8&lt;-- [end:ticker-guard-output]\n</code></pre>"},{"location":"arch/node/engines/naming_behaviour.html#resolvenameguard","title":"<code>resolveNameGuard</code>","text":"<pre><code>flowchart TD\n    C{ResolveNameRequest&lt;br&gt;received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoResolveName])</code></pre> resolveNameGuard flowchart <pre><code>resolveNameGuard\n  (t : TimestampedTrigger NamingTimerHandle)\n  (env : NamingEnvironment) : Option NamingGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgNaming (ResolveNameRequest x)) := do {\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n          matchedArgs := [ReplyTo (some sender) none] ;\n          actionLabel := DoResolveName x;\n          precomputationTasks := unit\n        });}\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/naming_behaviour.html#submitnameevidenceguard","title":"<code>submitNameEvidenceGuard</code>","text":"<pre><code>flowchart TD\n    C{SubmitNameEvidenceRequest&lt;br&gt;received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoSubmitNameEvidence])</code></pre> submitNameEvidenceGuard flowchart <pre><code>submitNameEvidenceGuard\n  (t : TimestampedTrigger NamingTimerHandle)\n  (env : NamingEnvironment) : Option NamingGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgNaming (SubmitNameEvidenceRequest x)) := do {\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n          matchedArgs := [ReplyTo (some sender) none] ;\n          actionLabel := DoSubmitNameEvidence x;\n          precomputationTasks := unit\n        });}\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/naming_behaviour.html#querynameevidenceguard","title":"<code>queryNameEvidenceGuard</code>","text":"<pre><code>flowchart TD\n    C{QueryNameEvidenceRequest&lt;br&gt;received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoQueryNameEvidence])</code></pre> queryNameEvidenceGuard flowchart <pre><code>queryNameEvidenceGuard\n  (t : TimestampedTrigger NamingTimerHandle)\n  (env : NamingEnvironment) : Option NamingGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgNaming (QueryNameEvidenceRequest x)) := do {\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n                matchedArgs := [ReplyTo (some sender) none] ;\n                actionLabel := DoQueryNameEvidence x;\n                precomputationTasks := unit\n                });\n        }\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/naming_behaviour.html#action-function","title":"Action function","text":"Auxiliary Juvix code <p>Type alias for the action function.</p> <pre><code>NamingActionInput : Type :=\n  ActionInput\n    NamingLocalState\n    NamingMailboxState\n    NamingTimerHandle\n    NamingMatchableArgument\n    NamingActionLabel\n    NamingPrecomputation;\n\nNamingActionEffect : Type :=\n  ActionEffect\n    NamingLocalState\n    NamingMailboxState\n    NamingTimerHandle\n    NamingMatchableArgument\n    NamingActionLabel\n    NamingPrecomputation;\n</code></pre> <pre><code>namingAction (input : NamingActionInput) : NamingActionEffect :=\n  let env := ActionInput.env input;\n      out := ActionInput.guardOutput input;\n      localState := EngineEnv.localState env;\n  in\n  case GuardOutput.actionLabel out of {\n    | DoResolveName identityName :=\n      case GuardOutput.matchedArgs out of {\n        | (ReplyTo (some whoAsked) _) :: _ := let\n            matchingEvidence := AVLTree.filter \\{evidence :=\n              isEqual (Ord.cmp (IdentityNameEvidence.identityName evidence) identityName)\n             } (NamingLocalState.evidenceStore localState);\n            identities := Set.fromList (map \\{evidence :=\n              IdentityNameEvidence.externalIdentity evidence\n             } (Set.toList matchingEvidence));\n            responseMsg := ResolveNameResponse@{\n              externalIdentities := identities;\n              err := none\n            };\n          in mkActionEffect@{\n            newEnv := env; -- No state change\n            producedMessages := [mkEngineMsg@{\n              sender := mkPair none (some (EngineEnv.name env));\n              target := whoAsked;\n              mailbox := some 0;\n              msg := MsgNaming responseMsg\n            }];\n            timers := [];\n            spawnedEngines := []\n          }\n        | _ := mkActionEffect@{newEnv := env; producedMessages := []; timers := []; spawnedEngines := []}\n      }\n    | DoSubmitNameEvidence evidence' :=\n      case GuardOutput.matchedArgs out of {\n        | (ReplyTo (some whoAsked) _) :: _ :=\n            let evidence := evidence';\n                isValid := NamingLocalState.verifyEvidence localState evidence;\n            in\n            case isValid of {\n              | false :=\n                  let responseMsg := SubmitNameEvidenceResponse@{\n                        err := some \"Invalid evidence\"\n                      };\n                  in mkActionEffect@{\n                    newEnv := env;\n                    producedMessages := [mkEngineMsg@{\n                      sender := mkPair none (some (EngineEnv.name env));\n                      target := whoAsked;\n                      mailbox := some 0;\n                      msg := MsgNaming responseMsg\n                    }];\n                    timers := [];\n                    spawnedEngines := []\n                  }\n              | true :=\n                  let alreadyExists := isElement \\{a b := a &amp;&amp; b} true (map \\{e :=\n                        isEqual (Ord.cmp e evidence)\n                      } (Set.toList (NamingLocalState.evidenceStore localState)));\n                      newLocalState := case alreadyExists of {\n                        | true := localState\n                        | false :=\n                            let newEvidenceStore := Set.insert evidence (NamingLocalState.evidenceStore localState);\n                            in localState@NamingLocalState{\n                              evidenceStore := newEvidenceStore\n                            }\n                      };\n                      newEnv' := env@EngineEnv{\n                        localState := newLocalState\n                      };\n                      responseMsg := SubmitNameEvidenceResponse@{\n                        err := case alreadyExists of {\n                          | true := some \"Evidence already exists\"\n                          | false := none\n                      }};\n                  in mkActionEffect@{\n                    newEnv := newEnv';\n                    producedMessages := [mkEngineMsg@{\n                      sender := mkPair none (some (EngineEnv.name env));\n                      target := whoAsked;\n                      mailbox := some 0;\n                      msg := MsgNaming responseMsg\n                    }];\n                    timers := [];\n                    spawnedEngines := []\n                  }\n            }\n        | _ := mkActionEffect@{\n            newEnv := env;\n            producedMessages := [];\n            timers := [];\n            spawnedEngines := []\n          }\n      }\n    | DoQueryNameEvidence externalIdentity' :=\n      case GuardOutput.matchedArgs out of {\n        | (ReplyTo (some whoAsked) _) :: _ := let\n            relevantEvidence := AVLTree.filter \\{evidence :=\n              isEqual (Ord.cmp (IdentityNameEvidence.externalIdentity evidence) externalIdentity')\n             } (NamingLocalState.evidenceStore localState);\n            responseMsg := QueryNameEvidenceResponse@{\n              externalIdentity := externalIdentity';\n              evidence := relevantEvidence;\n              err := none\n            };\n          in mkActionEffect@{\n            newEnv := env; -- No state change\n            producedMessages := [mkEngineMsg@{\n              sender := mkPair none (some (EngineEnv.name env));\n              target := whoAsked;\n              mailbox := some 0;\n              msg := MsgNaming responseMsg\n            }];\n            timers := [];\n            spawnedEngines := []\n          }\n        | _ := mkActionEffect@{newEnv := env; producedMessages := []; timers := []; spawnedEngines := []}\n      }\n  };\n</code></pre>"},{"location":"arch/node/engines/naming_behaviour.html#conflict-solver","title":"Conflict solver","text":"<pre><code>namingConflictSolver : Set NamingMatchableArgument -&gt; List (Set NamingMatchableArgument)\n  | _ := [];\n</code></pre>"},{"location":"arch/node/engines/naming_behaviour.html#namingbehaviour-type","title":"NamingBehaviour type","text":"<pre><code>NamingBehaviour : Type :=\n  EngineBehaviour\n    NamingLocalState\n    NamingMailboxState\n    NamingTimerHandle\n    NamingMatchableArgument\n    NamingActionLabel\n    NamingPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/naming_behaviour.html#namingbehaviour-instance","title":"NamingBehaviour instance","text":"<pre><code>namingBehaviour : NamingBehaviour :=\n  mkEngineBehaviour@{\n    guards := [resolveNameGuard; submitNameEvidenceGuard; queryNameEvidenceGuard];\n    action := namingAction;\n    conflictSolver := namingConflictSolver;\n  };\n</code></pre>"},{"location":"arch/node/engines/naming_environment.html","title":"Naming Engine Environment","text":"<p>Failure</p> <p>[6 of 8] Compiling arch.node.engines.naming_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/naming_environment.juvix.md:73:7-11: error: Unexpected argument node</p> <p>icon: octicons/container-24 search:   exclude: false categories: - engine-behaviour tags: - naming - engine-environment</p> Juvix imports <pre><code>module arch.node.engines.naming_environment;\n\nimport prelude open;\nimport arch.node.types.engine_environment open;\nimport arch.node.types.identities open;\nimport arch.node.engines.naming_messages open;\n</code></pre>"},{"location":"arch/node/engines/naming_environment.html#naming-environment","title":"Naming Environment","text":""},{"location":"arch/node/engines/naming_environment.html#overview","title":"Overview","text":"<p>The Naming Engine maintains the state necessary for managing associations between <code>IdentityName</code>s and <code>ExternalIdentity</code>s, including storing evidence submitted by clients.</p>"},{"location":"arch/node/engines/naming_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The Naming Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p> <pre><code>syntax alias NamingMailboxState := Unit;\n</code></pre>"},{"location":"arch/node/engines/naming_environment.html#local-state","title":"Local state","text":"<p>The local state of the Naming Engine includes the evidence for name associations.</p> <pre><code>type NamingLocalState := mkNamingLocalState@{\n  evidenceStore : Set IdentityNameEvidence;\n  verifyEvidence : IdentityNameEvidence -&gt; Bool;\n};\n</code></pre>"},{"location":"arch/node/engines/naming_environment.html#timer-handle","title":"Timer Handle","text":"<pre><code>syntax alias NamingTimerHandle := Unit;\n</code></pre> <p>The Naming Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>"},{"location":"arch/node/engines/naming_environment.html#environment-summary","title":"Environment summary","text":"<pre><code>NamingEnvironment : Type := EngineEnv\n  NamingLocalState\n  NamingMailboxState\n  NamingTimerHandle;\n</code></pre>"},{"location":"arch/node/engines/naming_environment.html#example-of-a-naming-environment","title":"Example of a <code>Naming</code> environment","text":"<pre><code>module naming_environment_example;\n\nnamingEnvironmentExample : NamingEnvironment :=\n    mkEngineEnv@{\n      node := Curve25519PubKey \"0xabcd1234\";\n      name := \"naming\";\n      localState := mkNamingLocalState@{\n        evidenceStore := Set.empty;\n        verifyEvidence := \\{ _ := true }\n      };\n      mailboxCluster := Map.empty;\n      acquaintances := Set.empty;\n      timers := []\n    }\n  ;\nend;\n</code></pre>"},{"location":"arch/node/engines/naming_messages.html","title":"Naming Engine Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.naming_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["naming","engine-messages"]},{"location":"arch/node/engines/naming_messages.html#naming-messages","title":"<code>Naming</code> Messages","text":"","tags":["naming","engine-messages"]},{"location":"arch/node/engines/naming_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type NamingMsg :=  | ResolveNameRequest {identityName : IdentityName}  | ResolveNameResponse {      externalIdentities : Set ExternalIdentity;      err : Option String    }  | SubmitNameEvidenceRequest {evidence : IdentityNameEvidence}  | SubmitNameEvidenceResponse {err : Option String}  | QueryNameEvidenceRequest {externalIdentity : ExternalIdentity}  | QueryNameEvidenceResponse {      externalIdentity : ExternalIdentity;      evidence : Set IdentityNameEvidence;      err : Option String    };</pre></code></pre>","tags":["naming","engine-messages"]},{"location":"arch/node/engines/naming_messages.html#resolvenamerequest-message","title":"<code>ResolveNameRequest</code> message","text":"<p>ResolveNameRequest</p> <pre><code>ResolveNameRequest {\n  identityName : IdentityName\n}\n</code></pre> <p>A <code>ResolveNameRequest</code> asks the Naming Engine which <code>ExternalIdentity</code>s are associated with a given <code>IdentityName</code>.</p> <ul> <li><code>identityName</code>: The name to resolve.</li> </ul>","tags":["naming","engine-messages"]},{"location":"arch/node/engines/naming_messages.html#resolvenameresponse-message","title":"<code>ResolveNameResponse</code> message","text":"<p>ResolveNameResponse</p> <pre><code>ResolveNameResponse {\n  externalIdentities : Set ExternalIdentity;\n  err : Option String\n}\n</code></pre> <p>A <code>ResolveNameResponse</code> is returned in response to a <code>ResolveNameRequest</code>.</p> <ul> <li><code>externalIdentities</code>: A set of ExternalIdentitys associated with the IdentityName.</li> <li><code>err</code>: An error message if the resolution failed.</li> </ul>","tags":["naming","engine-messages"]},{"location":"arch/node/engines/naming_messages.html#submitnameevidencerequest-message","title":"<code>SubmitNameEvidenceRequest</code> message","text":"<p>SubmitNameEvidenceRequest</p> <pre><code>SubmitNameEvidenceRequest {\n  evidence : IdentityNameEvidence\n}\n</code></pre> <p>A <code>SubmitNameEvidenceRequest</code> instructs the Naming Engine to store a new piece of IdentityNameEvidence.</p> <ul> <li><code>evidence</code>: The evidence supporting the association between an IdentityName and an ExternalIdentity.</li> </ul>","tags":["naming","engine-messages"]},{"location":"arch/node/engines/naming_messages.html#submitnameevidenceresponse-message","title":"<code>SubmitNameEvidenceResponse</code> message","text":"<p>SubmitNameEvidenceResponse</p> <pre><code>SubmitNameEvidenceResponse {\n  err : Option String\n}\n</code></pre> <p>A <code>SubmitNameEvidenceResponse</code> is sent in response to a <code>SubmitNameEvidenceRequest</code>.</p> <ul> <li><code>err</code>: An error message if the submission failed.</li> </ul>","tags":["naming","engine-messages"]},{"location":"arch/node/engines/naming_messages.html#querynameevidencerequest-message","title":"<code>QueryNameEvidenceRequest</code> message","text":"<p>QueryNameEvidenceRequest</p> <pre><code>QueryNameEvidenceRequest {\n  externalIdentity : ExternalIdentity\n}\n</code></pre> <p>A <code>QueryNameEvidenceRequest</code> instructs the Naming Engine to return any known IdentityNames and IdentityNameEvidence associated with a specific ExternalIdentity.</p> <ul> <li><code>externalIdentity</code>: The identity for which to retrieve evidence.</li> </ul>","tags":["naming","engine-messages"]},{"location":"arch/node/engines/naming_messages.html#querynameevidenceresponse-message","title":"<code>QueryNameEvidenceResponse</code> message","text":"<p>QueryNameEvidenceResponse</p> <pre><code>QueryNameEvidenceResponse {\n  externalIdentity : ExternalIdentity;\n  evidence : Set IdentityNameEvidence;\n  err : Option String\n}\n</code></pre> <p>A <code>QueryNameEvidenceResponse</code> provides the requested evidence.</p> <ul> <li><code>evidence</code>: A set of IdentityNameEvidence related to the identity.</li> <li><code>err</code>: An error message if the query failed.</li> </ul>","tags":["naming","engine-messages"]},{"location":"arch/node/engines/naming_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["naming","engine-messages"]},{"location":"arch/node/engines/naming_messages.html#resolving-a-name","title":"Resolving a Name","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant NamingEngine\n\n    Client-&gt;&gt;NamingEngine: ResolveNameRequest (name)\n    Note over NamingEngine: Check stored evidence\n    NamingEngine-&gt;&gt;Client: ResolveNameResponse</code></pre>  Resolving a name","tags":["naming","engine-messages"]},{"location":"arch/node/engines/naming_messages.html#submitting-name-evidence","title":"Submitting Name Evidence","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant NamingEngine\n\n    Client-&gt;&gt;NamingEngine: SubmitNameEvidenceRequest\n    Note over NamingEngine: Verify and store evidence\n    NamingEngine-&gt;&gt;Client: SubmitNameEvidenceResponse</code></pre>  Submitting name evidence","tags":["naming","engine-messages"]},{"location":"arch/node/engines/naming_messages.html#querying-name-evidence","title":"Querying Name Evidence","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant NamingEngine\n\n    Client-&gt;&gt;NamingEngine: QueryNameEvidenceRequest (for ExternalIdentity)\n    Note over NamingEngine: Retrieve relevant evidence\n    NamingEngine-&gt;&gt;Client: QueryNameEvidenceResponse</code></pre>  Querying name evidence for an identity.","tags":["naming","engine-messages"]},{"location":"arch/node/engines/naming_messages.html#engine-components","title":"Engine Components","text":"<ul> <li><code>Naming</code> Engine Environment</li> <li><code>Naming</code> Engine Dynamics</li> </ul>","tags":["naming","engine-messages"]},{"location":"arch/node/engines/naming_messages.html#useful-links","title":"Useful links","text":"","tags":["naming","engine-messages"]},{"location":"arch/node/engines/p2p.html","title":"P2P","text":"","boost":2},{"location":"arch/node/engines/p2p.html#network-abstraction-layer","title":"Network abstraction layer","text":"<p>The network abstraction layer is responsible for mapping logical sends (to a topic and external identity) to physical sends (to physical addresses, e.g. IPs). Higher protocol layers can send to and receive from external identities and topics, subscribe to topics of interest, and unsubscribe from topics no longer of interest. The network abstraction layer is responsible for keeping relevant state, including who is interested in what topic, who is reachable at what physical address, route information, latency information, and so forth. Internally, the network abstraction layer handles peer discovery, sampling, relaying, and routing, such that higher layers need only concern themselves with messages destined for this agent. The network abstraction layer collects and outputs latency information and relay accounting data which can be used to inform higher-level decisions and tracking.</p> <p>The network abstraction layer produces a logical pub/sub interface and consumes a set of physical send/recv interfaces (e.g. UDP/IP, TCP/IP, etc.). The central part we refer to as the P2P intelligence engine (PIE), as it is expected to run in parallel to higher layers and make decisions about discovery, routing, etc. internally.</p>","boost":2},{"location":"arch/node/engines/p2p.html#logical-pubsub-interface","title":"Logical pub/sub interface","text":"<p>The logical pub/sub interface allows higher layers to send to and receive from external identities and topics. All sends and receives reference an external identity and a topic. In order to send a message to everyone, the \"all\" identity can be used, and in order to send a message regardless of what topics have been subscribed to, the sentinel empty string topic can be used (in other words, all nodes are automatically subscribed to the default topic).</p> <p>Topics are self-authenticating, in that only messages which satisfy the topic predicate can be sent on the topic. Where we need to track strings for routing tables, the content address of the function can be used. If nodes publish invalid messages on the topic (which do not satisfy the predicates), other nodes should refuse to relay those messages and ban the peers.</p> <p>Note</p> <p>The difference between topics and external identities is that topics cannot be encrypted to. In the future (with witness encryption or similar) it may be possible to unify these concepts.</p> <p>Todo</p> <p>Give examples for usecases at different points in the spectrum of Identity/Topic combinations.</p> <p>Todo</p> <p>Simple local filtering on topics (i.e. subtopics) and potentially optimisations by broadcasting local filters.</p> <pre><code><pre>axiom Message : Type;type Bool :=  | True  | False;axiom ByteString : Type;axiom ExternalIdentity : Type;axiom Topic : Type;axiom IO : Type;axiom logicalSend : ExternalIdentity -&gt; Topic -&gt; Message -&gt; IO;axiom logicalOnRecv : (ExternalIdentity -&gt; Topic -&gt; Message -&gt; IO) -&gt; IO;axiom logicalSub : Topic -&gt; IO;axiom logicalUnsub : Topic -&gt; IO;</pre></code></pre>","boost":2},{"location":"arch/node/engines/p2p.html#p2p-intelligence-engine-pie","title":"P2P intelligence engine (PIE \ud83e\udd67)","text":"<p>The P2P intelligence engine (PIE) is where all the magic happens. The PIE takes information from higher protocol layers, including entanglement and bandwidth usage / routing preferences, and collects measurements internally (latency, available routes) which are both used to inform decision-making, allowing fine-grained tradeoffs between various constraints.</p>","boost":2},{"location":"arch/node/engines/p2p.html#information-from-above","title":"Information from above","text":"<p>From above, PIE receives:</p> <ul> <li>Trust/entanglement information. For now this is assumed to be of the form of a   scalar from 0 to 1 describing the entanglement between two external   identities, such that 0 is unknown, 1 is completely trusted, and everything in   between can be roughly understood as an interpolation.</li> </ul> <ul> <li>Routing preferences<p>- Bandwidth usage preferences. For now this is just 1-bit of information,     either \"use any amount of bandwidth\" or \"minimise bandwidth\".</p> <p>- Latency preferences. For now this is just 1-bit of information, either     \"minimize latency\" or \"don't care\".</p> <p>- Cost preferences, with heterogeneous denominations</p> <p>- Trust/entanglement preferences for (intermediate) nodes       - \"avoid nodes with entanglement scores lower than X\", for example</p> <p>- (eventually this can just be a function which selects between possible     routes and PIE calls when it needs to decide)</p> </li> </ul>","boost":2},{"location":"arch/node/engines/p2p.html#information-internally-from-below","title":"Information internally / from below","text":"<p>From below / internally, PIE collects:</p> <ul> <li>Relay accounting data (which other identities I have relayed how many / what   size / bandwidth of messages for)<p>- can start out very coarse (# of messages) and become more granular later     if necessary</p> </li> </ul> <ul> <li>Routing information (discovered from other nodes)<p>- (external identity, physical address | external identity, latency) tuples</p> <p>- (external identity, {topics of interest}) tuples</p> <p>- includes latency information measured with local clock</p> <p>- can have multiple routes to the same destination w/different addresses,     latency, etc.</p> <p>- nodes could express a priority list of their physical addresses</p> </li> </ul> <p>This information can be made available to higher protocol layers as desired.</p>","boost":2},{"location":"arch/node/engines/p2p.html#decision-making","title":"Decision-making","text":"<p>PIE makes decisions about how to route messages (from this agent to another external identity and topic), and about when/how to relay messages destined for another external identity and/or topic but sent initially to this agent.</p>","boost":2},{"location":"arch/node/engines/p2p.html#sub-protocols","title":"Sub-protocols","text":"<p>PIE includes sub-protocols for peer discovery, DHT (fallback routing option in case local routing fails), trust-aware random peer sampling, trust-aware relay/routing table synchronisation, NAT traversal/hole-punching, and possibly collaborative filtering (in the future).</p> <p>Sub-protocols:</p> <ul> <li>Peer discovery (e.g. via gossip/rps or DHT),</li> </ul> <ul> <li>DHT (SovKad)</li> </ul> <ul> <li>(Trust Aware) Random Peer Sampling</li> </ul> <ul> <li>(Trust Aware) Relaying Protocol<p>- Nodes can request to not have their physical addresses forwarded, but     instead relay packets via other nodes.</p> </li> </ul> <ul> <li> <p>(Trust Aware) Routing Table Sync</p> <ul> <li>1 bit of info instructing other node whether to share your (pubkey, IP) pair   or share their IP in response to queries</li> </ul> <ul> <li>Include latency data</li> </ul> </li> </ul> <ul> <li>NAT traversal / Hole Punching</li> </ul> <ul> <li>Privacy-preserving interest discovery / collaborative filtering (incl. interesting bloom filter stuff)</li> </ul>","boost":2},{"location":"arch/node/engines/p2p.html#routing-notes","title":"Routing notes","text":"<p>Logical routing should take into account compositionality of identities - e.g., if routes to Alice, Bob, and Charlie are known, but a route to (Alice &amp;&amp; Bob &amp;&amp; Charlie) is not, individual routes can be automatically tried. This state is constructed from physical address announcement messages sent (and signed) by particular external identities.</p> <p>Todo</p> <p>Figure out details around implicit vs explicit domains and expected topologies under some reasonable assumptions.</p> <p>Todo</p> <p>Figure out details around privacy-preservation in internal messages. Maybe the higher-layer should provide a default routing preference function which applies also to internal messages and can implement something like implicit domains (e.g. to restrict data leakage to a set of known nodes).</p>","boost":2},{"location":"arch/node/engines/p2p.html#physical-sendrecv","title":"Physical send/recv","text":"<p>Underlying physical networking layers are expected to expose an opaque type <code>PhysicalAddress</code>, to which messages can be sent and from which they might be received. Physical networking could be instantiated by a base physical protocol such as TCP/IP or UDP/IP, or a more complex layered one such as Tor or a mixnet. The physical layer needs to provide only two functions, <code>send</code> and <code>onRecv</code>, which act as one would expect. Messages are assumed to be delivered either completely or not at all, but the physical layer is not expected to provide any form of authentication, ordering, or reliable delivery - those concerns are handled by higher layers.</p> <p>Todo</p> <p>Work remains to be done to integrate the privacy properties which might be provided by Tor or a mixnet into the privacy preferences and  trust graph, which the higher-level logical layers might be able to reason about. This will likely need to be an abstract model of their properties, to be used by the information flow control system.</p> <pre><code><pre>axiom PhysicalAddress : Type;axiom send : PhysicalAddress -&gt; ByteString -&gt; IO;axiom onRecv : (PhysicalAddress -&gt; ByteString -&gt; IO) -&gt; IO;</pre></code></pre> <p>Physical routing also requires an underlying state, but as existing stacks can handle this perfectly well, so we keep all physical routing state and algorithms out of scope of the Anoma protocols.</p>","boost":2},{"location":"arch/node/engines/pinger.html","title":"Pinger Engine","text":"","boost":2},{"location":"arch/node/engines/pinger.html#overall-philosophy","title":"Overall Philosophy","text":"<p>The Pinger Engine is designed to provide a functionality of a scheduled Mempool executor. Keeping track of the Mempool Engine address and the timer set, it calls for the Mempool to execute every specified amount of time.</p>","boost":2},{"location":"arch/node/engines/pinger.html#initialization","title":"Initialization","text":"<p>The Engine requires one input, namely the Mempool address. The user may also provide a non-negative integer for the time information of the engine. If no argument is given, we assume that no timer is set.</p>","boost":2},{"location":"arch/node/engines/pinger.html#state","title":"State","text":"<p>The state types are provided as follows:</p>","boost":2},{"location":"arch/node/engines/pinger.html#state_1","title":"State","text":"<p>The state types are provided as follows:</p> <ul> <li><code>field(:mempool, Router.Addr.t())</code> Mempool Address</li> </ul> <ul> <li><code>field(:time, non_neg_integer() | atom(), default: :no_timer)</code> Timer field</li> </ul>","boost":2},{"location":"arch/node/engines/pinger.html#public-api","title":"Public API","text":"","boost":2},{"location":"arch/node/engines/pinger.html#set_timer","title":"Set_Timer","text":"","boost":2},{"location":"arch/node/engines/pinger.html#purpose","title":"Purpose","text":"<p>Sets the timer which the clock uses to schedule how frequently to ask Mempool for execution.</p>","boost":2},{"location":"arch/node/engines/pinger.html#type","title":"Type","text":"<p>Input</p> <ul> <li>`Router.Addr.t()``    Router address of the mempool</li> <li><code>non_neg_integer() | :no_timer</code> Timer for the Engine</li> </ul> <p>Output</p> <p>No user-visible output on success</p>","boost":2},{"location":"arch/node/engines/pinger.html#start","title":"Start","text":"<p>Starts the pinger process. If no timer is specified, send a default message. Otherwise, send message to itself after the specified time. Namely it launches the <code>pinger</code> function.</p> <p>Input</p> <ul> <li><code>Router.Addr.t()</code> An address of the Pinger Engine the user wants to start</li> </ul> <p>*Output</p> <ul> <li><code>String.t()</code> Message specifying successful launch</li> </ul>","boost":2},{"location":"arch/node/engines/pinger.html#pinger","title":"Pinger","text":"","boost":2},{"location":"arch/node/engines/pinger.html#purpose_1","title":"Purpose","text":"<p>The <code>pinger</code> function asks for a timer feed. If no timer is specified, sends a base message to the user. Otherwise, asks to send an <code>execute</code> message to the pinger itself after a specified amount of time.</p> <p>Input</p> <ul> <li><code>:no_timer | non_neg_integer()</code> Either the message specifying no timer or an integer specifying time setting</li> </ul> <p>Output</p> <ul> <li><code>:ok | reference()</code> Either returns a base message in case no timer is set or sends a classical reference</li> </ul>","boost":2},{"location":"arch/node/engines/pinger.html#message-flow","title":"Message Flow","text":"<p><pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Pinger Engine: Set_Timer\nAny Local Engine -&gt;&gt;+ Pinger Engine: Start\nPinger Engine --&gt;&gt;- Any Local Engine: Start_Reply\nPinger Engine -&gt;&gt;+ Pinger Engine: Pinger\n%% --8&lt;-- [end:sequence]</code></pre> </p>","boost":2},{"location":"arch/node/engines/reads_for.html","title":"Reads For Engine","text":"<p>Failure</p> <p>[10 of 16] Compiling arch.node.engines.reads_for_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/reads_for_environment.juvix.md:73:7-11: error: Unexpected argument node</p> <p>icon: octicons/project-template-24 search:   exclude: false tags: - reads_for - engines</p> Juvix imports <pre><code>module arch.node.engines.reads_for;\n\nimport prelude open;\nimport arch.node.types.engine open;\n\nimport arch.node.engines.reads_for_messages open public;\nimport arch.node.engines.reads_for_environment open public;\nimport arch.node.engines.reads_for_behaviour open public;\nopen reads_for_environment_example;\n</code></pre>"},{"location":"arch/node/engines/reads_for.html#readsfor-engine","title":"ReadsFor Engine","text":"<p>The Reads For Engine manages <code>reads_for</code> relationships between identities. A <code>reads_for</code> relationship indicates that one identity can read data encrypted for another identity.</p>"},{"location":"arch/node/engines/reads_for.html#purpose","title":"Purpose","text":"<p>The Reads For Engine maintains and manages the state of <code>reads_for</code> relationships between identities. It handles queries about these relationships, allows submission of new evidence, and provides information about existing relationships. This is useful in scenarios where data access needs to be delegated or shared.</p>"},{"location":"arch/node/engines/reads_for.html#components","title":"Components","text":"<ul> <li>ReadsFor Messages</li> <li>ReadsFor Environment</li> <li>ReadsFor Behaviour</li> </ul>"},{"location":"arch/node/engines/reads_for.html#useful-links","title":"Useful links","text":"<ul> <li>Composable Semantic Models for Actor Theories</li> </ul>"},{"location":"arch/node/engines/reads_for.html#type","title":"Type","text":"<pre><code>ReadsForEngine : Type := Engine\n  ReadsForLocalState\n  ReadsForMailboxState\n  ReadsForTimerHandle\n  ReadsForMatchableArgument\n  ReadsForActionLabel\n  ReadsForPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/reads_for.html#example-of-a-readsfor-engine","title":"Example of a readsFor engine","text":"<pre><code>exampleReadsForEngine : ReadsForEngine :=\n  mkEngine@{\n    behaviour := readsForBehaviour;\n    initEnv := readsForEnvironmentExample;\n  };\n</code></pre> <p>where <code>readsForEnvironmentExample</code> is defined as follows:</p> <pre><code><pre>readsForEnvironmentExample : ReadsForEnvironment :=  mkEngineEnvironment@{    name := \"reads_for\";    localState :=      mkReadsForLocalState@{        evidenceStore := Set.empty;        verifyEvidence := \\{_ := true};      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>"},{"location":"arch/node/engines/reads_for_behaviour.html","title":"Reads For Engine Behaviour","text":"<p>Failure</p> <p>[9 of 14] Compiling arch.node.engines.reads_for_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/reads_for_environment.juvix.md:73:7-11: error: Unexpected argument node</p> <p>icon: octicons/gear-16 search:   exclude: false categories: - engine-behaviour - juvix-module tags: - reads_for - engine-behavior</p> Juvix imports <pre><code>module arch.node.engines.reads_for_behaviour;\n\nimport prelude open;\nimport arch.node.types.messages open;\nimport arch.node.types.engine_behaviour open;\nimport arch.node.types.engine_environment open;\nimport arch.node.types.identities open;\nimport arch.node.engines.reads_for_messages open;\nimport arch.node.engines.reads_for_environment open;\nimport arch.node.types.anoma_message open;\n</code></pre>"},{"location":"arch/node/engines/reads_for_behaviour.html#reads-for-dynamics","title":"<code>Reads For</code> Dynamics","text":""},{"location":"arch/node/engines/reads_for_behaviour.html#overview","title":"Overview","text":"<p>The behavior of the Reads For Engine define how it processes incoming messages and updates its state accordingly.</p>"},{"location":"arch/node/engines/reads_for_behaviour.html#action-labels","title":"Action labels","text":"<pre><code>type ReadsForActionLabel :=\n  | -- --8&lt;-- [start:DoReadsForQuery]\n    DoReadsForQuery {\n      externalIdentityA : ExternalIdentity;\n      externalIdentityB : ExternalIdentity\n    }\n    -- --8&lt;-- [end:DoReadsForQuery]\n  | -- --8&lt;-- [start:DoSubmitEvidence]\n    DoSubmitEvidence {\n      evidence : ReadsForEvidence\n    }\n    -- --8&lt;-- [end:DoSubmitEvidence]\n  | -- --8&lt;-- [start:DoQueryEvidence]\n    DoQueryEvidence {\n      externalIdentity : ExternalIdentity\n    }\n    -- --8&lt;-- [end:DoQueryEvidence]\n;\n</code></pre>"},{"location":"arch/node/engines/reads_for_behaviour.html#doreadsforquery","title":"<code>DoReadsForQuery</code>","text":"<p>DoReadsForQuery {   externalIdentityA : ExternalIdentity;   externalIdentityB : ExternalIdentity }</p> <p>This action label corresponds to processing a reads_for query.</p> <code>DoReadsForQuery</code> action effect <p>This action does the following:</p> Aspect Description State update The state remains unchanged. Messages to be sent A <code>ReadsForResponse</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/reads_for_behaviour.html#dosubmitevidence","title":"<code>DoSubmitEvidence</code>","text":"<p>DoSubmitEvidence {   evidence : ReadsForEvidence }</p> <p>This action label corresponds to submitting new reads_for evidence.</p> <code>DoSubmitEvidence</code> action effect <p>This action does the following:</p> Aspect Description State update If the evidence doesn't already exist and is valid, it's added to the <code>evidenceStore</code> in the local state. Messages to be sent A <code>SubmitReadsForEvidenceResponse</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/reads_for_behaviour.html#doqueryevidence","title":"<code>DoQueryEvidence</code>","text":"<p>DoQueryEvidence {   externalIdentity : ExternalIdentity }</p> <p>This action label corresponds to querying reads_for evidence for a specific identity.</p> <code>DoQueryEvidence</code> action effect <p>This action does the following:</p> Aspect Description State update The state remains unchanged. Messages to be sent A <code>QueryReadsForEvidenceResponse</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/reads_for_behaviour.html#matchable-arguments","title":"Matchable arguments","text":"<pre><code>type ReadsForMatchableArgument :=\n  | -- --8&lt;-- [start:ReplyTo]\n  ReplyTo (Option EngineID) (Option MailboxID)\n  -- --8&lt;-- [end:ReplyTo]\n;\n</code></pre>"},{"location":"arch/node/engines/reads_for_behaviour.html#replyto","title":"<code>ReplyTo</code>","text":"<pre><code>ReplyTo (Option EngineID) (Option MailboxID)\n</code></pre> <p>This matchable argument contains the address and mailbox ID of where the response message should be sent.</p>"},{"location":"arch/node/engines/reads_for_behaviour.html#precomputation-results","title":"Precomputation results","text":"<p>The Reads For Engine does not require any non-trivial pre-computations.</p> <pre><code>syntax alias ReadsForPrecomputation := Unit;\n</code></pre>"},{"location":"arch/node/engines/reads_for_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code <p>Type alias for the guard.</p> <pre><code>-- --8&lt;-- [start:reads-for-guard]\nReadsForGuard : Type :=\n  Guard\n    ReadsForLocalState\n    ReadsForMailboxState\n    ReadsForTimerHandle\n    ReadsForMatchableArgument\n    ReadsForActionLabel\n    ReadsForPrecomputation;\n-- --8&lt;-- [end:reads-for-guard]\n\n-- --8&lt;-- [start:reads-for-guard-output]\nReadsForGuardOutput : Type :=\n  GuardOutput ReadsForMatchableArgument ReadsForActionLabel ReadsForPrecomputation;\n-- --8&lt;-- [end:reads-for-guard-output]\n</code></pre>"},{"location":"arch/node/engines/reads_for_behaviour.html#readsforqueryguard","title":"<code>readsForQueryGuard</code>","text":"<pre><code>flowchart TD\n    C{ReadsForRequest&lt;br&gt;received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoReadsForQuery])</code></pre> readsForQueryGuard flowchart <pre><code>readsForQueryGuard\n  (t : TimestampedTrigger ReadsForTimerHandle)\n  (env : ReadsForEnvironment) : Option ReadsForGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgReadsFor (ReadsForRequest x y)) := do {\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n          matchedArgs := [ReplyTo (some sender) none] ;\n          actionLabel := DoReadsForQuery x y;\n          precomputationTasks := unit\n        });}\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/reads_for_behaviour.html#submitevidenceguard","title":"<code>submitEvidenceGuard</code>","text":"<pre><code>flowchart TD\n    C{SubmitReadsForEvidence&lt;br&gt;Request received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoSubmitEvidence])</code></pre> submitEvidenceGuard flowchart <pre><code>submitEvidenceGuard\n  (t : TimestampedTrigger ReadsForTimerHandle)\n  (env : ReadsForEnvironment) : Option ReadsForGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgReadsFor (SubmitReadsForEvidenceRequest x)) := do {\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n                matchedArgs := [ReplyTo (some sender) none] ;\n                actionLabel := DoSubmitEvidence x;\n                precomputationTasks := unit\n        });}\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/reads_for_behaviour.html#queryevidenceguard","title":"<code>queryEvidenceGuard</code>","text":"<pre><code>flowchart TD\n    C{QueryReadsForEvidence&lt;br&gt;Request received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoQueryEvidence])</code></pre> queryEvidenceGuard flowchart <pre><code>queryEvidenceGuard\n  (t : TimestampedTrigger ReadsForTimerHandle)\n  (env : ReadsForEnvironment) : Option ReadsForGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgReadsFor (QueryReadsForEvidenceRequest x)) := do {\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n                matchedArgs := [ReplyTo (some sender) none] ;\n                actionLabel := DoQueryEvidence x;\n                precomputationTasks := unit\n                });\n        }\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/reads_for_behaviour.html#action-function","title":"Action function","text":"Auxiliary Juvix code <p>Type alias for the action function.</p> <pre><code>ReadsForActionInput : Type :=\n  ActionInput\n    ReadsForLocalState\n    ReadsForMailboxState\n    ReadsForTimerHandle\n    ReadsForMatchableArgument\n    ReadsForActionLabel\n    ReadsForPrecomputation;\n\nReadsForActionEffect : Type :=\n  ActionEffect\n    ReadsForLocalState\n    ReadsForMailboxState\n    ReadsForTimerHandle\n    ReadsForMatchableArgument\n    ReadsForActionLabel\n    ReadsForPrecomputation;\n</code></pre> <pre><code>readsForAction (input : ReadsForActionInput) : ReadsForActionEffect :=\n  let env := ActionInput.env input;\n      out := ActionInput.guardOutput input;\n      localState := EngineEnv.localState env;\n  in\n  case GuardOutput.actionLabel out of {\n    | DoReadsForQuery externalIdentityA externalIdentityB :=\n      case GuardOutput.matchedArgs out of {\n        | (ReplyTo (some whoAsked) _) :: _ := let\n            hasEvidence := isElement \\{a b := a &amp;&amp; b} true (map \\{ evidence :=\n              isEqual (Ord.cmp (ReadsForEvidence.fromIdentity evidence) externalIdentityA) &amp;&amp;\n              isEqual (Ord.cmp (ReadsForEvidence.toIdentity evidence) externalIdentityB)\n            } (Set.toList (ReadsForLocalState.evidenceStore localState)));\n            responseMsg := ReadsForResponse@{\n              readsFor := hasEvidence;\n              err := none\n            };\n          in mkActionEffect@{\n            newEnv := env; -- No state change\n            producedMessages := [mkEngineMsg@{\n              sender := mkPair none (some (EngineEnv.name env));\n              target := whoAsked;\n              mailbox := some 0;\n              msg := MsgReadsFor responseMsg\n            }];\n            timers := [];\n            spawnedEngines := []\n          }\n        | _ := mkActionEffect@{newEnv := env; producedMessages := []; timers := []; spawnedEngines := []}\n      }\n    | DoSubmitEvidence evidence :=\n      case GuardOutput.matchedArgs out of {\n        | (ReplyTo (some whoAsked) _) :: _ :=\n            let isValid := ReadsForLocalState.verifyEvidence localState evidence;\n            in\n            case isValid of {\n              | true :=\n                  let alreadyExists :=\n                    isElement \\{a b := a &amp;&amp; b} true (map \\{e :=\n                        isEqual (Ord.cmp e evidence)\n                      } (Set.toList (ReadsForLocalState.evidenceStore localState)));\n                  in\n                  case alreadyExists of {\n                    | true :=\n                        let responseMsg := SubmitReadsForEvidenceResponse@{\n                              err := some \"Evidence already exists.\"\n                            };\n                        in mkActionEffect@{\n                          newEnv := env;\n                          producedMessages := [mkEngineMsg@{\n                            sender := mkPair none (some (EngineEnv.name env));\n                            target := whoAsked;\n                            mailbox := some 0;\n                            msg := MsgReadsFor responseMsg\n                          }];\n                          timers := [];\n                          spawnedEngines := []\n                        }\n                    | false :=\n                        let newEvidenceStore := Set.insert evidence (ReadsForLocalState.evidenceStore localState);\n                            updatedLocalState := localState@ReadsForLocalState{\n                              evidenceStore := newEvidenceStore\n                            };\n                            newEnv' := env@EngineEnv{\n                              localState := updatedLocalState\n                            };\n                            responseMsg := SubmitReadsForEvidenceResponse@{\n                              err := none\n                            };\n                        in mkActionEffect@{\n                          newEnv := newEnv';\n                          producedMessages := [mkEngineMsg@{\n                            sender := mkPair none (some (EngineEnv.name env));\n                            target := whoAsked;\n                            mailbox := some 0;\n                            msg := MsgReadsFor responseMsg\n                          }];\n                          timers := [];\n                          spawnedEngines := []\n                        }\n                  }\n              | false :=\n                  let responseMsg := SubmitReadsForEvidenceResponse@{\n                        err := some \"Invalid evidence provided.\"\n                      };\n                  in mkActionEffect@{\n                    newEnv := env;\n                    producedMessages := [mkEngineMsg@{\n                      sender := mkPair none (some (EngineEnv.name env));\n                      target := whoAsked;\n                      mailbox := some 0;\n                      msg := MsgReadsFor responseMsg\n                    }];\n                    timers := [];\n                    spawnedEngines := []\n                  }\n            }\n        | _ := mkActionEffect@{\n            newEnv := env;\n            producedMessages := [];\n            timers := [];\n            spawnedEngines := []\n          }\n      }\n    | DoQueryEvidence externalIdentity' :=\n      case GuardOutput.matchedArgs out of {\n        | (ReplyTo (some whoAsked) _) :: _ := let\n            relevantEvidence := AVLTree.filter \\{evidence :=\n              isEqual (Ord.cmp (ReadsForEvidence.fromIdentity evidence) externalIdentity') ||\n              isEqual (Ord.cmp (ReadsForEvidence.toIdentity evidence) externalIdentity')\n            } (ReadsForLocalState.evidenceStore localState);\n            responseMsg := QueryReadsForEvidenceResponse@{\n              externalIdentity := externalIdentity';\n              evidence := relevantEvidence;\n              err := none\n            };\n          in mkActionEffect@{\n            newEnv := env; -- No state change\n            producedMessages := [mkEngineMsg@{\n              sender := mkPair none (some (EngineEnv.name env));\n              target := whoAsked;\n              mailbox := some 0;\n              msg := MsgReadsFor responseMsg\n            }];\n            timers := [];\n            spawnedEngines := []\n          }\n        | _ := mkActionEffect@{newEnv := env; producedMessages := []; timers := []; spawnedEngines := []}\n      }\n  };\n</code></pre>"},{"location":"arch/node/engines/reads_for_behaviour.html#conflict-solver","title":"Conflict solver","text":"<pre><code>readsForConflictSolver : Set ReadsForMatchableArgument -&gt; List (Set ReadsForMatchableArgument)\n  | _ := [];\n</code></pre>"},{"location":"arch/node/engines/reads_for_behaviour.html#readsforbehaviour-type","title":"ReadsForBehaviour type","text":"<pre><code>ReadsForBehaviour : Type :=\n  EngineBehaviour\n    ReadsForLocalState\n    ReadsForMailboxState\n    ReadsForTimerHandle\n    ReadsForMatchableArgument\n    ReadsForActionLabel\n    ReadsForPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/reads_for_behaviour.html#readsforbehaviour-instance","title":"ReadsForBehaviour instance","text":"<pre><code>readsForBehaviour : ReadsForBehaviour :=\n  mkEngineBehaviour@{\n    guards := [readsForQueryGuard; submitEvidenceGuard; queryEvidenceGuard];\n    action := readsForAction;\n    conflictSolver := readsForConflictSolver;\n  };\n</code></pre>"},{"location":"arch/node/engines/reads_for_environment.html","title":"Reads For Engine Environment","text":"<p>Failure</p> <p>[3 of 8] Compiling arch.node.engines.reads_for_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/reads_for_environment.juvix.md:73:7-11: error: Unexpected argument node</p> <p>icon: octicons/container-24 search:   exclude: false categories: - engine-behaviour tags: - reads_for - engine-environment</p> Juvix imports <pre><code>module arch.node.engines.reads_for_environment;\n\nimport prelude open;\nimport arch.node.types.engine_environment open;\nimport arch.node.types.identities open;\nimport arch.node.engines.reads_for_messages open;\n</code></pre>"},{"location":"arch/node/engines/reads_for_environment.html#reads-for-environment","title":"Reads For Environment","text":""},{"location":"arch/node/engines/reads_for_environment.html#overview","title":"Overview","text":"<p>The Reads For Engine environment maintains the state necessary for managing <code>reads_for</code> relationships between identities, including storing evidence submitted by clients.</p>"},{"location":"arch/node/engines/reads_for_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The Reads For Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p> <pre><code>syntax alias ReadsForMailboxState := Unit;\n</code></pre>"},{"location":"arch/node/engines/reads_for_environment.html#local-state","title":"Local state","text":"<p>The local state of the Reads For Engine includes the evidence for reads_for relationships.</p> <pre><code>type ReadsForLocalState := mkReadsForLocalState@{\n  evidenceStore : Set ReadsForEvidence;\n  verifyEvidence : ReadsForEvidence -&gt; Bool;\n};\n</code></pre>"},{"location":"arch/node/engines/reads_for_environment.html#timer-handle","title":"Timer Handle","text":"<pre><code>syntax alias ReadsForTimerHandle := Unit;\n</code></pre> <p>The Reads For Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>"},{"location":"arch/node/engines/reads_for_environment.html#environment-summary","title":"Environment summary","text":"<pre><code>ReadsForEnvironment : Type := EngineEnv\n  ReadsForLocalState\n  ReadsForMailboxState\n  ReadsForTimerHandle;\n</code></pre>"},{"location":"arch/node/engines/reads_for_environment.html#example-of-a-reads-for-environment","title":"Example of a <code>Reads For</code> environment","text":"<pre><code>module reads_for_environment_example;\n\nreadsForEnvironmentExample : ReadsForEnvironment :=\n    mkEngineEnv@{\n      node := Curve25519PubKey \"0xabcd1234\";\n      name := \"reads_for\";\n      localState := mkReadsForLocalState@{\n        evidenceStore := Set.empty;\n        verifyEvidence := \\{ _ := true }\n      };\n      mailboxCluster := Map.empty;\n      acquaintances := Set.empty;\n      timers := []\n    }\n  ;\nend;\n</code></pre>"},{"location":"arch/node/engines/reads_for_messages.html","title":"Reads For Engine Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.reads_for_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["reads_for","engine-messages"]},{"location":"arch/node/engines/reads_for_messages.html#reads-for-messages","title":"<code>Reads For</code> Messages","text":"","tags":["reads_for","engine-messages"]},{"location":"arch/node/engines/reads_for_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type ReadsForMsg :=  | ReadsForRequest {      externalIdentityA : ExternalIdentity;      externalIdentityB : ExternalIdentity    }  | ReadsForResponse {      readsFor : Bool;      err : Option String    }  | SubmitReadsForEvidenceRequest {evidence : ReadsForEvidence}  | SubmitReadsForEvidenceResponse {err : Option String}  | QueryReadsForEvidenceRequest {externalIdentity : ExternalIdentity}  | QueryReadsForEvidenceResponse {      externalIdentity : ExternalIdentity;      evidence : Set ReadsForEvidence;      err : Option String    };</pre></code></pre>","tags":["reads_for","engine-messages"]},{"location":"arch/node/engines/reads_for_messages.html#readsforrequest-message","title":"<code>ReadsForRequest</code> message","text":"<p>ReadsForRequest</p> <pre><code>ReadsForRequest {\n  externalIdentityA : ExternalIdentity;\n  externalIdentityB : ExternalIdentity\n}\n</code></pre> <p>A <code>ReadsForRequest</code> queries whether <code>externalIdentityA</code> can read data encrypted to <code>externalIdentityB</code>.</p> <ul> <li><code>externalIdentityA</code>: The identity attempting to read the data.</li> <li><code>externalIdentityB</code>: The identity for whom the data was originally encrypted.</li> </ul>","tags":["reads_for","engine-messages"]},{"location":"arch/node/engines/reads_for_messages.html#readsforresponse-message","title":"<code>ReadsForResponse</code> message","text":"<p>ReadsForResponse</p> <pre><code>ReadsForResponse {\n  readsFor : Bool;\n  err : Option String\n}\n</code></pre> <p>A <code>ReadsForResponse</code> indicates whether the <code>reads_for</code> relationship exists.</p> <ul> <li><code>readsFor</code>: True if externalIdentityA can read for externalIdentityB, False otherwise.</li> <li><code>err</code>: An error message if the query failed.</li> </ul>","tags":["reads_for","engine-messages"]},{"location":"arch/node/engines/reads_for_messages.html#submitreadsforevidencerequest-message","title":"<code>SubmitReadsForEvidenceRequest</code> message","text":"<p>SubmitReadsForEvidenceRequest</p> <pre><code>SubmitReadsForEvidenceRequest {\n  evidence : ReadsForEvidence\n}\n</code></pre> <p>A <code>SubmitReadsForEvidenceRequest</code> submits evidence of a <code>reads_for</code> relationship.</p> <ul> <li><code>evidence</code>: The evidence supporting the <code>reads_for</code> relationship.</li> </ul>","tags":["reads_for","engine-messages"]},{"location":"arch/node/engines/reads_for_messages.html#submitreadsforevidenceresponse-message","title":"<code>SubmitReadsForEvidenceResponse</code> message","text":"<p>SubmitReadsForEvidenceResponse</p> <pre><code>SubmitReadsForEvidenceResponse {\n  err : Option String\n}\n</code></pre> <p>A <code>SubmitReadsForEvidenceResponse</code> acknowledges the submission of evidence.</p> <ul> <li><code>err</code>: An error message if the submission failed.</li> </ul>","tags":["reads_for","engine-messages"]},{"location":"arch/node/engines/reads_for_messages.html#queryreadsforevidencerequest-message","title":"<code>QueryReadsForEvidenceRequest</code> message","text":"<p>QueryReadsForEvidenceRequest</p> <pre><code>QueryReadsForEvidenceRequest {\n  externalIdentity : ExternalIdentity\n}\n</code></pre> <p>A <code>QueryReadsForEvidenceRequest</code> queries all <code>reads_for</code> evidence related to an identity.</p> <ul> <li><code>externalIdentity</code>: The identity for which to retrieve evidence.</li> </ul>","tags":["reads_for","engine-messages"]},{"location":"arch/node/engines/reads_for_messages.html#queryreadsforevidenceresponse-message","title":"<code>QueryReadsForEvidenceResponse</code> message","text":"<p>QueryReadsForEvidenceResponse</p> <pre><code>QueryReadsForEvidenceResponse {\n  externalIdentity : ExternalIdentity;\n  evidence : Set ReadsForEvidence;\n  err : Option String\n}\n</code></pre> <p>A <code>QueryReadsForEvidenceResponse</code> provides the requested evidence.</p> <ul> <li><code>evidence</code>: A set of ReadsForEvidence related to the identity.</li> <li><code>err</code>: An error message if the query failed.</li> </ul>","tags":["reads_for","engine-messages"]},{"location":"arch/node/engines/reads_for_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["reads_for","engine-messages"]},{"location":"arch/node/engines/reads_for_messages.html#submitting-reads-for-evidence","title":"Submitting Reads For Evidence","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant ReadsForEngine\n\n    Client-&gt;&gt;ReadsForEngine: SubmitReadsForEvidenceRequest\n    Note over ReadsForEngine: Verify and store evidence\n    ReadsForEngine-&gt;&gt;Client: SubmitReadsForEvidenceResponse</code></pre>  Submitting <code>reads_for</code> evidence","tags":["reads_for","engine-messages"]},{"location":"arch/node/engines/reads_for_messages.html#querying-reads-for-relationship","title":"Querying Reads For Relationship","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant ReadsForEngine\n\n    Client-&gt;&gt;ReadsForEngine: ReadsForRequest (A reads for B?)\n    Note over ReadsForEngine: Check stored evidence\n    ReadsForEngine-&gt;&gt;Client: ReadsForResponse</code></pre>  Querying a <code>reads_for</code> relationship","tags":["reads_for","engine-messages"]},{"location":"arch/node/engines/reads_for_messages.html#querying-reads-for-evidence","title":"Querying Reads For Evidence","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant ReadsForEngine\n\n    Client-&gt;&gt;ReadsForEngine: QueryReadsForEvidenceRequest (for X)\n    Note over ReadsForEngine: Retrieve relevant evidence\n    ReadsForEngine-&gt;&gt;Client: QueryReadsForEvidenceResponse</code></pre>  Querying <code>reads_for</code> evidence for an identity","tags":["reads_for","engine-messages"]},{"location":"arch/node/engines/reads_for_messages.html#engine-components","title":"Engine Components","text":"<ul> <li><code>Reads For</code> Engine Environment</li> <li><code>Reads For</code> Engine Dynamics</li> </ul>","tags":["reads_for","engine-messages"]},{"location":"arch/node/engines/reads_for_messages.html#useful-links","title":"Useful links","text":"","tags":["reads_for","engine-messages"]},{"location":"arch/node/engines/signs_for.html","title":"Signs For Engine","text":"<p>Failure</p> <p>[11 of 16] Compiling arch.node.engines.signs_for_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/signs_for_environment.juvix.md:74:7-11: error: Unexpected argument node</p> <p>icon: octicons/project-template-24 search:   exclude: false tags: - signs_for - engines</p> Juvix imports <pre><code>module arch.node.engines.signs_for;\n\nimport prelude open;\nimport arch.node.types.engine open;\n\nimport arch.node.engines.signs_for_messages open public;\nimport arch.node.engines.signs_for_environment open public;\nimport arch.node.engines.signs_for_behaviour open public;\nopen signs_for_environment_example;\n</code></pre>"},{"location":"arch/node/engines/signs_for.html#signsfor-engine","title":"SignsFor Engine","text":"<p>The Signs For Engine manages <code>signs_for</code> relationships between identities. A <code>signs_for</code> relationship indicates that one identity can produce signatures (commitments) on behalf of another identity.</p>"},{"location":"arch/node/engines/signs_for.html#purpose","title":"Purpose","text":"<p>The Signs For Engine maintains and manages the state of <code>signs_for</code> relationships between identities. It handles queries about these relationships, allows submission of new evidence, and provides information about existing relationships. This is useful in scenarios where signature delegation or proxy signing is required.</p>"},{"location":"arch/node/engines/signs_for.html#components","title":"Components","text":"<ul> <li>SignsFor Messages</li> <li>SignsFor Environment</li> <li>SignsFor Behaviour</li> </ul>"},{"location":"arch/node/engines/signs_for.html#useful-links","title":"Useful links","text":"<ul> <li>Composable Semantic Models for Actor Theories</li> </ul>"},{"location":"arch/node/engines/signs_for.html#type","title":"Type","text":"<pre><code>SignsForEngine : Type := Engine\n  SignsForLocalState\n  SignsForMailboxState\n  SignsForTimerHandle\n  SignsForMatchableArgument\n  SignsForActionLabel\n  SignsForPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/signs_for.html#example-of-a-signsfor-engine","title":"Example of a signsFor engine","text":"<pre><code>exampleSignsForEngine : SignsForEngine :=\n  mkEngine@{\n    behaviour := signsForBehaviour;\n    initEnv := signsForEnvironmentExample;\n  };\n</code></pre> <p>where <code>signsForEnvironmentExample</code> is defined as follows:</p> <pre><code><pre>signsForEnvironmentExample : SignsForEnvironment :=  mkEngineEnvironment@{    name := \"signs_for\";    localState :=      mkSignsForLocalState@{        evidenceStore := Set.empty;        verifyEvidence := \\{_ := true};      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>"},{"location":"arch/node/engines/signs_for_behaviour.html","title":"Signs For Engine Behaviour","text":"<p>Failure</p> <p>[10 of 14] Compiling arch.node.engines.signs_for_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/signs_for_environment.juvix.md:74:7-11: error: Unexpected argument node</p> <p>icon: octicons/gear-16 search:   exclude: false categories: - engine-behaviour - juvix-module tags: - signs_for - engine-behavior</p> Juvix imports <pre><code>module arch.node.engines.signs_for_behaviour;\n\nimport prelude open;\nimport arch.node.types.messages open;\nimport arch.node.types.engine_behaviour open;\nimport arch.node.types.engine_environment open;\nimport arch.node.types.identities open;\nimport arch.node.engines.signs_for_environment open;\nimport arch.node.engines.signs_for_messages open;\nimport arch.node.types.anoma_message open;\n</code></pre>"},{"location":"arch/node/engines/signs_for_behaviour.html#signs-for-dynamics","title":"<code>Signs For</code> Dynamics","text":""},{"location":"arch/node/engines/signs_for_behaviour.html#overview","title":"Overview","text":"<p>The behavior of the Signs For Engine define how it processes incoming messages and updates its state accordingly.</p>"},{"location":"arch/node/engines/signs_for_behaviour.html#action-labels","title":"Action labels","text":"<pre><code>type SignsForActionLabel :=\n  | -- --8&lt;-- [start:DoSignsForQuery]\n    DoSignsForQuery {\n      externalIdentityA : ExternalIdentity;\n      externalIdentityB : ExternalIdentity\n    }\n    -- --8&lt;-- [end:DoSignsForQuery]\n  | -- --8&lt;-- [start:DoSubmitEvidence]\n    DoSubmitEvidence {\n      evidence : SignsForEvidence\n    }\n    -- --8&lt;-- [end:DoSubmitEvidence]\n  | -- --8&lt;-- [start:DoQueryEvidence]\n    DoQueryEvidence {\n      externalIdentity : ExternalIdentity\n    }\n    -- --8&lt;-- [end:DoQueryEvidence]\n;\n</code></pre>"},{"location":"arch/node/engines/signs_for_behaviour.html#dosignsforquery","title":"<code>DoSignsForQuery</code>","text":"<p>DoSignsForQuery {   externalIdentityA : ExternalIdentity;   externalIdentityB : ExternalIdentity }</p> <p>This action label corresponds to processing a signs_for query.</p> <code>DoSignsForQuery</code> action effect <p>This action does the following:</p> Aspect Description State update The state remains unchanged. Messages to be sent A <code>SignsForResponse</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/signs_for_behaviour.html#dosubmitevidence","title":"<code>DoSubmitEvidence</code>","text":"<p>DoSubmitEvidence {   evidence : SignsForEvidence }</p> <p>This action label corresponds to submitting new signs_for evidence.</p> <code>DoSubmitEvidence</code> action effect <p>This action does the following:</p> Aspect Description State update If the evidence doesn't already exist and is valid, it's added to the <code>evidenceStore</code> in the local state. Messages to be sent A <code>SubmitSignsForEvidenceResponse</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/signs_for_behaviour.html#doqueryevidence","title":"<code>DoQueryEvidence</code>","text":"<p>DoQueryEvidence {   externalIdentity : ExternalIdentity }</p> <p>This action label corresponds to querying signs_for evidence for a specific identity.</p> <code>DoQueryEvidence</code> action effect <p>This action does the following:</p> Aspect Description State update The state remains unchanged. Messages to be sent A <code>QuerySignsForEvidenceResponse</code> message is sent back to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/signs_for_behaviour.html#matchable-arguments","title":"Matchable arguments","text":"<pre><code>type SignsForMatchableArgument :=\n  | -- --8&lt;-- [start:ReplyTo]\n  ReplyTo (Option EngineID) (Option MailboxID)\n  -- --8&lt;-- [end:ReplyTo]\n;\n</code></pre>"},{"location":"arch/node/engines/signs_for_behaviour.html#replyto","title":"<code>ReplyTo</code>","text":"<pre><code>ReplyTo (Option EngineID) (Option MailboxID)\n</code></pre> <p>This matchable argument contains the address and mailbox ID of where the response message should be sent.</p>"},{"location":"arch/node/engines/signs_for_behaviour.html#precomputation-results","title":"Precomputation results","text":"<p>The Signs For Engine does not require any non-trivial pre-computations.</p> <pre><code>syntax alias SignsForPrecomputation := Unit;\n</code></pre>"},{"location":"arch/node/engines/signs_for_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code <p>Type alias for the guard.</p> <pre><code>-- --8&lt;-- [start:signs-for-guard]\nSignsForGuard : Type :=\n  Guard\n    SignsForLocalState\n    SignsForMailboxState\n    SignsForTimerHandle\n    SignsForMatchableArgument\n    SignsForActionLabel\n    SignsForPrecomputation;\n-- --8&lt;-- [end:signs-for-guard]\n\n-- --8&lt;-- [start:signs-for-guard-output]\nSignsForGuardOutput : Type :=\n  GuardOutput SignsForMatchableArgument SignsForActionLabel SignsForPrecomputation;\n-- --8&lt;-- [end:signs-for-guard-output]\n</code></pre>"},{"location":"arch/node/engines/signs_for_behaviour.html#signsforqueryguard","title":"<code>signsForQueryGuard</code>","text":"<pre><code>flowchart TD\n    C{SignsForRequest&lt;br&gt;received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoSignsForQuery])</code></pre> signsForQueryGuard flowchart <pre><code>signsForQueryGuard\n  (t : TimestampedTrigger SignsForTimerHandle)\n  (env : SignsForEnvironment) : Option SignsForGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgSignsFor (SignsForRequest x y)) := do {\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n                matchedArgs := [ReplyTo (some sender) none] ;\n                actionLabel := DoSignsForQuery x y;\n                precomputationTasks := unit\n        });}\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/signs_for_behaviour.html#submitevidenceguard","title":"<code>submitEvidenceGuard</code>","text":"<pre><code>flowchart TD\n    C{SubmitSignsForEvidence&lt;br&gt;Request received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoSubmitEvidence])</code></pre> submitEvidenceGuard flowchart <pre><code>submitEvidenceGuard\n  (t : TimestampedTrigger SignsForTimerHandle)\n  (env : SignsForEnvironment) : Option SignsForGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgSignsFor (SubmitSignsForEvidenceRequest x)) := do {\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n                matchedArgs := [ReplyTo (some sender) none] ;\n                actionLabel := DoSubmitEvidence x;\n                precomputationTasks := unit\n        });}\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/signs_for_behaviour.html#queryevidenceguard","title":"<code>queryEvidenceGuard</code>","text":"<pre><code>flowchart TD\n    C{QuerySignsForEvidence&lt;br&gt;Request received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoQueryEvidence])</code></pre> queryEvidenceGuard flowchart <pre><code>queryEvidenceGuard\n  (t : TimestampedTrigger SignsForTimerHandle)\n  (env : SignsForEnvironment) : Option SignsForGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgSignsFor (QuerySignsForEvidenceRequest x)) := do {\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n                matchedArgs := [ReplyTo (some sender) none] ;\n                actionLabel := DoQueryEvidence x;\n                precomputationTasks := unit\n                });\n        }\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/signs_for_behaviour.html#action-function","title":"Action function","text":"Auxiliary Juvix code <p>Type alias for the action function.</p> <pre><code>SignsForActionInput : Type :=\n  ActionInput\n    SignsForLocalState\n    SignsForMailboxState\n    SignsForTimerHandle\n    SignsForMatchableArgument\n    SignsForActionLabel\n    SignsForPrecomputation;\n\nSignsForActionEffect : Type :=\n  ActionEffect\n    SignsForLocalState\n    SignsForMailboxState\n    SignsForTimerHandle\n    SignsForMatchableArgument\n    SignsForActionLabel\n    SignsForPrecomputation;\n</code></pre> <pre><code>signsForAction (input : SignsForActionInput) : SignsForActionEffect :=\n  let env := ActionInput.env input;\n      out := ActionInput.guardOutput input;\n      localState := EngineEnv.localState env;\n  in\n  case GuardOutput.actionLabel out of {\n    | DoSignsForQuery externalIdentityA externalIdentityB :=\n      case GuardOutput.matchedArgs out of {\n        | (ReplyTo (some whoAsked) _) :: _ := let\n            hasEvidence := isElement \\{a b := a &amp;&amp; b} true (map \\{ evidence :=\n              isEqual (Ord.cmp (SignsForEvidence.fromIdentity evidence) externalIdentityA) &amp;&amp;\n              isEqual (Ord.cmp (SignsForEvidence.toIdentity evidence) externalIdentityB)\n            } (Set.toList (SignsForLocalState.evidenceStore localState)));\n            responseMsg := SignsForResponse@{\n              signsFor := hasEvidence;\n              err := none\n            };\n          in mkActionEffect@{\n            newEnv := env; -- No state change\n            producedMessages := [mkEngineMsg@{\n              sender := mkPair none (some (EngineEnv.name env));\n              target := whoAsked;\n              mailbox := some 0;\n              msg := MsgSignsFor responseMsg\n            }];\n            timers := [];\n            spawnedEngines := []\n          }\n        | _ := mkActionEffect@{newEnv := env; producedMessages := []; timers := []; spawnedEngines := []}\n      }\n    | DoSubmitEvidence evidence :=\n      case GuardOutput.matchedArgs out of {\n        | (ReplyTo (some whoAsked) _) :: _ :=\n            let isValid := SignsForLocalState.verifyEvidence localState evidence;\n            in\n            case isValid of {\n              | true :=\n                  let alreadyExists :=\n                    isElement \\{a b := a &amp;&amp; b} true (map \\{e :=\n                        isEqual (Ord.cmp e evidence)\n                      } (Set.toList (SignsForLocalState.evidenceStore localState)));\n                  in\n                  case alreadyExists of {\n                    | true :=\n                        let responseMsg := SubmitSignsForEvidenceResponse@{\n                              err := some \"Evidence already exists.\"\n                            };\n                        in mkActionEffect@{\n                          newEnv := env;\n                          producedMessages := [mkEngineMsg@{\n                            sender := mkPair none (some (EngineEnv.name env));\n                            target := whoAsked;\n                            mailbox := some 0;\n                            msg := MsgSignsFor responseMsg\n                          }];\n                          timers := [];\n                          spawnedEngines := []\n                        }\n                    | false :=\n                        let newEvidenceStore := Set.insert evidence (SignsForLocalState.evidenceStore localState);\n                            updatedLocalState := localState@SignsForLocalState{\n                              evidenceStore := newEvidenceStore\n                            };\n                            newEnv' := env@EngineEnv{\n                              localState := updatedLocalState\n                            };\n                            responseMsg := SubmitSignsForEvidenceResponse@{\n                              err := none\n                            };\n                        in mkActionEffect@{\n                          newEnv := newEnv';\n                          producedMessages := [mkEngineMsg@{\n                            sender := mkPair none (some (EngineEnv.name env));\n                            target := whoAsked;\n                            mailbox := some 0;\n                            msg := MsgSignsFor responseMsg\n                          }];\n                          timers := [];\n                          spawnedEngines := []\n                        }\n                  }\n              | false :=\n                  let responseMsg := SubmitSignsForEvidenceResponse@{\n                        err := some \"Invalid evidence provided.\"\n                      };\n                  in mkActionEffect@{\n                    newEnv := env;\n                    producedMessages := [mkEngineMsg@{\n                      sender := mkPair none (some (EngineEnv.name env));\n                      target := whoAsked;\n                      mailbox := some 0;\n                      msg := MsgSignsFor responseMsg\n                    }];\n                    timers := [];\n                    spawnedEngines := []\n                  }\n            }\n        | _ := mkActionEffect@{\n            newEnv := env;\n            producedMessages := [];\n            timers := [];\n            spawnedEngines := []\n          }\n      }\n    | DoQueryEvidence externalIdentity' :=\n      case GuardOutput.matchedArgs out of {\n        | (ReplyTo (some whoAsked) _) :: _ := let\n            relevantEvidence := AVLTree.filter \\{evidence :=\n              isEqual (Ord.cmp (SignsForEvidence.fromIdentity evidence) externalIdentity') ||\n              isEqual (Ord.cmp (SignsForEvidence.toIdentity evidence) externalIdentity')\n            } (SignsForLocalState.evidenceStore localState);\n            responseMsg := QuerySignsForEvidenceResponse@{\n              externalIdentity := externalIdentity';\n              evidence := relevantEvidence;\n              err := none\n            };\n          in mkActionEffect@{\n            newEnv := env; -- No state change\n            producedMessages := [mkEngineMsg@{\n              sender := mkPair none (some (EngineEnv.name env));\n              target := whoAsked;\n              mailbox := some 0;\n              msg := MsgSignsFor responseMsg\n            }];\n            timers := [];\n            spawnedEngines := []\n          }\n        | _ := mkActionEffect@{newEnv := env; producedMessages := []; timers := []; spawnedEngines := []}\n      }\n  };\n</code></pre>"},{"location":"arch/node/engines/signs_for_behaviour.html#conflict-solver","title":"Conflict solver","text":"<pre><code>signsForConflictSolver : Set SignsForMatchableArgument -&gt; List (Set SignsForMatchableArgument)\n  | _ := [];\n</code></pre>"},{"location":"arch/node/engines/signs_for_behaviour.html#signsforbehaviour-type","title":"SignsForBehaviour type","text":"<pre><code>SignsForBehaviour : Type :=\n  EngineBehaviour\n    SignsForLocalState\n    SignsForMailboxState\n    SignsForTimerHandle\n    SignsForMatchableArgument\n    SignsForActionLabel\n    SignsForPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/signs_for_behaviour.html#signsforbehaviour-instance","title":"SignsForBehaviour instance","text":"<pre><code>signsForBehaviour : SignsForBehaviour :=\n  mkEngineBehaviour@{\n    guards := [signsForQueryGuard; submitEvidenceGuard; queryEvidenceGuard];\n    action := signsForAction;\n    conflictSolver := signsForConflictSolver;\n  };\n</code></pre>"},{"location":"arch/node/engines/signs_for_environment.html","title":"Signs For Engine Environment","text":"<p>Failure</p> <p>[6 of 8] Compiling arch.node.engines.signs_for_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/signs_for_environment.juvix.md:74:7-11: error: Unexpected argument node</p> <p>icon: octicons/container-24 search:   exclude: false categories: - engine-behaviour tags: - signs_for - engine-environment</p> Juvix imports <pre><code>module arch.node.engines.signs_for_environment;\n\nimport prelude open;\nimport arch.node.types.messages open;\nimport arch.node.types.engine_environment open;\nimport arch.node.types.identities open;\nimport arch.node.engines.signs_for_messages open;\n</code></pre>"},{"location":"arch/node/engines/signs_for_environment.html#signs-for-environment","title":"Signs For Environment","text":""},{"location":"arch/node/engines/signs_for_environment.html#overview","title":"Overview","text":"<p>The Signs For Engine environment maintains the state necessary for managing <code>signs_for</code> relationships between identities, including storing evidence submitted by clients.</p>"},{"location":"arch/node/engines/signs_for_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The Signs For Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p> <pre><code>syntax alias SignsForMailboxState := Unit;\n</code></pre>"},{"location":"arch/node/engines/signs_for_environment.html#local-state","title":"Local state","text":"<p>The local state of the Signs For Engine includes the evidence for signs_for relationships.</p> <pre><code>type SignsForLocalState := mkSignsForLocalState@{\n  evidenceStore : Set SignsForEvidence;\n  verifyEvidence : SignsForEvidence -&gt; Bool;\n};\n</code></pre>"},{"location":"arch/node/engines/signs_for_environment.html#timer-handle","title":"Timer Handle","text":"<pre><code>syntax alias SignsForTimerHandle := Unit;\n</code></pre> <p>The Signs For Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>"},{"location":"arch/node/engines/signs_for_environment.html#environment-summary","title":"Environment summary","text":"<pre><code>SignsForEnvironment : Type := EngineEnv\n  SignsForLocalState\n  SignsForMailboxState\n  SignsForTimerHandle;\n</code></pre>"},{"location":"arch/node/engines/signs_for_environment.html#example-of-a-signs-for-environment","title":"Example of a <code>Signs For</code> environment","text":"<pre><code>module signs_for_environment_example;\n\nsignsForEnvironmentExample : SignsForEnvironment :=\n    mkEngineEnv@{\n      node := Curve25519PubKey \"0xabcd1234\";\n      name := \"signs_for\";\n      localState := mkSignsForLocalState@{\n        evidenceStore := Set.empty;\n        verifyEvidence := \\{ _ := true }\n      };\n      mailboxCluster := Map.empty;\n      acquaintances := Set.empty;\n      timers := []\n    }\n  ;\nend;\n</code></pre>"},{"location":"arch/node/engines/signs_for_messages.html","title":"Signs For Engine Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.signs_for_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["signs_for","engine-messages"]},{"location":"arch/node/engines/signs_for_messages.html#signs-for-messages","title":"<code>Signs For</code> Messages","text":"","tags":["signs_for","engine-messages"]},{"location":"arch/node/engines/signs_for_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type SignsForMsg :=  | SignsForRequest {      externalIdentityA : ExternalIdentity;      externalIdentityB : ExternalIdentity    }  | SignsForResponse {      signsFor : Bool;      err : Option String    }  | SubmitSignsForEvidenceRequest {evidence : SignsForEvidence}  | SubmitSignsForEvidenceResponse {err : Option String}  | QuerySignsForEvidenceRequest {externalIdentity : ExternalIdentity}  | QuerySignsForEvidenceResponse {      externalIdentity : ExternalIdentity;      evidence : Set SignsForEvidence;      err : Option String    };</pre></code></pre>","tags":["signs_for","engine-messages"]},{"location":"arch/node/engines/signs_for_messages.html#signsforrequest-message","title":"<code>SignsForRequest</code> message","text":"<p>SignsForRequest</p> <pre><code>SignsForRequest {\n  externalIdentityA : ExternalIdentity;\n  externalIdentityB : ExternalIdentity\n}\n</code></pre> <p>A <code>SignsForRequest</code> queries whether <code>externalIdentityA</code> can sign on behalf of <code>externalIdentityB</code>.</p> <ul> <li><code>externalIdentityA</code>: The identity attempting to sign.</li> <li><code>externalIdentityB</code>: The identity on whose behalf the signature is made.</li> </ul>","tags":["signs_for","engine-messages"]},{"location":"arch/node/engines/signs_for_messages.html#signsforresponse-message","title":"<code>SignsForResponse</code> message","text":"<p>SignsForResponse</p> <pre><code>SignsForResponse {\n  signsFor : Bool;\n  err : Option String\n}\n</code></pre> <p>A <code>SignsForResponse</code> indicates whether the <code>signs_for</code> relationship exists.</p> <ul> <li><code>signsFor</code>: True if externalIdentityA can sign for externalIdentityB, False otherwise.</li> <li><code>err</code>: An error message if the query failed.</li> </ul>","tags":["signs_for","engine-messages"]},{"location":"arch/node/engines/signs_for_messages.html#submitsignsforevidencerequest-message","title":"<code>SubmitSignsForEvidenceRequest</code> message","text":"<p>SubmitSignsForEvidenceRequest</p> <pre><code>SubmitSignsForEvidenceRequest {\n  evidence : SignsForEvidence\n}\n</code></pre> <p>A <code>SubmitSignsForEvidenceRequest</code> submits evidence of a <code>signs_for</code> relationship.</p> <ul> <li><code>evidence</code>: The evidence supporting the <code>signs_for</code> relationship.</li> </ul>","tags":["signs_for","engine-messages"]},{"location":"arch/node/engines/signs_for_messages.html#submitsignsforevidenceresponse-message","title":"<code>SubmitSignsForEvidenceResponse</code> message","text":"<p>SubmitSignsForEvidenceResponse</p> <pre><code>SubmitSignsForEvidenceResponse {\n  err : Option String\n}\n</code></pre> <p>A <code>SubmitSignsForEvidenceResponse</code> acknowledges the submission of evidence.</p> <ul> <li><code>err</code>: An error message if the submission failed.</li> </ul>","tags":["signs_for","engine-messages"]},{"location":"arch/node/engines/signs_for_messages.html#querysignsforevidencerequest-message","title":"<code>QuerySignsForEvidenceRequest</code> message","text":"<p>QuerySignsForEvidenceRequest</p> <pre><code>QuerySignsForEvidenceRequest {\n  externalIdentity : ExternalIdentity\n}\n</code></pre> <p>A <code>QuerySignsForEvidenceRequest</code> queries all <code>signs_for</code> evidence related to an identity.</p> <ul> <li><code>externalIdentity</code>: The identity for which to retrieve evidence.</li> </ul>","tags":["signs_for","engine-messages"]},{"location":"arch/node/engines/signs_for_messages.html#querysignsforevidenceresponse-message","title":"<code>QuerySignsForEvidenceResponse</code> message","text":"<p>QuerySignsForEvidenceResponse</p> <pre><code>QuerySignsForEvidenceResponse {\n  externalIdentity : ExternalIdentity;\n  evidence : Set SignsForEvidence;\n  err : Option String\n}\n</code></pre> <p>A <code>QuerySignsForEvidenceResponse</code> provides the requested evidence.</p> <ul> <li><code>evidence</code>: A set of SignsForEvidence related to the identity.</li> <li><code>err</code>: An error message if the query failed.</li> </ul>","tags":["signs_for","engine-messages"]},{"location":"arch/node/engines/signs_for_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["signs_for","engine-messages"]},{"location":"arch/node/engines/signs_for_messages.html#submitting-signs-for-evidence","title":"Submitting Signs For Evidence","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant SignsForEngine\n\n    Client-&gt;&gt;SignsForEngine: SubmitSignsForEvidenceRequest\n    Note over SignsForEngine: Process and store evidence\n    SignsForEngine-&gt;&gt;Client: SubmitSignsForEvidenceResponse</code></pre>  Submitting evidence of a signs_for relationship","tags":["signs_for","engine-messages"]},{"location":"arch/node/engines/signs_for_messages.html#querying-signs-for-relationship","title":"Querying Signs For Relationship","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant SignsForEngine\n\n    Client-&gt;&gt;SignsForEngine: SignsForRequest (X signs for Y?)\n    Note over SignsForEngine: Check stored evidence\n    SignsForEngine-&gt;&gt;Client: SignsForResponse</code></pre>  Querying whether a specific signs_for relationship exists","tags":["signs_for","engine-messages"]},{"location":"arch/node/engines/signs_for_messages.html#retrieving-signs-for-evidence","title":"Retrieving Signs For Evidence","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant SignsForEngine\n\n    Client-&gt;&gt;SignsForEngine: QuerySignsForEvidenceRequest (for X)\n    Note over SignsForEngine: Retrieve relevant evidence\n    SignsForEngine-&gt;&gt;Client: QuerySignsForEvidenceResponse</code></pre>  Retrieving all signs_for evidence related to a particular identity","tags":["signs_for","engine-messages"]},{"location":"arch/node/engines/signs_for_messages.html#engine-components","title":"Engine Components","text":"<ul> <li><code>Signs For</code> Engine Environment</li> <li><code>Signs For</code> Engine Dynamics</li> </ul>","tags":["signs_for","engine-messages"]},{"location":"arch/node/engines/signs_for_messages.html#useful-links","title":"Useful links","text":"","tags":["signs_for","engine-messages"]},{"location":"arch/node/engines/solver.html","title":"Solver","text":"<ul> <li>Inputs     Intents</li> <li>Outputs     Partially/fully matched intents</li> <li>Preferences     What/when to match, what to charge (for partial solving), how to deal w/surplus</li> <li>Accounting     Solving actually done</li> </ul>"},{"location":"arch/node/engines/storage.html","title":"Storage","text":"<ul> <li>Inputs     - Data to store with preferences (locality, redundancy, duration)     - Requests to fetch data</li> <li>Outputs     - Data fetched (locally or remotely)</li> <li>Preferences     - When to store for other nodes     - Trust info for cache rebalancing</li> <li>Accounting     - Local storage info, storage granted to other nodes, cache latency</li> </ul>","boost":2},{"location":"arch/node/engines/strategy.html","title":"Strategy synthesis","text":"<ul> <li>Inputs     User instructions</li> <li>Outputs     Intents, decisions</li> <li>Preferences     User-defined</li> <li>Accounting     Decisions made, intents created</li> </ul> <p>Examples:</p> <ul> <li>Automatically grant kudos for trade between compute, storage, network resources</li> <li>Automatically rebalance kudo portfolio</li> <li>Decide whether to use locally controlled liquidity for solving</li> <li>Create intent to match 1:1 kudo liquidity each day</li> </ul> <p>Tracks trust preferences.</p>","boost":2},{"location":"arch/node/engines/template.html","title":"Template Engine","text":"Juvix preamble <p><pre><code><pre>module arch.node.engines.template;import prelude open;import arch.node.engines.template_messages open public;import arch.node.engines.template_config open public;import arch.node.engines.template_environment open public;import arch.node.engines.template_behaviour open public;import arch.node.types.engine open public;import arch.node.types.anoma as Anoma open;open template_config_example;open template_environment_example;</pre></code></pre></p>","tags":["template-engine","engine-definition"]},{"location":"arch/node/engines/template.html#template-engine","title":"Template Engine","text":"","tags":["template-engine","engine-definition"]},{"location":"arch/node/engines/template.html#purpose","title":"Purpose","text":"<p>Brief summary of the purpose of the engine.</p>","tags":["template-engine","engine-definition"]},{"location":"arch/node/engines/template.html#components","title":"Components","text":"<ul> <li>Template Messages</li> <li>Template Configuration</li> <li>Template Environment</li> <li>Template Behaviour</li> </ul>","tags":["template-engine","engine-definition"]},{"location":"arch/node/engines/template.html#useful-links","title":"Useful links","text":"<ul> <li>Some</li> <li>Useful</li> <li>Links</li> </ul>","tags":["template-engine","engine-definition"]},{"location":"arch/node/engines/template.html#type","title":"Type","text":"<pre><code><pre>TemplateEngine : Type :=  Engine    TemplateCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["template-engine","engine-definition"]},{"location":"arch/node/engines/template.html#example-of-a-template-engine","title":"Example of a template engine","text":"<pre><code><pre>exampleTemplateEngine : TemplateEngine :=  mkEngine@{    cfg := templateCfg;    env := templateEnv;    behaviour := templateBehaviour;  };</pre></code></pre> <p>where <code>templateCfg</code> is defined as follows:</p> <pre><code><pre>templateCfg : EngineCfg TemplateCfg :=  mkEngineCfg@{    node := Curve25519PubKey \"0xabcd1234\";    name := \"template\";    cfg :=      mkTemplateCfg@{        example := 1;        value := \"hello world\";      };  };</pre></code></pre> <p><code>templateEnv</code> is defined as follows:</p> <pre><code><pre>templateEnv : TemplateEnv :=  mkEngineEnv@{    localState :=      mkTemplateLocalState@{        taskQueue :=          mkCustomData@{            word := \"taskQueue\";          };      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>templateBehaviour</code> is defined as follows:</p> <pre><code><pre>templateBehaviour : TemplateBehaviour :=  mkEngineBehaviour@{    guards := First [justHiGuard; exampleReplyGuard];  };</pre></code></pre> (Wiki) links on this page<ul><li>Template Messages</li><li>Template Environment</li><li>Template Behaviour</li></ul>","tags":["template-engine","engine-definition"]},{"location":"arch/node/engines/template_behaviour.html","title":"Template Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.template_behaviour;import arch.node.engines.template_messages open;import arch.node.engines.template_config open;import arch.node.engines.template_environment open;import prelude open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#template-behaviour","title":"Template Behaviour","text":"","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#overview","title":"Overview","text":"<p>A template engine acts in the ways described on this page. The action labels correspond to the actions that can be performed by the engine. Using the action labels, we describe the effects of the actions.</p>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#action-arguments","title":"Action arguments","text":"<p>The action arguments are set by a guard and passed to the action function as part of the <code>GuardOutput</code>.</p> Auxiliary Juvix code <p> <pre><code><pre>syntax alias Val := Nat;</pre></code></pre> </p>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#templateactionargumentone-firstargument","title":"<code>TemplateActionArgumentOne FirstArgument</code>","text":"<pre><code><pre>type FirstArgument := mkFirstArgument@{data : Val};</pre></code></pre> Arguments <code>data</code>: is the value of the action argument.","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#templateactionargumenttwo-secondargument","title":"<code>TemplateActionArgumentTwo SecondArgument</code>","text":"<pre><code><pre>type SecondArgument := mkSecondArgument@{data : String};</pre></code></pre> Arguments <code>data</code>: is the value of the action argument.","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#templateactionargument","title":"<code>TemplateActionArgument</code>","text":"<pre><code><pre>type TemplateActionArgument :=  | TemplateActionArgumentOne FirstArgument  | TemplateActionArgumentTwo SecondArgument;</pre></code></pre>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#templateactionarguments","title":"<code>TemplateActionArguments</code>","text":"<pre><code><pre>TemplateActionArguments : Type := List TemplateActionArgument;</pre></code></pre>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#templateaction","title":"<code>TemplateAction</code>","text":"<p> <pre><code><pre>TemplateAction : Type :=  Action    TemplateCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#templateactioninput","title":"<code>TemplateActionInput</code>","text":"<p> <pre><code><pre>TemplateActionInput : Type :=  ActionInput    TemplateCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg;</pre></code></pre> </p>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#templateactioneffect","title":"<code>TemplateActionEffect</code>","text":"<p> <pre><code><pre>TemplateActionEffect : Type :=  ActionEffect    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#templateactionexec","title":"<code>TemplateActionExec</code>","text":"<p> <pre><code><pre>TemplateActionExec : Type :=  ActionExec    TemplateCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#justhiaction","title":"<code>justHiAction</code>","text":"<p>Action description.</p> State update Update state with the data set by <code>justHiGuard</code>. Messages to be sent No messages are added to the send queue. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. Acquaintance updates None. <pre><code><pre>justHiAction (input : TemplateActionInput) : Option TemplateActionEffect :=  let    args := ActionInput.args input;    env := ActionInput.env input;  in case args of       | TemplateActionArgumentTwo mkSecondArgument@{data := data} :: _ :=         some           mkActionEffect@{             env :=               env@EngineEnv{localState := mkTemplateLocalState@{                                             taskQueue :=                                               mkCustomData@{                                                 word := data;                                               };                                           }};             msgs := [];             timers := [];             engines := [];           }       | _ := none;</pre></code></pre>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#examplereplyaction","title":"<code>exampleReplyAction</code>","text":"<p>Respond with a <code>TemplateMsgExampleResponse</code>.</p> State update The state remains unchanged. Messages to be sent A <code>TemplateMsgExampleReply</code> message with the data set by <code>exampleReplyGuard</code>. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>exampleReplyAction  (input : TemplateActionInput) : Option TemplateActionEffect :=  let    cfg := ActionInput.cfg input;    env := ActionInput.env input;    trigger := ActionInput.trigger input;  in case getEngineMsgFromTimestampedTrigger trigger of       | some mkEngineMsg@{                msg := Anoma.MsgTemplate (TemplateMsgExampleRequest req);                sender := sender;                target := target;                mailbox := mailbox;              } :=         some           mkActionEffect@{             env := env;             msgs :=               [                 mkEngineMsg@{                   sender := getEngineIDFromEngineCfg cfg;                   target := sender;                   mailbox := some 0;                   msg :=                     Anoma.MsgTemplate                       (TemplateMsgExampleReply                         (ok                           mkExampleReplyOk@{                             argOne := ExampleRequest.argOne req;                           }));                 };               ];             timers := [];             engines := [];           }       | _ := none;</pre></code></pre>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#justhiactionlabel","title":"<code>justHiActionLabel</code>","text":"<pre><code><pre>justHiActionLabel : TemplateActionExec := Seq [justHiAction];</pre></code></pre>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#examplereplyactionlabel","title":"<code>exampleReplyActionLabel</code>","text":"<pre><code><pre>exampleReplyActionLabel : TemplateActionExec := Seq [exampleReplyAction];</pre></code></pre>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#dobothactionlabel","title":"<code>doBothActionLabel</code>","text":"<pre><code><pre>doBothActionLabel : TemplateActionExec := Seq [justHiAction; exampleReplyAction];</pre></code></pre>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#templateguard","title":"<code>TemplateGuard</code>","text":"<p> <pre><code><pre>TemplateGuard : Type :=  Guard    TemplateCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#templateguardoutput","title":"<code>TemplateGuardOutput</code>","text":"<p> <pre><code><pre>TemplateGuardOutput : Type :=  GuardOutput    TemplateCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#templateguardeval","title":"<code>TemplateGuardEval</code>","text":"<p> <pre><code><pre>TemplateGuardEval : Type :=  GuardEval    TemplateCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#justhiguard","title":"<code>justHiGuard</code>","text":"<p>Guard description (optional).</p> Condition Message type is <code>TemplateMsgJustHi</code>. <pre><code><pre>justHiGuard  (trigger : TemplateTimestampedTrigger)  (cfg : EngineCfg TemplateCfg)  (env : TemplateEnv)  : Option TemplateGuardOutput :=  let    emsg := getEngineMsgFromTimestampedTrigger trigger;  in case emsg of       | some mkEngineMsg@{msg := Anoma.MsgTemplate TemplateMsgJustHi} :=         some           mkGuardOutput@{             action := justHiActionLabel;             args :=               [                 TemplateActionArgumentTwo                   mkSecondArgument@{                     data := \"Hello World!\";                   };               ];           }       | _ := none;</pre></code></pre>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#examplereplyguard","title":"<code>exampleReplyGuard</code>","text":"<p>Guard description (optional).</p> Condition Message type is <code>TemplateMsgExampleRequest</code>. <pre><code><pre>exampleReplyGuard  (tt : TemplateTimestampedTrigger)  (cfg : EngineCfg TemplateCfg)  (env : TemplateEnv)  : Option TemplateGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some mkEngineMsg@{             msg := Anoma.MsgTemplate (TemplateMsgExampleRequest req);             sender := mkPair none _;           } :=      some        mkGuardOutput@{          action := exampleReplyActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#the-template-behaviour","title":"The Template behaviour","text":"","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#templatebehaviour","title":"<code>TemplateBehaviour</code>","text":"<pre><code><pre>TemplateBehaviour : Type :=  EngineBehaviour    TemplateCfg    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    TemplateActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>templateBehaviour : TemplateBehaviour :=  mkEngineBehaviour@{    guards := First [justHiGuard; exampleReplyGuard];  };</pre></code></pre>","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#template-action-flowchart","title":"Template Action Flowchart","text":"","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#justhi-flowchart","title":"<code>justHi</code> Flowchart","text":"<pre><code>flowchart TD\n  CM&gt;TemplateMsgJustHi]\n  A(justHiAction)\n  ES[(State update)]\n\n  CM --justHiGuard--&gt; A --justHiActionLabel--&gt; ES</code></pre> <code>justHi</code> flowchart","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_behaviour.html#examplereply-flowchart","title":"<code>exampleReply</code> Flowchart","text":"<pre><code>flowchart TD\n  CM&gt;TemplateMsgExampleRequest]\n  CS[(State condition)]\n  A(exampleReplyAction)\n  ES[(State update)]\n  EM&gt;TemplateMsgExampleResponse]\n\n  CS &amp; CM --exampleReplyGuard--&gt; A --exampleReplyActionLabel--&gt; ES &amp; EM</code></pre> <code>exampleReply</code> flowchart","tags":["template-engine","engine-behaviour"]},{"location":"arch/node/engines/template_config.html","title":"Template config","text":"<ul> <li>engine</li> <li>node tags:</li> <li>template-engine</li> <li>engine-environment</li> </ul> Juvix imports <p><pre><code><pre>module arch.node.engines.template_config;import prelude open;import arch.node.engines.template_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;</pre></code></pre></p>"},{"location":"arch/node/engines/template_config.html#template-configuration","title":"Template Configuration","text":""},{"location":"arch/node/engines/template_config.html#overview","title":"Overview","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>"},{"location":"arch/node/engines/template_config.html#the-template-configuration","title":"The Template Configuration","text":""},{"location":"arch/node/engines/template_config.html#templatecfg","title":"<code>TemplateCfg</code>","text":"<pre><code><pre>type TemplateCfg :=  mkTemplateCfg@{    example : Nat;    value : String;  };</pre></code></pre>"},{"location":"arch/node/engines/template_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>templateCfg : EngineCfg TemplateCfg :=  mkEngineCfg@{    node := Curve25519PubKey \"0xabcd1234\";    name := \"template\";    cfg :=      mkTemplateCfg@{        example := 1;        value := \"hello world\";      };  };</pre></code></pre>"},{"location":"arch/node/engines/template_environment.html","title":"Template Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.template_environment;import prelude open;import arch.node.engines.template_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#template-environment","title":"Template Environment","text":"","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#overview","title":"Overview","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#mailbox-state-types","title":"Mailbox state types","text":"Auxiliary Juvix code <p><pre><code><pre>syntax alias MailboxOneOne := Nat;syntax alias MailboxTwoOne := String;syntax alias MailboxTwoTwo := Bool;</pre></code></pre></p>","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#templatemailboxstatefirstkind-firstkindmailboxstate","title":"<code>TemplateMailboxStateFirstKind FirstKindMailboxState</code>","text":"<pre><code><pre>type FirstKindMailboxState := mkFirstKindMailboxState@{fieldOne : MailboxOneOne};</pre></code></pre> <p>This is one family of mailbox states without much complexity.</p> Arguments <code>fieldOne</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#templatemailboxstatesecondkind-secondkindmailboxstate","title":"<code>TemplateMailboxStateSecondKind SecondKindMailboxState</code>","text":"<pre><code><pre>type SecondKindMailboxState :=  mkSecondKindMailboxState@{    fieldOne : MailboxTwoOne;    fieldTwo : MailboxTwoTwo;  };</pre></code></pre> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p> Arguments <code>fieldOne</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p> <code>fieldTwo</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#templatemailboxstate","title":"<code>TemplateMailboxState</code>","text":"<pre><code><pre>type TemplateMailboxState :=  | TemplateMailboxStateFirstKind FirstKindMailboxState  | TemplateMailboxStateSecondKind SecondKindMailboxState;</pre></code></pre>","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#local-state","title":"Local state","text":"Auxiliary Juvix code <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p> <p> <pre><code><pre>type CustomData := mkCustomData@{word : String};</pre></code></pre> </p> Arguments <code>word</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#templatelocalstate","title":"<code>TemplateLocalState</code>","text":"<pre><code><pre>type TemplateLocalState := mkTemplateLocalState@{taskQueue : CustomData};</pre></code></pre> Arguments <code>taskQueue</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#timer-handles","title":"Timer handles","text":"Auxiliary Juvix code <p> <pre><code><pre>syntax alias ArgOne := Nat;</pre></code></pre> </p>","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#templatetimerhandlefirstoption-firstoptiontimerhandle","title":"<code>TemplateTimerHandleFirstOption FirstOptionTimerHandle</code>","text":"<pre><code><pre>type FirstOptionTimerHandle := mkFirstOptionTimerHandle@{argOne : ArgOne};</pre></code></pre> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. The following code is an example of this case.</p> Arguments <code>argOne</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#templatetimerhandlesecondoption-secondoptiontimerhandle","title":"<code>TemplateTimerHandleSecondOption SecondOptionTimerHandle</code>","text":"<pre><code><pre>type SecondOptionTimerHandle :=  mkSecondOptionTimerHandle@{    argOne : String;    argTwo : Bool;  };</pre></code></pre> Arguments <code>argOne</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p> <code>argTwo</code> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#templatetimerhandle","title":"<code>TemplateTimerHandle</code>","text":"<pre><code><pre>type TemplateTimerHandle :=  | TemplateTimerHandleFirstOption FirstOptionTimerHandle  | TemplateTimerHandleSecondOption SecondOptionTimerHandle;</pre></code></pre>","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#templatetimestampedtrigger","title":"<code>TemplateTimestampedTrigger</code>","text":"<pre><code><pre>TemplateTimestampedTrigger : Type :=  TimestampedTrigger TemplateTimerHandle Anoma.Msg;</pre></code></pre>","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#the-template-environment","title":"The Template Environment","text":"","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#templateenv","title":"<code>TemplateEnv</code>","text":"<pre><code><pre>TemplateEnv : Type :=  EngineEnv    TemplateLocalState    TemplateMailboxState    TemplateTimerHandle    Anoma.Msg;</pre></code></pre>","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>templateEnv : TemplateEnv :=  mkEngineEnv@{    localState :=      mkTemplateLocalState@{        taskQueue :=          mkCustomData@{            word := \"taskQueue\";          };      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["template-engine","engine-environment"]},{"location":"arch/node/engines/template_messages.html","title":"Template Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.template_messages;import prelude open;</pre></code></pre></p>","tags":["template-engine","engine-messages"]},{"location":"arch/node/engines/template_messages.html#template-messages","title":"Template Messages","text":"<p>These are the messages that the Template engine can receive/respond to.</p>","tags":["template-engine","engine-messages"]},{"location":"arch/node/engines/template_messages.html#message-interface","title":"Message interface","text":"Auxiliary Juvix code <p><pre><code><pre>syntax alias MethodOneArgOne := Nat;syntax alias MethodOneArgTwo := Nat;syntax alias MethodOneArgThree := Nat;syntax alias MethodTwoArgOne := Nat;</pre></code></pre></p>","tags":["template-engine","engine-messages"]},{"location":"arch/node/engines/template_messages.html#templatemsgjusthi","title":"<code>TemplateMsgJustHi</code>","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>","tags":["template-engine","engine-messages"]},{"location":"arch/node/engines/template_messages.html#templatemsgexamplerequest-examplerequest","title":"<code>TemplateMsgExampleRequest ExampleRequest</code>","text":"<p>Example request.</p> <pre><code><pre>type ExampleRequest : Type :=  mkExampleRequest@{    argOne : Nat;    argTwo : Nat;  };</pre></code></pre> Arguments <code>argOne</code> Lorem ipsum dolor sit amet, consectetur adipiscing elit. <code>argTwo</code> Lorem ipsum dolor sit amet, consectetur adipiscing elit.","tags":["template-engine","engine-messages"]},{"location":"arch/node/engines/template_messages.html#templatemsgexamplereply-examplereply","title":"<code>TemplateMsgExampleReply ExampleReply</code>","text":"<p>Reply to an <code>ExampleRequest</code>.</p>","tags":["template-engine","engine-messages"]},{"location":"arch/node/engines/template_messages.html#examplereplyok","title":"<code>ExampleReplyOk</code>","text":"<p>Example OK reply.</p> <pre><code><pre>type ExampleReplyOk : Type := mkExampleReplyOk@{argOne : Nat};</pre></code></pre> Arguments <code>argOne</code> Lorem ipsum dolor sit amet, consectetur adipiscing elit.","tags":["template-engine","engine-messages"]},{"location":"arch/node/engines/template_messages.html#examplereplyerror","title":"<code>ExampleReplyError</code>","text":"<p>Example error reply.</p> <pre><code><pre>type ExampleReplyError : Type :=  | ExampleErrorOne  | ExampleErrorTwo;</pre></code></pre> Error types <code>ExampleErrorOne</code> Lorem ipsum dolor sit amet, consectetur adipiscing elit. <code>ExampleErrorTwo</code> Lorem ipsum dolor sit amet, consectetur adipiscing elit.","tags":["template-engine","engine-messages"]},{"location":"arch/node/engines/template_messages.html#examplereply","title":"<code>ExampleReply</code>","text":"<pre><code><pre>ExampleReply : Type := Result ExampleReplyError ExampleReplyOk;</pre></code></pre>","tags":["template-engine","engine-messages"]},{"location":"arch/node/engines/template_messages.html#templatemsg","title":"<code>TemplateMsg</code>","text":"<pre><code><pre>type TemplateMsg :=  | TemplateMsgJustHi  | TemplateMsgExampleRequest ExampleRequest  | TemplateMsgExampleReply ExampleReply;</pre></code></pre>","tags":["template-engine","engine-messages"]},{"location":"arch/node/engines/template_messages.html#sequence-diagrams","title":"Sequence Diagrams","text":"","tags":["template-engine","engine-messages"]},{"location":"arch/node/engines/template_messages.html#examplerequest-examplereply","title":"<code>ExampleRequest</code> &amp; <code>ExampleReply</code>","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ut purus eget sapien. Nulla facilisi.</p> <pre><code>sequenceDiagram\n    participant TemplateClient\n    participant Template\n\n    TemplateClient -&gt;&gt; Template: ExampleRequest\n    Template -&gt;&gt; TemplateClient: ExampleReplyOk\n\n    TemplateClient -&gt;&gt; Template: ExampleRequest\n    Template -&gt;&gt; TemplateClient: ExampleReplyErrorOne</code></pre>  Sequence Diagram: <code>ExampleRequest</code> &amp; <code>ExampleReply</code>","tags":["template-engine","engine-messages"]},{"location":"arch/node/engines/ticker.html","title":"Ticker Engine","text":"Juvix preamble <p><pre><code><pre>module arch.node.engines.ticker;import prelude open;import arch.node.types.engine_environment open;import arch.node.types.engine_behaviour open;import arch.node.types.engine open;import arch.node.engines.ticker_config open public;import arch.node.engines.ticker_messages open public;import arch.node.engines.ticker_environment open public;import arch.node.engines.ticker_behaviour open public;import arch.node.types.anoma as Anoma open;open ticker_config_example;open ticker_environment_example;</pre></code></pre></p>","tags":["ticker-engine","engine-definition"]},{"location":"arch/node/engines/ticker.html#ticker-engine","title":"Ticker Engine","text":"<p>The Ticker engine provides a simple counter functionality, allowing clients to increment a counter and retrieve its current value.</p>","tags":["ticker-engine","engine-definition"]},{"location":"arch/node/engines/ticker.html#purpose","title":"Purpose","text":"<p>A ticker engine maintains a counter in its local state. It increases the counter when it receives an <code>Increment</code> message and provides the updated result upon receiving a <code>Count</code> message. The initial state initializes the counter.</p>","tags":["ticker-engine","engine-definition"]},{"location":"arch/node/engines/ticker.html#components","title":"Components","text":"<ul> <li>Ticker Messages</li> <li>Ticker Config</li> <li>Ticker Environment</li> <li>Ticker Behaviour</li> </ul>","tags":["ticker-engine","engine-definition"]},{"location":"arch/node/engines/ticker.html#useful-links","title":"Useful links","text":"<ul> <li>Composable Semantic Models for Actor Theories</li> </ul>","tags":["ticker-engine","engine-definition"]},{"location":"arch/node/engines/ticker.html#type","title":"Type","text":"<pre><code><pre>TickerEngine : Type :=  Engine    TickerCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["ticker-engine","engine-definition"]},{"location":"arch/node/engines/ticker.html#example-of-a-ticker-engine","title":"Example of a ticker engine","text":"<pre><code><pre>exampleTickerEngine : TickerEngine :=  mkEngine@{    cfg := tickerCfg;    env := tickerEnv;    behaviour := tickerBehaviour;  };</pre></code></pre> <p>where <code>tickerCfg</code> is defined as follows:</p> <pre><code><pre>tickerCfg : EngineCfg TickerCfg :=  mkEngineCfg@{    node := Curve25519PubKey \"0xabcd1234\";    name := \"ticker\";    cfg :=      mkTickerCfg@{        example := 1;        value := \"hello world\";      };  };</pre></code></pre> <p><code>tickerEnv</code> is defined as follows:</p> <pre><code><pre>tickerEnv : TickerEnv :=  mkEngineEnv@{    localState :=      mkTickerLocalState@{        counter := 0;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre> <p>and <code>tickerBehaviour</code> is defined as follows:</p> <pre><code><pre>tickerBehaviour : TickerBehaviour :=  mkEngineBehaviour@{    guards := First [incrementGuard; countReplyGuard];  };</pre></code></pre> (Wiki) links on this page<ul><li>Ticker Messages</li><li>Ticker Environment</li><li>Ticker Behaviour</li></ul>","tags":["ticker-engine","engine-definition"]},{"location":"arch/node/engines/ticker_behaviour.html","title":"Ticker Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.ticker_behaviour;import arch.node.engines.ticker_messages open;import arch.node.engines.ticker_config open;import arch.node.engines.ticker_environment open;import prelude open;import arch.node.types.basics open;import arch.node.types.identities open;import arch.node.types.messages open;import arch.node.types.engine open;import arch.node.types.anoma as Anoma open;</pre></code></pre></p>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#ticker-behaviour","title":"Ticker Behaviour","text":"","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#overview","title":"Overview","text":"<p>The Ticker engine maintains a counter as local state and allows two actions: incrementing the counter and sending the current counter value.</p>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#action-arguments","title":"Action arguments","text":"","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickeractionargumentreplyto-replyto","title":"<code>TickerActionArgumentReplyTo ReplyTo</code>","text":"<pre><code><pre>type ReplyTo :=  mkReplyTo@{    whoAsked : Option EngineID;    mailbox : Option MailboxID;  };</pre></code></pre> <p>This action argument contains the address and mailbox ID of where the response message should be sent.</p> <code>whoAsked</code>: is the address of the engine that sent the message. <code>mailbox</code>: is the mailbox ID where the response message should be sent.","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickeractionargument","title":"<code>TickerActionArgument</code>","text":"<pre><code><pre>type TickerActionArgument := TickerActionArgumentReplyTo ReplyTo;</pre></code></pre>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickeractionarguments","title":"<code>TickerActionArguments</code>","text":"<pre><code><pre>TickerActionArguments : Type := List TickerActionArgument;</pre></code></pre>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#actions","title":"Actions","text":"Auxiliary Juvix code","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickeraction","title":"<code>TickerAction</code>","text":"<p><pre><code><pre>TickerAction : Type :=  Action    TickerCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickeractioninput","title":"<code>TickerActionInput</code>","text":"<p><pre><code><pre>TickerActionInput : Type :=  ActionInput    TickerCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg;</pre></code></pre></p>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickeractioneffect","title":"<code>TickerActionEffect</code>","text":"<p><pre><code><pre>TickerActionEffect : Type :=  ActionEffect    TickerLocalState    TickerMailboxState    TickerTimerHandle    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickeractionexec","title":"<code>TickerActionExec</code>","text":"<p><pre><code><pre>TickerActionExec : Type :=  ActionExec    TickerCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre></p>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#incrementaction","title":"<code>incrementAction</code>","text":"<p>Increment the counter.</p> State update The counter value is increased by one. Messages to be sent No messages are added to the send queue. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>incrementAction (input : TickerActionInput) : Option TickerActionEffect :=  let    env := ActionInput.env input;    counterValue := TickerLocalState.counter (EngineEnv.localState env);  in some    mkActionEffect@{      env :=        env@EngineEnv{localState := mkTickerLocalState@{                                      counter := counterValue + 1;                                    }};      msgs := [];      timers := [];      engines := [];    };</pre></code></pre>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#countreplyaction","title":"<code>countReplyAction</code>","text":"<p>Respond with the counter value.</p> State update The state remains unchanged. Messages to be sent A message with the current counter value is sent to the requester. Engines to be spawned No engine is created by this action. Timer updates No timers are set or cancelled. <pre><code><pre>countReplyAction (input : TickerActionInput) : Option TickerActionEffect :=  let    env := ActionInput.env input;    tt := ActionInput.trigger input;    cfg := ActionInput.cfg input;    counterValue := TickerLocalState.counter (EngineEnv.localState env);  in case getEngineMsgFromTimestampedTrigger tt of       | some emsg :=         some           mkActionEffect@{             env := env;             msgs :=               [                 mkEngineMsg@{                   sender := getEngineIDFromEngineCfg cfg;                   target := EngineMsg.sender emsg;                   mailbox := some 0;                   msg :=                     Anoma.MsgTicker                       (TickerMsgCountReply                         mkCountReply@{                           counter := counterValue;                         });                 };               ];             timers := [];             engines := [];           }       | _ := none;</pre></code></pre>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#action-labels","title":"Action Labels","text":"","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#incrementactionlabel","title":"<code>incrementActionLabel</code>","text":"<pre><code><pre>incrementActionLabel : TickerActionExec := Seq [incrementAction];</pre></code></pre>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#countreplyactionlabel","title":"<code>countReplyActionLabel</code>","text":"<pre><code><pre>countReplyActionLabel : TickerActionExec := Seq [countReplyAction];</pre></code></pre>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickerguard","title":"<code>TickerGuard</code>","text":"<p> <pre><code><pre>TickerGuard : Type :=  Guard    TickerCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickerguardoutput","title":"<code>TickerGuardOutput</code>","text":"<p> <pre><code><pre>TickerGuardOutput : Type :=  GuardOutput    TickerCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickerguardeval","title":"<code>TickerGuardEval</code>","text":"<p> <pre><code><pre>TickerGuardEval : Type :=  GuardEval    TickerCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre> </p>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#incrementguard","title":"<code>incrementGuard</code>","text":"Condition Message type is <code>TickerMsgIncrement</code>. <pre><code><pre>incrementGuard  (tt : TimestampedTrigger TickerTimerHandle Anoma.Msg)  (cfg : EngineCfg TickerCfg)  (env : TickerEnv)  : Option TickerGuardOutput :=  let    emsg := getEngineMsgFromTimestampedTrigger tt;  in case emsg of       | some mkEngineMsg@{msg := Anoma.MsgTicker TickerMsgIncrement} :=         some           mkGuardOutput@{             action := incrementActionLabel;             args := [];           }       | _ := none;</pre></code></pre>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#countreplyguard","title":"<code>countReplyGuard</code>","text":"Condition Message type is <code>TickerMsgCountRequest</code>. <pre><code><pre>countReplyGuard  (tt : TimestampedTrigger TickerTimerHandle Anoma.Msg)  (cfg : EngineCfg TickerCfg)  (env : TickerEnv)  : Option TickerGuardOutput :=  case getEngineMsgFromTimestampedTrigger tt of    | some mkEngineMsg@{msg := Anoma.MsgTicker TickerMsgCountRequest} :=      some        mkGuardOutput@{          action := countReplyActionLabel;          args := [];        }    | _ := none;</pre></code></pre>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#the-ticker-behaviour","title":"The Ticker behaviour","text":"","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#tickerbehaviour","title":"<code>TickerBehaviour</code>","text":"<pre><code><pre>TickerBehaviour : Type :=  EngineBehaviour    TickerCfg    TickerLocalState    TickerMailboxState    TickerTimerHandle    TickerActionArguments    Anoma.Msg    Anoma.Cfg    Anoma.Env;</pre></code></pre>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#instantiation","title":"Instantiation","text":"<pre><code><pre>tickerBehaviour : TickerBehaviour :=  mkEngineBehaviour@{    guards := First [incrementGuard; countReplyGuard];  };</pre></code></pre>","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#ticker-action-flowchart","title":"Ticker Action Flowchart","text":"","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#incrementaction-flowchart","title":"<code>incrementAction</code> flowchart","text":"<pre><code>flowchart TD\n  CM&gt;TickerMsgIncrement]\n  ES[(State update&lt;br&gt;counter := counter + 1)]\n\n  CM --incrementGuard--&gt; A --incrementActionLabel--&gt; incrementAction --&gt; ES</code></pre> <code>incrementAction</code> flowchart","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_behaviour.html#countreplyaction-flowchart","title":"<code>countReplyAction</code> flowchart","text":"<pre><code>flowchart TD\n  CM&gt;TickerMsgCountRequest]\n  A(countReplyAction)\n  RE&gt;TickerMsgCountReply counterVa]\n\n  CM --countReplyGuard--&gt; A --countReplyActionLabel--&gt; RE</code></pre> <code>countReplyAction</code> flowchart","tags":["ticker-engine","engine-behaviour"]},{"location":"arch/node/engines/ticker_config.html","title":"Ticker config","text":"<ul> <li>engine</li> <li>node tags:</li> <li>ticker-engine</li> <li>engine-environment</li> </ul> Juvix imports <p><pre><code><pre>module arch.node.engines.ticker_config;import prelude open;import arch.node.engines.ticker_messages open;import arch.node.types.engine open;import arch.node.types.messages open;import arch.node.types.identities open;</pre></code></pre></p>"},{"location":"arch/node/engines/ticker_config.html#ticker-configuration","title":"Ticker Configuration","text":""},{"location":"arch/node/engines/ticker_config.html#overview","title":"Overview","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>"},{"location":"arch/node/engines/ticker_config.html#the-ticker-configuration","title":"The Ticker Configuration","text":""},{"location":"arch/node/engines/ticker_config.html#tickercfg","title":"<code>TickerCfg</code>","text":"<pre><code><pre>type TickerCfg :=  mkTickerCfg@{    example : Nat;    value : String;  };</pre></code></pre>"},{"location":"arch/node/engines/ticker_config.html#instantiation","title":"Instantiation","text":"<pre><code><pre>tickerCfg : EngineCfg TickerCfg :=  mkEngineCfg@{    node := Curve25519PubKey \"0xabcd1234\";    name := \"ticker\";    cfg :=      mkTickerCfg@{        example := 1;        value := \"hello world\";      };  };</pre></code></pre>"},{"location":"arch/node/engines/ticker_environment.html","title":"Ticker Environment","text":"Juvix preamble <p><pre><code><pre>module arch.node.engines.ticker_environment;import prelude open;import arch.node.types.basics open;import arch.node.engines.ticker_messages open;import arch.node.types.engine_environment open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.anoma_message as Anoma open;</pre></code></pre></p>","tags":["ticker-engine","engine-environment"]},{"location":"arch/node/engines/ticker_environment.html#overview","title":"Overview","text":"<p>The sole data item of the ticker environment that deserves mention is the counter; we do not need timers, or mailbox state.</p>","tags":["ticker-engine","engine-environment"]},{"location":"arch/node/engines/ticker_environment.html#mailbox-states","title":"Mailbox states","text":"<pre><code><pre>syntax alias TickerMailboxState := Unit;</pre></code></pre>","tags":["ticker-engine","engine-environment"]},{"location":"arch/node/engines/ticker_environment.html#local-state","title":"Local state","text":"<pre><code><pre>type TickerLocalState := mkTickerLocalState@{counter : Nat};</pre></code></pre> Arguments <code>counter</code>: The counter value.","tags":["ticker-engine","engine-environment"]},{"location":"arch/node/engines/ticker_environment.html#timer-handle","title":"Timer Handle","text":"<pre><code><pre>syntax alias TickerTimerHandle := Unit;</pre></code></pre> <p>The ticker does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>","tags":["ticker-engine","engine-environment"]},{"location":"arch/node/engines/ticker_environment.html#timestamped-trigger","title":"Timestamped Trigger","text":"<pre><code><pre>TickerTimestampedTrigger : Type :=  TimestampedTrigger TickerTimerHandle Anoma.Msg;</pre></code></pre>","tags":["ticker-engine","engine-environment"]},{"location":"arch/node/engines/ticker_environment.html#the-ticker-environment","title":"The Ticker Environment","text":"","tags":["ticker-engine","engine-environment"]},{"location":"arch/node/engines/ticker_environment.html#tickerenv","title":"<code>TickerEnv</code>","text":"<pre><code><pre>TickerEnv : Type :=  EngineEnv TickerLocalState TickerMailboxState TickerTimerHandle Anoma.Msg;</pre></code></pre>","tags":["ticker-engine","engine-environment"]},{"location":"arch/node/engines/ticker_environment.html#instantiation","title":"Instantiation","text":"<pre><code><pre>tickerEnv : TickerEnv :=  mkEngineEnv@{    localState :=      mkTickerLocalState@{        counter := 0;      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := [];  };</pre></code></pre>","tags":["ticker-engine","engine-environment"]},{"location":"arch/node/engines/ticker_messages.html","title":"Ticker Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.ticker_messages;import prelude open;</pre></code></pre></p>","tags":["ticker-engine","engine-messages"]},{"location":"arch/node/engines/ticker_messages.html#tickermsg-message-interface","title":"TickerMsg Message Interface","text":"","tags":["ticker-engine","engine-messages"]},{"location":"arch/node/engines/ticker_messages.html#tickermsg-message-constructors","title":"TickerMsg Message Constructors","text":"","tags":["ticker-engine","engine-messages"]},{"location":"arch/node/engines/ticker_messages.html#tickermsgincrement","title":"<code>TickerMsgIncrement</code>","text":"<p>A <code>TickerMsgIncrement</code> message instructs the engine to increase the counter. This message doesn't require any arguments.</p>","tags":["ticker-engine","engine-messages"]},{"location":"arch/node/engines/ticker_messages.html#tickermsgcountrequest","title":"<code>TickerMsgCountRequest</code>","text":"<p>A <code>TickerMsgCountRequest</code> message requests the engine to send the current counter value back to the requester. This message doesn't require any arguments.</p>","tags":["ticker-engine","engine-messages"]},{"location":"arch/node/engines/ticker_messages.html#tickermsgcountreply-countreply","title":"<code>TickerMsgCountReply CountReply</code>","text":"<p>The <code>TickerMsgCountReply</code> contains the counter value.</p> <pre><code><pre>type CountReply : Type := mkCountReply@{counter : Nat};</pre></code></pre>","tags":["ticker-engine","engine-messages"]},{"location":"arch/node/engines/ticker_messages.html#tickermsg","title":"<code>TickerMsg</code>","text":"<pre><code><pre>type TickerMsg :=  | TickerMsgIncrement  | TickerMsgCountRequest  | TickerMsgCountReply CountReply;</pre></code></pre> <p>There are only two message tags: <code>TickerMsgIncrement</code>, which increases the counter state of the ticker, and <code>TickerMsgCount</code>, which the ticker responds to with the current counter state.</p>","tags":["ticker-engine","engine-messages"]},{"location":"arch/node/engines/ticker_messages.html#ticker-interaction-diagram","title":"Ticker Interaction Diagram","text":"<p>This diagram represents a simple interaction between a <code>Ticker</code> engine instance and another entity sending increment requests and count requests.</p> <pre><code>sequenceDiagram\n    participant Ticker\n    participant EngineTickerClient\n\n    EngineTickerClient -&gt;&gt; Ticker: Send TickerMsgIncrement\n    Note over Ticker: Counter = 1\n\n    EngineTickerClient -&gt;&gt; Ticker: Send TickerMsgIncrement\n    Note over Ticker: Counter = 2\n\n    EngineTickerClient -&gt;&gt; Ticker: Send TickerMsgCount\n    Ticker -&gt;&gt; EngineTickerClient: Respond with Counter (2)</code></pre>  A client interacts with the <code>Ticker</code> engine, which increments and responds with the counter value.","tags":["ticker-engine","engine-messages"]},{"location":"arch/node/engines/verification.html","title":"Verification Engine","text":"<p>Failure</p> <p>[10 of 18] Compiling arch.node.engines.verification_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/verification_environment.juvix.md:77:7-11: error: Unexpected argument node</p> <p>icon: octicons/project-template-24 search:   exclude: false tags: - verification - engines</p> Juvix imports <pre><code>module arch.node.engines.verification;\n\nimport prelude open;\nimport arch.node.types.engine open;\n\nimport arch.node.engines.verification_messages open public;\nimport arch.node.engines.verification_environment open public;\nimport arch.node.engines.verification_behaviour open public;\nopen verification_environment_example;\n</code></pre>"},{"location":"arch/node/engines/verification.html#verification-engine","title":"Verification Engine","text":"<p>The Verification Engine is responsible for verifying commitments (signatures) made by external identities. It automatically uses \"signs_for\" relationship information from the Signs For Engine along with caller preference information to determine how to verify a commitment.</p>"},{"location":"arch/node/engines/verification.html#purpose","title":"Purpose","text":"<p>The Verification Engine verifies commitments (signatures) made by external identities. It can use \"signs_for\" relationship information and caller preferences to determine how to verify a commitment. This engine is designed to be stateless, allowing for efficient implementation by the runtime.</p>"},{"location":"arch/node/engines/verification.html#components","title":"Components","text":"<ul> <li>Verification Messages</li> <li>Verification Environment</li> <li>Verification Behaviour</li> </ul>"},{"location":"arch/node/engines/verification.html#useful-links","title":"Useful links","text":"<p>???</p>"},{"location":"arch/node/engines/verification.html#type","title":"Type","text":"<pre><code>VerificationEngine : Type := Engine\n  VerificationLocalState\n  VerificationMailboxState\n  VerificationTimerHandle\n  VerificationMatchableArgument\n  VerificationActionLabel\n  VerificationPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/verification.html#example-of-a-verification-engine","title":"Example of a verification engine","text":"<pre><code>exampleVerificationEngine : VerificationEngine :=\n  mkEngine@{\n    behaviour := verificationBehaviour;\n    initEnv := verificationEnvironmentExample;\n  };\n</code></pre> <p>where <code>verificationEnvironmentExample</code> is defined as follows:</p> <pre><code><pre>verificationEnvironmentExample : VerificationEnvironment :=  mkEngineEnvironment@{    name := \"verification\";    localState :=      mkVerificationLocalState@{        verifier :=          \\ {_ _ :=            mkVerifier@{              verify := \\ {_ _ _ := true};              verifierHash :=                mkHASH@{                  ordKey :=                    mkOrdkey@{                      compare := Ord.cmp                    };                  hash := \\ {x := 0}                }            }};        backend := BackendLocalMemory;        signsForEngineAddress := mkPair none (some \"Blah\");        pendingRequests := Map.empty      };    mailboxCluster := Map.empty;    acquaintances := Set.empty;    timers := []  };</pre></code></pre>"},{"location":"arch/node/engines/verification_behaviour.html","title":"Verification Engine Behaviour","text":"<p>Failure</p> <p>[9 of 16] Compiling arch.node.engines.verification_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/verification_environment.juvix.md:77:7-11: error: Unexpected argument node</p> <p>icon: octicons/gear-16 search:   exclude: false categories: - engine-behaviour - juvix-module tags: - verification - engine-behavior</p> Juvix imports <pre><code>module arch.node.engines.verification_behaviour;\n\nimport prelude open;\nimport arch.node.types.messages open;\nimport arch.system.identity.identity open hiding {ExternalIdentity};\nimport arch.node.types.engine_behaviour open;\nimport arch.node.types.engine_environment open;\nimport arch.node.engines.verification_environment open;\nimport arch.node.engines.verification_messages open;\nimport arch.node.engines.signs_for_messages open;\nimport arch.node.types.crypto open;\nimport arch.node.types.identities open;\nimport arch.node.types.anoma_message open;\n</code></pre>"},{"location":"arch/node/engines/verification_behaviour.html#verification-dynamics","title":"<code>Verification</code> Dynamics","text":""},{"location":"arch/node/engines/verification_behaviour.html#overview","title":"Overview","text":"<p>The behavior of the Verification Engine define how it processes incoming verification requests and produces the corresponding responses.</p>"},{"location":"arch/node/engines/verification_behaviour.html#action-labels","title":"Action labels","text":"<pre><code>type VerificationActionLabel :=\n  | -- --8&lt;-- [start:DoVerify]\n    DoVerify {\n      data : Signable;\n      commitment : Commitment;\n      externalIdentity : ExternalIdentity;\n      useSignsFor : Bool\n    }\n    -- --8&lt;-- [end:DoVerify]\n  | -- --8&lt;-- [start:DoHandleSignsForResponse]\n    DoHandleSignsForResponse {\n      externalIdentity : ExternalIdentity;\n      signsForEvidence : Set SignsForEvidence\n    };\n    -- --8&lt;-- [end:DoHandleSignsForResponse]\n;\n</code></pre>"},{"location":"arch/node/engines/verification_behaviour.html#doverify","title":"<code>DoVerify</code>","text":"<p>DoVerify {   data : Signable;   commitment : Commitment;   externalIdentity : ExternalIdentity;   useSignsFor : Bool }</p> <p>This action label corresponds to verifying a commitment.</p> <code>DoVerify</code> action effect <p>This action does the following:</p> Aspect Description State update If <code>useSignsFor</code> is true, the state is updated to store pending requests. Otherwise, the state remains unchanged. Messages to be sent If <code>useSignsFor</code> is false, a <code>VerifyResponse</code> message is sent back to the requester. If <code>useSignsFor</code> is true and it's the first request for this identity, a <code>QuerySignsForEvidenceRequest</code> is sent to the SignsFor Engine. Engines to be spawned No engines are created by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/verification_behaviour.html#dohandlesignsforresponse","title":"<code>DoHandleSignsForResponse</code>","text":"<p>DoHandleSignsForResponse {   externalIdentity : ExternalIdentity;   signsForEvidence : Set SignsForEvidence };</p> <p>This action label corresponds to receiving signs for evidence and using it to address relevant pending requests.</p> <code>DoHandleSignsForResponse</code> action effect <p>This action does the following:</p> Aspect Description State update The state is updated to remove the processed pending requests for the given external identity. Messages to be sent <code>VerifyResponse</code> messages are sent to all requesters who were waiting for this SignsFor evidence. Engines to be spawned No engines are created by this action. Timer updates No timers are set or cancelled."},{"location":"arch/node/engines/verification_behaviour.html#matchable-arguments","title":"Matchable arguments","text":"<pre><code>type VerificationMatchableArgument :=\n  | -- --8&lt;-- [start:ReplyTo]\n  ReplyTo (Option EngineID) (Option MailboxID)\n  -- --8&lt;-- [end:ReplyTo]\n;\n</code></pre>"},{"location":"arch/node/engines/verification_behaviour.html#replyto","title":"<code>ReplyTo</code>","text":"<pre><code>ReplyTo (Option EngineID) (Option MailboxID)\n</code></pre> <p>This matchable argument contains the address and mailbox ID of where the response message should be sent.</p>"},{"location":"arch/node/engines/verification_behaviour.html#precomputation-results","title":"Precomputation results","text":"<p>The Verification Engine does not require any non-trivial pre-computations.</p> <pre><code>syntax alias VerificationPrecomputation := Unit;\n</code></pre>"},{"location":"arch/node/engines/verification_behaviour.html#guards","title":"Guards","text":"Auxiliary Juvix code <p>Type alias for the guard.</p> <pre><code>-- --8&lt;-- [start:verification-guard]\nVerificationGuard : Type :=\n  Guard\n    VerificationLocalState\n    VerificationMailboxState\n    VerificationTimerHandle\n    VerificationMatchableArgument\n    VerificationActionLabel\n    VerificationPrecomputation;\n-- --8&lt;-- [end:verification-guard]\n\n-- --8&lt;-- [start:verification-guard-output]\nVerificationGuardOutput : Type :=\n  GuardOutput VerificationMatchableArgument VerificationActionLabel VerificationPrecomputation;\n-- --8&lt;-- [end:verification-guard-output]\n</code></pre>"},{"location":"arch/node/engines/verification_behaviour.html#verifyguard","title":"<code>verifyGuard</code>","text":"<pre><code>flowchart TD\n    C{VerifyRequest&lt;br&gt;received?}\n    C --&gt;|Yes| D[enabled]\n    C --&gt;|No| E[not enabled]\n    D --&gt; F([DoVerify])</code></pre> verifyGuard flowchart <pre><code>verifyGuard\n  (t : TimestampedTrigger VerificationTimerHandle)\n  (env : VerificationEnvironment) : Option VerificationGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgVerification (VerifyRequest x y z w)) := do {\n        sender &lt;- getSenderFromTimestampedTrigger t;\n        pure (mkGuardOutput@{\n                matchedArgs := [ReplyTo (some sender) none] ;\n                actionLabel := DoVerify x y z w;\n                precomputationTasks := unit\n                });\n        }\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/verification_behaviour.html#signsforresponseguard","title":"<code>signsForResponseGuard</code>","text":"<pre><code>signsForResponseGuard\n  (t : TimestampedTrigger VerificationTimerHandle)\n  (env : VerificationEnvironment) : Option VerificationGuardOutput\n  := case getMessageFromTimestampedTrigger t of {\n      | some (MsgSignsFor (QuerySignsForEvidenceResponse externalIdentity evidence err)) :=\n          case getSenderFromTimestampedTrigger t of {\n            | some sender :=\n                case isEqual (Ord.cmp sender (VerificationLocalState.signsForEngineAddress (EngineEnv.localState env))) of {\n                  | true := some (mkGuardOutput@{\n                      matchedArgs := [];\n                      actionLabel := DoHandleSignsForResponse externalIdentity evidence;\n                      precomputationTasks := unit\n                    })\n                  | false := none\n                }\n            | none := none\n          }\n      | _ := none\n  };\n</code></pre>"},{"location":"arch/node/engines/verification_behaviour.html#action-function","title":"Action function","text":"Auxiliary Juvix code <p>Type alias for the action function.</p> <pre><code>VerificationActionInput : Type :=\n  ActionInput\n    VerificationLocalState\n    VerificationMailboxState\n    VerificationTimerHandle\n    VerificationMatchableArgument\n    VerificationActionLabel\n    VerificationPrecomputation;\n\nVerificationActionEffect : Type :=\n  ActionEffect\n    VerificationLocalState\n    VerificationMailboxState\n    VerificationTimerHandle\n    VerificationMatchableArgument\n    VerificationActionLabel\n    VerificationPrecomputation;\n</code></pre> <pre><code>verifyResponse (externalIdentity : ExternalIdentity) (env : VerificationEnvironment) (evidence : Set SignsForEvidence) (req : Pair EngineID (Pair Signable Commitment)) : EngineMsg :=\n  let localState := EngineEnv.localState env;\n      whoAsked := fst req;\n      input := snd req;\n      data := fst input;\n      commitment := snd input;\n      result' :=\n        Verifier.verify\n          (VerificationLocalState.verifier localState evidence externalIdentity)\n          (VerificationLocalState.backend localState)\n          data commitment;\n      responseMsg := VerifyResponse@{\n        result := result';\n        err := none\n      };\n      envelope := mkEngineMsg@{\n        sender := mkPair none (some (EngineEnv.name env));\n        target := whoAsked;\n        mailbox := some 0;\n        msg := MsgVerification responseMsg\n      };\n      in envelope;\n\nverificationAction (input : VerificationActionInput) : VerificationActionEffect :=\n  let env := ActionInput.env input;\n      out := ActionInput.guardOutput input;\n      localState := EngineEnv.localState env;\n  in\n  case GuardOutput.actionLabel out of {\n    | DoVerify data commitment externalIdentity' useSignsFor :=\n        case GuardOutput.matchedArgs out of {\n          | (ReplyTo (some whoAsked) _) :: _ :=\n              case useSignsFor of {\n                | false :=\n                    let envelope := verifyResponse externalIdentity' env Set.empty (mkPair whoAsked (mkPair data commitment))\n                    in mkActionEffect@{\n                      newEnv := env; -- No state change\n                      producedMessages := [envelope];\n                      timers := [];\n                      spawnedEngines := []\n                    }\n                | true :=\n                    -- Need to request SignsForEvidence from SignsFor Engine\n                    let existingRequests := Map.lookup externalIdentity' (VerificationLocalState.pendingRequests localState);\n                        newPendingList := case existingRequests of {\n                          | some reqs := reqs ++ [mkPair whoAsked (mkPair data commitment)]\n                          | none := [mkPair whoAsked (mkPair data commitment)]\n                        };\n                        newPendingRequests := Map.insert externalIdentity' newPendingList (VerificationLocalState.pendingRequests localState);\n                        newLocalState := localState@VerificationLocalState{\n                          pendingRequests := newPendingRequests\n                        };\n                        newEnv' := env@EngineEnv{\n                          localState := newLocalState\n                        };\n                        -- Only send request to SignsFor Engine if this is the first pending request for this identity\n                        messagesToSend := case existingRequests of {\n                          | some _ := [] -- Request already sent, do none\n                          | none := let requestMsg := QuerySignsForEvidenceRequest@{\n                                              externalIdentity := externalIdentity'\n                                            };\n                                            envelope := mkEngineMsg@{\n                                              sender := mkPair none (some (EngineEnv.name env));\n                                              target := VerificationLocalState.signsForEngineAddress localState;\n                                              mailbox := some 0;\n                                              msg := MsgSignsFor requestMsg\n                                            };\n                                        in [envelope]\n                        };\n                    in mkActionEffect@{\n                      newEnv := newEnv';\n                      producedMessages := messagesToSend;\n                      timers := [];\n                      spawnedEngines := []\n                    }\n              }\n          | _ := mkActionEffect@{newEnv := env; producedMessages := []; timers := []; spawnedEngines := []}\n      }\n    | DoHandleSignsForResponse externalIdentity evidence :=\n        -- Retrieve pending requests\n        case Map.lookup externalIdentity (VerificationLocalState.pendingRequests localState) of {\n          | some reqs :=\n              let messages := map (verifyResponse externalIdentity env evidence) reqs;\n                  newPendingRequests := Map.delete externalIdentity (VerificationLocalState.pendingRequests localState);\n                  newLocalState := localState@VerificationLocalState{\n                    pendingRequests := newPendingRequests\n                  };\n                  newEnv' := env@EngineEnv{\n                    localState := newLocalState\n                  };\n              in mkActionEffect@{\n                newEnv := newEnv';\n                producedMessages := messages;\n                timers := [];\n                spawnedEngines := []\n              }\n          | none :=\n              -- No pending requests, do none\n              mkActionEffect@{\n                newEnv := env;\n                producedMessages := [];\n                timers := [];\n                spawnedEngines := []\n              }\n        }\n  };\n</code></pre>"},{"location":"arch/node/engines/verification_behaviour.html#conflict-solver","title":"Conflict solver","text":"<pre><code>verificationConflictSolver : Set VerificationMatchableArgument -&gt; List (Set VerificationMatchableArgument)\n  | _ := [];\n</code></pre>"},{"location":"arch/node/engines/verification_behaviour.html#verificationbehaviour-type","title":"VerificationBehaviour type","text":"<pre><code>VerificationBehaviour : Type :=\n  EngineBehaviour\n    VerificationLocalState\n    VerificationMailboxState\n    VerificationTimerHandle\n    VerificationMatchableArgument\n    VerificationActionLabel\n    VerificationPrecomputation;\n</code></pre>"},{"location":"arch/node/engines/verification_behaviour.html#verificationbehaviour-instance","title":"VerificationBehaviour instance","text":"<pre><code>verificationBehaviour : VerificationBehaviour :=\n  mkEngineBehaviour@{\n    guards := [verifyGuard; signsForResponseGuard];\n    action := verificationAction;\n    conflictSolver := verificationConflictSolver;\n  }\n</code></pre>"},{"location":"arch/node/engines/verification_environment.html","title":"Verification Engine Environment","text":"<p>Failure</p> <p>[2 of 9] Compiling arch.node.engines.verification_environment /home/runner/work/nspec/nspec/docs/arch/node/engines/verification_environment.juvix.md:77:7-11: error: Unexpected argument node</p> <p>icon: octicons/container-24 search:   exclude: false categories: - engine-behaviour tags: - verification - engine-environment</p> Juvix imports <pre><code>module arch.node.engines.verification_environment;\n\nimport prelude open;\nimport arch.system.identity.identity open hiding {ExternalIdentity};\nimport arch.node.types.messages open;\nimport arch.node.types.engine_environment open;\nimport arch.node.types.identities open;\nimport arch.node.engines.verification_messages open;\n</code></pre>"},{"location":"arch/node/engines/verification_environment.html#verification-environment","title":"Verification Environment","text":""},{"location":"arch/node/engines/verification_environment.html#overview","title":"Overview","text":"<p>The Verification Engine is stateless and does not maintain any internal state between requests. It relies on external information (like the <code>signs_for</code> relationships) for its operations.</p>"},{"location":"arch/node/engines/verification_environment.html#mailbox-states","title":"Mailbox states","text":"<p>The Verification Engine does not require complex mailbox states. We define the mailbox state as <code>Unit</code>.</p> <pre><code>syntax alias VerificationMailboxState := Unit;\n</code></pre>"},{"location":"arch/node/engines/verification_environment.html#local-state","title":"Local state","text":"<p>The local state of a Verification Engine instance includes the identity's verification capabilities, the address of an associated <code>SignsFor</code> engine, and a specific backend. It also contains a map to a list of pending requests which require <code>SignsFor</code> information which is requested from the associated <code>SignsFor</code> engine.</p> <pre><code>type VerificationLocalState := mkVerificationLocalState {\n  verifier : Set SignsForEvidence -&gt; ExternalIdentity -&gt; Verifier ByteString Backend Signable Commitment;\n  backend : Backend;\n  signsForEngineAddress : EngineID;\n  pendingRequests : Map ExternalIdentity (List (Pair EngineID (Pair Signable Commitment)));\n};\n</code></pre>"},{"location":"arch/node/engines/verification_environment.html#timer-handle","title":"Timer Handle","text":"<pre><code>syntax alias VerificationTimerHandle := Unit;\n</code></pre> <p>The Verification Engine does not require a timer handle type. Therefore, we define the timer handle type as <code>Unit</code>.</p>"},{"location":"arch/node/engines/verification_environment.html#environment-summary","title":"Environment summary","text":"<pre><code>VerificationEnvironment : Type := EngineEnv\n  VerificationLocalState\n  VerificationMailboxState\n  VerificationTimerHandle;\n</code></pre>"},{"location":"arch/node/engines/verification_environment.html#example-of-a-verification-environment","title":"Example of a <code>Verification</code> environment","text":"<pre><code>module verification_environment_example;\n\nverificationEnvironmentExample : VerificationEnvironment :=\n    mkEngineEnv@{\n      node := Curve25519PubKey \"0xabcd1234\";\n      name := \"verification\";\n      localState := mkVerificationLocalState@{\n        verifier := \\{_ _ := mkVerifier@{\n          verify := \\{_ _ _ := true};\n          verifierHash := mkHASH@{\n            ordKey := mkOrdkey@{\n                compare := Ord.cmp\n            };\n            hash := \\{x := \"0x1234abcd\"};\n          };\n        }};\n        backend := BackendLocalMemory;\n        signsForEngineAddress := mkPair none (some \"Blah\");\n        pendingRequests := Map.empty\n      };\n      mailboxCluster := Map.empty;\n      acquaintances := Set.empty;\n      timers := []\n    }\n  ;\nend;\n</code></pre>"},{"location":"arch/node/engines/verification_messages.html","title":"Verification Engine Messages","text":"Juvix imports <p><pre><code><pre>module arch.node.engines.verification_messages;import prelude open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["verification","engine-messages"]},{"location":"arch/node/engines/verification_messages.html#verification-messages","title":"<code>Verification</code> Messages","text":"","tags":["verification","engine-messages"]},{"location":"arch/node/engines/verification_messages.html#message-interface","title":"Message interface","text":"<pre><code><pre>type VerificationMsg :=  | VerifyRequest {      data : Signable;      commitment : Commitment;      externalIdentity : ExternalIdentity;      useSignsFor : Bool    }  | VerifyResponse {      result : Bool;      err : Option String    };</pre></code></pre>","tags":["verification","engine-messages"]},{"location":"arch/node/engines/verification_messages.html#verifyrequest-message","title":"<code>VerifyRequest</code> message","text":"<p>VerifyRequest</p> <pre><code>VerifyRequest {\n  data : Signable;\n  commitment : Commitment;\n  externalIdentity : ExternalIdentity;\n  useSignsFor : Bool\n}\n</code></pre> <p>A <code>VerifyRequest</code> instructs the Verification Engine to verify a commitment (signature) from a particular external identity, possibly using known signs_for relationships.</p> <ul> <li><code>commitment</code>: The commitment (signature) to verify.</li> <li><code>data</code>: The data that was signed.</li> <li><code>externalIdentity</code>: The external identity that supposedly made the commitment.</li> <li><code>useSignsFor</code>: Whether or not to use known <code>signs_for</code> relationships.</li> </ul>","tags":["verification","engine-messages"]},{"location":"arch/node/engines/verification_messages.html#verifyresponse-message","title":"<code>VerifyResponse</code> message","text":"<p>VerifyResponse</p> <pre><code>VerifyResponse {\n  result : Bool;\n  err : Option String\n}\n</code></pre> <p>A <code>VerifyResponse</code> contains the result of verifying a commitment in response to a VerifyRequest.</p> <ul> <li><code>result</code>: True if the verification succeeded, False otherwise.</li> <li><code>err</code>: An error message if verification failed.</li> </ul>","tags":["verification","engine-messages"]},{"location":"arch/node/engines/verification_messages.html#message-sequence-diagrams","title":"Message sequence diagrams","text":"","tags":["verification","engine-messages"]},{"location":"arch/node/engines/verification_messages.html#verification-sequence-without-signsfor-evidence","title":"Verification Sequence (Without SignsFor evidence)","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant EE as Encryption Engine\n\n    C-&gt;&gt;EE: EncryptRequest(useReadsFor=false)\n    Note over EE: Encrypt data directly for external identity\n    EE--&gt;&gt;C: EncryptResponse</code></pre>  Sequence diagram for encryption (no signs for).","tags":["verification","engine-messages"]},{"location":"arch/node/engines/verification_messages.html#verification-sequence-with-signsfor-evidence","title":"Verification Sequence (With SignsFor evidence)","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant EE as Encryption Engine\n    participant RF as ReadsFor Engine\n\n    C-&gt;&gt;EE: EncryptRequest(useReadsFor=true)\n    EE-&gt;&gt;RF: QueryReadsForEvidenceRequest\n    Note over RF: Retrieve reads_for evidence\n    RF--&gt;&gt;EE: QueryReadsForEvidenceResponse\n    Note over EE: Encrypt data using ReadsFor evidence\n    EE--&gt;&gt;C: EncryptResponse</code></pre>  Sequence diagram for encryption (signs for).","tags":["verification","engine-messages"]},{"location":"arch/node/engines/verification_messages.html#engine-components","title":"Engine Components","text":"<ul> <li><code>Verification</code> Engine Environment</li> <li><code>Verification</code> Engine Dynamics</li> </ul>","tags":["verification","engine-messages"]},{"location":"arch/node/engines/verification_messages.html#useful-links","title":"Useful links","text":"","tags":["verification","engine-messages"]},{"location":"arch/node/hardware/index.html","title":"Hardware Machine","text":"","boost":2},{"location":"arch/node/hardware/index.html#purpose","title":"Purpose","text":"<p>The Hardware Machine provides a standardized interface for engines to interact with the underlying hardware components of the physical machine Anoma nodes are running. By decoupling engine software from specific hardware implementations, the Hardware Machine abstracts away complexities and facilitate cross-platform compatibility, enhancing software development and deployment.</p>","boost":2},{"location":"arch/node/hardware/index.html#background","title":"Background","text":"<p>Historically, developers that wanted to write a program had to know how each underlying hardware device communicated with the rest of the system to ensure the software's compatibility. With a hardware abstraction layer developers can just talk to the operating system what the hardware device should do, which then generates hardware-specific instructions to the device. Anoma's Hardware Machine thus provides an interface for accessing hardware-related resources such as CPU, memory, and storage.</p>","boost":2},{"location":"arch/node/hardware/index.html#scope","title":"Scope","text":"<p>For V1, we assume that the Hardware Machine provides other engines access to local storage, compute, time management, and logging functionalities of the physical machine an Anoma node is running.</p>","boost":2},{"location":"arch/node/hardware/index.html#overview","title":"Overview","text":"<p>The current Hardware Machine is composed of the following five engines.</p>","boost":2},{"location":"arch/node/hardware/index.html#local-storage-engine","title":"Local Storage Engine","text":"<p>The Local Storage Engines provide efficient data storage and retrieval mechanisms directly on the physical machine of an Anoma node. These engines are specialized to meet distinct requirements of data storage and retrieval from other engines.</p>","boost":2},{"location":"arch/node/hardware/index.html#local-logging-engine","title":"Local Logging Engine","text":"<p>The Local Logging Engine provides capabilities for recording, monitoring, analyzing, and managing events and activities locally on the physical machine that the Anoma node is running. It supports diagnostic efforts, security monitoring, performance optimization, and historical analysis to ensure the stability, security, and efficiency.</p>","boost":2},{"location":"arch/node/hardware/index.html#local-wall-clock-engine","title":"Local Wall Clock Engine","text":"<p>The Local Wall Clock Engine provides a mechanism for tracking and managing time locally on the physical machine that the Anoma node is running. It abstracts away the details of the underlying hardware and provides an interface for getting real-time clock functionality.</p>","boost":2},{"location":"arch/node/hardware/index.html#communication-diagram","title":"Communication Diagram","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Any Hardware Machine Engine: Operation Request\nAny Hardware Machine Engine --&gt;&gt;- Any Local Engine: Operation Response\nAny Hardware Machine Engine -&gt;&gt;+ Local Logging Engine: Append Log\n%% --8&lt;-- [end:sequence]</code></pre> <p>An engine communicates with the Hardware Machine by sending a request to one of its engines to perform a specific operation. The Hardware Machine engine executes the operation by interacting with the underlying hardware components and returns a response. It also logs relevant events and communicates them to the Local Logging Engine.</p> (Wiki) links on this page<ul><li>Local Logging Engine</li></ul>","boost":2},{"location":"arch/node/hardware/local_logging_engine/index.html","title":"Index","text":"(Wiki) links on this page<ul><li>LocalLoggingAppend</li><li>LocalLoggingAppendV1</li><li>AppendValueV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_logging_engine/index.html#local-logging-engine","title":"Local Logging Engine","text":"","boost":2},{"location":"arch/node/hardware/local_logging_engine/index.html#purpose","title":"Purpose","text":"<p>The Local Logging Engine provides capabilities for recording, monitoring, analyzing, and managing events and activities locally on the physical machine that the Anoma node is running. It supports diagnostic efforts, security monitoring, performance optimization, and historical analysis to ensure the stability, security, and efficiency.</p>","boost":2},{"location":"arch/node/hardware/local_logging_engine/index.html#state","title":"State","text":"","boost":2},{"location":"arch/node/hardware/local_logging_engine/index.html#messages-received","title":"Messages Received","text":"","boost":2},{"location":"arch/node/hardware/local_logging_engine/index.html#localloggingappend","title":"LocalLoggingAppend","text":"<p>Append new values to the logbook.</p> <p>Reception:</p>","boost":2},{"location":"arch/node/hardware/local_logging_engine/index.html#localloggingappendv1","title":"LocalLoggingAppendV1","text":"<p>Records with fields:</p> <ul> <li> <p><code>external identity</code>: ExternalIdentity</p> <p>External identity of the engine that wants to append the values to the logbook</p> </li> </ul> <ul> <li> <p><code>append value</code>: AppendValueV1</p> <p>The value in a string format, which needs to be added to the logbook</p> </li> </ul> <p>Triggers:</p>","boost":2},{"location":"arch/node/hardware/local_logging_engine/index.html#notifications-sent","title":"Notifications Sent","text":"","boost":2},{"location":"arch/node/hardware/local_logging_engine/index.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\nAny Local Engine -&gt;&gt;+ Local Logging Engine: LocalLoggingAppend</code></pre>","boost":2},{"location":"arch/node/hardware/local_logging_engine/messages/local_logging_append.html","title":"LocalLoggingAppend","text":"(Wiki) links on this page<ul><li>LocalLoggingAppendV1</li><li>AppendValueV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_logging_engine/messages/local_logging_append.html#localloggingappend","title":"LocalLoggingAppend","text":"","boost":2},{"location":"arch/node/hardware/local_logging_engine/messages/local_logging_append.html#purpose","title":"Purpose","text":"<p>Append new values to the logbook.</p>","boost":2},{"location":"arch/node/hardware/local_logging_engine/messages/local_logging_append.html#type","title":"Type","text":"<p>Reception:</p>","boost":2},{"location":"arch/node/hardware/local_logging_engine/messages/local_logging_append.html#localloggingappendv1","title":"LocalLoggingAppendV1","text":"<p>Records with fields:</p> <ul> <li> <p><code>external identity</code>: ExternalIdentity</p> <p>External identity of the engine that wants to append the values to the logbook</p> </li> </ul> <ul> <li> <p><code>append value</code>: AppendValueV1</p> <p>The value in a string format, which needs to be added to the logbook</p> </li> </ul> <p>Triggers:</p>","boost":2},{"location":"arch/node/hardware/local_logging_engine/messages/local_logging_append.html#behaviour","title":"Behaviour","text":"<p>Appends the new value to the logbook.</p>","boost":2},{"location":"arch/node/hardware/local_logging_engine/messages/local_logging_append.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local Logging Engine: LocalLoggingAppend\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_logging_engine/types/append_value_v1.html","title":"AppendValueV1","text":"","boost":2},{"location":"arch/node/hardware/local_logging_engine/types/append_value_v1.html#purpose","title":"Purpose","text":"<p>The value in a string format, which needs to be added to the logbook.</p>","boost":2},{"location":"arch/node/hardware/local_logging_engine/types/append_value_v1.html#type","title":"Type","text":"<p>The AppendValueV1 has empty record.</p>","boost":2},{"location":"arch/node/hardware/local_logging_engine/types/append_value_v1.html#values","title":"Values","text":"","boost":2},{"location":"arch/node/hardware/local_logging_engine/types/local_logging_append_v1.html","title":"LocalLoggingAppendV1","text":"","boost":2},{"location":"arch/node/hardware/local_logging_engine/types/local_logging_append_v1.html#purpose","title":"Purpose","text":"<p>Append new values to the logbook.</p>","boost":2},{"location":"arch/node/hardware/local_logging_engine/types/local_logging_append_v1.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>external identity</code>: ExternalIdentity</p> <p>External identity of the engine that wants to append the values to the logbook</p> </li> </ul> <ul> <li> <p><code>append value</code>: AppendValueV1</p> <p>The value in a string format, which needs to be added to the logbook</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_logging_engine/types/local_logging_append_v1.html#values","title":"Values","text":"(Wiki) links on this page<ul><li>AppendValueV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/index.html","title":"Local Storage Engines","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/index.html#purpose","title":"Purpose","text":"<p>The Local Storage Engines provide efficient data storage and retrieval mechanisms directly on the physical machine of an Anoma node. These engines are specialized to meet distinct requirements of data storage and retrieval from other engines.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/index.html#background","title":"Background","text":"<p>Local data storage is foundational in modern computing environments. It enables direct storage and retrieval of data on hardware without relying on external networks or resources. Within an Anoma node, the Local Storage Engines are manage and use of storage devices while abstracting away the complexities of the underlying hardware.</p> <p>In blockchain environments, various types of data must be stored and made available to other engines upon request. This ranges from simple routing data in the Networking Machine to more complex time series data such as transaction batches from the Ordering Machine.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/index.html#scope","title":"Scope","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/index.html#functionality","title":"Functionality","text":"<p>The Local Storage Engines provide a flexible and efficient mechanism for storing and retrieving data in a key-value format on the physical machine an Anoma node is running. Key-value storage is suitable for scenarios that require fast data access and low-latency operations that are present in engines such as Static Configuration Engine.</p> <p>Additionally, the engines support functionality for time series data, enabling the storage and analysis of time-stamped data points collected over time interval. Examples include the AvailabilityCertificate.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/index.html#overview","title":"Overview","text":"<p>The Hardware Machine incorporates two specialized storage engines designed to cater to distinct data storage and retrieval requirements from other engines:</p> <ul> <li>The Local Key-Value Storage Engine (KV) provides a flexible and efficient mechanism for storing and retrieving data in a key-value format on the physical machine an Anoma node is running. Key-value storage is suitable for scenarios that require fast data access and low-latency operations such as configuration storage.</li> </ul> <ul> <li>The Local Time-Series Storage Engine (TS) is usually optimized for storing and analyzing time-stamped data points collected over time interval such as AvailabilityCertificate.</li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/index.html#communication-diagram","title":"Communication diagram","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/index.html#example-scenario","title":"Example scenario","text":"<p>The diagram above visualized an example scenario where an Anoma node has generated an AvailabilityCertificate (AC) in the Ordering Machine that needs to be stored by the Local Storage Engines and sent to other Anoma nodes in the network by the Networking Machine. The Ordering Machine sends the AC to the Router. The Router Engine records the AC in the Local Time-Series Storage Engine and then request the transport identity from one of Local Key-Value Storage Engine instances that stores routing information.</p> (Wiki) links on this page<ul><li>Networking Machine</li><li>Ordering Machine</li><li>Ordering Machine</li><li>Networking Machine</li><li>Router</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_key_value_storage_engine/index.html","title":"Index","text":"(Wiki) links on this page<ul><li>GetValueKVStoreRequest</li><li>GetValueKVStoreRequestV1</li><li>StorageKeyV1</li><li>GetValueKVStoreResponseV1</li><li>StorageKeyV1</li><li>StorageValueV1</li><li>SetValueKVStoreRequest</li><li>SetValueKVStoreRequestV1</li><li>StorageKeyV1</li><li>StorageValueV1</li><li>SetValueKVStoreResponseV1</li><li>StorageKeyV1</li><li>SuccessOperationV1</li><li>DeleteValueKVStoreRequest</li><li>DeleteValueKVStoreRequestV1</li><li>StorageKeyV1</li><li>DeleteValueKVStoreResponseV1</li><li>StorageKeyV1</li><li>SuccessOperationV1</li><li>ValueChangedKVStore</li><li>StorageKeyV1</li><li>StorageValueV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_key_value_storage_engine/index.html#local-key-value-storage-engine","title":"Local Key-Value Storage Engine","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_key_value_storage_engine/index.html#purpose","title":"Purpose","text":"<p>The Local Key-Value Storage Engine provides the local storage and retrieval of data in a key-value format.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_key_value_storage_engine/index.html#state","title":"State","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_key_value_storage_engine/index.html#messages-received","title":"Messages received","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_key_value_storage_engine/index.html#getvaluekvstorerequest","title":"GetValueKVStoreRequest","text":"<p>Find stored data by its key in the KV-store and return the value.</p> <p>Reception:</p> <p>GetValueKVStoreRequestV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that maps to the requested value in the KV-store.</p> </li> </ul> <p>Triggers</p> <p>GetValueKVStoreResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that maps to the requested value in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Storage Value</code>: StorageValueV1</p> <p>The requested value in the KV-store.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_key_value_storage_engine/index.html#setvaluekvstorerequest","title":"SetValueKVStoreRequest","text":"<p>Add a piece of data to the KV store by adding its key and the corresponding value. If the key already exists, override the value.</p> <p>Reception:</p> <p>SetValueKVStoreRequestV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the piece of data in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Storage Value</code>: StorageValueV1</p> <p>The corresponding value that needs to be added to the KV-store.</p> </li> </ul> <p>Triggers</p> <p>SetValueKVStoreResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the piece of data in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was stored successfully or not.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_key_value_storage_engine/index.html#deletevaluekvstorerequest","title":"DeleteValueKVStoreRequest","text":"<p>Prevent actors capable of sending read requests to the Storage Engine to be able to read a previously set value for a specified key.</p> <p>Reception:</p> <p>DeleteValueKVStoreRequestV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the piece of data that should be removed from the KV-store.</p> </li> </ul> <p>Triggers</p> <p>DeleteValueKVStoreResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the piece of data in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was deleted successfully or not.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_key_value_storage_engine/index.html#notifications-sent","title":"Notifications sent","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_key_value_storage_engine/index.html#valuechangedkvstore","title":"ValueChangedKVStore","text":"<p>When the value in the KV-store changes, engines interested in this information get notified.</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the changed piece of data in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Storage Value</code>: StorageValueV1</p> <p>The corresponding value that needs to be recorded in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Epoch Timestamp</code>: EpochTimestamp</p> <p>The wall clock time of the moment the value was changed.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_key_value_storage_engine/index.html#message-flow","title":"Message Flow","text":"<p><pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local KV Storage Engine: GetValueKVStoreRequest\nLocal KV Storage Engine --&gt;&gt;- Any Local Engine: GetValueKVStoreResponse\nAny Local Engine -&gt;&gt;+ Local KV Storage Engine: SetValueKVStoreRequest\nLocal KV Storage Engine --&gt;&gt;- Any Local Engine: SetValueKVStoreResponse\nAny Local Engine -&gt;&gt;+ Local KV Storage Engine: DeleteValueKVStoreRequest\nLocal KV Storage Engine --&gt;&gt;- Any Local Engine: DeleteValueKVStoreResponse\n%% --8&lt;-- [end:sequence]</code></pre> </p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/delete_value_kv_store_request.html","title":"DeleteValueKVStoreRequest","text":"(Wiki) links on this page<ul><li>DeleteValueKVStoreRequestV1</li><li>StorageKeyV1</li><li>DeleteValueKVStoreResponseV1</li><li>StorageKeyV1</li><li>SuccessOperationV1</li><li>DeleteValueKVStoreRequestV1</li><li>DeleteValueKVStoreResponseV1</li><li>GetValueKVStoreRequestV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/delete_value_kv_store_request.html#deletevaluekvstorerequest","title":"DeleteValueKVStoreRequest","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/delete_value_kv_store_request.html#purpose","title":"Purpose","text":"<p>Prevent actors capable of sending read requests to the Storage Engine to be able to read a previously set value for a specified key.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/delete_value_kv_store_request.html#type","title":"Type","text":"<p>Reception:</p> <p>DeleteValueKVStoreRequestV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the piece of data that should be removed from the KV-store.</p> </li> </ul> <p>Triggers</p> <p>DeleteValueKVStoreResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the piece of data in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was deleted successfully or not.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/delete_value_kv_store_request.html#behaviour","title":"Behaviour","text":"<p>Finds a value by its key in the KV-store and modifies the reading capabilities related to said key availiable through the Storage API.</p> <p>The behavior is tied directly to reading capabilities of the Storage Engine and hence can be described via interaction with GetValueKVStore as follows:</p> <p>If DeleteValueKVStoreRequestV1 was sent with key <code>key</code> specified and DeleteValueKVStoreResponseV1 returns a success then GetValueKVStoreRequestV1 sent with key <code>key</code> will trigger a <code>Nothing</code> response.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/delete_value_kv_store_request.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local KV Storage Engine: DeleteValueKVStoreRequest\nLocal KV Storage Engine --&gt;&gt;- Any Local Engine: DeleteValueKVStoreResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/delete_value_kv_store_response.html","title":"DeleteValueKVStoreResponse","text":"(Wiki) links on this page<ul><li>DeleteValueKVStoreRequest</li><li>DeleteValueKVStoreRequestV1</li><li>StorageKeyV1</li><li>SuccessOperationV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/delete_value_kv_store_response.html#deletevaluekvstoreresponse","title":"DeleteValueKVStoreResponse","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/delete_value_kv_store_response.html#purpose","title":"Purpose","text":"<p>Response to DeleteValueKVStoreRequest.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/delete_value_kv_store_response.html#type","title":"Type","text":"<p>Reception:</p> <p>DeleteValueKVStoreRequestV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the piece of data in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was deleted successfully or not.</p> </li> </ul> <p>Triggers</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/delete_value_kv_store_response.html#behaviour","title":"Behaviour","text":"<p>After deleting the KV-pair from the KV-store, send a message indicating the success or failure of the operation.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/delete_value_kv_store_response.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Dynamic Config Engine: GetDynamicConfigRequest\nDynamic Config Engine --&gt;&gt;- Any Local Engine: GetDynamicConfigResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/get_value_kv_store_request.html","title":"GetValueKVStoreRequest","text":"(Wiki) links on this page<ul><li>GetValueKVStoreRequestV1</li><li>StorageKeyV1</li><li>GetValueKVStoreResponseV1</li><li>StorageKeyV1</li><li>StorageValueV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/get_value_kv_store_request.html#getvaluekvstorerequest","title":"GetValueKVStoreRequest","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/get_value_kv_store_request.html#purpose","title":"Purpose","text":"<p>Find stored data by its key in the KV-store and return the value.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/get_value_kv_store_request.html#type","title":"Type","text":"<p>Reception:</p> <p>GetValueKVStoreRequestV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that maps to the requested value in the KV-store.</p> </li> </ul> <p>Triggers</p> <p>GetValueKVStoreResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that maps to the requested value in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Storage Value</code>: StorageValueV1</p> <p>The requested value in the KV-store.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/get_value_kv_store_request.html#behaviour","title":"Behaviour","text":"<p>Performs a key-based search operation in the KV-store to find the corresponding value.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/get_value_kv_store_request.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local KV Storage Engine: GetValueKVStoreRequest\nLocal KV Storage Engine --&gt;&gt;- Any Local Engine: GetValueKVStoreResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/get_value_kv_store_response.html","title":"GetValueKVStoreResponse","text":"(Wiki) links on this page<ul><li>GetValueKVStoreRequest</li><li>GetValueKVStoreResponseV1</li><li>StorageKeyV1</li><li>StorageValueV1</li><li>GetValueKVStoreRequest</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/get_value_kv_store_response.html#getvaluekvstoreresponse","title":"GetValueKVStoreResponse","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/get_value_kv_store_response.html#purpose","title":"Purpose","text":"<p>Return the value from the search operation which is triggered by a GetValueKVStoreRequest.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/get_value_kv_store_response.html#type","title":"Type","text":"<p>Reception:</p> <p>GetValueKVStoreResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that maps to the requested value in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Storage Value</code>: StorageValueV1</p> <p>The requested value in the KV-store.</p> </li> </ul> <p>Triggers</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/get_value_kv_store_response.html#behaviour","title":"Behaviour","text":"<p>Returns the value from the search operation which is triggered by a GetValueKVStoreRequest.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/get_value_kv_store_response.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local KV Storage Engine: GetValueKVStoreRequest\nLocal KV Storage Engine --&gt;&gt;- Any Local Engine: GetValueKVStoreResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/set_value_kv_store_request.html","title":"SetValueKVStoreRequest","text":"(Wiki) links on this page<ul><li>SetValueKVStoreRequestV1</li><li>StorageKeyV1</li><li>StorageValueV1</li><li>SetValueKVStoreResponseV1</li><li>StorageKeyV1</li><li>SuccessOperationV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/set_value_kv_store_request.html#setvaluekvstorerequest","title":"SetValueKVStoreRequest","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/set_value_kv_store_request.html#purpose","title":"Purpose","text":"<p>Add a piece of data to the KV store by adding its key and the corresponding value. If the key already exists, override the value.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/set_value_kv_store_request.html#type","title":"Type","text":"<p>Reception:</p> <p>SetValueKVStoreRequestV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the piece of data in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Storage Value</code>: StorageValueV1</p> <p>The corresponding value that needs to be added to the KV-store.</p> </li> </ul> <p>Triggers</p> <p>SetValueKVStoreResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the piece of data in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was stored successfully or not.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/set_value_kv_store_request.html#behaviour","title":"Behaviour","text":"<p>Adds a piece of data to the KV store by inserting its key and the corresponding value. If the key already exists, it overrides the value.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/set_value_kv_store_request.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local KV Storage Engine: SetValueKVStoreRequest\nLocal KV Storage Engine --&gt;&gt;- Any Local Engine: SetValueKVStoreResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/set_value_kv_store_response.html","title":"SetValueKVStoreResponse","text":"(Wiki) links on this page<ul><li>SetValueKVStoreRequest</li><li>SetValueKVStoreResponseV1</li><li>StorageKeyV1</li><li>SuccessOperationV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/set_value_kv_store_response.html#setvaluekvstoreresponse","title":"SetValueKVStoreResponse","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/set_value_kv_store_response.html#purpose","title":"Purpose","text":"<p>Response to a SetValueKVStoreRequest.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/set_value_kv_store_response.html#type","title":"Type","text":"<p>Reception:</p> <p>SetValueKVStoreResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the piece of data in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was stored successfully or not.</p> </li> </ul> <p>Triggers</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/set_value_kv_store_response.html#behaviour","title":"Behaviour","text":"<p>After adding the KV-pair to the KV-store, send a message indicating the success or failure of the operation.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/messages/set_value_kv_store_response.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local KV Storage Engine: SetValueKVStoreRequest\nLocal KV Storage Engine --&gt;&gt;- Any Local Engine: SetValueKVStoreResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/notifications/value_changed_kv_store.html","title":"ValueChangedKVStore","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/notifications/value_changed_kv_store.html#purpose","title":"Purpose","text":"<p>When the value in the KV-store changes, engines interested in this information get notified.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/notifications/value_changed_kv_store.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the changed piece of data in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Storage Value</code>: StorageValueV1</p> <p>The corresponding value that needs to be recorded in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Epoch Timestamp</code>: EpochTimestamp</p> <p>The wall clock time of the moment the value was changed.</p> </li> </ul> (Wiki) links on this page<ul><li>StorageKeyV1</li><li>StorageValueV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/delete_value_kv_store_request_v1.html","title":"DeleteValueKVStoreRequestV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/delete_value_kv_store_request_v1.html#purpose","title":"Purpose","text":"<p>Find a value by its key in the KV-store and delete both the key and the value.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/delete_value_kv_store_request_v1.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the piece of data that should be removed from the KV-store.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/delete_value_kv_store_request_v1.html#values","title":"Values","text":"(Wiki) links on this page<ul><li>StorageKeyV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/delete_value_kv_store_response_v1.html","title":"DeleteValueKVStoreResponseV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/delete_value_kv_store_response_v1.html#purpose","title":"Purpose","text":"<p>Indicates the success or failure of the attempt to delete the KV-pair from the KV store.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/delete_value_kv_store_response_v1.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the piece of data in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was deleted successfully or not.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/delete_value_kv_store_response_v1.html#values","title":"Values","text":"(Wiki) links on this page<ul><li>StorageKeyV1</li><li>SuccessOperationV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/get_value_kv_store_request_v1.html","title":"GetValueKVStoreRequestV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/get_value_kv_store_request_v1.html#purpose","title":"Purpose","text":"<p>Perform a key-based search operation in the KV-store to find the corresponding value.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/get_value_kv_store_request_v1.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that maps to the requested value in the KV-store.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/get_value_kv_store_request_v1.html#values","title":"Values","text":"(Wiki) links on this page<ul><li>StorageKeyV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/get_value_kv_store_response_v1.html","title":"GetValueKVStoreResponseV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/get_value_kv_store_response_v1.html#purpose","title":"Purpose","text":"<p>Return the value corresponding to StorageKeyV1.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/get_value_kv_store_response_v1.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that maps to the requested value in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Storage Value</code>: StorageValueV1</p> <p>The requested value in the KV-store.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/get_value_kv_store_response_v1.html#values","title":"Values","text":"(Wiki) links on this page<ul><li>StorageKeyV1</li><li>StorageKeyV1</li><li>StorageValueV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/set_value_kv_store_request_v1.html","title":"SetValueKVStoreRequestV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/set_value_kv_store_request_v1.html#purpose","title":"Purpose","text":"<p>Add a piece of data to the KV store by adding its key and the corresponding value. If the key already exists, override the value.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/set_value_kv_store_request_v1.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the piece of data in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Storage Value</code>: StorageValueV1</p> <p>The corresponding value that needs to be added to the KV-store.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/set_value_kv_store_request_v1.html#values","title":"Values","text":"(Wiki) links on this page<ul><li>StorageKeyV1</li><li>StorageValueV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/set_value_kv_store_response_v1.html","title":"SetValueKVStoreResponseV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/set_value_kv_store_response_v1.html#purpose","title":"Purpose","text":"<p>After adding the KV-pair to the KV-store, send a message indicating the success or failure of the operation.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/set_value_kv_store_response_v1.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>Storage Key</code>: StorageKeyV1</p> <p>The key that that identifies the piece of data in the KV-store.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was stored successfully or not.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/set_value_kv_store_response_v1.html#values","title":"Values","text":"(Wiki) links on this page<ul><li>StorageKeyV1</li><li>SuccessOperationV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/storage_key_v1.html","title":"StorageKeyV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/storage_key_v1.html#purpose","title":"Purpose","text":"<p>The key that maps to the data value in the KV-store.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/storage_key_v1.html#type","title":"Type","text":"<p>Records with fields:</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/storage_key_v1.html#values","title":"Values","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/storage_value_v1.html","title":"StorageValueV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/storage_value_v1.html#purpose","title":"Purpose","text":"<p>The value corresponding with a StorageKeyV1 in the KV-store.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/storage_value_v1.html#type","title":"Type","text":"<p>Records with fields:</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/storage_value_v1.html#values","title":"Values","text":"(Wiki) links on this page<ul><li>StorageKeyV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/success_operation_kv_store_v1.html","title":"SuccessOperationV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/success_operation_kv_store_v1.html#purpose","title":"Purpose","text":"<p>Indicates whether an operation performed by Local Key-Value Storage Engine was executed successfully or not.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/success_operation_kv_store_v1.html#type","title":"Type","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_kv_storage_engine/types/success_operation_kv_store_v1.html#values","title":"Values","text":"<p>Boolean value where:</p> <ul> <li><code>1</code>: Operation was successful.</li> <li><code>0</code>: Operation was unsuccessful.</li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/index.html","title":"Index","text":"(Wiki) links on this page<ul><li>GetDataTimeSeriesDBRequest</li><li>GetDataTimeSeriesDBRequestV1</li><li>TimeSeriesDBQueryV1</li><li>GetDataTimeSeriesDBResponseV1</li><li>TimeSeriesDBQueryV1</li><li>TimeSeriesDBDataV1</li><li>RecordDataTimeSeriesDBRequest</li><li>RecordDataTimeSeriesDBRequestV1</li><li>TimeSeriesDBQueryV1</li><li>RecordDataTimeSeriesDBResponseV1</li><li>TimeSeriesDBQueryV1</li><li>SuccessOperationV1</li><li>DeleteDataTimeSeriesDBRequest</li><li>DeleteDataTimeSeriesDBRequestV1</li><li>TimeSeriesDBQueryV1</li><li>DeleteDataTimeSeriesDBResponseV1</li><li>TimeSeriesDBQueryV1</li><li>SuccessOperationV1</li><li>DataChangedTimeSeriesDB</li><li>TimeSeriesDBQueryV1</li><li>TimeSeriesDBDataV1</li><li>EpochTimestampV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/index.html#local-time-series-storage-engine","title":"Local Time Series Storage Engine","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/index.html#purpose","title":"Purpose","text":"<p>The Local Time Series Storage Engine provides local storage and retrieval of time series data.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/index.html#state","title":"State","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/index.html#messages-received","title":"Messages received","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/index.html#getdatatimeseriesdbrequest","title":"GetDataTimeSeriesDBRequest","text":"<p>Get the queried time series data and return it.</p> <p>Reception:</p> <p>GetDataTimeSeriesDBRequestV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that finds the requested time series data in the DB.</p> </li> </ul> <p>Triggers</p> <p>GetDataTimeSeriesDBResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that finds the requested time series data in the DB.</p> </li> </ul> <ul> <li> <p><code>Time Series DB Data</code>: TimeSeriesDBDataV1</p> <p>The requested time series data.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/index.html#recorddatatimeseriesdbrequest","title":"RecordDataTimeSeriesDBRequest","text":"<p>Add time series data to the DB.</p> <p>Reception:</p> <p>RecordDataTimeSeriesDBRequestV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the addition of the time series data into the DB.</p> </li> </ul> <p>Triggers</p> <p>RecordDataTimeSeriesDBResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the recording of the time series data into the DB.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was stored successfully or not.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/index.html#deletedatatimeseriesdbrequest","title":"DeleteDataTimeSeriesDBRequest","text":"<p>Delete time series data from the DB.</p> <p>Reception:</p> <p>DeleteDataTimeSeriesDBRequestV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the deletion of the time series data from the DB.</p> </li> </ul> <p>Triggers</p> <p>DeleteDataTimeSeriesDBResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the deletion of the time series data from the DB.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was deleted successfully or not.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/index.html#notifications-sent","title":"Notifications sent","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/index.html#datachangedtimeseriesdb","title":"DataChangedTimeSeriesDB","text":"<p>When the value in the time series DB changes, engines interested in this information get notified.</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the desire change of the time series DB.</p> </li> </ul> <ul> <li> <p><code>Time Series DB Data</code>: TimeSeriesDBDataV1</p> <p>The changed time series data.</p> </li> </ul> <ul> <li> <p><code>Epoch Timestamp</code>: EpochTimestampV1</p> <p>The wall clock time of the moment the data was changed.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/index.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local Time Series Storage Engine: GetDataTimeSeriesDBRequest\nLocal Time Series Storage Engine --&gt;&gt;- Any Local Engine: GetDataTimeSeriesDBResponse\nAny Local Engine -&gt;&gt;+ Local Time Series Storage Engine: RecordDataTimeSeriesDBRequest\nLocal Time Series Storage Engine --&gt;&gt;- Any Local Engine: RecordDataTimeSeriesDBResponse\nAny Local Engine -&gt;&gt;+ Local Time Series Storage Engine: DeleteDataTimeSeriesDBRequest\nLocal Time Series Storage Engine --&gt;&gt;- Any Local Engine: DeleteDataTimeSeriesDBResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/delete_data_time_series_db_request.html","title":"DeleteDataTimeSeriesDBRequest","text":"(Wiki) links on this page<ul><li>DeleteDataTimeSeriesDBRequestV1</li><li>TimeSeriesDBQueryV1</li><li>DeleteDataTimeSeriesDBResponseV1</li><li>TimeSeriesDBQueryV1</li><li>SuccessOperationV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/delete_data_time_series_db_request.html#deletedatatimeseriesdbrequest","title":"DeleteDataTimeSeriesDBRequest","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/delete_data_time_series_db_request.html#purpose","title":"Purpose","text":"<p>Delete time series data from the DB.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/delete_data_time_series_db_request.html#type","title":"Type","text":"<p>Reception:</p> <p>DeleteDataTimeSeriesDBRequestV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the deletion of the time series data from the DB.</p> </li> </ul> <p>Triggers</p> <p>DeleteDataTimeSeriesDBResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the deletion of the time series data from the DB.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was deleted successfully or not.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/delete_data_time_series_db_request.html#behaviour","title":"Behaviour","text":"<p>Delete time series data from the time series DB.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/delete_data_time_series_db_request.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local Time Series DB Engine: DeleteDataTimeSeriesDBRequest\nLocal Time Series DB Engine --&gt;&gt;- Any Local Engine: DeleteDataTimeSeriesDBResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/delete_data_time_series_db_response.html","title":"DeleteDataTimeSeriesDBResponse","text":"(Wiki) links on this page<ul><li>DeleteDataTimeSeriesDBRequest</li><li>DeleteDataTimeSeriesDBResponseV1</li><li>TimeSeriesDBQueryV1</li><li>SuccessOperationV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/delete_data_time_series_db_response.html#recorddatatimeseriesdbresponse","title":"RecordDataTimeSeriesDBResponse","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/delete_data_time_series_db_response.html#purpose","title":"Purpose","text":"<p>Response to a DeleteDataTimeSeriesDBRequest.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/delete_data_time_series_db_response.html#type","title":"Type","text":"<p>Reception:</p> <p>DeleteDataTimeSeriesDBResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the deletion of the time series data from the DB.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was deleted successfully or not.</p> </li> </ul> <p>Triggers</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/delete_data_time_series_db_response.html#behaviour","title":"Behaviour","text":"<p>Performs the requested data record delete operation in the time series DB.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/delete_data_time_series_db_response.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local Time Series DB Engine: DeleteDataTimeSeriesDBRequest\nLocal Time Series DB Engine --&gt;&gt;- Any Local Engine: DeleteDataTimeSeriesDBResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/get_data_time_series_db_request.html","title":"GetDataTimeSeriesDBRequest","text":"(Wiki) links on this page<ul><li>GetDataTimeSeriesDBRequestV1</li><li>TimeSeriesDBQueryV1</li><li>GetDataTimeSeriesDBResponseV1</li><li>TimeSeriesDBQueryV1</li><li>TimeSeriesDBDataV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/get_data_time_series_db_request.html#getdatatimeseriesdbrequest","title":"GetDataTimeSeriesDBRequest","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/get_data_time_series_db_request.html#purpose","title":"Purpose","text":"<p>Get the queried time series data and return it.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/get_data_time_series_db_request.html#type","title":"Type","text":"<p>Reception:</p> <p>GetDataTimeSeriesDBRequestV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that finds the requested time series data in the DB.</p> </li> </ul> <p>Triggers</p> <p>GetDataTimeSeriesDBResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that finds the requested time series data in the DB.</p> </li> </ul> <ul> <li> <p><code>Time Series DB Data</code>: TimeSeriesDBDataV1</p> <p>The requested time series data.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/get_data_time_series_db_request.html#behaviour","title":"Behaviour","text":"<p>Performs the requested search operation in the time series DB and returns the value.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/get_data_time_series_db_request.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local Time Series DB Engine: GetDataTimeSeriesDBRequest\nLocal Time Series DB Engine --&gt;&gt;- Any Local Engine: GetDataTimeSeriesDBResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/get_data_time_series_db_response.html","title":"GetDataTimeSeriesDBResponse","text":"(Wiki) links on this page<ul><li>GetDataTimeSeriesDBResponseV1</li><li>TimeSeriesDBQueryV1</li><li>TimeSeriesDBDataV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/get_data_time_series_db_response.html#getdatatimeseriesdbresponse","title":"GetDataTimeSeriesDBResponse","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/get_data_time_series_db_response.html#purpose","title":"Purpose","text":"<p>Return the queried time series data.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/get_data_time_series_db_response.html#type","title":"Type","text":"<p>Reception:</p> <p>GetDataTimeSeriesDBResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that finds the requested time series data in the DB.</p> </li> </ul> <ul> <li> <p><code>Time Series DB Data</code>: TimeSeriesDBDataV1</p> <p>The requested time series data.</p> </li> </ul> <p>Triggers</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/get_data_time_series_db_response.html#behaviour","title":"Behaviour","text":"<p>Return the queried time series data.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/get_data_time_series_db_response.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local Time Series DB Engine: GetDataTimeSeriesDBRequest\nLocal Time Series DB Engine --&gt;&gt;- Any Local Engine: GetDataTimeSeriesDBResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/record_data_time_series_db_request.html","title":"RecordDataTimeSeriesDBRequest","text":"(Wiki) links on this page<ul><li>RecordDataTimeSeriesDBRequestV1</li><li>TimeSeriesDBQueryV1</li><li>RecordDataTimeSeriesDBResponseV1</li><li>TimeSeriesDBQueryV1</li><li>SuccessOperationV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/record_data_time_series_db_request.html#recorddatatimeseriesdbrequest","title":"RecordDataTimeSeriesDBRequest","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/record_data_time_series_db_request.html#purpose","title":"Purpose","text":"<p>Add time series data to the DB.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/record_data_time_series_db_request.html#type","title":"Type","text":"<p>Reception:</p> <p>RecordDataTimeSeriesDBRequestV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the addition of the time series data into the DB.</p> </li> </ul> <p>Triggers</p> <p>RecordDataTimeSeriesDBResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the recording of the time series data into the DB.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was stored successfully or not.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/record_data_time_series_db_request.html#behaviour","title":"Behaviour","text":"<p>Add time series data to the time series DB.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/record_data_time_series_db_request.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local Time Series DB Engine: RecordDataTimeSeriesDBRequest\nLocal Time Series DB Engine --&gt;&gt;- Any Local Engine: RecordDataTimeSeriesDBResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/record_data_time_series_db_response.html","title":"RecordDataTimeSeriesDBResponse","text":"(Wiki) links on this page<ul><li>RecordDataTimeSeriesDBRequest</li><li>RecordDataTimeSeriesDBResponseV1</li><li>TimeSeriesDBQueryV1</li><li>SuccessOperationV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/record_data_time_series_db_response.html#recorddatatimeseriesdbresponse","title":"RecordDataTimeSeriesDBResponse","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/record_data_time_series_db_response.html#purpose","title":"Purpose","text":"<p>Response to a RecordDataTimeSeriesDBRequest.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/record_data_time_series_db_response.html#type","title":"Type","text":"<p>Reception:</p> <p>RecordDataTimeSeriesDBResponseV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the recording of the time series data into the DB.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was stored successfully or not.</p> </li> </ul> <p>Triggers</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/record_data_time_series_db_response.html#behaviour","title":"Behaviour","text":"<p>Performs the requested data record operation in the time series DB.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/messages/record_data_time_series_db_response.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local Time Series DB Engine: RecordDataTimeSeriesDBRequest\nLocal Time Series DB Engine --&gt;&gt;- Any Local Engine: RecordDataTimeSeriesDBResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/notifications/data_changed_time_series_db.html","title":"DataChangedTimeSeriesDB","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/notifications/data_changed_time_series_db.html#purpose","title":"Purpose","text":"<p>When the value in the time series DB changes, engines interested in this information get notified.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/notifications/data_changed_time_series_db.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the desire change of the time series DB.</p> </li> </ul> <ul> <li> <p><code>Time Series DB Data</code>: TimeSeriesDBDataV1</p> <p>The changed time series data.</p> </li> </ul> <ul> <li> <p><code>Epoch Timestamp</code>: EpochTimestampV1</p> <p>The wall clock time of the moment the data was changed.</p> </li> </ul> (Wiki) links on this page<ul><li>TimeSeriesDBQueryV1</li><li>TimeSeriesDBDataV1</li><li>EpochTimestampV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/delete_data_time_series_db_request_v1.html","title":"DeleteDataTimeSeriesDBRequestV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/delete_data_time_series_db_request_v1.html#purpose","title":"Purpose","text":"<p>Delete time series data from the time series DB.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/delete_data_time_series_db_request_v1.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the deletion of the time series data from the DB.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/delete_data_time_series_db_request_v1.html#values","title":"Values","text":"(Wiki) links on this page<ul><li>TimeSeriesDBQueryV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/delete_data_time_series_db_response_v1.html","title":"RecordDataTimeSeriesDBResponseV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/delete_data_time_series_db_response_v1.html#purpose","title":"Purpose","text":"<p>Response to a DeleteDataTimeSeriesDBRequestV1</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/delete_data_time_series_db_response_v1.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the deletion of the time series data from the DB.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was deleted successfully or not.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/delete_data_time_series_db_response_v1.html#values","title":"Values","text":"(Wiki) links on this page<ul><li>DeleteDataTimeSeriesDBRequestV1</li><li>TimeSeriesDBQueryV1</li><li>SuccessOperationV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/get_data_time_series_db_request_v1.html","title":"GetDataTimeSeriesDBRequestV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/get_data_time_series_db_request_v1.html#purpose","title":"Purpose","text":"<p>Retrieve the queried time series data.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/get_data_time_series_db_request_v1.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that finds the requested time series data in the DB.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/get_data_time_series_db_request_v1.html#values","title":"Values","text":"(Wiki) links on this page<ul><li>TimeSeriesDBQueryV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/get_data_time_series_db_response_v1.html","title":"GetDataTimeSeriesDBResponseV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/get_data_time_series_db_response_v1.html#purpose","title":"Purpose","text":"<p>Return the queried time series data.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/get_data_time_series_db_response_v1.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that finds the requested time series data in the DB.</p> </li> </ul> <ul> <li> <p><code>Time Series DB Data</code>: TimeSeriesDBDataV1</p> <p>The requested time series data.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/get_data_time_series_db_response_v1.html#values","title":"Values","text":"(Wiki) links on this page<ul><li>TimeSeriesDBQueryV1</li><li>TimeSeriesDBDataV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/record_data_time_series_db_request_v1.html","title":"RecordDataTimeSeriesDBRequestV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/record_data_time_series_db_request_v1.html#purpose","title":"Purpose","text":"<p>Add time series data to the time series DB.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/record_data_time_series_db_request_v1.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the addition of the time series data into the DB.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/record_data_time_series_db_request_v1.html#values","title":"Values","text":"(Wiki) links on this page<ul><li>TimeSeriesDBQueryV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/record_data_time_series_db_response_v1.html","title":"RecordDataTimeSeriesDBResponseV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/record_data_time_series_db_response_v1.html#purpose","title":"Purpose","text":"<p>Response to a RecordDataTimeSeriesDBRequestV1</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/record_data_time_series_db_response_v1.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>Time Series DB Query</code>: TimeSeriesDBQueryV1</p> <p>The query that expresses the recording of the time series data into the DB.</p> </li> </ul> <ul> <li> <p><code>Success Operation</code>: SuccessOperationV1</p> <p>The success of the operation, indicating that the KV-pair was stored successfully or not.</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/record_data_time_series_db_response_v1.html#values","title":"Values","text":"(Wiki) links on this page<ul><li>RecordDataTimeSeriesDBRequestV1</li><li>TimeSeriesDBQueryV1</li><li>SuccessOperationV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/time_series_db_data_v1.html","title":"TimeSeriesDBDataV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/time_series_db_data_v1.html#purpose","title":"Purpose","text":"<p>A piece of data in the time series DB.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/time_series_db_data_v1.html#type","title":"Type","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/time_series_db_data_v1.html#values","title":"Values","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/time_series_db_query_v1.html","title":"TimeSeriesDBQueryV1","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/time_series_db_query_v1.html#purpose","title":"Purpose","text":"<p>The command that expresses the retrieval, addition or other manipulation of data in the time series database.</p>","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/time_series_db_query_v1.html#type","title":"Type","text":"","boost":2},{"location":"arch/node/hardware/local_storage_engines/local_timeseries_storage_engine/types/time_series_db_query_v1.html#values","title":"Values","text":"","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/index.html","title":"Index","text":"(Wiki) links on this page<ul><li>LocalWallClockGetTime</li><li>LocalWallClockGetTimeV1</li><li>LocalWallClockGetTimeResultV1</li><li>EpochTimestampV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/index.html#local-wall-clock-engine","title":"Local Wall Clock Engine","text":"","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/index.html#purpose","title":"Purpose","text":"<p>The Local Wall Clock Engine provides a mechanism for tracking and managing time locally on the physical machine that the Anoma node is running. It abstracts away the details of the underlying hardware and provides an interface for getting real-time clock functionality.</p>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/index.html#state","title":"State","text":"","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/index.html#messages-received","title":"Messages Received","text":"","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/index.html#localwallclockgettime","title":"LocalWallClockGetTime","text":"<p>Tracks and manages time within the local computing environment.</p> <p>Reception:</p> <p>LocalWallClockGetTimeV1</p> <p>The LocalWallClockGetTimeV1 has an empty record.</p> <p>Triggers</p> <p>LocalWallClockGetTimeResultV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Epoch Timestamp</code>: EpochTimestampV1</p> <p>Current time according to local wall clock, typically expressed in seconds (or milliseconds) elapsed since a reference point in time (the epoch)</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/index.html#notifications-sent","title":"Notifications Sent","text":"","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/index.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\nAny Local Engine -&gt;&gt;+ Local Wall Clock Engine: LocalWallClockGetTime\nLocal Wall Clock Engine --&gt;&gt;- Any Local Engine: LocalWallClockGetTimeResult</code></pre>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/messages/local_wall_clock_get_time.html","title":"LocalWallClockGetTime","text":"(Wiki) links on this page<ul><li>LocalWallClockGetTimeV1</li><li>LocalWallClockGetTimeResultV1</li><li>EpochTimestampV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/messages/local_wall_clock_get_time.html#localwallclockgettime","title":"LocalWallClockGetTime","text":"","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/messages/local_wall_clock_get_time.html#purpose","title":"Purpose","text":"<p>Tracks and manages time within the local computing environment.</p>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/messages/local_wall_clock_get_time.html#type","title":"Type","text":"<p>Reception:</p> <p>LocalWallClockGetTimeV1</p> <p>The LocalWallClockGetTimeV1 has an empty record.</p> <p>Triggers</p> <p>LocalWallClockGetTimeResultV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Epoch Timestamp</code>: EpochTimestampV1</p> <p>Current time according to local wall clock, typically expressed in seconds (or milliseconds) elapsed since a reference point in time (the epoch)</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/messages/local_wall_clock_get_time.html#behaviour","title":"Behaviour","text":"<p>Give the current time according to the physical machine's internal clock system.</p>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/messages/local_wall_clock_get_time.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local Wall Clock Engine: LocalWallClockGetTime\nLocal Wall Clock Engine --&gt;&gt;- Any Local Engine: LocalWallClockGetTimeResult\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/messages/local_wall_clock_get_time_result.html","title":"LocalWallClockGetTimeResult","text":"(Wiki) links on this page<ul><li>LocalWallClockGetTime</li><li>LocalWallClockGetTimeResultV1</li><li>EpochTimestampV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/messages/local_wall_clock_get_time_result.html#localwallclockgettimeresult","title":"LocalWallClockGetTimeResult","text":"","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/messages/local_wall_clock_get_time_result.html#purpose","title":"Purpose","text":"<p>Response to a LocalWallClockGetTime request.</p>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/messages/local_wall_clock_get_time_result.html#type","title":"Type","text":"<p>Reception:</p> <p>LocalWallClockGetTimeResultV1</p> <p>Records with fields:</p> <ul> <li> <p><code>Epoch Timestamp</code>: EpochTimestampV1</p> <p>Current time according to local wall clock, typically expressed in seconds (or milliseconds) elapsed since a reference point in time (the epoch)</p> </li> </ul> <p>Triggers</p>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/messages/local_wall_clock_get_time_result.html#behaviour","title":"Behaviour","text":"<p>Give the current time according to the physical machine's internal clock system.</p>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/messages/local_wall_clock_get_time_result.html#message-flow","title":"Message Flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Local Wall Clock Engine: LocalWallClockGetTime\nLocal Wall Clock Engine --&gt;&gt;- Any Local Engine: LocalWallClockGetTimeResult\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/types/epoch_timestamp_v1.html","title":"EpochTimestampV1","text":"","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/types/epoch_timestamp_v1.html#purpose","title":"Purpose","text":"<p>Current time according to local wall clock, typically expressed in seconds (or milliseconds) elapsed since a reference point in time (the epoch).</p>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/types/epoch_timestamp_v1.html#type","title":"Type","text":"","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/types/epoch_timestamp_v1.html#values","title":"Values","text":"","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/types/local_wall_clock_get_time_result_v1.html","title":"LocalWallClockGetTimeResultV1","text":"","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/types/local_wall_clock_get_time_result_v1.html#purpose","title":"Purpose","text":"<p>Response to a LocalWallClockGetTimeV1</p>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/types/local_wall_clock_get_time_result_v1.html#type","title":"Type","text":"<p>Records with fields:</p> <ul> <li> <p><code>Epoch Timestamp</code>: EpochTimestampV1</p> <p>Current time according to local wall clock, typically expressed in seconds (or milliseconds) elapsed since a reference point in time (the epoch)</p> </li> </ul>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/types/local_wall_clock_get_time_result_v1.html#values","title":"Values","text":"(Wiki) links on this page<ul><li>LocalWallClockGetTimeV1</li><li>EpochTimestampV1</li></ul>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/types/local_wall_clock_get_time_v1.html","title":"LocalWallClockGetTimeV1","text":"","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/types/local_wall_clock_get_time_v1.html#purpose","title":"Purpose","text":"<p>Track and manage time within the local computing environment.</p>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/types/local_wall_clock_get_time_v1.html#type","title":"Type","text":"<p>The LocalWallClockGetTimeV1 has an empty record.</p>","boost":2},{"location":"arch/node/hardware/local_wall_clock_engine/types/local_wall_clock_get_time_v1.html#values","title":"Values","text":"","boost":2},{"location":"arch/node/networking/index.html","title":"Networking Machine","text":"","boost":2},{"location":"arch/node/networking/index.html#purpose","title":"Purpose","text":"<p>The Networking Machine is responsible for message passing between engine instances, both locally (intra-node), and over the network (inter-node). The core functionality includes message routing and transport, upon which more complex peer-to-peer (P2P) protocols are built.</p>","boost":2},{"location":"arch/node/networking/index.html#scope","title":"Scope","text":"<p>The Anoma v1 network is limited to the following.</p> <ul> <li>The network consists of multiple nodes that can establish direct connections with each other over QUIC/TLS transport protocols.</li> </ul> <ul> <li>Nodes know about each other's addresses by explicitly adding NodeAdverts to their configuration.</li> </ul> <ul> <li>Engines can send unicast and multicast (pub/sub) messages to both local and remote engines.</li> </ul> <ul> <li>Pub/sub is limited to a single publisher with directly connected subscribers.</li> </ul> <p>The Anoma v2 network is going to support domains, dynamic P2P overlays, and P2P routing protocols. This is described in more detail in P2P Overlay Domains with Sovereignty (PODS). In PODS, the network architecture consists of a collection of nodes that are part of one or multiple heterogeneous domains. Each domain has its own overlay topology, and a distinct set of P2P intra-domain protocols, tailored to the characteristics and needs of the nodes in that domain.</p>","boost":2},{"location":"arch/node/networking/index.html#overview","title":"Overview","text":"","boost":2},{"location":"arch/node/networking/index.html#terminology","title":"Terminology","text":"<p>A node is the set of running engine instances that collectively participate in the network as a single entity. Each node has a Router engine instance responsible for intra- and inter-node message routing, and a Transport engine instance responsible for inter-node connectivity.</p> <p>A peer is a connected neighbor of a node in the network.</p> <p>The node identity in the networking context is the engine identity of the Router engine instance.</p>","boost":2},{"location":"arch/node/networking/index.html#message-passing","title":"Message passing","text":"<p>Communication between engines follows the actor model with asynchronous message passing between engines.</p> <p>Communicating engines can reside either on the same node or on different nodes connected over the network.</p> <p>A message received by an engine may trigger reactions in the form of one or more messages sent by the receiver. A typical reaction is a response to a request in the often used request-response pattern, or a forwarding decision in a network protocol.</p>","boost":2},{"location":"arch/node/networking/index.html#message-transmission-addressing-routing","title":"Message transmission, addressing, routing","text":"<p>Message transmission in the network is either one-to-one (unicast), few-to-many (multicast), or one-to-any (anycast).</p> <p>A unicast message is sent between two engines by a single sender to a single recipient, and routed over the network either directly to the destination or over multiple hops, depending on the transport protocol used.</p> <p>Multicast messaging follows the topic-based publish-subscribe (pub/sub) pattern, where a message (a.k.a. event) is sent by an authorized publisher to all subscribers of the topic, and routed over the network along multi-hop paths from a publisher towards subscribers.</p> <p>Anycast messages are used when sending a request to any known member of a domain.</p> <p>An EngineMessage is addressed from a source engine identity to a destination external identity, and the content of the message is authenticated by a signature of the source engine. The destination identity is either a NodeIdentity or EngineIdentity (for unicast messages), a pub/sub TopicIdentity (for multicast messages), or a DomainIdentity (for anycast messages).</p> <p>The Router engine of each node is responsible for message routing between local engines, local and remote engines, and in some cases relaying between two remote engines. It makes routing decisions based on the destination identity in the message.</p>","boost":2},{"location":"arch/node/networking/index.html#message-flow","title":"Message flow","text":"","boost":2},{"location":"arch/node/networking/index.html#intra-node-unicast-multicast-messages","title":"Intra-node unicast &amp; multicast messages","text":"Unicast message from engine A_X to engine A_Y, along edges labeled Y. Multicast message from publisher engine A_Z to topic T, delivered to subscribed engines A_X and A_Y by the router A_R, along edges labeled T.","boost":2},{"location":"arch/node/networking/index.html#inter-node-unicast-messages","title":"Inter-node unicast messages","text":"Unicast message between engine A_X of node A and engine B_X of node B, via router engines A_R &amp; B_R and transport engines A_T &amp; B_T.","boost":2},{"location":"arch/node/networking/index.html#inter-node-multicast-messages","title":"Inter-node multicast messages","text":"Multicast (pub/sub) message with publisher A_X and subscribers B_X, C_X, D_X sent to topic T. Published by node A and forwarded to node B and C, then from node B to node D. Multicast messages are sent along edges labeled T, while B, C, D are unicast messages between PubSub engine instances.","boost":2},{"location":"arch/node/networking/index.html#network-architecture","title":"Network architecture","text":"<p>The network consists of several sovereign domains with heterogenous protocols, where each domain maintains its own peer-to-peer overlay topology, manages its own membership, and determines the set of protocols that run inside the domain. A set of inter_domain protocols are responsible for clustering nodes based on domain membership and routing anycast messages to domains.</p>","boost":2},{"location":"arch/node/networking/index.html#intra-domain-protocols","title":"Intra-domain protocols","text":"<p>Inside each domain, a Domain membership and an overlay Topology maintenance protocol are responsible for responding to membership decisions, as well as keeping the overlay connected and keeping track of a partial view of online members.</p> <p>The P2P PubSub (publish-subscribe) protocol is responsible for event dissemination from authorized publishers to subscribers, while the P2P Storage protocol offers block storage and retrieval.</p>","boost":2},{"location":"arch/node/networking/index.html#inter-domain-protocols","title":"Inter-domain protocols","text":"<p>Two inter_domain gossip protocol run in parallel: a Trust-Aware Peer Sampling (TAPS) and a Trust-Aware Clustering (TAC) protocol. The two protocols together construct a small world network, where TAPS provides continuously changing long-range routing links, while TAC discovers nodes with similar domain membership. Using trust information in these protocols aids in making these protocols more resilient against eclipse and hub attacks. TAPS is further enhanced by Uniform Peer Sampling (URPS) that uses statistical analysis to filter out peers over-represented in the peer sampling stream. Domain membership privacy in TAC is achieved by using the Bloom-and-Flip (BLIP) algorithm that calculates similarity between randomized Bloom filters (see BLIP), and then calculating the exact overlap using a Private Set Intersection (PSI) protocol. Participation in the inter_domain protocols is optional: nodes that do not wish to be discovered outside of their domains and have fixed domain membership may opt out of participating in inter_domain protocols, in order to decrease load, increase security, and thwart potential attacks coming from outsiders (e.g. DDoS). This allows domains to have internal-only and external-facing members.</p> <p>There are two ways to interact with a Domain: either by sending external requests to any available domain member that may return a reply, or by joining the domain and participating in the intra-domain protocols. For both type of requests, a node needs to know about one or more domain members to send the request to, which can be discovered either via the Clustering protocol, or via a lookup request that is routed in the inter_domain overlay using a greedy routing algorithm by the Domain Routing protocol. Both methods use domain membership similarity as a distance metric.</p>","boost":2},{"location":"arch/node/networking/index.html#software-architecture","title":"Software architecture","text":"Engines of the Networking Machine. Octagons are engines with a single instance per node. Double octagons are engines with multiple instances. Solid arrows mark unicast message flow directions. Dashed arrows mark multicast notifications. Dotted arrows mark messages sent via the Router.","boost":2},{"location":"arch/node/networking/index.html#engines","title":"Engines","text":"<p>Engines are grouped based on their scope in the network architecture.</p>","boost":2},{"location":"arch/node/networking/index.html#intra-node-and-inter-node-protocols","title":"Intra-node and inter-node protocols","text":"<p>This group of engines are responsible for facilitating communication between local engines (intra-node), and between engines of two directly connected remote nodes (inter-node).</p> <p>These engines provide message routing and network transport functionality, and store information about network identities: advertisements received from the network and associated local metadata.</p>","boost":2},{"location":"arch/node/networking/index.html#router","title":"Router","text":"<p>The Router engine is responsible for message routing and handles both inter-node and intra-node messages. It authenticates received messages by verifying the signature of the source identity, and makes routing decisions based on the destination identity.</p> <p>It also provides topic-based pub/sub functionality for local engines and performs local multicast message routing.</p> <p>It can also relay messages between two remote nodes, in which case the EngineMessage is encrypted and wrapped in a RelayMessage.</p> <p>The message routing algorithm is described in the EngineMessage section.</p> <p>Note</p> <p>An implementation may optimize intra-node messaging between local engine instances, such that they communicate directly instead of via the router.</p>","boost":2},{"location":"arch/node/networking/index.html#transport","title":"Transport","text":"<p>The Transport engine is responsible for establishing and maintaining encrypted transport connections between peers. It supports various network transport protocols that are chosen according to transport preferences set by locally on a per-message or per-node basis, and defaults to the remote node's preferences specified in a NodeAdvert message.</p>","boost":2},{"location":"arch/node/networking/index.html#network-identity-store","title":"Network Identity Store","text":"<p>The Network Identity Store engine maintains a data store with records that contain information associated with identities of engines, nodes, pub/sub topics, and domains.</p> <p>The source of this information can be either local configuration or advertisements received from other nodes via P2P protocols.</p> <p>For each EngineIdentity it stores its local engine address, if applicable to the implementation.</p> <p>For each NodeIdentity, it stores transport addresses in order of preference, measurements, trust value, and reputation value.</p> <p>For each TopicIdentity, it stores the PubSub TopicAdvert.</p> <p>For each DomainIdentity, it stores the DomainAdvert.</p>","boost":2},{"location":"arch/node/networking/index.html#intra-domain-protocols_1","title":"Intra-domain protocols","text":"<p>This engine group implements intra-domain P2P protocols that run and offer services inside a domain.</p> <p>Each domain has determines the set of protocols it runs and the authentication mechanism it uses.</p>","boost":2},{"location":"arch/node/networking/index.html#pubsub","title":"PubSub","text":"<p>The PubSub engine implements a P2P topic-based pub/sub protocol and performs inter-node multicast message routing within a domain.</p>","boost":2},{"location":"arch/node/networking/index.html#storage","title":"Storage","text":"<p>The Storage engine implements a P2P block storage protocol.</p> (Wiki) links on this page<ul><li>NodeAdvert</li><li>Router</li><li>Transport</li><li>NodeIdentity</li><li>EngineIdentity</li><li>Router</li><li>EngineMessage</li><li>EngineIdentity</li><li>NodeIdentity</li><li>EngineIdentity</li><li>TopicIdentity</li><li>DomainIdentity</li><li>Router</li><li>PubSub</li><li>Storage</li><li>Router</li><li>EngineMessage</li><li>EngineMessage</li><li>RelayMessage</li><li>EngineMessage</li><li>Transport</li><li>NodeAdvert</li><li>Network Identity Store</li><li>IdentityStore</li><li>IdentityRecord</li><li>EngineIdentity</li><li>NodeIdentity</li><li>TopicIdentity</li><li>PubSub</li><li>TopicAdvert</li><li>DomainIdentity</li><li>PubSub</li><li>Storage</li></ul>","boost":2},{"location":"arch/node/networking/inter_domain.html","title":"Inter-domain P2P protocols","text":"","boost":2},{"location":"arch/node/networking/inter_domain.html#purpose","title":"Purpose","text":"<p>Inter-domain P2P protocols are responsible for peer sampling and clustering, as well as routing requests to domains.</p>","boost":2},{"location":"arch/node/networking/inter_domain.html#background","title":"Background","text":"","boost":2},{"location":"arch/node/networking/inter_domain.html#scope","title":"Scope","text":"","boost":2},{"location":"arch/node/networking/inter_domain.html#functionality","title":"Functionality","text":"","boost":2},{"location":"arch/node/networking/inter_domain.html#peer-sampling","title":"Peer Sampling","text":"<p>The Peer Sampling engine runs a P2P gossip-based trust-aware peer sampling protocol that provides a continously changing partial view of the network.</p> <p>Nodes periodically exchange their partial views with each other, and update their local view after each exchange. Peer sampling protocols are prone to attacks where partial views can be biased by attackers, to prevent this and make the protocol more robust and avoid attacks, nodes peform statistical analysis to filter out over-represented nodes in view exchanges, and they always keep a number of trusted nodes in their view.</p>","boost":2},{"location":"arch/node/networking/inter_domain.html#clustering","title":"Clustering","text":"<p>The clustering protocol performs node clustering according to a proximity metric based on shared domain membership. When choosing gossip targets, it considers nodes from the Peer Sampling view.</p> <p>Clustering optimizes the overlay structure by reducing the number of links necessary in the overlay by discovering nodes that can exchange messages for multiple domains over a single connection.</p>","boost":2},{"location":"arch/node/networking/inter_domain.html#domain-routing","title":"Domain Routing","text":"<p>The Domain Routing protocol allows routing join and data requests to one of the members of a domain, via the small world overlay structure created by the Clustering protocol.</p>","boost":2},{"location":"arch/node/networking/inter_domain.html#overview","title":"Overview","text":"","boost":2},{"location":"arch/node/networking/inter_domain.html#communication-diagram","title":"Communication diagram","text":"","boost":2},{"location":"arch/node/networking/inter_domain.html#example-scenario","title":"Example scenario","text":"","boost":2},{"location":"arch/node/networking/inter_domain.html#further-reading","title":"Further reading","text":"","boost":2},{"location":"arch/node/networking/inter_domain/clustering.html","title":"Clustering","text":"<p>Trust-aware clustering protocol.</p>","boost":2},{"location":"arch/node/networking/inter_domain/clustering.html#clusteringview","title":"ClusteringView","text":"<ul> <li>Clustering \\(\\to\\) ClusteringView \\(\\to\\) Clustering</li> </ul>","boost":2},{"location":"arch/node/networking/inter_domain/domain_routing.html","title":"Domain Routing","text":"<p>Route a message to any known domain member.</p>","boost":2},{"location":"arch/node/networking/inter_domain/domain_routing.html#domainrequest","title":"DomainRequest","text":"<p>A request sent to a domain that is delivered to any domain member.</p> <p>Reception:</p> <ul> <li>Domain \\(\\to\\) DomainRequest \\(\\to\\) Domain Routing</li> <li>Domain Routing \\(\\to\\) DomainRequest \\(\\to\\) Domain Routing</li> </ul> <p>Triggers:</p> <ul> <li>Domain Routing \\(\\to\\) DomainRequest \\(\\to\\) Domain Routing</li> <li>Domain Routing \\(\\to\\) DomainRequest \\(\\to\\) Domain</li> </ul>","boost":2},{"location":"arch/node/networking/inter_domain/domain_routing.html#domainresponse","title":"DomainResponse","text":"<p>A response returned to a DomainRequest.</p> <p>Reception:</p> <ul> <li>Router \\(\\to\\) DomainResponse \\(\\to\\) DomainRouting</li> <li>DomainRouting \\(\\to\\) DomainResponse \\(\\to\\) DomainRouting</li> <li>DomainRouting \\(\\to\\) DomainResponse \\(\\to\\) Router</li> </ul>","boost":2},{"location":"arch/node/networking/inter_domain/peer_sampling.html","title":"Peer Sampling","text":"<p>Trust-aware peer sampling protocol.</p>","boost":2},{"location":"arch/node/networking/inter_domain/peer_sampling.html#peersamplingview","title":"PeerSamplingView","text":"<ul> <li>PeerSampling \\(\\to\\) PeerSamplingView \\(\\to\\) PeerSampling</li> </ul>","boost":2},{"location":"arch/node/networking/inter_domain/clustering/clustering_view.html","title":"ClusteringView","text":"","boost":2},{"location":"arch/node/networking/inter_domain/clustering/clustering_view.html#purpose","title":"Purpose","text":"<p>Clustering view exchange.</p>","boost":2},{"location":"arch/node/networking/inter_domain/clustering/clustering_view.html#reception","title":"Reception","text":"<ul> <li>Clustering \\(\\to\\) PeerSamplingView \\(\\to\\) Clustering</li> </ul>","boost":2},{"location":"arch/node/networking/inter_domain/clustering/clustering_view.html#structure","title":"Structure","text":"Field Type Description <code>view</code> Vec View","boost":2},{"location":"arch/node/networking/inter_domain/clustering/clustering_view.html#triggers","title":"Triggers","text":"<ul> <li>Clustering \\(\\to\\) PeerSamplingView \\(\\to\\) Clustering</li> </ul>","boost":2},{"location":"arch/node/networking/inter_domain/domain_routing/domain_request.html","title":"DomainRequest","text":"","boost":2},{"location":"arch/node/networking/inter_domain/domain_routing/domain_request.html#purpose","title":"Purpose","text":"<p>A request sent to a domain that is delivered to any domain member.</p>","boost":2},{"location":"arch/node/networking/inter_domain/domain_routing/domain_request.html#reception","title":"Reception","text":"<ul> <li>Domain \\(\\to\\) DomainRequest \\(\\to\\) Domain Routing</li> <li>Domain Routing \\(\\to\\) DomainRequest \\(\\to\\) Domain Routing</li> </ul>","boost":2},{"location":"arch/node/networking/inter_domain/domain_routing/domain_request.html#structure","title":"Structure","text":"Field Type Description <code>src</code> ExternalIdentity External identity of sender <code>domain</code> ExternalIdentity External identity of destination domain <code>path</code> Vec Path of the request, updated at each hop. <code>protocol</code> Protocol Protocol &amp; version used in <code>body</code> <code>body</code> Vec Serialized message body.","boost":2},{"location":"arch/node/networking/inter_domain/domain_routing/domain_request.html#triggers","title":"Triggers","text":"<ul> <li>Domain Routing \\(\\to\\) DomainRequest \\(\\to\\) Domain Routing</li> <li>Domain Routing \\(\\to\\) DomainRequest \\(\\to\\) Domain</li> </ul>","boost":2},{"location":"arch/node/networking/inter_domain/domain_routing/domain_response.html","title":"DomainResponse","text":"","boost":2},{"location":"arch/node/networking/inter_domain/domain_routing/domain_response.html#purpose","title":"Purpose","text":"<p>A response returned to a DomainRequest.</p>","boost":2},{"location":"arch/node/networking/inter_domain/domain_routing/domain_response.html#reception","title":"Reception","text":"<ul> <li>Router \\(\\to\\) DomainResponse \\(\\to\\) DomainRouting</li> <li>DomainRouting \\(\\to\\) DomainResponse \\(\\to\\) DomainRouting</li> <li>DomainRouting \\(\\to\\) DomainResponse \\(\\to\\) Router</li> </ul>","boost":2},{"location":"arch/node/networking/inter_domain/domain_routing/domain_response.html#structure","title":"Structure","text":"Field Type Description <code>domain</code> ExternalIdentity External identity of domain <code>src</code> ExternalIdentity External identity of sender <code>dst</code> ExternalIdentity External identity of recipient <code>path</code> Vec Reverse path of the corresponding DomainRequest <code>protocol</code> Protocol Protocol &amp; version used in <code>body</code> <code>body</code> Vec Serialized message body.","boost":2},{"location":"arch/node/networking/inter_domain/peer_sampling/peer_sampling_view.html","title":"PeerSamplingView","text":"","boost":2},{"location":"arch/node/networking/inter_domain/peer_sampling/peer_sampling_view.html#purpose","title":"Purpose","text":"<p>Peer Sampling view exchange.</p>","boost":2},{"location":"arch/node/networking/inter_domain/peer_sampling/peer_sampling_view.html#reception","title":"Reception","text":"<ul> <li>PeerSampling \\(\\to\\) PeerSamplingView \\(\\to\\) PeerSampling</li> </ul>","boost":2},{"location":"arch/node/networking/inter_domain/peer_sampling/peer_sampling_view.html#structure","title":"Structure","text":"Field Type Description <code>view</code> Vec View","boost":2},{"location":"arch/node/networking/inter_domain/peer_sampling/peer_sampling_view.html#triggers","title":"Triggers","text":"<ul> <li>PeerSampling \\(\\to\\) PeerSamplingView \\(\\to\\) PeerSampling</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/index.html","title":"Intra-domain P2P protocols","text":"","boost":2},{"location":"arch/node/networking/intra_domain/index.html#purpose","title":"Purpose","text":"<p>This engine group implements intra-domain P2P protocols that run and offer services inside a domain.</p> <p>Each domain has determines the set of protocols it runs and the authentication mechanism it uses.</p>","boost":2},{"location":"arch/node/networking/intra_domain/index.html#overview","title":"Overview","text":"","boost":2},{"location":"arch/node/networking/intra_domain/index.html#topology","title":"Topology","text":"<p>The Topology engine is responsible for overlay topology and membership management of a domain. The overlay maintenance protocol keeps the overlay connected despite high level of node failures. The membership protocol provides a partial view of the online members known locally.</p>","boost":2},{"location":"arch/node/networking/intra_domain/index.html#pubsub","title":"PubSub","text":"<p>The PubSub engine is responsible for P2P topic-based publish-subscribe event dissemination. It offers reliable causal delivery semantics with low latency.</p>","boost":2},{"location":"arch/node/networking/intra_domain/index.html#topics","title":"Topics","text":"<p>Each topic has a TopicIdentity, a set of publishers, and a set of subscribers.</p> <p>Topics are advertised by TopicAdvert messages, which include the TopicIdentity, the set of publishers, and an optional set of tags that allow automatic subscription to topics of interest.</p> <p>Topic advertisements and events published in the topic are authenticated by a signature of the TopicIdentity. Advertisements and events without a valid signature are dropped and not forwarded in the network.</p>","boost":2},{"location":"arch/node/networking/intra_domain/index.html#events","title":"Events","text":"<p>An event is a message sent to a topic by an authorized publisher. An event may have causal dependencies, which need to be delivered beforehand. The protocol includes a recovery mechanism for lost messages to ensure reliability, which can be detected by either gaps in per-publisher sequence numbers, or a missing dependency.</p>","boost":2},{"location":"arch/node/networking/intra_domain/index.html#usage","title":"Usage","text":"<p>Engines access the pub/sub service via the Router, and do not directly talk to the PubSub engine.</p> <p>The PubSub engine is solely responsible for participating in the P2P pub/sub protocols, while the Router engine is solely responsible for providing a pub/sub service for local engines.</p> <p>The PubSub engine subscribes to the local topics that correspond to the P2P pub/sub topics it manages. This allows republishing received events locally, and publishing events of local origin to remote subscribers in the network.</p> <p>The message flow diagram below shows intra-node and inter-node pub/sub messaging.</p>","boost":2},{"location":"arch/node/networking/intra_domain/index.html#storage","title":"Storage","text":"<p>The Storage engine provides P2P block storage.</p> <p>It supports block put and get requests, and a search mechanism to find nodes that store a specific storage block.</p> <p>When a node receives a storage request, it decides whether or not it provides service to the requesting node, and for how long it can guarantee storage. Storage nodes may require a certain level of trust and reputation, some form of authentication, or a proof of payment to store a block and guarantee its durability for a certain time.</p> <p>Storage blocks have limited lifetime, and expired blocks are garbage collected. Block lifetime may be extended upon request before expiration. Durability guarantees are ensured by storage requests that include the desired length of time the block should be stored for, and corresponding signed storage receipts with the provided guarantees.</p>","boost":2},{"location":"arch/node/networking/intra_domain/index.html#message-flow","title":"Message flow","text":"Multicast (pub/sub) message with publisher A_X and subscribers B_X, C_X, D_X sent to topic T. Published by node A and forwarded to node B and C, then from node B to node D. Multicast messages are sent along edges labeled T, while B, C, D are unicast messages between PubSub engine instances.   (Wiki) links on this page<ul><li>TopicIdentity</li><li>TopicAdvert</li><li>TopicIdentity</li><li>TopicIdentity</li><li>Router</li><li>PubSub</li><li>PubSub</li><li>Router</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/topology.html","title":"Topology","text":"","boost":2},{"location":"arch/node/networking/intra_domain/topology.html#purpose","title":"Purpose","text":"<p>Overlay topology maintenance protocol.</p>","boost":2},{"location":"arch/node/networking/intra_domain/topology.html#messages-received","title":"Messages received","text":"","boost":2},{"location":"arch/node/networking/intra_domain/topology.html#notifications-sent","title":"Notifications sent","text":"<ul> <li>PeerAddedToView</li> <li>PeerRemovedFromView</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/ext_request.html","title":"ExtRequest","text":"","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/ext_request.html#purpose","title":"Purpose","text":"<p>External request to a domain.</p>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/ext_request.html#reception","title":"Reception","text":"<ul> <li>Any Local Engine \\(\\to\\) ExtRequest \\(\\to\\) Domain</li> <li>Domain \\(\\to\\) ExtRequest \\(\\to\\) Domain</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/ext_request.html#structure","title":"Structure","text":"<p>Defined by domain protocols.</p>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/ext_request.html#effects","title":"Effects","text":"<ul> <li>When received from a local engine, the request is wrapped in a DomainRequest and sent over the network.</li> <li>When received from the network, an ExtResponse is sent back.</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/ext_request.html#triggers","title":"Triggers","text":"<ul> <li>Domain \\(\\to\\) DomainRequest \\(\\to\\) Domain Routing</li> <li>Domain \\(\\to\\) DomainResponse \\(\\to\\) Domain Routing</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/ext_response.html","title":"ExtResponse","text":"","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/ext_response.html#purpose","title":"Purpose","text":"<p>External request to a domain.</p>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/ext_response.html#reception","title":"Reception","text":"<ul> <li>Domain \\(\\to\\) ExtResponse \\(\\to\\) Domain</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/ext_response.html#structure","title":"Structure","text":"<p>Defined by domain protocols.</p>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/ext_response.html#effects","title":"Effects","text":"<p>The ExtResponse is forwarded to the local engine who sent the ExtRequest.</p>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/ext_response.html#triggers","title":"Triggers","text":"<ul> <li>Domain \\(\\to\\) ExtResponse \\(\\to\\) Any Local Engine</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/join_request.html","title":"JoinRequest","text":"","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/join_request.html#purpose","title":"Purpose","text":"<p>Request to join a domain.</p>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/join_request.html#reception","title":"Reception","text":"<ul> <li>Any Local Engine \\(\\to\\) JoinRequest \\(\\to\\) Domain</li> <li>Domain \\(\\to\\) JoinRequest \\(\\to\\) Domain</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/join_request.html#structure","title":"Structure","text":"Field Type Description <code>requestor</code> ExternalIdentity External identity of requestor <code>domain</code> ExternalIdentity Domain ID to join <code>auth</code> Option&gt; Optional authentication data <code>sig</code> Signature Signature by <code>requestor</code>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/join_request.html#triggers","title":"Triggers","text":"<ul> <li>Domain \\(\\to\\) JoinResponse \\(\\to\\) Domain</li> <li>Domain \\(\\to\\) JoinResponse \\(\\to\\) Any Local Engine</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/join_response.html","title":"JoinResponse","text":"","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/join_response.html#purpose","title":"Purpose","text":"<p>Response to a JoinRequest.</p>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/join_response.html#reception","title":"Reception","text":"<ul> <li>Domain \\(\\to\\) JoinResponse \\(\\to\\) Domain</li> <li>Domain \\(\\to\\) JoinResponse \\(\\to\\) Any Local Engine</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/join_response.html#structure","title":"Structure","text":"Field Type Description <code>approver</code> ExternalIdentity Identity of approver <code>requestor</code> ExternalIdentity Identity of requestor <code>domain</code> ExternalIdentity Domain ID to join <code>epoch</code> Option Current epoch of domain the membership is valid from, if approved <code>result</code> Result Join decision: acceptance or refusal <code>sig</code> Signature Signature by <code>approver</code>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/join_response.html#effects","title":"Effects","text":"<p>The JoinResponse is forwarded to the local engine who sent the JoinRequest.</p>","boost":2},{"location":"arch/node/networking/intra_domain/domain/messages/join_response.html#triggers","title":"Triggers","text":"<ul> <li>Domain \\(\\to\\) JoinResponse \\(\\to\\) Any Local Engine</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/domain/types/domain_advert_v1.html","title":"DomainAdvert","text":"","boost":2},{"location":"arch/node/networking/intra_domain/domain/types/domain_advert_v1.html#domainadvertv1","title":"DomainAdvertV1","text":"","boost":2},{"location":"arch/node/networking/intra_domain/domain/types/domain_advert_v1.html#purpose","title":"Purpose","text":"<p>Advertisement of a list of peers that are members of a domain.</p>","boost":2},{"location":"arch/node/networking/intra_domain/domain/types/domain_advert_v1.html#type","title":"Type","text":"<ul> <li> <p><code>id</code>: DomainIdentity</p> <p>Domain ID</p> </li> </ul> <ul> <li> <p><code>nodes</code>: Vec <p>List of nodes that handle external requests from non-members</p> <ul> <li> <p><code>version</code>: u32</p> <p>Version number</p> </li> </ul> <ul> <li> <p><code>created</code>: Time</p> <p>Time of creation</p> </li> </ul> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature by <code>id</code></p> </li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html","title":"Index","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#pubsub","title":"PubSub","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#purpose","title":"Purpose","text":"<p>The Publish-Subscribe (PubSub) engine implements a peer-to-peer topic-based publish-subscribe protocol. It is responsible for handling P2P protocol messages and managing subscriptions. Local engines send and receive pub/sub messages via the Router.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#usage","title":"~Usage~","text":"<p>The Router engine interfaces with the PubSub engine directly, while other local engines use the Router to subscribe to topics and send messages destined to the multicast address of a pub/sub topic, which the Router then forwards to PubSub for delivery.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#state","title":"State","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#pubsubroutingtable","title":"PubSubRoutingTable","text":"<p>Todo</p> <p>Pending a proper description.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#messages-received","title":"Messages received","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#topicadvert","title":"TopicAdvert","text":"<p>Topic advertisement by a publisher.</p> <p>Reception:</p> <p>TopicAdvertV1</p> <p>Record with fields:</p> <ul> <li> <p><code>topic</code>: TopicIdentity</p> <p>Topic ID</p> </li> </ul> <ul> <li> <p><code>tags</code>: list <p>List of optional tags to facilitate subscribing to new topics with relevant tags</p> <ul> <li> <p><code>publisher</code>: EngineIdentity</p> <p>PubSub engine ID of publisher</p> </li> </ul> <ul> <li> <p><code>created</code>: Time</p> <p>Creation time</p> </li> </ul> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature over the above fields by <code>topic</code></p> </li> </ul> <p>Triggers:</p> <p>TopicAdvert</p> <p>TopicAdvertReceived</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#subscribe","title":"Subscribe","text":"<p>Subscribe to a topic at another peer.</p> <p>Reception:</p> <p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <p>Triggers:</p> <p>SubscribeAck</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#unsubscribe","title":"Unsubscribe","text":"<p>Unsubscribe from a topic at other peers.</p> <p>Reception:</p> <p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <p>Triggers:</p> <p>UnsubscribeAck</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#event","title":"Event","text":"<p>An event sent to a topic.</p> <p>Reception:</p> <p>EventV1</p> <p>Record with fields:</p> <ul> <li> <p><code>topic</code>: TopicIdentity</p> <p>Topic the event is published to</p> </li> </ul> <ul> <li> <p><code>publisher</code>: EngineIdentity</p> <p>PubSub engine identity of pulisher</p> </li> </ul> <ul> <li> <p><code>seq</code>: u32</p> <p>Sequence number of publisher</p> </li> </ul> <ul> <li> <p><code>deps</code>: Vec <p>Events this event depends on</p> <ul> <li> <p><code>seen</code>: Vec <p>Independent events recently seen</p> <ul> <li> <p><code>body</code>: Vec <p>Encapsulated EngineMessage</p> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature by <code>publisher</code> over the above fields</p> </li> </ul> <p>Triggers:</p> <p>Event</p> <p>EngineMessage</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#enginemessage","title":"EngineMessage","text":"<p>A message sent to a pub/sub topic by an engine.</p> <p>Reception:</p> <p>EngineMessageV1</p> <p>Record with fields:</p> <ul> <li> <p><code>src</code>: EngineIdentity</p> <p>Source engine identity</p> </li> </ul> <ul> <li> <p><code>dst</code>: DestinationIdentity</p> <p>Destination identity</p> </li> </ul> <ul> <li> <p><code>id</code>: u64</p> <p>Message ID: unique per <code>src</code>-<code>dst</code> pairs</p> </li> </ul> <ul> <li> <p><code>reply_to</code>: Option <p><code>id</code> of a previous message this message is in reply to</p> <ul> <li> <p><code>expiry</code> Option <p>Expiry time for outgoing messages. See P2PMessage &amp; TransportMessage.</p> <ul> <li> <p><code>rprefs</code>: Option&lt;RoutingPrefs&gt;</p> <p>Routing preferences</p> </li> </ul> <ul> <li> <p><code>tprefs</code>: Option&lt;TransportPrefs&gt;</p> <p>Transport preferences</p> </li> </ul> <ul> <li> <p><code>protocol</code>: Protocol</p> <p>Protocol &amp; version used in <code>body</code></p> </li> </ul> <ul> <li> <p><code>body</code>: Vec <p>Serialized message body</p> <ul> <li> <p><code>sig</code>: Option <p>Signature over the above fields by <code>src</code></p> <p>Triggers:</p> <p>Event</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#subscriberequest","title":"SubscribeRequest","text":"<p>Subscription request.</p> <p>Reception:</p> <p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <p>Triggers:</p> <p>TopicResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#unsubscriberequest","title":"UnsubscribeRequest","text":"<p>Unsubscription request.</p> <p>Reception:</p> <p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <p>Triggers:</p> <p>TopicResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#startadvertrequest","title":"StartAdvertRequest","text":"<p>Start advertising a topic in the network.</p> <p>Reception:</p> <p>TopicCreateRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <ul> <li><code>scope</code>: RoutingScope Whether the topic should be advertised over the network.</li> </ul> <ul> <li><code>advert</code>: Option&lt;TopicAdvertV1&gt;  Topic advertisement to send to the network, when the <code>scope</code> allows.</li> </ul> <p>Triggers:</p> <p>TopicResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#stopadvertrequest","title":"StopAdvertRequest","text":"<p>Stop advertising a topic in the network.</p> <p>Reception:</p> <p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <p>Triggers:</p> <p>TopicResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#notifications-sent","title":"Notifications sent","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#topicsubscribed","title":"TopicSubscribed","text":"<p>Notification about a topic that was successfully subscribed at another peer.</p> <p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#topicunsubscribed","title":"TopicUnsubscribed","text":"<p>Notification about a topic that was successfully unsubscribed at another peer.</p> <p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#topicadvertreceived","title":"TopicAdvertReceived","text":"<p>A TopicAdvert has been received from another peer.</p> <p>TopicCreateRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <ul> <li><code>scope</code>: RoutingScope Whether the topic should be advertised over the network.</li> </ul> <ul> <li><code>advert</code>: Option&lt;TopicAdvertV1&gt;  Topic advertisement to send to the network, when the <code>scope</code> allows.</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/index.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% TODO\n\nRouter -) PubSub: EngineMessage\nPubSub -) PubSub: Event\nPubSub -) Router: EngineMessage\nRouter -) Any Local Engine: EngineMessage\n\nAny Local Engine -) Router: EngineMessage\nRouter -) PubSub: EngineMessage\nPubSub -) PubSub: Event\n\nPubSub -&gt;&gt;+ PubSub_R: Subscribe\nPubSub_R --&gt;&gt;- PubSub: SubscribeAck\n\nPubSub -&gt;&gt;+ PubSub_R: Unsubscribe\nPubSub_R --&gt;&gt;- PubSub: UnsubscribeAck\n\nRouter -&gt;&gt;+ PubSub: SubscribeRequest\nPubSub --&gt;&gt;- Router: SubscribeResponse\n\nRouter -&gt;&gt;+ PubSub: UnsubscribeRequest\nPubSub --&gt;&gt;- Router: UnsubscribeResponse\n\nRouter -&gt;&gt;+ PubSub: StartAdvertRequest\nPubSub --&gt;&gt;- Router: StartAdvertResponse\n\nRouter -&gt;&gt;+ PubSub: StopAdvertRequest\nPubSub --&gt;&gt;- Router: StopAdvertResponse\n\nPubSub -) Any Local Engine: TopicSubscribed\n\nPubSub -) Any Local Engine: TopicUnsubscribed\n\nPubSub -) Any Local Engine: TopicAdvertReceived</code></pre> (Wiki) links on this page<ul><li>Router</li><li>Router</li><li>PubSubRoutingTable</li><li>TopicAdvert</li><li>TopicAdvertV1</li><li>TopicIdentity</li><li>EngineIdentity</li><li>TopicAdvertReceived</li><li>Subscribe</li><li>TopicRequestV1</li><li>TopicIdentity</li><li>SubscribeAck</li><li>Unsubscribe</li><li>TopicRequestV1</li><li>TopicIdentity</li><li>UnsubscribeAck</li><li>Event</li><li>EventV1</li><li>TopicIdentity</li><li>EngineIdentity</li><li>EngineMessage</li><li>EngineMessage</li><li>EngineMessage to PubSub</li><li>EngineMessageV1</li><li>EngineIdentity</li><li>DestinationIdentity</li><li>P2PMessage to Transport</li><li>TransportMessage</li><li>RoutingPrefs</li><li>TransportPrefs</li><li>Event</li><li>SubscribeRequest</li><li>TopicRequestV1</li><li>TopicIdentity</li><li>TopicRequestV1</li><li>UnsubscribeRequest</li><li>TopicRequestV1</li><li>TopicIdentity</li><li>TopicRequestV1</li><li>StartAdvertRequest</li><li>TopicCreateRequestV1</li><li>TopicIdentity</li><li>RoutingScope</li><li>TopicAdvertV1</li><li>TopicRequestV1</li><li>StopAdvertRequest</li><li>TopicRequestV1</li><li>TopicIdentity</li><li>TopicRequestV1</li><li>TopicSubscribed</li><li>TopicRequestV1</li><li>TopicIdentity</li><li>TopicUnsubscribed</li><li>TopicRequestV1</li><li>TopicIdentity</li><li>TopicAdvertReceived</li><li>TopicAdvert</li><li>TopicCreateRequestV1</li><li>TopicIdentity</li><li>RoutingScope</li><li>TopicAdvertV1</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/engine_message.html","title":"EngineMessage to PubSub","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/engine_message.html#enginemessage","title":"EngineMessage","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/engine_message.html#purpose","title":"Purpose","text":"<p>A message sent to a pub/sub topic by an engine.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/engine_message.html#type","title":"Type","text":"<p>Reception:</p> <p>EngineMessageV1</p> <p>Record with fields:</p> <ul> <li> <p><code>src</code>: EngineIdentity</p> <p>Source engine identity</p> </li> </ul> <ul> <li> <p><code>dst</code>: DestinationIdentity</p> <p>Destination identity</p> </li> </ul> <ul> <li> <p><code>id</code>: u64</p> <p>Message ID: unique per <code>src</code>-<code>dst</code> pairs</p> </li> </ul> <ul> <li> <p><code>reply_to</code>: Option <p><code>id</code> of a previous message this message is in reply to</p> <ul> <li> <p><code>expiry</code> Option <p>Expiry time for outgoing messages. See P2PMessage &amp; TransportMessage.</p> <ul> <li> <p><code>rprefs</code>: Option&lt;RoutingPrefs&gt;</p> <p>Routing preferences</p> </li> </ul> <ul> <li> <p><code>tprefs</code>: Option&lt;TransportPrefs&gt;</p> <p>Transport preferences</p> </li> </ul> <ul> <li> <p><code>protocol</code>: Protocol</p> <p>Protocol &amp; version used in <code>body</code></p> </li> </ul> <ul> <li> <p><code>body</code>: Vec <p>Serialized message body</p> <ul> <li> <p><code>sig</code>: Option <p>Signature over the above fields by <code>src</code></p> <p>Triggers:</p> <p>Event</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/engine_message.html#behaviour","title":"Behaviour","text":"<p>When a local engine sends an EngineMessage destined to a pub/sub topic, the Router forwards it to all local engines subscribed to the message, including PubSub.</p> <p>PubSub then encapsulates the message in an Event, and forwards it to its neighbors along the event dissemination path.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/engine_message.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -) Router: EngineMessage\nRouter -) PubSub: EngineMessage\nPubSub -) PubSub: Event\n%% --8&lt;-- [end:sequence]</code></pre> (Wiki) links on this page<ul><li>EngineMessageV1</li><li>EngineIdentity</li><li>DestinationIdentity</li><li>P2PMessage to Transport</li><li>TransportMessage</li><li>RoutingPrefs</li><li>TransportPrefs</li><li>Event</li><li>EngineMessage</li><li>Router</li><li>Event</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/event.html","title":"Event","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/event.html#purpose","title":"Purpose","text":"<p>An event sent to a topic.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/event.html#type","title":"Type","text":"<p>Reception:</p> <p>EventV1</p> <p>Record with fields:</p> <ul> <li> <p><code>topic</code>: TopicIdentity</p> <p>Topic the event is published to</p> </li> </ul> <ul> <li> <p><code>publisher</code>: EngineIdentity</p> <p>PubSub engine identity of pulisher</p> </li> </ul> <ul> <li> <p><code>seq</code>: u32</p> <p>Sequence number of publisher</p> </li> </ul> <ul> <li> <p><code>deps</code>: Vec <p>Events this event depends on</p> <ul> <li> <p><code>seen</code>: Vec <p>Independent events recently seen</p> <ul> <li> <p><code>body</code>: Vec <p>Encapsulated EngineMessage</p> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature by <code>publisher</code> over the above fields</p> </li> </ul> <p>Triggers:</p> <p>Event</p> <p>EngineMessage</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/event.html#behaviour","title":"Behaviour","text":"<p>The Event is forwarded in the network along topic dissemination paths. It contains an encapsulated EngineMessage addressed from an engine to the topic.</p> <p>The PubSub engine delivers the encapsulated EngineMessage to local engines by sending it to the Router, which forwards it to local engines subscribed to the topic.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/event.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nRouter -) PubSub: EngineMessage\nPubSub -) PubSub: Event\nPubSub -) Router: EngineMessage\nRouter -) Any Local Engine: EngineMessage\n%% --8&lt;-- [end:sequence]</code></pre> (Wiki) links on this page<ul><li>EventV1</li><li>TopicIdentity</li><li>EngineIdentity</li><li>EngineMessage</li><li>EngineMessage</li><li>EngineMessage</li><li>EngineMessage</li><li>Router</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/start_advert_request.html","title":"Start advert request","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/start_advert_request.html#startadvertrequest","title":"StartAdvertRequest","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/start_advert_request.html#purpose","title":"Purpose","text":"<p>Start advertising a topic in the network.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/start_advert_request.html#type","title":"Type","text":"<p>Reception:</p> <p>TopicCreateRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <ul> <li><code>scope</code>: RoutingScope Whether the topic should be advertised over the network.</li> </ul> <ul> <li><code>advert</code>: Option&lt;TopicAdvertV1&gt;  Topic advertisement to send to the network, when the <code>scope</code> allows.</li> </ul> <p>Triggers:</p> <p>TopicResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/start_advert_request.html#behaviour","title":"Behaviour","text":"<p>Send TopicAdvert to connected neighbors in the domain.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/start_advert_request.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nRouter -&gt;&gt;+ PubSub: StartAdvertRequest\nPubSub --&gt;&gt;- Router: StartAdvertResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/stop_advert_request.html","title":"Stop advert request","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/stop_advert_request.html#stopadvertrequest","title":"StopAdvertRequest","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/stop_advert_request.html#purpose","title":"Purpose","text":"<p>Stop advertising a topic in the network.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/stop_advert_request.html#type","title":"Type","text":"<p>Reception:</p> <p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <p>Triggers:</p> <p>TopicResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/stop_advert_request.html#behaviour","title":"Behaviour","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/stop_advert_request.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nRouter -&gt;&gt;+ PubSub: StopAdvertRequest\nPubSub --&gt;&gt;- Router: StopAdvertResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe.html","title":"Subscribe","text":"(Wiki) links on this page<ul><li>TopicRequestV1</li><li>TopicIdentity</li><li>SubscribeAck</li><li>PubSubRoutingTable</li><li>SubscribeAck</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe.html#subscribe","title":"Subscribe","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe.html#purpose","title":"Purpose","text":"<p>Subscribe to a topic at another peer.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe.html#type","title":"Type","text":"<p>Reception:</p> <p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <p>Triggers:</p> <p>SubscribeAck</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe.html#behaviour","title":"Behaviour","text":"<p>The peer the request arrived from is added to the PubSubRoutingTable, and a SubscribeAck is returned in response.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nPubSub -&gt;&gt;+ PubSub_R: Subscribe\nPubSub_R --&gt;&gt;- PubSub: SubscribeAck\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe_ack.html","title":"SubscribeAck","text":"(Wiki) links on this page<ul><li>TopicRequestV1</li><li>TopicIdentity</li><li>TopicSubscribed</li><li>TopicSubscribed</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe_ack.html#subscribeack","title":"SubscribeAck","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe_ack.html#purpose","title":"Purpose","text":"<p>Subscription acknowledgement.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe_ack.html#type","title":"Type","text":"<p>Reception:</p> <p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <p>Triggers:</p> <p>TopicSubscribed</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe_ack.html#behaviour","title":"Behaviour","text":"<p>A TopicSubscribed notification is sent to local engines.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe_ack.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nPubSub -&gt;&gt;+ PubSub_R: Subscribe\nPubSub_R --&gt;&gt;- PubSub: SubscribeAck\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe_request.html","title":"SubscribeRequest","text":"(Wiki) links on this page<ul><li>TopicRequestV1</li><li>TopicIdentity</li><li>TopicRequestV1</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe_request.html#subscriberequest","title":"SubscribeRequest","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe_request.html#purpose","title":"Purpose","text":"<p>Subscription request.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe_request.html#type","title":"Type","text":"<p>Reception:</p> <p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <p>Triggers:</p> <p>TopicResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe_request.html#behaviour","title":"Behaviour","text":"<p>If not already subscribed, PubSub subscribes to the specified topic by sending a P2P subscription request(s) to connected peers in the domain.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/subscribe_request.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nRouter -&gt;&gt;+ PubSub: SubscribeRequest\nPubSub --&gt;&gt;- Router: SubscribeResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/topic_advert.html","title":"TopicAdvert","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/topic_advert.html#purpose","title":"Purpose","text":"<p>Topic advertisement by a publisher.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/topic_advert.html#type","title":"Type","text":"<p>Reception:</p> <p>TopicAdvertV1</p> <p>Record with fields:</p> <ul> <li> <p><code>topic</code>: TopicIdentity</p> <p>Topic ID</p> </li> </ul> <ul> <li> <p><code>tags</code>: list <p>List of optional tags to facilitate subscribing to new topics with relevant tags</p> <ul> <li> <p><code>publisher</code>: EngineIdentity</p> <p>PubSub engine ID of publisher</p> </li> </ul> <ul> <li> <p><code>created</code>: Time</p> <p>Creation time</p> </li> </ul> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature over the above fields by <code>topic</code></p> </li> </ul> <p>Triggers:</p> <p>TopicAdvert</p> <p>TopicAdvertReceived</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/topic_advert.html#behaviour","title":"Behaviour","text":"<p>Update topic routing table, snd a TopicAdvertReceived notification, and forward the TopicAdvert to connected peers in the same domain.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/topic_advert.html#reception","title":"Reception","text":"<ul> <li>PubSub \\(\\to\\) TopicAdvert \\(\\to\\) PubSub</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/topic_advert.html#triggers","title":"Triggers","text":"<ul> <li>PubSub \\(\\to\\) TopicAdvert \\(\\to\\) PubSub</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/topic_advert.html#message-flow","title":"Message flow","text":"<pre><code>%% --8&lt;-- [start:sequence]\n%% TODO\n%% --8&lt;-- [end:sequence]</code></pre> (Wiki) links on this page<ul><li>TopicAdvertV1</li><li>TopicIdentity</li><li>EngineIdentity</li><li>TopicAdvertReceived</li><li>TopicAdvertReceived</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe.html","title":"Unsubscribe","text":"(Wiki) links on this page<ul><li>TopicRequestV1</li><li>TopicIdentity</li><li>UnsubscribeAck</li><li>PubSubRoutingTable</li><li>UnsubscribeAck</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe.html#unsubscribe","title":"Unsubscribe","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe.html#purpose","title":"Purpose","text":"<p>Unsubscribe from a topic at other peers.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe.html#type","title":"Type","text":"<p>Reception:</p> <p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <p>Triggers:</p> <p>UnsubscribeAck</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe.html#behaviour","title":"Behaviour","text":"<p>The peer the request arrived from is removed from the PubSubRoutingTable, and an UnsubscribeAck is returned in response.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nPubSub -&gt;&gt;+ PubSub_R: Unsubscribe\nPubSub_R --&gt;&gt;- PubSub: UnsubscribeAck\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe_ack.html","title":"UnsubscribeAck","text":"(Wiki) links on this page<ul><li>TopicRequestV1</li><li>TopicIdentity</li><li>TopicUnsubscribed</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe_ack.html#unsubscribeack","title":"UnsubscribeAck","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe_ack.html#purpose","title":"Purpose","text":"<p>Unsubscription acknowledgement.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe_ack.html#type","title":"Type","text":"<p>Reception:</p> <p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <p>Triggers:</p> <p>ToicUnsubscribed</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe_ack.html#behaviour","title":"Behaviour","text":"<p>A TopicUnsubscribed notification is sent to local engines.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe_ack.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nPubSub -&gt;&gt;+ PubSub_R: Unsubscribe\nPubSub_R --&gt;&gt;- PubSub: UnsubscribeAck\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe_request.html","title":"UnsubscribeRequest","text":"(Wiki) links on this page<ul><li>TopicRequestV1</li><li>TopicIdentity</li><li>TopicRequestV1</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe_request.html#unsubscriberequest","title":"UnsubscribeRequest","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe_request.html#purpose","title":"Purpose","text":"<p>Unsubscription request.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe_request.html#type","title":"Type","text":"<p>Reception:</p> <p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <p>Triggers:</p> <p>TopicResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe_request.html#behaviour","title":"Behaviour","text":"<p>If subscribed to the given topic, PubSub unsubscribes from it by sending P2P unsubscription requests to connected peers.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/messages/unsubscribe_request.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nRouter -&gt;&gt;+ PubSub: UnsubscribeRequest\nPubSub --&gt;&gt;- Router: UnsubscribeResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/notifications/topic_advert_received.html","title":"TopicAdvertReceived","text":"(Wiki) links on this page<ul><li>TopicAdvert</li><li>TopicCreateRequestV1</li><li>TopicIdentity</li><li>RoutingScope</li><li>TopicAdvertV1</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/notifications/topic_advert_received.html#topicadvertreceived","title":"TopicAdvertReceived","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/notifications/topic_advert_received.html#purpose","title":"Purpose","text":"<p>A TopicAdvert has been received from another peer.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/notifications/topic_advert_received.html#type","title":"Type","text":"<p>TopicCreateRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <ul> <li><code>scope</code>: RoutingScope Whether the topic should be advertised over the network.</li> </ul> <ul> <li><code>advert</code>: Option&lt;TopicAdvertV1&gt;  Topic advertisement to send to the network, when the <code>scope</code> allows.</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/notifications/topic_advert_received.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nPubSub -) Any Local Engine: TopicAdvertReceived\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/notifications/topic_subscribed.html","title":"TopicSubscribed","text":"(Wiki) links on this page<ul><li>TopicRequestV1</li><li>TopicIdentity</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/notifications/topic_subscribed.html#topicsubscribed","title":"TopicSubscribed","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/notifications/topic_subscribed.html#purpose","title":"Purpose","text":"<p>Notification about a topic that was successfully subscribed at another peer.   </p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/notifications/topic_subscribed.html#type","title":"Type","text":"<p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/notifications/topic_subscribed.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nPubSub -) Any Local Engine: TopicSubscribed\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/notifications/topic_unsubscribed.html","title":"TopicUnsubscribed","text":"(Wiki) links on this page<ul><li>TopicRequestV1</li><li>TopicIdentity</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/notifications/topic_unsubscribed.html#topicunsubscribed","title":"TopicUnsubscribed","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/notifications/topic_unsubscribed.html#purpose","title":"Purpose","text":"<p>Notification about a topic that was successfully unsubscribed at another peer.   </p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/notifications/topic_unsubscribed.html#type","title":"Type","text":"<p>TopicRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/notifications/topic_unsubscribed.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nPubSub -) Any Local Engine: TopicUnsubscribed\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/event_v1.html","title":"EventV1","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/event_v1.html#purpose","title":"Purpose","text":"<p>Describe the purpose of the type.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/event_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>topic</code>: TopicIdentity</p> <p>Topic the event is published to</p> </li> </ul> <ul> <li> <p><code>publisher</code>: EngineIdentity</p> <p>PubSub engine identity of pulisher</p> </li> </ul> <ul> <li> <p><code>seq</code>: u32</p> <p>Sequence number of publisher</p> </li> </ul> <ul> <li> <p><code>deps</code>: Vec <p>Events this event depends on</p> <ul> <li> <p><code>seen</code>: Vec <p>Independent events recently seen</p> <ul> <li> <p><code>body</code>: Vec <p>Encapsulated EngineMessage</p> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature by <code>publisher</code> over the above fields</p> </li> </ul> (Wiki) links on this page<ul><li>TopicIdentity</li><li>EngineIdentity</li><li>EngineMessage</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/pubsub_routing_table.html","title":"PubSubRoutingTable","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/pubsub_routing_table.html#purpose","title":"Purpose","text":"<p>Todo</p> <p>Pending a proper description.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/pubsub_routing_table.html#type","title":"Type","text":"<p>A list of type PubSubRoutingTableEntry.</p> (Wiki) links on this page<ul><li>PubSubRoutingTableEntry</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/pubsub_routing_table_entry.html","title":"PubSubRoutingTableEntry","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/pubsub_routing_table_entry.html#purpose","title":"Purpose","text":"<p>A pub/sub routing table entry.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/pubsub_routing_table_entry.html#type","title":"Type","text":"<p>A struct with the following fields:</p> Field Type Description <code>id</code> TopicIdentity Topic ID <code>advert</code> TopicAdvert Topic advertisement <code>parents</code> NodeIdentity Parent peers incoming messages arrive from for the topic <code>children</code> NodeIdentity Children peers to forward incoming messages to in the topic (Wiki) links on this page<ul><li>TopicIdentity</li><li>TopicAdvert</li><li>NodeIdentity</li><li>NodeIdentity</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/topic_advert_v1.html","title":"TopicAdvertV1","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/topic_advert_v1.html#purpose","title":"Purpose","text":"<p>Topic advertisement.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/topic_advert_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>topic</code>: TopicIdentity</p> <p>Topic ID</p> </li> </ul> <ul> <li> <p><code>tags</code>: list <p>List of optional tags to facilitate subscribing to new topics with relevant tags</p> <ul> <li> <p><code>publisher</code>: EngineIdentity</p> <p>PubSub engine ID of publisher</p> </li> </ul> <ul> <li> <p><code>created</code>: Time</p> <p>Creation time</p> </li> </ul> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature over the above fields by <code>topic</code></p> </li> </ul> (Wiki) links on this page<ul><li>TopicIdentity</li><li>EngineIdentity</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/topic_request_v1.html","title":"TopicRequestV1","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/topic_request_v1.html#purpose","title":"Purpose","text":"<p>Request for an operation on a pub/sub topic.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/topic_request_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> (Wiki) links on this page<ul><li>TopicIdentity</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/topic_response_v1.html","title":"TopicResponseV1","text":"","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/topic_response_v1.html#purpose","title":"Purpose","text":"<p>Response to a TopicRequestV1.</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/topic_response_v1.html#type","title":"Type","text":"<p>Result</p>","boost":2},{"location":"arch/node/networking/intra_domain/pubsub/types/topic_response_v1.html#values","title":"Values","text":"<ul> <li>OK: Success</li> <li>ERROR: Failure</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/index.html","title":"Storage","text":"","boost":2},{"location":"arch/node/networking/intra_domain/storage/index.html#purpose","title":"Purpose","text":"<p>Content-addressed block storage.</p>","boost":2},{"location":"arch/node/networking/intra_domain/storage/index.html#blocklookuprequest","title":"BlockLookupRequest","text":"<p>From Any Local Engine, may trigger:</p> <ul> <li>BlockResult</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/index.html#blockgetrequest","title":"BlockGetRequest","text":"<p>From any local engine, may trigger:</p> <ul> <li>BlockResult</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/index.html#blockputrequest","title":"BlockPutRequest","text":"<p>From any local engine, may trigger:</p> <ul> <li>BlockPutResponse</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/index.html#blocksearchtopic","title":"BlockSearchTopic","text":"<p>From Storage, may trigger:</p> <ul> <li>BlockSearchTopic</li> <li>BlockResult</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/index.html#blocksearchrandom","title":"BlockSearchRandom","text":"<p>From Storage, may trigger:</p> <ul> <li>BlockSearchRandom</li> <li>BlockResult</li> </ul> (Wiki) links on this page<ul><li>BlockLookupRequest</li><li>BlockResult</li><li>BlockGetRequest</li><li>BlockResult</li><li>BlockPutRequest</li><li>BlockPutResponse</li><li>BlockSearchTopic</li><li>BlockSearchTopic</li><li>BlockResult</li><li>BlockSearchRandom</li><li>BlockSearchRandom</li><li>BlockResult</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_get_request.html","title":"BlockGetRequest","text":"","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_get_request.html#purpose","title":"Purpose","text":"<p>Request contents of a block by its content hash ID.</p>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_get_request.html#reception","title":"Reception","text":"<ul> <li>Any \\(\\to\\) BlockGetRequest \\(\\to\\) Storage</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_get_request.html#structure","title":"Structure","text":"Field Type Description <code>id</code> BlockId Block ID","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_get_request.html#triggers","title":"Triggers","text":"<ul> <li>Storage \\(\\to\\) BlockGetResponse \\(\\to\\) Any</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_put_request.html","title":"BlockPutRequest","text":"","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_put_request.html#purpose","title":"Purpose","text":"<p>Request storing a block.</p>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_put_request.html#reception","title":"Reception","text":"<ul> <li>Any \\(\\to\\) BlockPutRequest \\(\\to\\) Storage</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_put_request.html#structure","title":"Structure","text":"Field Type Description <code>id</code> BlockId Block ID <code>content</code> Vec Block content <code>prefs</code> StoragePrefs Block storage preferences","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_put_request.html#triggers","title":"Triggers","text":"<ul> <li>Storage \\(\\to\\) BlockPutResponse \\(\\to\\) Any</li> </ul> (Wiki) links on this page<ul><li>BlockPutResponse</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_result.html","title":"BlockResponse","text":"","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_result.html#purpose","title":"Purpose","text":"<p>Response to a block request.</p>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_result.html#structure","title":"Structure","text":"Field Type Description <code>id</code> BlockId Block ID <code>content</code> Vec Block content <code>prefs</code> StoragePrefs Storage preferences (Wiki) links on this page<ul><li>StoragePrefs</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search.html","title":"BlockLookupRequest","text":"","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search.html#purpose","title":"Purpose","text":"<p>Look up a block in local storage and on the network.</p>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search.html#reception","title":"Reception","text":"<ul> <li>Any Local Engine \\(\\to\\) BlockLookupRequest \\(\\to\\) Storage</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search.html#structure","title":"Structure","text":"Field Type Description <code>block</code> BlockId Block ID <code>topic</code> Option&lt;TopicIdentity&gt; Enable search in a PubSub topic <code>random</code> bool Enable search using random walk <code>domain</code> Option&lt;DomainIdentity&gt; Restrict the random walk to a domain","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search.html#behaviour","title":"Behaviour","text":"<p>First query the local storage for the block. If not found, initiate a search on the network, when either <code>topic</code> or <code>random</code> is enabled.</p>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search.html#triggers","title":"Triggers","text":"<ul> <li>Storage \\(\\to\\) BlockResponse \\(\\to\\) Any Local Engine</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search_random.html","title":"BlockSearchRandom","text":"","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search_random.html#purpose","title":"Purpose","text":"<p>Search for a block along a random walk.</p>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search_random.html#reception","title":"Reception","text":"<ul> <li>Storage \\(\\to\\) BlockSearchTopic \\(\\to\\) Storage</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search_random.html#structure","title":"Structure","text":"Field Type Description <code>block</code> BlockId Block ID <code>domain</code> Option&lt;DomainIdentity&gt; Restrict the random walk to a domain <code>requestor</code> NodeIdentity Requestor's Peer ID","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search_random.html#behaviour","title":"Behaviour","text":"<p>BlockResponse</p> (Wiki) links on this page<ul><li>DomainIdentity</li><li>NodeIdentity</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search_topic.html","title":"BlockSearchTopic","text":"","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search_topic.html#purpose","title":"Purpose","text":"<p>Search for a block along the reverse publishing path of a pub/sub topic.</p>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search_topic.html#reception","title":"Reception","text":"<ul> <li>Storage \\(\\to\\) BlockSearchTopic \\(\\to\\) Storage</li> </ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search_topic.html#structure","title":"Structure","text":"Field Type Description <code>block</code> BlockId Block ID <code>topic</code> TopicIdentity Topic ID","boost":2},{"location":"arch/node/networking/intra_domain/storage/messages/block_search_topic.html#behaviour","title":"Behaviour","text":"<p>BlockResponse</p> (Wiki) links on this page<ul><li>TopicIdentity</li></ul>","boost":2},{"location":"arch/node/networking/intra_domain/storage/types/storage_prefs.html","title":"StoragePrefs","text":"","boost":2},{"location":"arch/node/networking/intra_domain/storage/types/storage_prefs.html#purpose","title":"Purpose","text":"<p>Storage preferences.</p>","boost":2},{"location":"arch/node/networking/intra_domain/storage/types/storage_prefs.html#type","title":"Type","text":"<p>Struct with the following fields.</p> Field Type Description <code>expiry</code> Timestamp Expiry time after which the block is deleted. <code>min_trust</code> u8 Minimum trust value required when serving the block to third parties.","boost":2},{"location":"arch/node/networking/node/index.html","title":"Intra-node &amp; inter-node protocols","text":"","boost":2},{"location":"arch/node/networking/node/index.html#purpose","title":"Purpose","text":"<p>This group of engines are responsible for facilitating communication between local engines (intra-node), and between engines of two directly connected remote nodes (inter-node).</p> <p>These engines provide message routing and network transport functionality, and store information about network identities: advertisements received from the network and associated local metadata.</p>","boost":2},{"location":"arch/node/networking/node/index.html#overview","title":"Overview","text":"","boost":2},{"location":"arch/node/networking/node/index.html#router","title":"Router","text":"","boost":2},{"location":"arch/node/networking/node/index.html#purpose_1","title":"Purpose","text":"<p>The Router is responsible for forwarding both intra-node and inter-node messages between engine instances. It forwards intra-node messages directly between local engines, and sends and receives inter-node messages via the Transport engine. It makes routing decisions based on the DestinationIdentity in EngineMessage headers, and retrieves routing information for identities from the Network Identity Store engine.</p>","boost":2},{"location":"arch/node/networking/node/index.html#addressing","title":"Addressing","text":"<p>Both the source and destination address of an EngineMessage is an ExternalIdentity. The source is always the EngineIdentity of an engine instance, while the DestinationIdentity can belong to either an engine instance, a domain, or a pub/sub topic, which corresponds to unicast, anycast, and multicast communication patterns, respectively.</p> <p>A unicast message is sent between two (local or remote) engine instances, an anycast message is sent from an engine instance to any member of a domain, while a pub/sub message is sent from an engine instance to all subscribers of a topic. Pub/sub messages are sent between local engine instances via the Router that manages subscriptions and routes messages, whereas inter-node pub/sub messages are handled by the PubSub engine.</p> <p>When an EngineMessage is sent between peers, it is wrapped in a P2PMessage and signed by the source NodeIdentity. The node identity is defined as the external identity of the Router engine instance of a node.</p>","boost":2},{"location":"arch/node/networking/node/index.html#routing","title":"Routing","text":"<p>The Router makes routing decisions based on the DestinationIdentity of an EngineMessage, and forwards the message either to one or more local engines, or to the Transport engine for delivery to a remote node.</p> <p>The message processing and routing process is described in the EngineMessage section.</p>","boost":2},{"location":"arch/node/networking/node/index.html#inter-node-messages","title":"Inter-node messages","text":"<p>When forwarding an EngineMessage to a remote node, the Router wraps it in P2PMessage, signs it with its NodeIdentity key, and forwards it to Transport for delivery over the network.</p>","boost":2},{"location":"arch/node/networking/node/index.html#transport","title":"Transport","text":"","boost":2},{"location":"arch/node/networking/node/index.html#purpose_2","title":"Purpose","text":"<p>The Transport engine is responsible for sending and receiving messages from other nodes over the network, establishing and maintaining authenticated and encrypted communication channels to other nodes via various transport protocols.</p>","boost":2},{"location":"arch/node/networking/node/index.html#connection-pool","title":"Connection pool","text":"<p>The Transport engine maintains a pool of connections to remote nodes, which can be either permanent or ephemeral. Ephemeral connections are disconnected after a period of inactivity, and lost in case of a network error. Permanent connections are maintained indefinitely and reconnected when the connection fails.</p>","boost":2},{"location":"arch/node/networking/node/index.html#transport-protocols","title":"Transport protocols","text":"<p>The Transport engine delivers messages over the network via various transport protocols, either using protocols directly over IP (such as QUIC or Secure WebSocket), through an overlay network (such as onion routed or mix networks), or via asynchronous, delay-tolerant networks.</p> <p>Transport protocols are responsible for the authentication and encryption of each sent and received TransportMessage, but not responsible for authenticating or verifying remote node identities, which is done by the Router instead, by signing and verifying each sent and received P2PMessage.</p>","boost":2},{"location":"arch/node/networking/node/index.html#transport-preferences","title":"Transport preferences","text":"<p>Transport protocol choice is based on Transport preferences that can be specified in either an EngineMessage header, or a NodeIdentityRecord stored by the Network Identity Store engine, which contains both NodeAdverts received from the network and local preferences associated with nodes.</p> <p>When multiple transport addresses of a peer are known for the transport(s) chosen according to transport preferences, then address choice is based on both the peer's own preferences in its NodeAdvert, and local measurements (e.g. latency) and preferences (e.g. prefer LAN over WAN IP addresses)</p>","boost":2},{"location":"arch/node/networking/node/index.html#connection-establishement","title":"Connection establishement","text":"<p>To establish a connection, the Transport engine needs a TransportAddress to connect to, which contains the transport protocol and address for the network connection.</p> <p>In case of transports over IP that use X.509 certificates (such as QUIC or Secure WebSocket), the TransportAddress contains the destination IP address &amp; port, as well as the certificate issuer's public key, which is used for subsequent verification of the remote peer's transport certificate. Whereas for transports that use public key addressing, the destination public key address is given instead, possibly together with additional transport-specific dial information.</p> <p>Once the connection is set up, Transport sends a PeerConnected notification, or in case of connection failure a PeerConnectFailed notification instead. While at the end of the connection, a PeerDisconnected notification is sent.</p>","boost":2},{"location":"arch/node/networking/node/index.html#network-identity-store","title":"Network Identity Store","text":"<p>The Network Identity Store (NIS) engine stores information associated with known external identities (of peers, topics, domains, and engines), such as advertised addresses and local metadata. The information stored can come from various sources, such as local configuration, P2P protocols (e.g. peer sampling, clustering, pub/sub), other engines, or user input.</p> <p>In case of peer identities, it stores known addresses along with local routing and transport preferences, latency measurements, trust metric and trust zone (e.g. local, remote).</p>","boost":2},{"location":"arch/node/networking/node/index.html#message-flow","title":"Message flow","text":"Unicast message from engine A_X to engine A_Y, along edges labeled Y. Multicast message from publisher engine A_Z to topic T, delivered to subscribed engines A_X and A_Y by the router A_R, along edges labeled T.   Unicast message between engine A_X of node A and engine B_X of node B, via router engines A_R &amp; B_R and transport engines A_T &amp; B_T.   (Wiki) links on this page<ul><li>Router</li><li>Transport</li><li>DestinationIdentity</li><li>EngineMessage</li><li>Network Identity Store</li><li>EngineMessage</li><li>EngineIdentity</li><li>DestinationIdentity</li><li>Router</li><li>PubSub</li><li>EngineMessage</li><li>P2PMessage</li><li>NodeIdentity</li><li>Router</li><li>DestinationIdentity</li><li>EngineMessage</li><li>Transport</li><li>EngineMessage</li><li>EngineMessage</li><li>P2PMessage</li><li>NodeIdentity</li><li>Transport</li><li>Transport</li><li>TransportMessage</li><li>NodeIdentity</li><li>Router</li><li>P2PMessage</li><li>TransportPrefs</li><li>EngineMessage</li><li>NodeIdentityRecord</li><li>Network Identity Store</li><li>NodeAdvert</li><li>NodeAdvert</li><li>TransportAddress</li><li>TransportAddress</li><li>Network Identity Store</li></ul>","boost":2},{"location":"arch/node/networking/node/id_store/index.html","title":"Index","text":"","boost":2},{"location":"arch/node/networking/node/id_store/index.html#network-identity-store","title":"Network Identity Store","text":"","boost":2},{"location":"arch/node/networking/node/id_store/index.html#purpose","title":"Purpose","text":"<p>The Network Identity Store (NIS) engine stores information associated with known external identities (of peers, topics, domains, and engines), such as advertised addresses and local metadata. The information stored can come from various sources, such as local configuration, P2P protocols (e.g. peer sampling, clustering, pub/sub), other engines, or user input.</p> <p>In case of peer identities, it stores known addresses along with local routing and transport preferences, latency measurements, trust metric and trust zone (e.g. local, remote).</p>","boost":2},{"location":"arch/node/networking/node/id_store/index.html#state","title":"State","text":"","boost":2},{"location":"arch/node/networking/node/id_store/index.html#identitystore","title":"IdentityStore","text":"<p>Contains all identity records stored by the engine.</p> <p>Backed by the local key-value store (key: external identity, value: identity record).</p> <p>list&lt;(ExternalIdentity, IdentityRecord)&gt;</p>","boost":2},{"location":"arch/node/networking/node/id_store/index.html#messages-received","title":"Messages received","text":"","boost":2},{"location":"arch/node/networking/node/id_store/index.html#lookupidentityrequest","title":"LookupIdentityRequest","text":"<p>Look up information about an  external identity in the local database.</p> <p>Reception:</p> <p>LookupIdentityRequestV1</p> <p>Record with fields:</p> <ul> <li> <p><code>id</code>: ExternalIdentity</p> <p>External identity to look up.</p> </li> </ul> <p>Triggers:</p> <p>LookupIdentityResponseV1</p> <p>Record with fields:</p> <ul> <li> <p><code>id</code>: ExternalIdentity</p> <p>External identity the response is about.</p> </li> </ul> <ul> <li> <p><code>record</code>: IdentityRecord</p> <p>Identity record associated with <code>id</code>.</p> </li> </ul>","boost":2},{"location":"arch/node/networking/node/id_store/index.html#updateidentityrequest","title":"UpdateIdentityRequest","text":"<p>Update information associated with a given external identity.</p> <p>Reception:</p> <p>UpdateIdentityRequestV1</p> <p>Record with fields:</p> <ul> <li> <p><code>id</code>: ExternalIdentity</p> <p>External identity to update.</p> </li> </ul> <ul> <li> <p><code>record</code>: IdentityRecord</p> <p>Identity record with updated fields.</p> </li> </ul> <p>Triggers:</p> <p>UpdateIdentityResponseV1</p> <p>Record with fields:</p> <ul> <li> <p><code>id</code>: ExternalIdentity</p> <p>External identity the response is about.</p> </li> </ul> <ul> <li> <p><code>result</code>: Result</p> <p>Result of the update operation.</p> </li> </ul>","boost":2},{"location":"arch/node/networking/node/id_store/index.html#notifications-sent","title":"Notifications sent","text":"","boost":2},{"location":"arch/node/networking/node/id_store/index.html#identityupdated","title":"IdentityUpdated","text":"<p>Notification sent after an IdentityRecord has been updated.</p> <p>IdentityUpdatedV1</p> <p>Record with fields:</p> <ul> <li> <p><code>id</code>: ExternalIdentity</p> <p>External identity the notification is about.</p> </li> </ul> <ul> <li> <p><code>record</code>: IdentityRecord</p> <p>Updated identity record.</p> </li> </ul>","boost":2},{"location":"arch/node/networking/node/id_store/index.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\nAny Local Engine -&gt;&gt;+ Network Identity Store: LookupIdentityRequest\nNetwork Identity Store --&gt;&gt;- Any Local Engine: LookupIdentityResponse\n\nAny Local Engine -&gt;&gt;+ Network Identity Store: UpdateIdentityRequest\nNetwork Identity Store --&gt;&gt;- Any Local Engine: UpdateIdentityResponse</code></pre> (Wiki) links on this page<ul><li>Network Identity Store</li><li>IdentityStore</li><li>IdentityRecord</li><li>LookupIdentityRequest</li><li>LookupIdentityRequestV1</li><li>LookupIdentityResponseV1</li><li>IdentityRecord</li><li>UpdateIdentityRequest</li><li>UpdateIdentityRequestV1</li><li>IdentityRecord</li><li>UpdateIdentityResponseV1</li><li>IdentityUpdated</li><li>IdentityRecord</li><li>IdentityUpdatedV1</li><li>IdentityRecord</li></ul>","boost":2},{"location":"arch/node/networking/node/id_store/messages/lookup_identity_request.html","title":"LookupIdentityRequest","text":"(Wiki) links on this page<ul><li>LookupIdentityRequestV1</li><li>LookupIdentityResponseV1</li><li>IdentityRecord</li></ul>","boost":2},{"location":"arch/node/networking/node/id_store/messages/lookup_identity_request.html#lookupidentityrequest","title":"LookupIdentityRequest","text":"","boost":2},{"location":"arch/node/networking/node/id_store/messages/lookup_identity_request.html#lookupidentityresponse","title":"LookupIdentityResponse","text":"","boost":2},{"location":"arch/node/networking/node/id_store/messages/lookup_identity_request.html#purpose","title":"Purpose","text":"<p>Look up information about an  external identity in the local database.</p>","boost":2},{"location":"arch/node/networking/node/id_store/messages/lookup_identity_request.html#type","title":"Type","text":"<p>Reception:</p> <p>LookupIdentityRequestV1</p> <p>Record with fields:</p> <ul> <li> <p><code>id</code>: ExternalIdentity</p> <p>External identity to look up.</p> </li> </ul> <p>Triggers:</p> <p>LookupIdentityResponseV1</p> <p>Record with fields:</p> <ul> <li> <p><code>id</code>: ExternalIdentity</p> <p>External identity the response is about.</p> </li> </ul> <ul> <li> <p><code>record</code>: IdentityRecord</p> <p>Identity record associated with <code>id</code>.</p> </li> </ul>","boost":2},{"location":"arch/node/networking/node/id_store/messages/lookup_identity_request.html#behaviour","title":"Behaviour","text":"<p>Return the information associated with the requested external identity.</p>","boost":2},{"location":"arch/node/networking/node/id_store/messages/lookup_identity_request.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Network Identity Store: LookupIdentityRequest\nNetwork Identity Store --&gt;&gt;- Any Local Engine: LookupIdentityResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/node/id_store/messages/update_identity_request.html","title":"UpdateIdentityRequest","text":"(Wiki) links on this page<ul><li>UpdateIdentityRequestV1</li><li>IdentityRecord</li><li>UpdateIdentityResponseV1</li></ul>","boost":2},{"location":"arch/node/networking/node/id_store/messages/update_identity_request.html#updateidentityrequest","title":"UpdateIdentityRequest","text":"","boost":2},{"location":"arch/node/networking/node/id_store/messages/update_identity_request.html#updateidentityresponse","title":"UpdateIdentityResponse","text":"","boost":2},{"location":"arch/node/networking/node/id_store/messages/update_identity_request.html#purpose","title":"Purpose","text":"<p>Update information associated with a given external identity.</p>","boost":2},{"location":"arch/node/networking/node/id_store/messages/update_identity_request.html#type","title":"Type","text":"<p>Reception:</p> <p>UpdateIdentityRequestV1</p> <p>Record with fields:</p> <ul> <li> <p><code>id</code>: ExternalIdentity</p> <p>External identity to update.</p> </li> </ul> <ul> <li> <p><code>record</code>: IdentityRecord</p> <p>Identity record with updated fields.</p> </li> </ul> <p>Triggers:</p> <p>UpdateIdentityResponseV1</p> <p>Record with fields:</p> <ul> <li> <p><code>id</code>: ExternalIdentity</p> <p>External identity the response is about.</p> </li> </ul> <ul> <li> <p><code>result</code>: Result</p> <p>Result of the update operation.</p> </li> </ul>","boost":2},{"location":"arch/node/networking/node/id_store/messages/update_identity_request.html#behaviour","title":"Behaviour","text":"<p>Update the provided information in the local data store.</p>","boost":2},{"location":"arch/node/networking/node/id_store/messages/update_identity_request.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Network Identity Store: UpdateIdentityRequest\nNetwork Identity Store --&gt;&gt;- Any Local Engine: UpdateIdentityResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/node/id_store/notifications/identity_updated.html","title":"IdentityUpdated","text":"(Wiki) links on this page<ul><li>IdentityRecord</li><li>IdentityUpdatedV1</li><li>IdentityRecord</li></ul>","boost":2},{"location":"arch/node/networking/node/id_store/notifications/identity_updated.html#identityupdated","title":"IdentityUpdated","text":"","boost":2},{"location":"arch/node/networking/node/id_store/notifications/identity_updated.html#purpose","title":"Purpose","text":"<p>Notification sent after an IdentityRecord has been updated.</p>","boost":2},{"location":"arch/node/networking/node/id_store/notifications/identity_updated.html#type","title":"Type","text":"<p>IdentityUpdatedV1</p> <p>Record with fields:</p> <ul> <li> <p><code>id</code>: ExternalIdentity</p> <p>External identity the notification is about.</p> </li> </ul> <ul> <li> <p><code>record</code>: IdentityRecord</p> <p>Updated identity record.</p> </li> </ul>","boost":2},{"location":"arch/node/networking/node/id_store/types/domain_identity_record.html","title":"DomainIdentityRecord","text":"","boost":2},{"location":"arch/node/networking/node/id_store/types/domain_identity_record.html#purpose","title":"Purpose","text":"<p>Record stored about a domain identity.</p>","boost":2},{"location":"arch/node/networking/node/id_store/types/domain_identity_record.html#type","title":"Type","text":"<p>Struct with the following fields.</p> Field Type Description <code>id</code> DomainIdentity Domain identity <code>advert</code> DomainAdvert Domain advertisement (Wiki) links on this page<ul><li>DomainIdentity</li></ul>","boost":2},{"location":"arch/node/networking/node/id_store/types/engine_identity_record.html","title":"EngineIdentityRecord","text":"","boost":2},{"location":"arch/node/networking/node/id_store/types/engine_identity_record.html#purpose","title":"Purpose","text":"<p>Record stored about an engine identity.</p>","boost":2},{"location":"arch/node/networking/node/id_store/types/engine_identity_record.html#type","title":"Type","text":"<p>Struct with the following fields.</p> Field Type Description <code>id</code> EngineIdentity Engine identity <code>addr</code> EngineAddress Engine address (Wiki) links on this page<ul><li>EngineIdentity</li></ul>","boost":2},{"location":"arch/node/networking/node/id_store/types/identity_record.html","title":"IdentityRecord","text":"","boost":2},{"location":"arch/node/networking/node/id_store/types/identity_record.html#purpose","title":"Purpose","text":"<p>Record stored about an identity.</p>","boost":2},{"location":"arch/node/networking/node/id_store/types/identity_record.html#type","title":"Type","text":"<p>Enum with values:</p> <ul> <li><code>Engine</code>: EngineIdentityRecord</li> <li><code>Node</code>: NodeIdentityRecord</li> <li><code>Domain</code>: DomainIdentityRecord</li> <li><code>Topic</code>: TopicIdentityRecord</li> </ul> (Wiki) links on this page<ul><li>EngineIdentityRecord</li><li>NodeIdentityRecord</li><li>DomainIdentityRecord</li><li>TopicIdentityRecord</li></ul>","boost":2},{"location":"arch/node/networking/node/id_store/types/identity_store.html","title":"IdentityStore","text":"","boost":2},{"location":"arch/node/networking/node/id_store/types/identity_store.html#purpose","title":"Purpose","text":"<p>Contains all identity records stored by the engine.</p> <p>Backed by the local key-value store (key: external identity, value: identity record).</p>","boost":2},{"location":"arch/node/networking/node/id_store/types/identity_store.html#type","title":"Type","text":"<p>list&lt;(ExternalIdentity, IdentityRecord)&gt;</p> (Wiki) links on this page<ul><li>IdentityRecord</li></ul>","boost":2},{"location":"arch/node/networking/node/id_store/types/identity_updated_v1.html","title":"IdentityUpdatedV1","text":"","boost":2},{"location":"arch/node/networking/node/id_store/types/identity_updated_v1.html#purpose","title":"Purpose","text":"<p>An updated IdentityRecord.</p>","boost":2},{"location":"arch/node/networking/node/id_store/types/identity_updated_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>id</code>: ExternalIdentity</p> <p>External identity the notification is about.</p> </li> </ul> <ul> <li> <p><code>record</code>: IdentityRecord</p> <p>Updated identity record.</p> </li> </ul> (Wiki) links on this page<ul><li>IdentityRecord</li><li>IdentityRecord</li></ul>","boost":2},{"location":"arch/node/networking/node/id_store/types/lookup_identity_request_v1.html","title":"LookupIdentityRequestV1","text":"","boost":2},{"location":"arch/node/networking/node/id_store/types/lookup_identity_request_v1.html#purpose","title":"Purpose","text":"<p>Request to look up information about an  external identity.</p>","boost":2},{"location":"arch/node/networking/node/id_store/types/lookup_identity_request_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>id</code>: ExternalIdentity</p> <p>External identity to look up.</p> </li> </ul>","boost":2},{"location":"arch/node/networking/node/id_store/types/lookup_identity_response_v1.html","title":"LookupIdentityResponseV1","text":"","boost":2},{"location":"arch/node/networking/node/id_store/types/lookup_identity_response_v1.html#purpose","title":"Purpose","text":"<p>Response to a LookupIdentityRequestV1.</p>","boost":2},{"location":"arch/node/networking/node/id_store/types/lookup_identity_response_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>id</code>: ExternalIdentity</p> <p>External identity the response is about.</p> </li> </ul> <ul> <li> <p><code>record</code>: IdentityRecord</p> <p>Identity record associated with <code>id</code>.</p> </li> </ul> (Wiki) links on this page<ul><li>LookupIdentityRequestV1</li><li>IdentityRecord</li></ul>","boost":2},{"location":"arch/node/networking/node/id_store/types/node_identity_record.html","title":"NodeIdentityRecord","text":"","boost":2},{"location":"arch/node/networking/node/id_store/types/node_identity_record.html#purpose","title":"Purpose","text":"<p>Record stored about a node identity.</p>","boost":2},{"location":"arch/node/networking/node/id_store/types/node_identity_record.html#type","title":"Type","text":"<p>Struct with the following fields.</p> Field Type Description <code>id</code> NodeIdentity Node identity <code>advert</code> Option&lt;NodeAdvert&gt; Node advertisement <code>trust</code> Option&lt;TrustValue&gt; Trust value <code>reputation</code> Option&lt;ReputationValue&gt; Reputation value <code>tprefs</code> Option&lt;TransportPrefs&gt; Transport preferences for this peer <code>cprefs</code> Option&lt;ConnectionPrefs&gt; Connection preferences for this peer (Wiki) links on this page<ul><li>NodeIdentity</li><li>NodeAdvert</li><li>TrustValue</li><li>ReputationValue</li><li>TransportPrefs</li><li>ConnectionPrefs</li></ul>","boost":2},{"location":"arch/node/networking/node/id_store/types/reputation_value.html","title":"ReputationValue","text":"","boost":2},{"location":"arch/node/networking/node/id_store/types/reputation_value.html#purpose","title":"Purpose","text":"<p>Express reputation of a peer.</p>","boost":2},{"location":"arch/node/networking/node/id_store/types/reputation_value.html#type","title":"Type","text":"<p>u8</p>","boost":2},{"location":"arch/node/networking/node/id_store/types/reputation_value.html#values","title":"Values","text":"<ul> <li>Range: <code>0..255</code></li> </ul>","boost":2},{"location":"arch/node/networking/node/id_store/types/topic_identity_record.html","title":"TopicIdentityRecord","text":"","boost":2},{"location":"arch/node/networking/node/id_store/types/topic_identity_record.html#purpose","title":"Purpose","text":"<p>Record stored about a pub/sub topic identity.</p>","boost":2},{"location":"arch/node/networking/node/id_store/types/topic_identity_record.html#type","title":"Type","text":"<p>Struct with the following fields.</p> Field Type Description <code>id</code> TopicIdentity Pub/sub topic identity <code>advert</code> TopicAdvert Pub/sub topic advertisement (Wiki) links on this page<ul><li>TopicIdentity</li><li>TopicAdvert</li></ul>","boost":2},{"location":"arch/node/networking/node/id_store/types/trust_value.html","title":"TrustValue","text":"","boost":2},{"location":"arch/node/networking/node/id_store/types/trust_value.html#purpose","title":"Purpose","text":"<p>Express trust for a peer.</p>","boost":2},{"location":"arch/node/networking/node/id_store/types/trust_value.html#type","title":"Type","text":"<p>u8</p>","boost":2},{"location":"arch/node/networking/node/id_store/types/trust_value.html#values","title":"Values","text":"<ul> <li>Range: <code>0..255</code></li> <li>Notable values:<ul> <li><code>0</code>: no trust, banned from communication</li> <li><code>128</code>: default value</li> <li><code>255</code>: fully trusted nodes (e.g. other nodes of the same user/entity)</li> </ul> </li> </ul>","boost":2},{"location":"arch/node/networking/node/id_store/types/update_identity_request_v1.html","title":"UpdateIdentityRequestV1","text":"","boost":2},{"location":"arch/node/networking/node/id_store/types/update_identity_request_v1.html#purpose","title":"Purpose","text":"<p>Update information associated with a given external identity.</p>","boost":2},{"location":"arch/node/networking/node/id_store/types/update_identity_request_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>id</code>: ExternalIdentity</p> <p>External identity to update.</p> </li> </ul> <ul> <li> <p><code>record</code>: IdentityRecord</p> <p>Identity record with updated fields.</p> </li> </ul> (Wiki) links on this page<ul><li>IdentityRecord</li></ul>","boost":2},{"location":"arch/node/networking/node/id_store/types/update_identity_response_v1.html","title":"UpdateIdentityResponseV1","text":"","boost":2},{"location":"arch/node/networking/node/id_store/types/update_identity_response_v1.html#purpose","title":"Purpose","text":"<p>Response to an UpdateIdentityRequest.</p>","boost":2},{"location":"arch/node/networking/node/id_store/types/update_identity_response_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>id</code>: ExternalIdentity</p> <p>External identity the response is about.</p> </li> </ul> <ul> <li> <p><code>result</code>: Result</p> <p>Result of the update operation.</p> </li> </ul> (Wiki) links on this page<ul><li>UpdateIdentityRequest</li></ul>","boost":2},{"location":"arch/node/networking/node/router/index.html","title":"Index","text":"","boost":2},{"location":"arch/node/networking/node/router/index.html#router","title":"Router","text":"","boost":2},{"location":"arch/node/networking/node/router/index.html#overview","title":"Overview","text":"","boost":2},{"location":"arch/node/networking/node/router/index.html#purpose","title":"Purpose","text":"<p>The Router is responsible for forwarding both intra-node and inter-node messages between engine instances. It forwards intra-node messages directly between local engines, and sends and receives inter-node messages via the Transport engine. It makes routing decisions based on the DestinationIdentity in EngineMessage headers, and retrieves routing information for identities from the Network Identity Store engine.</p>","boost":2},{"location":"arch/node/networking/node/router/index.html#state","title":"State","text":"","boost":2},{"location":"arch/node/networking/node/router/index.html#routingtable","title":"RoutingTable","text":"<p>The router maintains a routing table that associates message destination identities with either a local engine address, a list of local engines subscribed to a pub/sub topic, a peer identity, a relay identity, or a domain identity.</p> <p>The routing table is populated by lookups from the Network Identity Store (NIS) engine, and updated when the corresponding record changes in NIS, which the Router learns about by subscribing to IdentityUpdated notifications.</p> <p>list&lt;RoutingTableEntry&gt;</p>","boost":2},{"location":"arch/node/networking/node/router/index.html#messages-received","title":"Messages received","text":"","boost":2},{"location":"arch/node/networking/node/router/index.html#enginemessage","title":"EngineMessage","text":"<p>A message sent between engine instances (both local &amp; remote).</p> <p>Reception:</p> <p>EngineMessageV1</p> <p>Record with fields:</p> <ul> <li> <p><code>src</code>: EngineIdentity</p> <p>Source engine identity</p> </li> </ul> <ul> <li> <p><code>dst</code>: DestinationIdentity</p> <p>Destination identity</p> </li> </ul> <ul> <li> <p><code>id</code>: u64</p> <p>Message ID: unique per <code>src</code>-<code>dst</code> pairs</p> </li> </ul> <ul> <li> <p><code>reply_to</code>: Option <p><code>id</code> of a previous message this message is in reply to</p> <ul> <li> <p><code>expiry</code> Option <p>Expiry time for outgoing messages. See P2PMessage &amp; TransportMessage.</p> <ul> <li> <p><code>rprefs</code>: Option&lt;RoutingPrefs&gt;</p> <p>Routing preferences</p> </li> </ul> <ul> <li> <p><code>tprefs</code>: Option&lt;TransportPrefs&gt;</p> <p>Transport preferences</p> </li> </ul> <ul> <li> <p><code>protocol</code>: Protocol</p> <p>Protocol &amp; version used in <code>body</code></p> </li> </ul> <ul> <li> <p><code>body</code>: Vec <p>Serialized message body</p> <ul> <li> <p><code>sig</code>: Option <p>Signature over the above fields by <code>src</code></p> <p>Triggers:</p> <p>EngineMessage</p> <p>P2PMessage</p> <p>RelayMessage</p> <p>DomainRequest</p>","boost":2},{"location":"arch/node/networking/node/router/index.html#p2pmessage","title":"P2PMessage","text":"<p>A signed message sent between peers.</p> <p>Reception:</p> <p>P2PMessageV1</p> <p>Record with fields:</p> <ul> <li> <p><code>src</code>: NodeIdentity</p> <p>Source peer</p> </li> </ul> <ul> <li> <p><code>dst</code>: NodeIdentity</p> <p>Destination peer</p> </li> </ul> <ul> <li> <p><code>msg</code>: enum { EngineMessageV1, RelayMessageV1 }</p> <p>Encapsulated message</p> </li> </ul> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature over the above fields by <code>src</code></p> </li> </ul> <p>Triggers:</p> <p>EngineMessage</p>","boost":2},{"location":"arch/node/networking/node/router/index.html#relaymessage","title":"RelayMessage","text":"<p>A RelayMessage is used to relay an encrypted EngineMessage via multiple routing hops. It is sent between two nodes and encapsulates either an EngineMessage or another RelayMessage.</p> <p>Reception:</p> <p>RelayMessageV1</p> <p>Record with fields:</p> <ul> <li> <p><code>src</code>: NodeIdentity</p> <p>Source Node ID</p> </li> </ul> <ul> <li> <p><code>dst</code>: NodeIdentity</p> <p>Destination Node ID</p> </li> </ul> <ul> <li> <p><code>tprefs</code>: Option&lt;TransportPrefs&gt;</p> <p>Transport preferences for outgoing messages</p> </li> </ul> <ul> <li> <p><code>expiry</code>: Option <p>Expiry time for outgoing messages</p> <ul> <li> <p><code>msg</code>: Vec <p>Encrypted and padded EngineMessageV1 or RelayMessageV1</p> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature over the above fields by <code>src</code></p> </li> </ul> <p>Triggers:</p> <p>EngineMessage</p>","boost":2},{"location":"arch/node/networking/node/router/index.html#topiccreaterequest","title":"TopicCreateRequest","text":"<p>Create a pub/sub topic and start accepting subscriptions to it.</p> <p>Reception:</p> <p>TopicCreateRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <ul> <li><code>scope</code>: RoutingScope Whether the topic should be advertised over the network.</li> </ul> <ul> <li><code>advert</code>: Option&lt;TopicAdvertV1&gt;  Topic advertisement to send to the network, when the <code>scope</code> allows.</li> </ul> <p>Triggers:</p> <p>TopicCreateResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/node/router/index.html#topicdeleterequest","title":"TopicDeleteRequest","text":"<p>Delete a pub/sub topic and remove all subscribers.</p> <p>The request must come from the same engine that created the topic.</p> <p>Reception:</p> <p>TopicDeleteRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <ul> <li><code>scope</code>: RoutingScope Whether the topic should be stopped being advertised on the network.</li> </ul> <p>Triggers:</p> <p>TopicDeleteResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/node/router/index.html#topicsubrequest","title":"TopicSubRequest","text":"<p>Subscription request for a pub/sub topic.</p> <p>Reception:</p> <p>TopicSubRequestV1</p> <p>Record with fields:</p> <ul> <li> <p><code>topic</code>: TopicIdentity</p> <p>Pub/sub  topic identity</p> </li> </ul> <ul> <li> <p><code>scope</code>: RoutingScope</p> <p>Whether the subscription request is local-only or should be also sent to the network</p> </li> </ul> <p>Triggers:</p> <p>TopicSubResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/node/router/index.html#topicunsubrequest","title":"TopicUnsubRequest","text":"<p>Unsubscription request for a pub/sub topic.</p> <p>Reception:</p> <p>TopicUnsubRequestV1</p> <p>Record with fields:</p> <ul> <li> <p><code>topic</code>: TopicIdentity</p> <p>Pub/sub  topic identity</p> </li> </ul> <ul> <li> <p><code>scope</code>: RoutingScope</p> <p>Whether the unsubscription request is local-only or should be also sent to the network</p> </li> </ul> <p>Triggers:</p> <p>TopicUnsubResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/node/router/index.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\nTransport -) Router: P2PMessage\nRouter -) Router: EngineMessage\nRouter -) Any Local Engine: EngineMessage\nAny Local Engine -) Router: EngineMessage\nRouter -) Router: EngineMessage\nRouter -) Transport: P2PMessage\nRouter -) Router: RelayMessage\nRouter -) DomainRouting: DomainRequest\n\nTransport -) Router: P2PMessage\nRouter -) Any Local Engine: EngineMessage\n\nRouter -) Router: RelayMessage\nRouter -) Router: EngineMessage\n\nAny Local Engine -&gt;&gt;+ Router: TopicCreateRequest\nRouter -&gt;&gt;+ PubSub: StartAdvertRequest\nPubSub --&gt;&gt;- Router: StartAdvertResponse\nRouter --&gt;&gt;- Any Local Engine: TopicCreateResponse\n\nAny Local Engine -&gt;&gt;+ Router: TopicDeleteRequest\nRouter -&gt;&gt;+ PubSub: StopAdvertRequest\nPubSub --&gt;&gt;- Router: StopAdvertResponse\nRouter --&gt;&gt;- Any Local Engine: TopicDeleteResponse\n\nAny Local Engine -&gt;&gt;+ Router: TopicCreateRequest\nRouter -&gt;&gt;+ PubSub: SubscribeRequest\nPubSub --&gt;&gt;- Router: SubscribeResponse\nRouter --&gt;&gt;- Any Local Engine: TopicCreateResponse\n\nAny Local Engine -&gt;&gt;+ Router: TopicUnsubRequest\nRouter -&gt;&gt;+ PubSub: UnsubscribeRequest\nPubSub --&gt;&gt;- Router: UnsubscribeResponse\nRouter --&gt;&gt;- Any Local Engine: TopicUnsubResponse</code></pre> (Wiki) links on this page<ul><li>Router</li><li>Transport</li><li>DestinationIdentity</li><li>EngineMessage</li><li>Network Identity Store</li><li>RoutingTable</li><li>Network Identity Store</li><li>IdentityUpdated</li><li>RoutingTableEntry</li><li>EngineMessage</li><li>EngineMessageV1</li><li>EngineIdentity</li><li>DestinationIdentity</li><li>P2PMessage to Transport</li><li>TransportMessage</li><li>RoutingPrefs</li><li>TransportPrefs</li><li>EngineMessage</li><li>P2PMessage</li><li>RelayMessage</li><li>P2PMessage</li><li>P2PMessageV1</li><li>NodeIdentity</li><li>NodeIdentity</li><li>EngineMessageV1</li><li>RelayMessageV1</li><li>EngineMessage</li><li>RelayMessage</li><li>EngineMessage</li><li>EngineMessage</li><li>RelayMessageV1</li><li>NodeIdentity</li><li>NodeIdentity</li><li>TransportPrefs</li><li>EngineMessageV1</li><li>RelayMessageV1</li><li>EngineMessage</li><li>TopicCreateRequest</li><li>TopicCreateRequestV1</li><li>TopicIdentity</li><li>RoutingScope</li><li>TopicAdvertV1</li><li>TopicCreateResponseV1</li><li>TopicDeleteRequest</li><li>TopicDeleteRequestV1</li><li>TopicIdentity</li><li>RoutingScope</li><li>TopicDeleteResponseV1</li><li>TopicSubRequest</li><li>TopicSubRequestV1</li><li>TopicIdentity</li><li>RoutingScope</li><li>TopicSubResponseV1</li><li>TopicUnsubRequest</li><li>TopicUnsubRequestV1</li><li>TopicIdentity</li><li>RoutingScope</li><li>TopicUnsubResponseV1</li></ul>","boost":2},{"location":"arch/node/networking/node/router/messages/engine_message.html","title":"EngineMessage","text":"","boost":2},{"location":"arch/node/networking/node/router/messages/engine_message.html#enginemessage","title":"EngineMessage","text":"","boost":2},{"location":"arch/node/networking/node/router/messages/engine_message.html#purpose","title":"Purpose","text":"<p>A message sent between engine instances (both local &amp; remote).</p>","boost":2},{"location":"arch/node/networking/node/router/messages/engine_message.html#type","title":"Type","text":"<p>Reception:</p> <p>EngineMessageV1</p> <p>Record with fields:</p> <ul> <li> <p><code>src</code>: EngineIdentity</p> <p>Source engine identity</p> </li> </ul> <ul> <li> <p><code>dst</code>: DestinationIdentity</p> <p>Destination identity</p> </li> </ul> <ul> <li> <p><code>id</code>: u64</p> <p>Message ID: unique per <code>src</code>-<code>dst</code> pairs</p> </li> </ul> <ul> <li> <p><code>reply_to</code>: Option <p><code>id</code> of a previous message this message is in reply to</p> <ul> <li> <p><code>expiry</code> Option <p>Expiry time for outgoing messages. See P2PMessage &amp; TransportMessage.</p> <ul> <li> <p><code>rprefs</code>: Option&lt;RoutingPrefs&gt;</p> <p>Routing preferences</p> </li> </ul> <ul> <li> <p><code>tprefs</code>: Option&lt;TransportPrefs&gt;</p> <p>Transport preferences</p> </li> </ul> <ul> <li> <p><code>protocol</code>: Protocol</p> <p>Protocol &amp; version used in <code>body</code></p> </li> </ul> <ul> <li> <p><code>body</code>: Vec <p>Serialized message body</p> <ul> <li> <p><code>sig</code>: Option <p>Signature over the above fields by <code>src</code></p> <p>Triggers:</p> <p>EngineMessage</p> <p>P2PMessage</p> <p>RelayMessage</p> <p>DomainRequest</p>","boost":2},{"location":"arch/node/networking/node/router/messages/engine_message.html#behaviour","title":"Behaviour","text":"<p>When the router receives an EngineMessage from a local engine instance, it processes it the following way:</p> <ol> <li> <p>It looks up <code>dst</code>, the DestinationIdentity in the routing table:</p> <ul> <li>If not found, it sends a LookupIdentityRequest    with the destination address to the Network Identity Store engine.<ul> <li>If the LookupIdentityResponse returns a result, it is added to the routing table,    and the process continues with the next step.</li> </ul> </li> </ul> </li> <li> <p>If a route is found, the EngineMessage is processed the following way,    depending on the type of DestinationIdentity:</p> <ul> <li> <p>Engine (EngineIdentity): unicast message to a local engine</p> <ul> <li>The Router forwards the EngineMessage directly to the destination engine</li> </ul> </li> </ul> <ul> <li> <p>Node (NodeIdentity): unicast message to a remote node</p> <ul> <li>The Router wraps the EngineMessage in a P2PMessage    with the destination set to the remote node's identity,    and the source set to the local node's identity    (which equals to the engine instance identity of the Router),    then signs the message with its identity key,    and forwards it to the Transport engine for delivery over the network.</li> </ul> </li> </ul> <ul> <li> <p>Topic (TopicIdentity): multicast message to a local pub/sub topic</p> <ul> <li>The Router forwards the Message to all local engines subscribed to the multicast group,    which might include the PubSub engine    that is responsible for remote delivery over a P2P publish-subscribe protocol.</li> </ul> </li> </ul> </li> </ol> <ol> <li> <p>(cont.)</p> <ul> <li> <p>Relay (NodeIdentity): relayed message via another node</p> <ul> <li>The Router wraps the EngineMessage in a RelayMessage    with the destination set to the external identity from the routing table,    the source set to the local node identity,    and signs it with its identity key.</li> <li>The Router then wraps the RelayMessage in a P2PMessage    and sends it to Transport for delivery over the network.</li> </ul> </li> </ul> <ul> <li> <p>Domain (DomainIdentity): anycast message to a domain</p> <ul> <li>The Router wraps the EngineMessage in a DomainRequest    with the destination set to the domain's identity and the source set to the local node identity.</li> <li>The Router then sends the DomainRequest to the Domain Routing engine.</li> </ul> </li> </ul> </li> </ol> <ol> <li>If no route is found, the message is dropped.</li> </ol> <p>When processing the EngineMessage, the given RoutingPrefs and RoutingScope is respected.</p> <p>Note</p> <p>The router subscribes to IdentityUpdated notifications of the Network Identity Store engine, in order to keep addresses in the routing table up to date.</p>","boost":2},{"location":"arch/node/networking/node/router/messages/engine_message.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nTransport -) Router: P2PMessage\nRouter -) Router: EngineMessage\nRouter -) Any Local Engine: EngineMessage\nAny Local Engine -) Router: EngineMessage\nRouter -) Router: EngineMessage\nRouter -) Transport: P2PMessage\nRouter -) Router: RelayMessage\nRouter -) DomainRouting: DomainRequest\n%% --8&lt;-- [end:sequence]</code></pre> (Wiki) links on this page<ul><li>EngineMessageV1</li><li>EngineIdentity</li><li>DestinationIdentity</li><li>P2PMessage to Transport</li><li>TransportMessage</li><li>RoutingPrefs</li><li>TransportPrefs</li><li>EngineMessage</li><li>P2PMessage</li><li>RelayMessage</li><li>DestinationIdentity</li><li>LookupIdentityRequest</li><li>Network Identity Store</li><li>LookupIdentityRequest</li><li>DestinationIdentity</li><li>EngineIdentity</li><li>NodeIdentity</li><li>P2PMessage</li><li>Transport</li><li>TopicIdentity</li><li>PubSub</li><li>NodeIdentity</li><li>RelayMessage</li><li>RelayMessage</li><li>P2PMessage</li><li>Transport</li><li>DomainIdentity</li><li>RoutingPrefs</li><li>RoutingScope</li><li>IdentityUpdated</li><li>Network Identity Store</li></ul>","boost":2},{"location":"arch/node/networking/node/router/messages/p2p_message.html","title":"P2PMessage","text":"(Wiki) links on this page<ul><li>P2PMessageV1</li><li>NodeIdentity</li><li>NodeIdentity</li><li>EngineMessageV1</li><li>RelayMessageV1</li><li>EngineMessage</li><li>EngineMessage</li><li>RelayMessage</li><li>DisconnectRequest</li><li>Transport</li></ul>","boost":2},{"location":"arch/node/networking/node/router/messages/p2p_message.html#p2pmessage","title":"P2PMessage","text":"","boost":2},{"location":"arch/node/networking/node/router/messages/p2p_message.html#purpose","title":"Purpose","text":"<p>A signed message sent between peers.</p>","boost":2},{"location":"arch/node/networking/node/router/messages/p2p_message.html#type","title":"Type","text":"<p>Reception:</p> <p>P2PMessageV1</p> <p>Record with fields:</p> <ul> <li> <p><code>src</code>: NodeIdentity</p> <p>Source peer</p> </li> </ul> <ul> <li> <p><code>dst</code>: NodeIdentity</p> <p>Destination peer</p> </li> </ul> <ul> <li> <p><code>msg</code>: enum { EngineMessageV1, RelayMessageV1 }</p> <p>Encapsulated message</p> </li> </ul> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature over the above fields by <code>src</code></p> </li> </ul> <p>Triggers:</p> <p>EngineMessage</p>","boost":2},{"location":"arch/node/networking/node/router/messages/p2p_message.html#behaviour","title":"Behaviour","text":"<p>The Router verifies the signature, and if valid, it processes the contained EngineMessage or RelayMessage. Otherwise discards the message, and disconnects from the peer by sending a DisconnectRequest message to Transport.</p>","boost":2},{"location":"arch/node/networking/node/router/messages/p2p_message.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nTransport -) Router: P2PMessage\nRouter -) Any Local Engine: EngineMessage\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/node/router/messages/relay_message.html","title":"RelayMessage","text":"","boost":2},{"location":"arch/node/networking/node/router/messages/relay_message.html#relaymessage","title":"RelayMessage","text":"","boost":2},{"location":"arch/node/networking/node/router/messages/relay_message.html#purpose","title":"Purpose","text":"<p>A RelayMessage is used to relay an encrypted EngineMessage via multiple routing hops. It is sent between two nodes and encapsulates either an EngineMessage or another RelayMessage.</p>","boost":2},{"location":"arch/node/networking/node/router/messages/relay_message.html#type","title":"Type","text":"<p>Reception:</p> <p>RelayMessageV1</p> <p>Record with fields:</p> <ul> <li> <p><code>src</code>: NodeIdentity</p> <p>Source Node ID</p> </li> </ul> <ul> <li> <p><code>dst</code>: NodeIdentity</p> <p>Destination Node ID</p> </li> </ul> <ul> <li> <p><code>tprefs</code>: Option&lt;TransportPrefs&gt;</p> <p>Transport preferences for outgoing messages</p> </li> </ul> <ul> <li> <p><code>expiry</code>: Option <p>Expiry time for outgoing messages</p> <ul> <li> <p><code>msg</code>: Vec <p>Encrypted and padded EngineMessageV1 or RelayMessageV1</p> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature over the above fields by <code>src</code></p> </li> </ul> <p>Triggers:</p> <p>EngineMessage</p>","boost":2},{"location":"arch/node/networking/node/router/messages/relay_message.html#behaviour","title":"Behaviour","text":"<p>When the router receives a RelayMessage from a remote node via the Transport engine, it processes it the following way:</p> <ol> <li>It checks whether it is configured to allow relaying    either from the source node or to the destination node.<ul> <li>If not, it drop the message</li> </ul> </li> <li>It decrypts the contained EngineMessage or RelayMessage, and processes it.</li> </ol>","boost":2},{"location":"arch/node/networking/node/router/messages/relay_message.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nRouter -) Router: RelayMessage\nRouter -) Router: EngineMessage\n%% --8&lt;-- [end:sequence]</code></pre> (Wiki) links on this page<ul><li>EngineMessage</li><li>EngineMessage</li><li>RelayMessageV1</li><li>NodeIdentity</li><li>NodeIdentity</li><li>TransportPrefs</li><li>EngineMessageV1</li><li>RelayMessageV1</li><li>EngineMessage</li><li>RelayMessage</li><li>Transport</li><li>EngineMessage</li><li>RelayMessage</li></ul>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_create_request.html","title":"TopicCreateRequest","text":"(Wiki) links on this page<ul><li>TopicCreateRequestV1</li><li>TopicIdentity</li><li>RoutingScope</li><li>TopicAdvertV1</li><li>TopicCreateResponseV1</li><li>RoutingTable</li></ul>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_create_request.html#topiccreaterequest","title":"TopicCreateRequest","text":"","boost":2},{"location":"arch/node/networking/node/router/messages/topic_create_request.html#purpose","title":"Purpose","text":"<p>Create a pub/sub topic and start accepting subscriptions to it.</p>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_create_request.html#type","title":"Type","text":"<p>Reception:</p> <p>TopicCreateRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <ul> <li><code>scope</code>: RoutingScope Whether the topic should be advertised over the network.</li> </ul> <ul> <li><code>advert</code>: Option&lt;TopicAdvertV1&gt;  Topic advertisement to send to the network, when the <code>scope</code> allows.</li> </ul> <p>Triggers:</p> <p>TopicCreateResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_create_request.html#behaviour","title":"Behaviour","text":"<p>The topic is added to the RoutingTable with an initially empty subscriber list.</p>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_create_request.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Router: TopicCreateRequest\nRouter -&gt;&gt;+ PubSub: StartAdvertRequest\nPubSub --&gt;&gt;- Router: StartAdvertResponse\nRouter --&gt;&gt;- Any Local Engine: TopicCreateResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_delete_request.html","title":"TopicDeleteRequest","text":"(Wiki) links on this page<ul><li>TopicDeleteRequestV1</li><li>TopicIdentity</li><li>RoutingScope</li><li>TopicDeleteResponseV1</li><li>RoutingTable</li></ul>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_delete_request.html#topicdeleterequest","title":"TopicDeleteRequest","text":"","boost":2},{"location":"arch/node/networking/node/router/messages/topic_delete_request.html#purpose","title":"Purpose","text":"<p>Delete a pub/sub topic and remove all subscribers.</p> <p>The request must come from the same engine that created the topic.</p>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_delete_request.html#type","title":"Type","text":"<p>Reception:</p> <p>TopicDeleteRequestV1</p> <p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <ul> <li><code>scope</code>: RoutingScope Whether the topic should be stopped being advertised on the network.</li> </ul> <p>Triggers:</p> <p>TopicDeleteResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_delete_request.html#behaviour","title":"Behaviour","text":"<p>The topic is removed from the RoutingTable along with all subscribers.</p>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_delete_request.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Router: TopicDeleteRequest\nRouter -&gt;&gt;+ PubSub: StopAdvertRequest\nPubSub --&gt;&gt;- Router: StopAdvertResponse\nRouter --&gt;&gt;- Any Local Engine: TopicDeleteResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_sub_request.html","title":"TopicSubRequest","text":"(Wiki) links on this page<ul><li>TopicSubRequestV1</li><li>TopicIdentity</li><li>RoutingScope</li><li>TopicSubResponseV1</li><li>RoutingTable</li><li>EngineIdentity</li><li>RoutingTable</li><li>TopicSubRequest</li><li>Router</li><li>SubscribeRequest</li><li>PubSub</li></ul>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_sub_request.html#topicsubrequest","title":"TopicSubRequest","text":"","boost":2},{"location":"arch/node/networking/node/router/messages/topic_sub_request.html#purpose","title":"Purpose","text":"<p>Subscription request for a pub/sub topic.</p>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_sub_request.html#type","title":"Type","text":"<p>Reception:</p> <p>TopicSubRequestV1</p> <p>Record with fields:</p> <ul> <li> <p><code>topic</code>: TopicIdentity</p> <p>Pub/sub  topic identity</p> </li> </ul> <ul> <li> <p><code>scope</code>: RoutingScope</p> <p>Whether the subscription request is local-only or should be also sent to the network</p> </li> </ul> <p>Triggers:</p> <p>TopicSubResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_sub_request.html#behaviour","title":"Behaviour","text":"<p>If the topic already exists in the RoutingTable, the EngineIdentity of the requesting engine is added to the RoutingTable, and  a TopicSubResponse is returned with a success result.</p> <p>Otherwise, if the topic does not exist yet:</p> <ul> <li>when the <code>scope</code> is LocalOnly, an error is returned</li> <li>when the <code>scope</code> is Any, the Router sends a SubscribeRequest to PubSub</li> </ul>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_sub_request.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Router: TopicCreateRequest\nRouter -&gt;&gt;+ PubSub: SubscribeRequest\nPubSub --&gt;&gt;- Router: SubscribeResponse\nRouter --&gt;&gt;- Any Local Engine: TopicCreateResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_unsub_request.html","title":"TopicUnsubRequest","text":"(Wiki) links on this page<ul><li>TopicUnsubRequestV1</li><li>TopicIdentity</li><li>RoutingScope</li><li>TopicUnsubResponseV1</li><li>TopicIdentity</li><li>RoutingScope</li><li>RoutingTable</li><li>EngineIdentity</li><li>RoutingTable</li><li>TopicSubRequest</li><li>Router</li><li>SubscribeRequest</li><li>PubSub</li></ul>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_unsub_request.html#topicunsubrequest","title":"TopicUnsubRequest","text":"","boost":2},{"location":"arch/node/networking/node/router/messages/topic_unsub_request.html#purpose","title":"Purpose","text":"<p>Unsubscription request for a pub/sub topic.</p>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_unsub_request.html#type","title":"Type","text":"<p>Reception:</p> <p>TopicUnsubRequestV1</p> <p>Record with fields:</p> <ul> <li> <p><code>topic</code>: TopicIdentity</p> <p>Pub/sub  topic identity</p> </li> </ul> <ul> <li> <p><code>scope</code>: RoutingScope</p> <p>Whether the unsubscription request is local-only or should be also sent to the network</p> </li> </ul> <p>Triggers:</p> <p>TopicUnsubResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_unsub_request.html#structure","title":"Structure","text":"Field Type Description <code>topic</code> TopicIdentity Topic ID to unsubscribe <code>scope</code> RoutingScope Whether the unsubscription request should be sent to the network","boost":2},{"location":"arch/node/networking/node/router/messages/topic_unsub_request.html#behaviour","title":"Behaviour","text":"<p>If the topic does not exist yet in the RoutingTable, the EngineIdentity of the requesting engine is added to the RoutingTable, and  a TopicSubResponse is returned with a success result.</p> <p>Otherwise, if the topic does not exist yet:</p> <ul> <li>when the <code>scope</code> is LocalOnly, an error is returned</li> <li>when the <code>scope</code> is Any, the Router sends a SubscribeRequest to PubSub</li> </ul>","boost":2},{"location":"arch/node/networking/node/router/messages/topic_unsub_request.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Router: TopicUnsubRequest\nRouter -&gt;&gt;+ PubSub: UnsubscribeRequest\nPubSub --&gt;&gt;- Router: UnsubscribeResponse\nRouter --&gt;&gt;- Any Local Engine: TopicUnsubResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/node/router/types/destination_identity.html","title":"DestinationIdentity","text":"","boost":2},{"location":"arch/node/networking/node/router/types/destination_identity.html#purpose","title":"Purpose","text":"<p>Destination identity of an EngineMessageV1.</p>","boost":2},{"location":"arch/node/networking/node/router/types/destination_identity.html#type","title":"Type","text":"<p>Enum with values:</p> <ul> <li><code>Engine</code>: EngineIdentity</li> </ul> <ul> <li><code>Node</code>: NodeIdentity</li> </ul> <ul> <li><code>Topic</code>: TopicIdentity</li> </ul> <ul> <li><code>Relay</code>: NodeIdentity</li> </ul> <ul> <li><code>Domain</code>: DomainIdentity</li> </ul> (Wiki) links on this page<ul><li>EngineMessageV1</li><li>EngineIdentity</li><li>NodeIdentity</li><li>TopicIdentity</li><li>NodeIdentity</li><li>DomainIdentity</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/domain_identity.html","title":"DomainID","text":"","boost":2},{"location":"arch/node/networking/node/router/types/domain_identity.html#purpose","title":"Purpose","text":"<p>External identity of a Domain.</p>","boost":2},{"location":"arch/node/networking/node/router/types/domain_identity.html#type","title":"Type","text":"<p>ExternalIdentity</p>","boost":2},{"location":"arch/node/networking/node/router/types/engine_advert_v1.html","title":"EngineAdvert","text":"","boost":2},{"location":"arch/node/networking/node/router/types/engine_advert_v1.html#engineadvertv1","title":"EngineAdvertV1","text":"","boost":2},{"location":"arch/node/networking/node/router/types/engine_advert_v1.html#purpose","title":"Purpose","text":"<p>Advertisement of an engine that specifies the node where it is running.</p>","boost":2},{"location":"arch/node/networking/node/router/types/engine_advert_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>id</code>: EngineIdentity</p> <p>Node ID</p> </li> </ul> <ul> <li> <p><code>node</code>: NodeIdentity</p> <p>Node ID where the engine is running</p> </li> </ul> <ul> <li> <p><code>version</code>: u32</p> <p>Version number</p> </li> </ul> <ul> <li> <p><code>created</code>: Time</p> <p>Time of creation</p> </li> </ul> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature by <code>id</code></p> </li> </ul> (Wiki) links on this page<ul><li>EngineIdentity</li><li>NodeIdentity</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/engine_identity.html","title":"EngineIdentity","text":"","boost":2},{"location":"arch/node/networking/node/router/types/engine_identity.html#purpose","title":"Purpose","text":"<p>External identity of an Engine.</p>","boost":2},{"location":"arch/node/networking/node/router/types/engine_identity.html#type","title":"Type","text":"<p>ExternalIdentity</p>","boost":2},{"location":"arch/node/networking/node/router/types/engine_message_v1.html","title":"EngineMessageV1","text":"","boost":2},{"location":"arch/node/networking/node/router/types/engine_message_v1.html#purpose","title":"Purpose","text":"<p>A message sent between two engine instances .</p>","boost":2},{"location":"arch/node/networking/node/router/types/engine_message_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>src</code>: EngineIdentity</p> <p>Source engine identity</p> </li> </ul> <ul> <li> <p><code>dst</code>: DestinationIdentity</p> <p>Destination identity</p> </li> </ul> <ul> <li> <p><code>id</code>: u64</p> <p>Message ID: unique per <code>src</code>-<code>dst</code> pairs</p> </li> </ul> <ul> <li> <p><code>reply_to</code>: Option <p><code>id</code> of a previous message this message is in reply to</p> <ul> <li> <p><code>expiry</code> Option <p>Expiry time for outgoing messages. See P2PMessage &amp; TransportMessage.</p> <ul> <li> <p><code>rprefs</code>: Option&lt;RoutingPrefs&gt;</p> <p>Routing preferences</p> </li> </ul> <ul> <li> <p><code>tprefs</code>: Option&lt;TransportPrefs&gt;</p> <p>Transport preferences</p> </li> </ul> <ul> <li> <p><code>protocol</code>: Protocol</p> <p>Protocol &amp; version used in <code>body</code></p> </li> </ul> <ul> <li> <p><code>body</code>: Vec <p>Serialized message body</p> <ul> <li> <p><code>sig</code>: Option <p>Signature over the above fields by <code>src</code></p> (Wiki) links on this page<ul><li>EngineIdentity</li><li>DestinationIdentity</li><li>P2PMessage to Transport</li><li>TransportMessage</li><li>RoutingPrefs</li><li>TransportPrefs</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/node_advert_v1.html","title":"NodeAdvert","text":"","boost":2},{"location":"arch/node/networking/node/router/types/node_advert_v1.html#nodeadvertv1","title":"NodeAdvertV1","text":"","boost":2},{"location":"arch/node/networking/node/router/types/node_advert_v1.html#purpose","title":"Purpose","text":"<p>Advertisement of a peer's transport addresses.</p>","boost":2},{"location":"arch/node/networking/node/router/types/node_advert_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>id</code>: NodeIdentity</p> <p>Node ID</p> </li> </ul> <ul> <li> <p><code>addrs</code>: Vec&lt;(TransportAddress, u8)&gt;</p> <p>Transport addresses with preferences expressed as weights</p> </li> </ul> <ul> <li> <p><code>version</code>: u32</p> <p>Version number</p> </li> </ul> <ul> <li> <p><code>created</code>: Time</p> <p>Time of creation</p> </li> </ul> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature by <code>id</code></p> </li> </ul> (Wiki) links on this page<ul><li>NodeIdentity</li><li>TransportAddress</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/node_identity.html","title":"NodeIdentity","text":"","boost":2},{"location":"arch/node/networking/node/router/types/node_identity.html#purpose","title":"Purpose","text":"<p>External identity of a node.</p>","boost":2},{"location":"arch/node/networking/node/router/types/node_identity.html#type","title":"Type","text":"<p>ExternalIdentity</p>","boost":2},{"location":"arch/node/networking/node/router/types/p2p_message_v1.html","title":"P2PMessageV1","text":"","boost":2},{"location":"arch/node/networking/node/router/types/p2p_message_v1.html#purpose","title":"Purpose","text":"<p>Message between two nodes.</p>","boost":2},{"location":"arch/node/networking/node/router/types/p2p_message_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>src</code>: NodeIdentity</p> <p>Source peer</p> </li> </ul> <ul> <li> <p><code>dst</code>: NodeIdentity</p> <p>Destination peer</p> </li> </ul> <ul> <li> <p><code>msg</code>: enum { EngineMessageV1, RelayMessageV1 }</p> <p>Encapsulated message</p> </li> </ul> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature over the above fields by <code>src</code></p> </li> </ul> (Wiki) links on this page<ul><li>NodeIdentity</li><li>NodeIdentity</li><li>EngineMessageV1</li><li>RelayMessageV1</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/relay_message_v1.html","title":"RelayMessageV1","text":"","boost":2},{"location":"arch/node/networking/node/router/types/relay_message_v1.html#purpose","title":"Purpose","text":"<p>Relayed message.</p>","boost":2},{"location":"arch/node/networking/node/router/types/relay_message_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>src</code>: NodeIdentity</p> <p>Source Node ID</p> </li> </ul> <ul> <li> <p><code>dst</code>: NodeIdentity</p> <p>Destination Node ID</p> </li> </ul> <ul> <li> <p><code>tprefs</code>: Option&lt;TransportPrefs&gt;</p> <p>Transport preferences for outgoing messages</p> </li> </ul> <ul> <li> <p><code>expiry</code>: Option <p>Expiry time for outgoing messages</p> <ul> <li> <p><code>msg</code>: Vec <p>Encrypted and padded EngineMessageV1 or RelayMessageV1</p> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature over the above fields by <code>src</code></p> </li> </ul> (Wiki) links on this page<ul><li>NodeIdentity</li><li>NodeIdentity</li><li>TransportPrefs</li><li>EngineMessageV1</li><li>RelayMessageV1</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/routing_prefs.html","title":"RoutingPrefs","text":"","boost":2},{"location":"arch/node/networking/node/router/types/routing_prefs.html#purpose","title":"Purpose","text":"<p>Routing preferences.</p>","boost":2},{"location":"arch/node/networking/node/router/types/routing_prefs.html#type","title":"Type","text":"<p>Struct with the following fields.</p> Field Type Description <code>scope</code> RoutingScope Routing scope restriction (Wiki) links on this page<ul><li>RoutingScope</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/routing_scope.html","title":"RoutingScope","text":"","boost":2},{"location":"arch/node/networking/node/router/types/routing_scope.html#purpose","title":"Purpose","text":"<p>Message routing scope restriction.</p>","boost":2},{"location":"arch/node/networking/node/router/types/routing_scope.html#type","title":"Type","text":"<p>Enum with values:</p> <ul> <li> <p><code>Local</code></p> <p>Routing of the message is restricted to the local node.</p> </li> </ul> <ul> <li> <p><code>Domain</code> (DomainIdentity)</p> <p>The message is restricted to the specified domain.</p> </li> </ul> <ul> <li> <p><code>Any</code></p> <p>The message may be forwarded without restrictions to remote peers.</p> </li> </ul> (Wiki) links on this page<ul><li>DomainIdentity</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/routing_table.html","title":"RoutingTable","text":"","boost":2},{"location":"arch/node/networking/node/router/types/routing_table.html#purpose","title":"Purpose","text":"<p>The router maintains a routing table that associates message destination identities with either a local engine address, a list of local engines subscribed to a pub/sub topic, a peer identity, a relay identity, or a domain identity.</p> <p>The routing table is populated by lookups from the Network Identity Store (NIS) engine, and updated when the corresponding record changes in NIS, which the Router learns about by subscribing to IdentityUpdated notifications.</p>","boost":2},{"location":"arch/node/networking/node/router/types/routing_table.html#type","title":"Type","text":"<p>list&lt;RoutingTableEntry&gt;</p> (Wiki) links on this page<ul><li>Network Identity Store</li><li>IdentityUpdated</li><li>RoutingTableEntry</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/routing_table_dest.html","title":"RoutingTableDest","text":"","boost":2},{"location":"arch/node/networking/node/router/types/routing_table_dest.html#purpose","title":"Purpose","text":"<p>Destination of a RoutingTable entry.</p>","boost":2},{"location":"arch/node/networking/node/router/types/routing_table_dest.html#type","title":"Type","text":"<p>Enum with the following possible values.</p> Value Type Description Engine EngineAddr Local engine reachable directly Topic RoutingTableTopic Locally subscribed engines to a topic Transport Remote peer reachable via Transport Peer NodeIdentity Relay via remote peer Domain RoutingTableDomain Known domain members for sending requests to (Wiki) links on this page<ul><li>RoutingTable</li><li>RoutingTableTopic</li><li>Transport</li><li>NodeIdentity</li><li>RoutingTableDomain</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/routing_table_domain.html","title":"RoutingTableDomain","text":"","boost":2},{"location":"arch/node/networking/node/router/types/routing_table_domain.html#purpose","title":"Purpose","text":"<p>A domain in a routing table entry.</p>","boost":2},{"location":"arch/node/networking/node/router/types/routing_table_domain.html#type","title":"Type","text":"<p>Struct with the following fields.</p> Field Type Description <code>members</code> Vec&lt;NodeIdentity&gt; List of known domain members (Wiki) links on this page<ul><li>NodeIdentity</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/routing_table_topic.html","title":"RoutingTableTopic","text":"","boost":2},{"location":"arch/node/networking/node/router/types/routing_table_topic.html#purpose","title":"Purpose","text":"<p>A pub/sub topic in a routing table entry.</p>","boost":2},{"location":"arch/node/networking/node/router/types/routing_table_topic.html#type","title":"Type","text":"<p>Struct with the following fields.</p> Field Type Description <code>creator</code> EngineIdentity Topic creator engine <code>subscribers</code> Vec&lt;EngineIdentity&gt; List of subscribed engines (Wiki) links on this page<ul><li>EngineIdentity</li><li>EngineIdentity</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/topic_create_request_v1.html","title":"TopicCreateRequestV1","text":"","boost":2},{"location":"arch/node/networking/node/router/types/topic_create_request_v1.html#purpose","title":"Purpose","text":"<p>Request to create a pub/sub topic.</p>","boost":2},{"location":"arch/node/networking/node/router/types/topic_create_request_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <ul> <li><code>scope</code>: RoutingScope Whether the topic should be advertised over the network.</li> </ul> <ul> <li><code>advert</code>: Option&lt;TopicAdvertV1&gt;  Topic advertisement to send to the network, when the <code>scope</code> allows.</li> </ul> (Wiki) links on this page<ul><li>TopicIdentity</li><li>RoutingScope</li><li>TopicAdvertV1</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/topic_create_response_v1.html","title":"TopicCreateResponseV1","text":"","boost":2},{"location":"arch/node/networking/node/router/types/topic_create_response_v1.html#purpose","title":"Purpose","text":"<p>Response to a TopicCreateRequestV1.</p>","boost":2},{"location":"arch/node/networking/node/router/types/topic_create_response_v1.html#type","title":"Type","text":"<p>Result</p>","boost":2},{"location":"arch/node/networking/node/router/types/topic_create_response_v1.html#values","title":"Values","text":"<ul> <li>OK: Topic created.</li> <li>ERROR: Topic already exists.</li> </ul> (Wiki) links on this page<ul><li>TopicCreateRequestV1</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/topic_delete_request_v1.html","title":"TopicDeleteRequestV1","text":"","boost":2},{"location":"arch/node/networking/node/router/types/topic_delete_request_v1.html#purpose","title":"Purpose","text":"<p>Request to delete a pub/sub topic.</p>","boost":2},{"location":"arch/node/networking/node/router/types/topic_delete_request_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li><code>topic</code>: TopicIdentity Pub/sub topic identity.</li> </ul> <ul> <li><code>scope</code>: RoutingScope Whether the topic should be stopped being advertised on the network.</li> </ul> (Wiki) links on this page<ul><li>TopicIdentity</li><li>RoutingScope</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/topic_delete_response_v1.html","title":"TopicDeleteResponseV1","text":"","boost":2},{"location":"arch/node/networking/node/router/types/topic_delete_response_v1.html#purpose","title":"Purpose","text":"<p>Response to a TopicDeleteRequestV1.</p>","boost":2},{"location":"arch/node/networking/node/router/types/topic_delete_response_v1.html#type","title":"Type","text":"<p>Result</p>","boost":2},{"location":"arch/node/networking/node/router/types/topic_delete_response_v1.html#values","title":"Values","text":"<ul> <li>OK: Topic deleted.</li> <li>ERROR: Topic unknown.</li> </ul> (Wiki) links on this page<ul><li>TopicDeleteRequestV1</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/topic_identity.html","title":"TopicId","text":"","boost":2},{"location":"arch/node/networking/node/router/types/topic_identity.html#purpose","title":"Purpose","text":"<p>External identity of a Topic.</p>","boost":2},{"location":"arch/node/networking/node/router/types/topic_identity.html#type","title":"Type","text":"<p>ExternalIdentity</p>","boost":2},{"location":"arch/node/networking/node/router/types/topic_sub_request_v1.html","title":"TopicSubRequestV1","text":"","boost":2},{"location":"arch/node/networking/node/router/types/topic_sub_request_v1.html#purpose","title":"Purpose","text":"<p>Request to subscribe to a pub/sub topic.</p>","boost":2},{"location":"arch/node/networking/node/router/types/topic_sub_request_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>topic</code>: TopicIdentity</p> <p>Pub/sub  topic identity</p> </li> </ul> <ul> <li> <p><code>scope</code>: RoutingScope</p> <p>Whether the subscription request is local-only or should be also sent to the network</p> </li> </ul> (Wiki) links on this page<ul><li>TopicIdentity</li><li>RoutingScope</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/topic_sub_response_v1.html","title":"TopicSubResponseV1","text":"","boost":2},{"location":"arch/node/networking/node/router/types/topic_sub_response_v1.html#purpose","title":"Purpose","text":"<p>Response to a TopicSubRequestV1.</p>","boost":2},{"location":"arch/node/networking/node/router/types/topic_sub_response_v1.html#type","title":"Type","text":"<p>Result</p>","boost":2},{"location":"arch/node/networking/node/router/types/topic_sub_response_v1.html#values","title":"Values","text":"<ul> <li>OK: Topic subscribed.</li> <li>ERROR: Topic already subscribed.</li> </ul> (Wiki) links on this page<ul><li>TopicSubRequestV1</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/topic_unsub_request_v1.html","title":"TopicUnsubRequestV1","text":"","boost":2},{"location":"arch/node/networking/node/router/types/topic_unsub_request_v1.html#purpose","title":"Purpose","text":"<p>Request to unsubscribe from a pub/sub topic.</p>","boost":2},{"location":"arch/node/networking/node/router/types/topic_unsub_request_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>topic</code>: TopicIdentity</p> <p>Pub/sub  topic identity</p> </li> </ul> <ul> <li> <p><code>scope</code>: RoutingScope</p> <p>Whether the unsubscription request is local-only or should be also sent to the network</p> </li> </ul> (Wiki) links on this page<ul><li>TopicIdentity</li><li>RoutingScope</li></ul>","boost":2},{"location":"arch/node/networking/node/router/types/topic_unsub_response_v1.html","title":"TopicUnsubResponseV1","text":"","boost":2},{"location":"arch/node/networking/node/router/types/topic_unsub_response_v1.html#purpose","title":"Purpose","text":"<p>Response to a TopicUnsubRequestV1.</p>","boost":2},{"location":"arch/node/networking/node/router/types/topic_unsub_response_v1.html#type","title":"Type","text":"<p>Result</p>","boost":2},{"location":"arch/node/networking/node/router/types/topic_unsub_response_v1.html#values","title":"Values","text":"<ul> <li>OK: Topic unsubscribed.</li> <li>ERROR: Topic was not subscribed.</li> </ul> (Wiki) links on this page<ul><li>TopicUnsubRequestV1</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/index.html","title":"Index","text":"","boost":2},{"location":"arch/node/networking/node/transport/index.html#transport","title":"Transport","text":"","boost":2},{"location":"arch/node/networking/node/transport/index.html#overview","title":"Overview","text":"","boost":2},{"location":"arch/node/networking/node/transport/index.html#purpose","title":"Purpose","text":"<p>The Transport engine is responsible for sending and receiving messages from other nodes over the network, establishing and maintaining authenticated and encrypted communication channels to other nodes via various transport protocols.</p>","boost":2},{"location":"arch/node/networking/node/transport/index.html#state","title":"State","text":"<p>The Transport engine maintains a ConnectionPool, a pool of open connections associated with node identities of connected nodes. For protocols that support session resumption (such as QUIC, TLS), it also maintains a TransportSessionCache for this purpose.</p>","boost":2},{"location":"arch/node/networking/node/transport/index.html#messages-received","title":"Messages received","text":"","boost":2},{"location":"arch/node/networking/node/transport/index.html#p2pmessage","title":"P2PMessage","text":"<p>An outgoing message to be delivered to another node over the network.</p> <p>Reception:</p> <p>P2PMessageV1</p> <p>Record with fields:</p> <ul> <li> <p><code>src</code>: NodeIdentity</p> <p>Source peer</p> </li> </ul> <ul> <li> <p><code>dst</code>: NodeIdentity</p> <p>Destination peer</p> </li> </ul> <ul> <li> <p><code>msg</code>: enum { EngineMessageV1, RelayMessageV1 }</p> <p>Encapsulated message</p> </li> </ul> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature over the above fields by <code>src</code></p> </li> </ul> <p>Triggers:</p> <p>TransportMessage</p>","boost":2},{"location":"arch/node/networking/node/transport/index.html#transportmessage","title":"TransportMessage","text":"<p>A message from/to one of the transport protocols.</p> <p>Reception:</p> <p>TransportMessageV1</p> <p>Record with fields:</p> <ul> <li> <p><code>addr</code>: TransportAddress</p> <p>Source or destination address</p> </li> </ul> <ul> <li> <p><code>tprefs</code>: Option&lt;TransportPrefs&gt;</p> <p>Transport preferences for outgoing messages</p> </li> </ul> <ul> <li> <p><code>expiry</code>: Option <p>Expiry time for outgoing messages</p> <ul> <li> <p><code>msg</code>: P2PMessageV1</p> <p>Encapsulated message</p> </li> </ul> <p>Triggers:</p> <p>P2PMessage</p>","boost":2},{"location":"arch/node/networking/node/transport/index.html#connectrequest","title":"ConnectRequest","text":"<p>Establish connection to a node.</p> <p>Reception:</p> <p>ConnectRequestV1</p> <p>Record with fields:</p> <ul> <li> <p><code>node</code>: NodeIdentity</p> <p>Node to connect to.</p> </li> </ul> <p>Triggers:</p> <p>ConnectResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/node/transport/index.html#disconnectrequest","title":"DisconnectRequest","text":"<p>Establish disconnection to a node.</p> <p>Reception:</p> <p>DisconnectRequestV1</p> <p>Record with fields:</p> <ul> <li> <p><code>node</code>: NodeIdentity</p> <p>Node to disconnect from.</p> </li> </ul> <p>Triggers:</p> <p>DisconnectResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/node/transport/index.html#connectednodesrequest","title":"ConnectedNodesRequest","text":"<p>Request the list of currently connected nodes.</p> <p>Reception:</p> <p>unit</p> <p>Triggers:</p> <p>ConnectedNodesResponseV1</p> <p>list&lt;(NodeIdentity, TransportAddress)&gt;</p>","boost":2},{"location":"arch/node/networking/node/transport/index.html#notifications-sent","title":"Notifications sent","text":"","boost":2},{"location":"arch/node/networking/node/transport/index.html#nodeconnected","title":"NodeConnected","text":"<p>Notification sent when a transport connection is established to a node.</p> <p>NodeTransportAddress</p> <p>Record with fields:</p> <ul> <li> <p><code>node</code>: NodeIdentity</p> <p>Node ID</p> </li> </ul> <ul> <li> <p><code>addr</code>: TransportAddress</p> <p>Transport address of <code>node</code></p> </li> </ul>","boost":2},{"location":"arch/node/networking/node/transport/index.html#nodeconnectfailed","title":"NodeConnectFailed","text":"<p>Notification sent when a transport connection is closed to a node.</p> <p>NodeTransportAddress</p> <p>Record with fields:</p> <ul> <li> <p><code>node</code>: NodeIdentity</p> <p>Node ID</p> </li> </ul> <ul> <li> <p><code>addr</code>: TransportAddress</p> <p>Transport address of <code>node</code></p> </li> </ul>","boost":2},{"location":"arch/node/networking/node/transport/index.html#nodedisconnected","title":"NodeDisconnected","text":"<p>Notification sent when failed to establish a connection to a node.</p> <p>NodeTransportAddress</p> <p>Record with fields:</p> <ul> <li> <p><code>node</code>: NodeIdentity</p> <p>Node ID</p> </li> </ul> <ul> <li> <p><code>addr</code>: TransportAddress</p> <p>Transport address of <code>node</code></p> </li> </ul>","boost":2},{"location":"arch/node/networking/node/transport/index.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\nTransportProtocol -) Transport: TransportMessage\nTransport -) Router: P2PMessage\nRouter -) Transport: P2PMessage\nTransport -) TransportProtocol: TransportMessage\n\nTopology -&gt;&gt;+ Transport: ConnectRequest\nTransport --&gt;&gt;- Topology: ConnectResponse\n\nTopology -&gt;&gt;+ Transport: DisconnectRequest\nTransport --&gt;&gt;- Topology: DisconnectResponse\n\nAny Local Engine -&gt;&gt;+ Transport: ConnectedNodesRequest\nTransport --&gt;&gt;- Any Local Engine: ConnectedNodesResponse\n\nTransport -) Any Local Engine: NodeConnected\n\nTransport -) Any Local Engine: NodeDisconnected\n\nTransport -) Any Local Engine: NodeConnectFailed</code></pre> (Wiki) links on this page<ul><li>Transport</li><li>NodeIdentity</li><li>P2PMessage to Transport</li><li>P2PMessageV1</li><li>NodeIdentity</li><li>NodeIdentity</li><li>EngineMessageV1</li><li>RelayMessageV1</li><li>TransportMessage</li><li>TransportMessage</li><li>TransportMessageV1</li><li>TransportAddress</li><li>TransportPrefs</li><li>P2PMessageV1</li><li>P2PMessage</li><li>ConnectRequest</li><li>ConnectRequestV1</li><li>NodeIdentity</li><li>ConnectResponseV1</li><li>DisconnectRequest</li><li>DisconnectRequestV1</li><li>NodeIdentity</li><li>DisconnectResponseV1</li><li>ConnectedNodesRequest</li><li>ConnectedNodesResponseV1</li><li>NodeIdentity</li><li>TransportAddress</li><li>NodeConnected</li><li>NodeTransportAddress</li><li>NodeIdentity</li><li>TransportAddress</li><li>NodeConnectFailed</li><li>NodeTransportAddress</li><li>NodeIdentity</li><li>TransportAddress</li><li>NodeDisconnected</li><li>NodeTransportAddress</li><li>NodeIdentity</li><li>TransportAddress</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/messages/connect_request.html","title":"ConnectRequest","text":"(Wiki) links on this page<ul><li>ConnectRequestV1</li><li>NodeIdentity</li><li>ConnectResponseV1</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/messages/connect_request.html#connectrequest","title":"ConnectRequest","text":"","boost":2},{"location":"arch/node/networking/node/transport/messages/connect_request.html#connectresponse","title":"ConnectResponse","text":"","boost":2},{"location":"arch/node/networking/node/transport/messages/connect_request.html#purpose","title":"Purpose","text":"<p>Establish connection to a node.</p>","boost":2},{"location":"arch/node/networking/node/transport/messages/connect_request.html#type","title":"Type","text":"<p>Reception:</p> <p>ConnectRequestV1</p> <p>Record with fields:</p> <ul> <li> <p><code>node</code>: NodeIdentity</p> <p>Node to connect to.</p> </li> </ul> <p>Triggers:</p> <p>ConnectResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/node/transport/messages/connect_request.html#behaviour","title":"Behaviour","text":"<p>Establish connection to the specified node, if not yet connected.</p>","boost":2},{"location":"arch/node/networking/node/transport/messages/connect_request.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nTopology -&gt;&gt;+ Transport: ConnectRequest\nTransport --&gt;&gt;- Topology: ConnectResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/node/transport/messages/connected_nodes_request.html","title":"ConnectedNodesRequest","text":"","boost":2},{"location":"arch/node/networking/node/transport/messages/connected_nodes_request.html#connectednodesresponse","title":"ConnectedNodesResponse","text":"","boost":2},{"location":"arch/node/networking/node/transport/messages/connected_nodes_request.html#purpose","title":"Purpose","text":"<p>Request the list of currently connected nodes.</p>","boost":2},{"location":"arch/node/networking/node/transport/messages/connected_nodes_request.html#type","title":"Type","text":"<p>Reception:</p> <p>unit</p> <p>Triggers:</p> <p>ConnectedNodesResponseV1</p> <p>list&lt;(NodeIdentity, TransportAddress)&gt;</p>","boost":2},{"location":"arch/node/networking/node/transport/messages/connected_nodes_request.html#behaviour","title":"Behaviour","text":"<p>Return the list of currently connected nodes from the ConnectionPool.</p>","boost":2},{"location":"arch/node/networking/node/transport/messages/connected_nodes_request.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nAny Local Engine -&gt;&gt;+ Transport: ConnectedNodesRequest\nTransport --&gt;&gt;- Any Local Engine: ConnectedNodesResponse\n%% --8&lt;-- [end:sequence]</code></pre> (Wiki) links on this page<ul><li>ConnectedNodesResponseV1</li><li>NodeIdentity</li><li>TransportAddress</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/messages/disconnect_request.html","title":"DisconnectRequest","text":"(Wiki) links on this page<ul><li>DisconnectRequestV1</li><li>NodeIdentity</li><li>DisconnectResponseV1</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/messages/disconnect_request.html#disconnectrequest","title":"DisconnectRequest","text":"","boost":2},{"location":"arch/node/networking/node/transport/messages/disconnect_request.html#disconnectresponse","title":"DisconnectResponse","text":"","boost":2},{"location":"arch/node/networking/node/transport/messages/disconnect_request.html#purpose","title":"Purpose","text":"<p>Establish disconnection to a node.</p>","boost":2},{"location":"arch/node/networking/node/transport/messages/disconnect_request.html#type","title":"Type","text":"<p>Reception:</p> <p>DisconnectRequestV1</p> <p>Record with fields:</p> <ul> <li> <p><code>node</code>: NodeIdentity</p> <p>Node to disconnect from.</p> </li> </ul> <p>Triggers:</p> <p>DisconnectResponseV1</p> <p>Result</p>","boost":2},{"location":"arch/node/networking/node/transport/messages/disconnect_request.html#behaviour","title":"Behaviour","text":"<p>Disconnect from the specified node, if connected.</p>","boost":2},{"location":"arch/node/networking/node/transport/messages/disconnect_request.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nTopology -&gt;&gt;+ Transport: DisconnectRequest\nTransport --&gt;&gt;- Topology: DisconnectResponse\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/node/transport/messages/p2p_message.html","title":"P2PMessage","text":"","boost":2},{"location":"arch/node/networking/node/transport/messages/p2p_message.html#purpose","title":"Purpose","text":"<p>An outgoing message to be delivered to another node over the network.</p>","boost":2},{"location":"arch/node/networking/node/transport/messages/p2p_message.html#type","title":"Type","text":"<p>Reception:</p> <p>P2PMessageV1</p> <p>Record with fields:</p> <ul> <li> <p><code>src</code>: NodeIdentity</p> <p>Source peer</p> </li> </ul> <ul> <li> <p><code>dst</code>: NodeIdentity</p> <p>Destination peer</p> </li> </ul> <ul> <li> <p><code>msg</code>: enum { EngineMessageV1, RelayMessageV1 }</p> <p>Encapsulated message</p> </li> </ul> <ul> <li> <p><code>sig</code>: Signature</p> <p>Signature over the above fields by <code>src</code></p> </li> </ul> <p>Triggers:</p> <p>TransportMessage</p>","boost":2},{"location":"arch/node/networking/node/transport/messages/p2p_message.html#behaviour","title":"Behaviour","text":"<p>The Transport engine looks up the transport addresses associated with the destination peer identity using a LookupIdentityRequest to the Network Identity Store engine. Address choice is influenced by the TransportPrefs specified in the encapsulated EngineMessage. If this lookup fails, the message is dropped.</p> <p>Transport then wraps the P2PMessage in a TransportMessage with the selected TransportAddress. and sends it to the network using the corresponding transport protocol, establishing a new connection if not connected yet to the destination.</p> <p>Once the connection is set up, Transport announces this via a NodeConnected notification. At the end of the connection, a NodeDisconnected notification is sent instead.</p> <p>When a connection cannot be established immediately, the message is queued and sending periodically retried, possibly via different transport addresses, until the <code>expiry</code> time specified in the encapsulated EngineMessage is reached, after which the message is dropped.</p>","boost":2},{"location":"arch/node/networking/node/transport/messages/p2p_message.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nTransportProtocol -) Transport: TransportMessage\nTransport -) Router: P2PMessage\nRouter -) Transport: P2PMessage\nTransport -) TransportProtocol: TransportMessage\n%% --8&lt;-- [end:sequence]</code></pre> (Wiki) links on this page<ul><li>P2PMessageV1</li><li>NodeIdentity</li><li>NodeIdentity</li><li>EngineMessageV1</li><li>RelayMessageV1</li><li>TransportMessage</li><li>LookupIdentityRequest</li><li>Network Identity Store</li><li>TransportPrefs</li><li>EngineMessage</li><li>P2PMessage</li><li>TransportMessage</li><li>TransportAddress</li><li>NodeConnected</li><li>NodeDisconnected</li><li>EngineMessage</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/messages/transport_message.html","title":"TransportMessage","text":"","boost":2},{"location":"arch/node/networking/node/transport/messages/transport_message.html#purpose","title":"Purpose","text":"<p>A message from/to one of the transport protocols.</p>","boost":2},{"location":"arch/node/networking/node/transport/messages/transport_message.html#type","title":"Type","text":"<p>Reception:</p> <p>TransportMessageV1</p> <p>Record with fields:</p> <ul> <li> <p><code>addr</code>: TransportAddress</p> <p>Source or destination address</p> </li> </ul> <ul> <li> <p><code>tprefs</code>: Option&lt;TransportPrefs&gt;</p> <p>Transport preferences for outgoing messages</p> </li> </ul> <ul> <li> <p><code>expiry</code>: Option <p>Expiry time for outgoing messages</p> <ul> <li> <p><code>msg</code>: P2PMessageV1</p> <p>Encapsulated message</p> </li> </ul> <p>Triggers:</p> <p>P2PMessage</p>","boost":2},{"location":"arch/node/networking/node/transport/messages/transport_message.html#behaviour","title":"Behaviour","text":"<p>When receiving a TransportMessage from one of the transport protocols <code>addr</code> contains the source address, <code>tprefs</code> and <code>expiry</code> are not set, and <code>msg</code> contains the message received. Upon reception, Transport forwards the contained P2PMessage to the Router.</p> <p>When sending a TransportMessage via one of the transport prototocols, <code>addr</code> contains the destination address, <code>tprefs</code> is set to the transport prefences from either the contained EngineMessage, the NodeIdentityRecord from the Network Identity Store, or the defaults in the local configuration of the Transport engine, <code>expiry</code> is set from the contained EngineMessage, and <code>msg</code> contains the message to be sent.</p>","boost":2},{"location":"arch/node/networking/node/transport/messages/transport_message.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nTransportProtocol -) Transport: TransportMessage\nTransport -) Router: P2PMessage\nRouter -) Transport: P2PMessage\nTransport -) TransportProtocol: TransportMessage\n%% --8&lt;-- [end:sequence]</code></pre> (Wiki) links on this page<ul><li>TransportMessageV1</li><li>TransportAddress</li><li>TransportPrefs</li><li>P2PMessageV1</li><li>P2PMessage</li><li>P2PMessage</li><li>Router</li><li>EngineMessage</li><li>NodeIdentityRecord</li><li>Network Identity Store</li><li>EngineMessage</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/notifications/node_connect_failed.html","title":"NodeConnectFailed","text":"<p>Notification sent when failed to establish a connection to a node.</p>","boost":2},{"location":"arch/node/networking/node/transport/notifications/node_connect_failed.html#type","title":"Type","text":"<p>NodeTransportAddress</p> <p>Record with fields:</p> <ul> <li> <p><code>node</code>: NodeIdentity</p> <p>Node ID</p> </li> </ul> <ul> <li> <p><code>addr</code>: TransportAddress</p> <p>Transport address of <code>node</code></p> </li> </ul>","boost":2},{"location":"arch/node/networking/node/transport/notifications/node_connect_failed.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nTransport -) Any Local Engine: NodeConnectFailed\n%% --8&lt;-- [end:sequence]</code></pre> (Wiki) links on this page<ul><li>NodeTransportAddress</li><li>NodeIdentity</li><li>TransportAddress</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/notifications/node_connected.html","title":"NodeConnected","text":"(Wiki) links on this page<ul><li>NodeTransportAddress</li><li>NodeIdentity</li><li>TransportAddress</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/notifications/node_connected.html#nodeconnected","title":"NodeConnected","text":"","boost":2},{"location":"arch/node/networking/node/transport/notifications/node_connected.html#purpose","title":"Purpose","text":"<p>Notification sent when a transport connection is established to a node.</p>","boost":2},{"location":"arch/node/networking/node/transport/notifications/node_connected.html#type","title":"Type","text":"<p>NodeTransportAddress</p> <p>Record with fields:</p> <ul> <li> <p><code>node</code>: NodeIdentity</p> <p>Node ID</p> </li> </ul> <ul> <li> <p><code>addr</code>: TransportAddress</p> <p>Transport address of <code>node</code></p> </li> </ul>","boost":2},{"location":"arch/node/networking/node/transport/notifications/node_connected.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nTransport -) Any Local Engine: NodeConnected\n%% --8&lt;-- [end:sequence]</code></pre>","boost":2},{"location":"arch/node/networking/node/transport/notifications/node_disconnected.html","title":"NodeDisconnected","text":"<p>Notification sent when a transport connection is closed to a node.</p>","boost":2},{"location":"arch/node/networking/node/transport/notifications/node_disconnected.html#type","title":"Type","text":"<p>NodeTransportAddress</p> <p>Record with fields:</p> <ul> <li> <p><code>node</code>: NodeIdentity</p> <p>Node ID</p> </li> </ul> <ul> <li> <p><code>addr</code>: TransportAddress</p> <p>Transport address of <code>node</code></p> </li> </ul>","boost":2},{"location":"arch/node/networking/node/transport/notifications/node_disconnected.html#message-flow","title":"Message flow","text":"<pre><code>sequenceDiagram\n\n%% --8&lt;-- [start:sequence]\nTransport -) Any Local Engine: NodeDisconnected\n%% --8&lt;-- [end:sequence]</code></pre> (Wiki) links on this page<ul><li>NodeTransportAddress</li><li>NodeIdentity</li><li>TransportAddress</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/types/connect_request_v1.html","title":"ConnectRequestV1","text":"","boost":2},{"location":"arch/node/networking/node/transport/types/connect_request_v1.html#purpose","title":"Purpose","text":"<p>Request connection to a node.</p>","boost":2},{"location":"arch/node/networking/node/transport/types/connect_request_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>node</code>: NodeIdentity</p> <p>Node to connect to.</p> </li> </ul> (Wiki) links on this page<ul><li>NodeIdentity</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/types/connect_response_v1.html","title":"ConnectResponseV1","text":"","boost":2},{"location":"arch/node/networking/node/transport/types/connect_response_v1.html#purpose","title":"Purpose","text":"<p>Response to a ConnectRequestV1.</p>","boost":2},{"location":"arch/node/networking/node/transport/types/connect_response_v1.html#type","title":"Type","text":"<p>Result</p>","boost":2},{"location":"arch/node/networking/node/transport/types/connect_response_v1.html#values","title":"Values","text":"<ul> <li>OK_CONNECTED: connection is already established.</li> <li>OK_LOOKUP: connection establishment initiated after successful address lookup.</li> <li>ERROR_LOOKUP: node address lookup failed.</li> </ul> (Wiki) links on this page<ul><li>ConnectRequestV1</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/types/connected_nodes_response_v1.html","title":"ConnectedNodesResponseV1","text":"","boost":2},{"location":"arch/node/networking/node/transport/types/connected_nodes_response_v1.html#purpose","title":"Purpose","text":"<p>A list of open connections associated with node identities.</p>","boost":2},{"location":"arch/node/networking/node/transport/types/connected_nodes_response_v1.html#type","title":"Type","text":"<p>list&lt;(NodeIdentity, TransportAddress)&gt;</p> (Wiki) links on this page<ul><li>NodeIdentity</li><li>TransportAddress</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/types/connection_prefs.html","title":"ConnectionPrefs","text":"","boost":2},{"location":"arch/node/networking/node/transport/types/connection_prefs.html#purpose","title":"Purpose","text":"<p>Connection preferences for a peer</p>","boost":2},{"location":"arch/node/networking/node/transport/types/connection_prefs.html#type","title":"Type","text":"<p>Enum with one the following values:</p> <ul> <li>Ephemeral: ephemeral connection that is lost upon disconnect</li> <li>Permanent: permanent connection that is re-established upon disconnect</li> </ul>","boost":2},{"location":"arch/node/networking/node/transport/types/disconnect_request_v1.html","title":"DisconnectRequestV1","text":"","boost":2},{"location":"arch/node/networking/node/transport/types/disconnect_request_v1.html#purpose","title":"Purpose","text":"<p>Request to disconnect from a node.</p>","boost":2},{"location":"arch/node/networking/node/transport/types/disconnect_request_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>node</code>: NodeIdentity</p> <p>Node to disconnect from.</p> </li> </ul> (Wiki) links on this page<ul><li>NodeIdentity</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/types/disconnect_response_v1.html","title":"DisconnectResponseV1","text":"","boost":2},{"location":"arch/node/networking/node/transport/types/disconnect_response_v1.html#purpose","title":"Purpose","text":"<p>Response to a DisconnectRequestV1.</p>","boost":2},{"location":"arch/node/networking/node/transport/types/disconnect_response_v1.html#type","title":"Type","text":"<p>Result</p>","boost":2},{"location":"arch/node/networking/node/transport/types/disconnect_response_v1.html#values","title":"Values","text":"<ul> <li>OK: Node has been disconnected successfully.</li> <li>ERROR: Node was not connected.</li> </ul> (Wiki) links on this page<ul><li>DisconnectRequestV1</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/types/node_transport_address.html","title":"NodeTransportAddress","text":"","boost":2},{"location":"arch/node/networking/node/transport/types/node_transport_address.html#purpose","title":"Purpose","text":"<p>Node with its transport address</p>","boost":2},{"location":"arch/node/networking/node/transport/types/node_transport_address.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>node</code>: NodeIdentity</p> <p>Node ID</p> </li> </ul> <ul> <li> <p><code>addr</code>: TransportAddress</p> <p>Transport address of <code>node</code></p> </li> </ul> (Wiki) links on this page<ul><li>NodeIdentity</li><li>TransportAddress</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/types/ordering_prefs.html","title":"TransportOrderingPrefs","text":"","boost":2},{"location":"arch/node/networking/node/transport/types/ordering_prefs.html#purpose","title":"Purpose","text":"<p>Transport ordering preferences.</p>","boost":2},{"location":"arch/node/networking/node/transport/types/ordering_prefs.html#type","title":"Type","text":"<p>Enum with the following values.</p> Value Type Description Ordered Unordered","boost":2},{"location":"arch/node/networking/node/transport/types/reliability_prefs.html","title":"TransportReliabilityPrefs","text":"","boost":2},{"location":"arch/node/networking/node/transport/types/reliability_prefs.html#purpose","title":"Purpose","text":"<p>Transport reliability preferences.</p>","boost":2},{"location":"arch/node/networking/node/transport/types/reliability_prefs.html#type","title":"Type","text":"<p>Enum with the following values.</p> Value Type Description Reliable Unreliable","boost":2},{"location":"arch/node/networking/node/transport/types/security_prefs.html","title":"TransportSecurityPrefs","text":"","boost":2},{"location":"arch/node/networking/node/transport/types/security_prefs.html#purpose","title":"Purpose","text":"<p>Transport privacy preferences.</p>","boost":2},{"location":"arch/node/networking/node/transport/types/security_prefs.html#type","title":"Type","text":"<p>Enum with the following possible values.</p> Value Type Description Direct OnionRouting u8 OR with given min. number of hops Mixnet","boost":2},{"location":"arch/node/networking/node/transport/types/transport_address.html","title":"TransportAddress","text":"","boost":2},{"location":"arch/node/networking/node/transport/types/transport_address.html#purpose","title":"Purpose","text":"<p>A transport address.</p>","boost":2},{"location":"arch/node/networking/node/transport/types/transport_address.html#type","title":"Type","text":"<p>One of the following types, depending on the transport protocol.</p> <ul> <li>QUICAddr</li> <li>WSSAddr</li> <li>TorAddr</li> <li>VeilidAddr</li> <li>...</li> </ul>","boost":2},{"location":"arch/node/networking/node/transport/types/transport_address.html#quicaddr-wssaddr","title":"QUICAddr &amp; WSSAddr","text":"<p>For transports over IP that use X.509 certificates (such as QUIC &amp; Secure WebSocket), the destination IP address &amp; port, as well as the certificate issuer public key is given. The latter is used to verify the transport certificate of the remote peer.</p> Field Type Description <code>ip</code> IPAddress IP Address <code>port</code> u16 Port number <code>cert_issuer</code> ExternalIdentity Certificate issuer public key","boost":2},{"location":"arch/node/networking/node/transport/types/transport_address.html#toraddr-veilidaddr","title":"TorAddr &amp; VeilidAddr","text":"<p>For transports that use public key addressing (such as Tor &amp; Veilid), the destination public key address is given, possibly together with additional transport-specific dial information.</p> Field Type Description <code>addr</code> Vec Address","boost":2},{"location":"arch/node/networking/node/transport/types/transport_message_v1.html","title":"TransportMessageV1","text":"","boost":2},{"location":"arch/node/networking/node/transport/types/transport_message_v1.html#purpose","title":"Purpose","text":"<p>Describe the purpose of the type.</p>","boost":2},{"location":"arch/node/networking/node/transport/types/transport_message_v1.html#type","title":"Type","text":"<p>Record with fields:</p> <ul> <li> <p><code>addr</code>: TransportAddress</p> <p>Source or destination address</p> </li> </ul> <ul> <li> <p><code>tprefs</code>: Option&lt;TransportPrefs&gt;</p> <p>Transport preferences for outgoing messages</p> </li> </ul> <ul> <li> <p><code>expiry</code>: Option <p>Expiry time for outgoing messages</p> <ul> <li> <p><code>msg</code>: P2PMessageV1</p> <p>Encapsulated message</p> </li> </ul> (Wiki) links on this page<ul><li>TransportAddress</li><li>TransportPrefs</li><li>P2PMessageV1</li></ul>","boost":2},{"location":"arch/node/networking/node/transport/types/transport_prefs.html","title":"TransportPrefs","text":"","boost":2},{"location":"arch/node/networking/node/transport/types/transport_prefs.html#purpose","title":"Purpose","text":"<p>Transport preferences.</p>","boost":2},{"location":"arch/node/networking/node/transport/types/transport_prefs.html#type","title":"Type","text":"<p>Struct with the following fields.</p> Field Type Description <code>ordering</code> OrderingPrefs Transport ordering preferences <code>reliability</code> ReliabilityPrefs Transport reliability preferences <code>security</code> SecurityPrefs Transport security preferences (Wiki) links on this page<ul><li>OrderingPrefs</li><li>ReliabilityPrefs</li><li>SecurityPrefs</li></ul>","boost":2},{"location":"arch/node/ordering/index.html","title":"Ordering Machine","text":"","boost":2},{"location":"arch/node/ordering/index.html#introduction","title":"Introduction","text":"","boost":2},{"location":"arch/node/ordering/index.html#purpose","title":"Purpose","text":"<p>The ordering machine is a set of communicating engines that collaborate in</p> <ul> <li>receiving transaction candidates from   users or solvers</li> </ul> <ul> <li>ordering these requests for   execution,</li> </ul> <ul> <li>executing the   transaction candidates,</li> </ul> <ul> <li>updated the state accordingly,</li> </ul> <ul> <li>making the state available.</li> </ul>","boost":2},{"location":"arch/node/ordering/index.html#background","title":"Background","text":"<p>In full generality, Anoma nodes form a distributed system that implements a transaction processing system (TPS) and a replicated state machine (RSM). This state machine must represent all anoma state, including commitments and nullifiers. The Ordering Machine, however, does not need to understand the full complexity of the anoma state: only that it can be represented as a Key Value Store, where transaction candidates each read some (arbitrary) data from keys, and can write some (arbitrary) data to keys. We outline the full requirements of the abstraction boundary with the State Machine in the Execution Engines page.</p> <p>In V1, the implementation is running on a single physical machine. As a consequence the consensus problem is trivial. Roughly, in V1, we only have the machine that is going to be replicated from V2 onward.</p> <p>Scope</p> <p>We start by describing the overall structure of the ordering machine while the details of the protocol and the functionality of the engines is described in the respective pages. The collection of all engines of the ordering machine is organized into three groups:</p> <ul> <li>Mempool Engines;</li> </ul> <ul> <li>Consensus Engine;</li> </ul> <ul> <li>Execution Engines.</li> </ul> <p>We mention the consensus engine, because it is one of the most important components from V2 onward, although it is not present in V1.</p>","boost":2},{"location":"arch/node/ordering/index.html#overview","title":"Overview","text":"<p>Transaction requests trigger transaction processing. Users or Solvers send transaction requests to the ordering machine: more specifically, to a worker engine. The ordering machine will eventually order and execute the transaction candidates included in these requests. Successfully processing a transaction request amounts to invoking the transition function of the RSM, according to an agreed upon order (determined by the mempool in collaboration with consensus). Typical transactions contain read and write operations to a \u201cglobal\u201d key-value store representing the state of the RSM. In general, transactions may have side effects besides state updates, but these are not considered in V1.</p> <p>Todo</p> <p>Are they ignored? Are ExecutionSummary and pub sub information of execution data side effects?</p> <ul> <li>The mempool engines are responsible for   managing transaction data,   (pre-)processing them for consensus and execution.</li> </ul> <ul> <li> <p>The trivial consensus problem is already implicitly solved   by the worker in V1.</p> <ul> <li>In V1, there is only one worker.   There will be multiple (on each Node) in future versions.</li> </ul> </li> </ul> <ul> <li> <p>The execution engines execute   the transactions:</p> <ul> <li>Shards maintain the local copy of the global state (of the RSM),   i.e., serve read and write requests of Executors   to the key-value store (of the RSM).</li> </ul> <ul> <li>Executors process transaction candidates, effectively    invoking the transition function          of the RSM.</li> </ul> </li> </ul> <p></p>","boost":2},{"location":"arch/node/ordering/index.html#a-life-cycle-with-some-details","title":"A life cycle with some details","text":"<p>Let us consider a typical/generic case of what transaction submission triggers in the ordering machine. Note that all message sending is asynchronous.</p> <p>Todo</p> <p>removed <code>ExecutorProcess--)ExecutorProcess: .</code> just before  <code>activate ExecutorProcess</code>. I'm not sure what it represented. --&gt;</p> <pre><code>sequenceDiagram\n    participant User\n    participant Worker\n    participant ExecutionSupervisor\n    participant ExecutorProcess\n    User-)Worker: TransactionRequest\n    Worker--)Worker: fix batch \u2116\n    Worker-)User: TransactionAck\n    Worker--)Worker: Buffering &amp; Shuffling\n    Worker--)Worker: fix tx \u2116\n    Worker-)ExecutionSupervisor: spawnExecutor\n    ExecutionSupervisor-)Worker: EPID\n    Worker-)ExecutorProcess: ExecuteTransaction\n    Worker-)Shard: KVSAcquireLock\n    Shard-)Worker: KVSLockAcquired\n    Worker-)Shard: UpdateSeenAll\n    activate ExecutorProcess\n    ExecutorProcess-)Shard: KVSReadRequest\n    Shard-)ExecutorProcess: KVSRead\n    ExecutorProcess-)Shard: KVSWrite(Request)\n    %%    ExecutorProcess-)WhereToIdontKnow: pub sub information of execution data\n    ExecutorProcess-)User: ExecutionSummary\n    ExecutorProcess-)Worker: ExecutorFinished\n    deactivate ExecutorProcess</code></pre>","boost":2},{"location":"arch/node/ordering/index.html#the-origin-of-the-request","title":"The origin of the request","text":"<p>at user</p> <p>The user creates a TransactionCandidate \\(T\\).</p> \\[T = \\Bigl(\\mathit{code},     \\underbrace{(r_e,r_l)}_{\\text{read label}},     \\overbrace{(w_w,w_m)}^{\\text{write label}}\\Bigr)\\] <p>Quote</p> <p>transaction executable \\(\\mathit{code}\\) eager read keys \\(r_e\\) lazy read keys \\(r_l\\) \\(w_w\\) will-write keys \\(w_m\\) may-write keys</p> <p>The User transmits the TransactionCandidate, packaged as a TransactionRequest, to the worker.</p> <ul> <li>TransactionRequest \u2192 Worker Engine<p>This message is the origin of the life cycle.</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/index.html#acknowledging-the-userss-transactionrequest","title":"Acknowledging the Users's TransactionRequest","text":"<p>at Worker Engine</p> <p>Once it is clear that the transaction can be included into the current  batch, the transaction candidate is \"stamped\" with the current  batch number.</p> <ul> <li>TransactionAck \u2192 user<p>This is mainly for purposes of UX,   but gives also information for re-submission strategies.</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/index.html#buffering-and-shuffling-optional","title":"Buffering and shuffling (optional)","text":"<p>at Worker Engine</p> <p>One may want to order each transaction request within a batch only after a  minimum number of other requests are received such that they can be \"slightly\"  re-ordered within a very short time period---for several reasons.</p> <p>Todo</p> <p>add footnote / explain exactly the issues this avoids</p>","boost":2},{"location":"arch/node/ordering/index.html#assigning-a-transaction-number","title":"Assigning a transaction number","text":"<p>at Worker Engine</p> <p>Eventually, possibly triggered by a timer or when sufficiently many  other transaction candidates have been received, the transaction  request will be assigned a transaction number  (within the current batch). Together the batch and transaction numbers can form a unique  TxFingerprint for the TransactionRequest.</p> <p>Transaction Numbers can be assigned immediately from some set of  available transaction numbers, provided this complies with the  buffering and shuffling scheme. For example, a worker could maintain a shuffled list of natural  numbers for each batch, and assign them sequentially from the list. Alternatively, a worker could assign Transaction Numbers sequentially, in which case transaction candidates will end up ordered in the  order they were received. This may slightly change in V2.</p>","boost":2},{"location":"arch/node/ordering/index.html#requesting-an-available-executor-engine","title":"Requesting an available executor engine","text":"<p>at Worker Engine</p> <p>The Worker Engine either directly spawns an Executor process  or contacts an Execution Supervisor that provides an  Executor Process ID (EPID).</p> <ul> <li>SpawnExecutor\u2192Execution Supervisor<p>Request a fresh process id of an available Executor,   typically a newly spawned executor engine instance.</p> </li> </ul> <p>Note that the Execution Supervisor cannot, in general, wait for some existing Executor processes to terminate before spawning a new Executor process. It is possible that the existing Executor is waiting for a transaction candidate with an earlier TxFingerprint to be executed, but which does not yet have an Executor, in order to run. Therefore waiting for existing Executors to terminate can cause deadlock.</p> <p>Also, we do not want to Execution Supervisor to become a bottleneck. Hence, the supervisor itself may be a concurrently running group of engines.</p>","boost":2},{"location":"arch/node/ordering/index.html#providing-a-fresh-executor","title":"Providing a \"fresh\" executor","text":"<p>at Execution Supervisor</p> <ul> <li>ExecutorPIDAssigned\u2192Worker<p>Send the external identity of a \"fresh\" executor engine instance,   either newly spawned or a waiting in a fixed pool of available executors.</p> </li> </ul> <p>Todo</p> <p>add one supervisor for each executor --&gt;</p>","boost":2},{"location":"arch/node/ordering/index.html#informing-shards-about-upcoming-read-and-write-requests","title":"Informing shard(s) about upcoming read and write requests","text":"<p>at Worker Engine</p> <ul> <li>KVSAcquireLock \u2192 Shards<p>The Worker Engine informs all relevant Shards about locks   for this TransactionCandidate (at this TxFingerprint).   This also  allows the shard to prepare for read and write requests   (which can be used for optimizations like warming up disk storage).</p> </li> </ul> <p>If it helps, these messages can be batched and sent periodically.</p>","boost":2},{"location":"arch/node/ordering/index.html#notifying-the-curator-about-acquired-locks","title":"Notifying the curator about acquired locks","text":"<p>at Shard</p> <ul> <li>KVSLockAcquired \u2192 Worker Engine<p>The Shard informs the Worker Engine about locks acquired   or \"recorded\" for this Worker Engine's TransactionCandidate.   This becomes crucial below, at \"Notifying shards about locks seen.\"</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/index.html#starting-transaction-execution","title":"Starting transaction execution","text":"<p>at Worker Engine</p> <ul> <li>ExecuteTransaction \u2192 Executor<p>This will trigger the actual execution.   This execution includes any finalization or resource logic checks.   Reads, for executor process purposes, include any reads of state   necessary for any post-ordering execution, resource logic checks,   or anything else dependent on the \"current\" state of the state   machine.   Writes, for purposes of the state machine, include only final,   valid updates to state that are definitely committed.</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/index.html#sending-read-requests","title":"Sending read requests","text":"<p>at Executor</p> <ul> <li>KVSReadRequest \u2192 Shard<p>While executing the transaction   (depending on previous reads and or static data in the code)   send the optional read requests to the Shard.</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/index.html#sending-write-requests","title":"Sending write requests","text":"<p>at Executor</p> <p>Todo</p> <p>this should be a Request!</p> <ul> <li>KVSWrite \u2192 Shards<p>When the transaction candidate has run,   for each write lock, the   Executor informs the relevant Shard of a value to write   (or, for <code>may_write</code>s, maybe to not update this value).</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/index.html#notifying-shards-about-locks-seen","title":"Notifying shards about locks \"seen\"","text":"<p>at Worker Engine</p> <ul> <li>UpdateSeenAll \u2192 Shards<p>The Worker Engine informs each Shard of the greatest   TxFingerprint such that it can be sure   (because it has heard enough KVSLockAcquired messages)   that the Shard will never hear a   KVSAcquireLock from this Worker Engine with an equal or   lower TxFingerprint in the future.   This is crucial, because Shards cannot \"read\" values from   storage at a particular TxFingerprint until they are sure that   no writes with earlier TxFingerprints will happen.</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/index.html#serving-read-and-write-requests-from-executors","title":"Serving read and write requests from executors","text":"<p>at Shards</p> <ul> <li>KVSRead \u2192 Executor<p>For each read lock, if all preceding write locks have been   recorded, and the unique preceding write has produced a value, the   Shard can read a value.   For eager reads (as defined in KVSAcquireLock), it sends this   value immediately to the Executor, and for lazy reads, it   sends it in response to a KVSReadRequest from the Executor.</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/index.html#handling-transaction-candidate-side-effects","title":"Handling transaction candidate side effects","text":"<p>at Executor</p> <p>In addition to updates to state, transaction candidates can do other stuff (so long as it does not non-deterministically effect updates to state). This can include logging and sending messages to users.</p>","boost":2},{"location":"arch/node/ordering/index.html#informing-users-about-results-and-logs","title":"Informing users about results and logs","text":"<p>The user is informed about the results of the transaction outcome. In future versions (from V2 onward), this comes in two flavors:</p> <ul> <li>communication from only one validator's executor process   (probably whatever validator the user submitted to)</li> </ul> <ul> <li>some reliable transmission protocol between   the user and at least a weak quorum of validators.</li> </ul>","boost":2},{"location":"arch/node/ordering/index.html#informing-the-curator-about-execution-termination","title":"Informing the curator about execution termination","text":"<p>at Executor</p> <ul> <li>ExecutorFinished \u2192 Worker Engine<p>Notify the Worker Engine about the finished execution.   This triggers a log dump at the Worker Engine,   and will be used for garbage collection from V2 onward.   For logging purposes, we could encode values read / written in here.</p> </li> </ul> (Wiki) links on this page<ul><li>TransactionCandidate</li><li>TransactionCandidate</li><li>Shard</li><li>TransactionCandidate</li><li>Ordering Machine</li><li>Consensus Engine</li><li>TransactionRequest</li><li>TransactionRequest</li><li>Worker Engine</li><li>TransactionCandidate</li><li>TransactionRequest</li><li>Consensus Engine</li><li>TxData</li><li>Worker Engine</li><li>Worker Engine</li><li>Shard</li><li>Executor</li><li>Executor</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionRequest</li><li>Worker Engine</li><li>TransactionRequest</li><li>Worker Engine</li><li>Worker Engine</li><li>TransactionAck</li><li>Worker Engine</li><li>Worker Engine</li><li>TxFingerprint</li><li>TransactionRequest</li><li>TransactionCandidate</li><li>Worker Engine</li><li>Worker Engine</li><li>Executor</li><li>Execution Supervisor</li><li>SpawnExecutor</li><li>Execution Supervisor</li><li>Executor</li><li>Execution Supervisor</li><li>Executor</li><li>Executor</li><li>Executor</li><li>TransactionCandidate</li><li>TxFingerprint</li><li>Executor</li><li>Executor</li><li>Execution Supervisor</li><li>ExecutorPIDAssigned</li><li>Worker Engine</li><li>Worker Engine</li><li>KVSAcquireLock</li><li>Shard</li><li>Worker Engine</li><li>Shard</li><li>TransactionCandidate</li><li>TxFingerprint</li><li>Shard</li><li>KVSLockAcquired</li><li>Worker Engine</li><li>Shard</li><li>Worker Engine</li><li>Worker Engine</li><li>TransactionCandidate</li><li>Worker Engine</li><li>ExecuteTransaction</li><li>Executor</li><li>Executor</li><li>KVSReadRequest</li><li>Shard</li><li>Shard</li><li>Executor</li><li>KVSWrite</li><li>Shard</li><li>TransactionCandidate</li><li>Executor</li><li>Shard</li><li>Worker Engine</li><li>UpdateSeenAll</li><li>Shard</li><li>Worker Engine</li><li>Shard</li><li>TxFingerprint</li><li>KVSLockAcquired</li><li>Shard</li><li>KVSAcquireLock</li><li>Worker Engine</li><li>TxFingerprint</li><li>Shard</li><li>TxFingerprint</li><li>TxFingerprint</li><li>Shard</li><li>KVSRead</li><li>Executor</li><li>Shard</li><li>KVSAcquireLock</li><li>Executor</li><li>KVSReadRequest</li><li>Executor</li><li>Executor</li><li>Executor</li><li>ExecutorFinished</li><li>Worker Engine</li><li>Worker Engine</li><li>Worker Engine</li></ul> <ol> <li> <p>In fact it is the latter time stamp that is most relevant; the former is merely an indicator about performance of the worker.\u00a0\u21a9</p> </li> <li> <p>This response may be delayed until the TxFingerprint is assigned. In V2, the \"shuffling\" of transactions may be pseudo-random so that we can quickly pass on transaction data to mirror workers.\u00a0\u21a9</p> </li> </ol>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html","title":"A complete lifecycle","text":"","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#a-life-cycle-with-some-details","title":"A life cycle with some details","text":"<p>Let us consider a typical/generic case of what transaction submission triggers in the ordering machine. Note that all message sending is asynchronous.</p> <p>Todo</p> <p>removed <code>ExecutorProcess--)ExecutorProcess: .</code> just before  <code>activate ExecutorProcess</code>. I'm not sure what it represented. --&gt;</p> <pre><code>sequenceDiagram\n    participant User\n    participant Worker\n    participant ExecutionSupervisor\n    participant ExecutorProcess\n    User-)Worker: TransactionRequest\n    Worker--)Worker: fix batch \u2116\n    Worker-)User: TransactionAck\n    Worker--)Worker: Buffering &amp; Shuffling\n    Worker--)Worker: fix tx \u2116\n    Worker-)ExecutionSupervisor: spawnExecutor\n    ExecutionSupervisor-)Worker: EPID\n    Worker-)ExecutorProcess: ExecuteTransaction\n    Worker-)Shard: KVSAcquireLock\n    Shard-)Worker: KVSLockAcquired\n    Worker-)Shard: UpdateSeenAll\n    activate ExecutorProcess\n    ExecutorProcess-)Shard: KVSReadRequest\n    Shard-)ExecutorProcess: KVSRead\n    ExecutorProcess-)Shard: KVSWrite(Request)\n    %%    ExecutorProcess-)WhereToIdontKnow: pub sub information of execution data\n    ExecutorProcess-)User: ExecutionSummary\n    ExecutorProcess-)Worker: ExecutorFinished\n    deactivate ExecutorProcess</code></pre>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#the-origin-of-the-request","title":"The origin of the request","text":"<p>at user</p> <p>The user creates a TransactionCandidate \\(T\\).</p> \\[T = \\Bigl(\\mathit{code},     \\underbrace{(r_e,r_l)}_{\\text{read label}},     \\overbrace{(w_w,w_m)}^{\\text{write label}}\\Bigr)\\] <p>Quote</p> <p>transaction executable \\(\\mathit{code}\\) eager read keys \\(r_e\\) lazy read keys \\(r_l\\) \\(w_w\\) will-write keys \\(w_m\\) may-write keys</p> <p>The User transmits the TransactionCandidate, packaged as a TransactionRequest, to the worker.</p> <ul> <li>TransactionRequest \u2192 Worker Engine<p>This message is the origin of the life cycle.</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#acknowledging-the-userss-transactionrequest","title":"Acknowledging the Users's TransactionRequest","text":"<p>at Worker Engine</p> <p>Once it is clear that the transaction can be included into the current  batch, the transaction candidate is \"stamped\" with the current  batch number.</p> <ul> <li>TransactionAck \u2192 user<p>This is mainly for purposes of UX,   but gives also information for re-submission strategies.</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#buffering-and-shuffling-optional","title":"Buffering and shuffling (optional)","text":"<p>at Worker Engine</p> <p>One may want to order each transaction request within a batch only after a  minimum number of other requests are received such that they can be \"slightly\"  re-ordered within a very short time period---for several reasons.</p> <p>Todo</p> <p>add footnote / explain exactly the issues this avoids</p>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#assigning-a-transaction-number","title":"Assigning a transaction number","text":"<p>at Worker Engine</p> <p>Eventually, possibly triggered by a timer or when sufficiently many  other transaction candidates have been received, the transaction  request will be assigned a transaction number  (within the current batch). Together the batch and transaction numbers can form a unique  TxFingerprint for the TransactionRequest.</p> <p>Transaction Numbers can be assigned immediately from some set of  available transaction numbers, provided this complies with the  buffering and shuffling scheme. For example, a worker could maintain a shuffled list of natural  numbers for each batch, and assign them sequentially from the list. Alternatively, a worker could assign Transaction Numbers sequentially, in which case transaction candidates will end up ordered in the  order they were received. This may slightly change in V2.</p>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#requesting-an-available-executor-engine","title":"Requesting an available executor engine","text":"<p>at Worker Engine</p> <p>The Worker Engine either directly spawns an Executor process  or contacts an Execution Supervisor that provides an  Executor Process ID (EPID).</p> <ul> <li>SpawnExecutor\u2192Execution Supervisor<p>Request a fresh process id of an available Executor,   typically a newly spawned executor engine instance.</p> </li> </ul> <p>Note that the Execution Supervisor cannot, in general, wait for some existing Executor processes to terminate before spawning a new Executor process. It is possible that the existing Executor is waiting for a transaction candidate with an earlier TxFingerprint to be executed, but which does not yet have an Executor, in order to run. Therefore waiting for existing Executors to terminate can cause deadlock.</p> <p>Also, we do not want to Execution Supervisor to become a bottleneck. Hence, the supervisor itself may be a concurrently running group of engines.</p>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#providing-a-fresh-executor","title":"Providing a \"fresh\" executor","text":"<p>at Execution Supervisor</p> <ul> <li>ExecutorPIDAssigned\u2192Worker<p>Send the external identity of a \"fresh\" executor engine instance,   either newly spawned or a waiting in a fixed pool of available executors.</p> </li> </ul> <p>Todo</p> <p>add one supervisor for each executor --&gt;</p>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#informing-shards-about-upcoming-read-and-write-requests","title":"Informing shard(s) about upcoming read and write requests","text":"<p>at Worker Engine</p> <ul> <li>KVSAcquireLock \u2192 Shards<p>The Worker Engine informs all relevant Shards about locks   for this TransactionCandidate (at this TxFingerprint).   This also  allows the shard to prepare for read and write requests   (which can be used for optimizations like warming up disk storage).</p> </li> </ul> <p>If it helps, these messages can be batched and sent periodically.</p>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#notifying-the-curator-about-acquired-locks","title":"Notifying the curator about acquired locks","text":"<p>at Shard</p> <ul> <li>KVSLockAcquired \u2192 Worker Engine<p>The Shard informs the Worker Engine about locks acquired   or \"recorded\" for this Worker Engine's TransactionCandidate.   This becomes crucial below, at \"Notifying shards about locks seen.\"</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#starting-transaction-execution","title":"Starting transaction execution","text":"<p>at Worker Engine</p> <ul> <li>ExecuteTransaction \u2192 Executor<p>This will trigger the actual execution.   This execution includes any finalization or resource logic checks.   Reads, for executor process purposes, include any reads of state   necessary for any post-ordering execution, resource logic checks,   or anything else dependent on the \"current\" state of the state   machine.   Writes, for purposes of the state machine, include only final,   valid updates to state that are definitely committed.</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#sending-read-requests","title":"Sending read requests","text":"<p>at Executor</p> <ul> <li>KVSReadRequest \u2192 Shard<p>While executing the transaction   (depending on previous reads and or static data in the code)   send the optional read requests to the Shard.</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#sending-write-requests","title":"Sending write requests","text":"<p>at Executor</p> <p>Todo</p> <p>this should be a Request!</p> <ul> <li>KVSWrite \u2192 Shards<p>When the transaction candidate has run,   for each write lock, the   Executor informs the relevant Shard of a value to write   (or, for <code>may_write</code>s, maybe to not update this value).</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#notifying-shards-about-locks-seen","title":"Notifying shards about locks \"seen\"","text":"<p>at Worker Engine</p> <ul> <li>UpdateSeenAll \u2192 Shards<p>The Worker Engine informs each Shard of the greatest   TxFingerprint such that it can be sure   (because it has heard enough KVSLockAcquired messages)   that the Shard will never hear a   KVSAcquireLock from this Worker Engine with an equal or   lower TxFingerprint in the future.   This is crucial, because Shards cannot \"read\" values from   storage at a particular TxFingerprint until they are sure that   no writes with earlier TxFingerprints will happen.</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#serving-read-and-write-requests-from-executors","title":"Serving read and write requests from executors","text":"<p>at Shards</p> <ul> <li>KVSRead \u2192 Executor<p>For each read lock, if all preceding write locks have been   recorded, and the unique preceding write has produced a value, the   Shard can read a value.   For eager reads (as defined in KVSAcquireLock), it sends this   value immediately to the Executor, and for lazy reads, it   sends it in response to a KVSReadRequest from the Executor.</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#handling-transaction-candidate-side-effects","title":"Handling transaction candidate side effects","text":"<p>at Executor</p> <p>In addition to updates to state, transaction candidates can do other stuff (so long as it does not non-deterministically effect updates to state). This can include logging and sending messages to users.</p>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#informing-users-about-results-and-logs","title":"Informing users about results and logs","text":"<p>The user is informed about the results of the transaction outcome. In future versions (from V2 onward), this comes in two flavors:</p> <ul> <li>communication from only one validator's executor process   (probably whatever validator the user submitted to)</li> </ul> <ul> <li>some reliable transmission protocol between   the user and at least a weak quorum of validators.</li> </ul>","boost":2},{"location":"arch/node/ordering/a_complete_lifecycle.html#informing-the-curator-about-execution-termination","title":"Informing the curator about execution termination","text":"<p>at Executor</p> <ul> <li>ExecutorFinished \u2192 Worker Engine<p>Notify the Worker Engine about the finished execution.   This triggers a log dump at the Worker Engine,   and will be used for garbage collection from V2 onward.   For logging purposes, we could encode values read / written in here.</p> </li> </ul>","boost":2},{"location":"arch/node/ordering/consensus_v1.html","title":"Consensus Engine","text":"<p>There is no non-trivial consensus problem to solve in v2.</p>","boost":2},{"location":"arch/node/ordering/engine_template/message_reaction_template.html","title":"Message reaction template","text":"","boost":2},{"location":"arch/node/ordering/engine_template/message_reaction_template.html#somemessagetoreactto","title":"<code>SomeMessageToReactTo</code>","text":"<ul> <li>from SendingEngine, AnotherSendingEngine</li> </ul>","boost":2},{"location":"arch/node/ordering/engine_template/message_reaction_template.html#purpose","title":"Purpose","text":"<p>A message typically informs (about \"observations\" of the sending engine) or requests data (that the receiving engine is missing). Thus, it makes sense to make precise, what the purpose of the message is.</p>","boost":2},{"location":"arch/node/ordering/engine_template/message_reaction_template.html#structure","title":"Structure","text":"Field Type Description <code>name_of_field</code> <code>TypeName</code> describe the field information ... ... ... <code>last_field</code> <code>NameN</code> more descriptions","boost":2},{"location":"arch/node/ordering/engine_template/message_reaction_template.html#effects","title":"Effects","text":"<ul> <li>This message may changes the state of the engine instance in certain ways.</li> <li>It might impose new obligations ...</li> <li>... resolve obligations.</li> <li>\u2026</li> </ul>","boost":2},{"location":"arch/node/ordering/engine_template/message_reaction_template.html#triggers","title":"Triggers","text":"<ul> <li>to Engine: <code>ReactionMessage</code>, <code>AnotherMessage</code> <code>if</code> <code>then</code>    &amp;   <code>if</code> <code>then</code>    &amp;   ...   &amp;   <code>if</code> \\(n\\) one liner&gt;   <code>then</code> \\(n\\) contents description&gt; <ul> <li>to AnotherEngine: <code>AnotherReactionMessage</code>, <code>YetAnotherMessage</code> [...]</li> <li>\u2026</li> </ul>","boost":2},{"location":"arch/node/ordering/engine_template/message_reaction_template_example.html","title":"Message reaction template example","text":"","boost":2},{"location":"arch/node/ordering/engine_template/message_reaction_template_example.html#newtransaction","title":"<code>NewTransaction</code>","text":"<ul> <li>from Worker</li> </ul>","boost":2},{"location":"arch/node/ordering/engine_template/message_reaction_template_example.html#purpose","title":"Purpose","text":"<p>The sending worker is forwarding transaction data for the purpose of storing a copy (a trivial erasure coding share) at the receiving worker.</p>","boost":2},{"location":"arch/node/ordering/engine_template/message_reaction_template_example.html#structure","title":"Structure","text":"Field Type Description <code>tx_data</code> <code>TxData</code> the transaction data to store <code>fingerprint</code> <code>TxFingerprint</code> the transaction's fingerprint ... ... ...","boost":2},{"location":"arch/node/ordering/engine_template/message_reaction_template_example.html#effects","title":"Effects","text":"<ul> <li>A correct worker will keep the message available until post-order execution.</li> </ul>","boost":2},{"location":"arch/node/ordering/engine_template/message_reaction_template_example.html#triggers","title":"Triggers","text":"<ul> <li>to Primary: <code>WorkerHashAvailable</code> <code>If</code> the received transaction data is completing a worker hash copy / erasure coding share   <code>then</code> notify the primary that the respective worker hash is available</li> <li>to \"execution\" <code>If</code> conditions to be figured out \ud83d\ude05   <code>then</code> notify the relevant shards that they will get tx data from this worker (if they want?)</li> </ul> <p>Todo</p> <p>get this sorted out</p>","boost":2},{"location":"arch/node/ordering/execution/index.html","title":"Execution","text":"<p>Purpose</p> <p>Given a total order of transaction candidates (from the mempool),<sup>1</sup> the execution engine updates \"the\" state of the replicated state machine by executing them. The execution engine uses state dependency labels to calculate updates concurrently when possible. Furthermore, partial order information can suffice to start concurrent computation, even before mempool and consensus determine a total order.  Transaction candidates that include side effects (such  as sending messages to a user or solver) perform those effects from the Executor process within the Execution Engines.</p> <p>In V1, following each state update, the mempool's [[Worker</p> <p>results.</p> <p>Background</p> <p>The ordering machine maintains a replicated state machine, which is a core concept of distributed systems. The architecture of the ordering machine is an adaptation of Calvin: Fast Distributed Transactions for Partitioned Database Systems, to Narwhal's scale-out architecture. The execution engine exploits concurrency of transactions, using the idea of serializability (a key concept of Transaction processing systems and databases). Given that we follow a pre-determined total order of transactions, we have what has been called deterministic execution scheduling. In V1, the mempool alone suffices to determine the total order (without the need for any Consensus Engine).</p> <p>Scope</p> <p>The Execution Engine group is responsible for updating and maintaining the state of the state machine. It relies on the mempool to store and order transaction candidates.<sup>4</sup></p> <p>In specifying the Execution Engines, we abstract over the contents of the state machine, or exactly what has to be done to update it given a TransactionCandidate. The state of Anoma's state machine will contain Resources, Nullifiers, and Commitments, and executing each Transaction Candidate will require, among other things, checking the respective Resource Logics of the involved resources. Roughly, the state and precise \"code\" of transactions are essentially a type parameter.<sup>2</sup></p> <p>For V1, we assume that there is a single validator that is maintaining a single state machine. V1 does not include any kind of garbage collection or deletion of old state.</p> <p>Each Validator maintains its own Execution Engine group. These are complete replicas of the state machine, with complete replication of Transaction Candidate execution. Future optimizations may allow for distributed proofs of various kinds allowing some validators to skip some of the execution.</p> <p>We do, however, allow for checkpointing: By performing a full-state read from a weak quorum of validators, a validator can learn the complete state of the state machine at a particular timestamp, and then compute all the Transaction Candidates thereafter. It should not have to compute from genesis. No one should need to store a complete history of all Transaction Candidates or past state values.</p>","boost":2},{"location":"arch/node/ordering/execution/index.html#functionality","title":"Functionality","text":"","boost":2},{"location":"arch/node/ordering/execution/index.html#high-level-protocols","title":"High Level Protocols","text":"<p>The main functionality of the Execution engine is serializable  TransactionCandidate execution. We want to execute each TransactionCandidate, i.e., read the necessary values from storage, evaluate the executor function, and write the computed results to state, concurrently but serializably: each Transaction Candidate's reads and writes should be as if the TransactionCandidates were executed in the total order chosen by the mempool.<sup>5</sup> As this order is fixed, we can use deterministic execution scheduling.</p> <p>We can imagine the simplest system as executing each TransactionCandidate,  after they are ordered, sequentially in the fixed order. However, we want to  exploit concurrency of transactions as much as possible to minimize latency. Several optimizations improve over sequential execution. We can increase  concurrency of transaction by partitioning state as key/value pairs: we can execute TransactionCandidates that only access disjoint sets of keys concurrently (or even in parallel).</p>","boost":2},{"location":"arch/node/ordering/execution/index.html#responsibilities","title":"Responsibilities","text":"","boost":2},{"location":"arch/node/ordering/execution/index.html#state","title":"State","text":"<p>The core purpose of the Execution Engine group is updating and maintaining the  state of the RSM. As an abstraction, we assume state is stored as mutable Data (unlimited size blobs of binary), each of which is accessed using an  immutable Key. If we want to mutate a Key associated with specific Data, that  means that we have to delete the Data associated with the old Key, and write a copy of the data to the new Key. Keys that have never had Data written to them  are mapped to an empty value. Thus, we can create, read, update, and  delete Keys. These are the only primitives we use.<sup>6</sup></p> <p>For V2, we do not assume any key structure, so TransactionLabels  will have an explicit list of Keys they can use, rather than  something more clever.<sup>3</sup></p>","boost":2},{"location":"arch/node/ordering/execution/index.html#transaction-candidate-labels","title":"Transaction Candidate Labels","text":"<p>TransactionCandidates are labeled with a  set of keys they can read, and a set of keys they can write. Writing \\(\\wp\\mathit{Keys}\\) for the powerset of all keys, we have the following:</p> <p>\\(\\mathsf{read\u2013keys}:   \\mathit{Tx\\_Candidates} \\rightarrow \\wp\\mathit{Keys}\\)</p> <p>\\(\\mathsf{write\u2013keys}: \\mathit{Tx\\_Candidates} \\rightarrow \\wp\\mathit{Keys}\\)</p> <p>The Execution Engines must not allow a TransactionCandidate to affect any  key outside of its write set, aborting the transaction with an error message.  Moreover, each TransactionCandidate's effects must be a deterministic function of the TransactionCandidate and the values  of the keys in its read set in RSM state.</p>","boost":2},{"location":"arch/node/ordering/execution/index.html#executor-function","title":"Executor Function","text":"<p>In order to define a state machine, we assume a fixed  Executor Function:</p> <p>\\(\\mathsf{executor\\_function}\\colon \\left(\\mathit{Data}^{\\mathit{Keys}} \\times \\mathit{Tx\\_Candidates}\\right) \\to \\left(  \\wp(\\mathit{Keys}\\times \\mathit{Data})\\times \\mathit{IO\u2013commands} \\right)\\)</p> <p>Inputs:</p> <ul> <li>the previous state, represented as a function from Keys to Data</li> <li>the TransactionCandidate itself</li> </ul> <p>Outputs:</p> <ul> <li>The new \\(\\left\\langle \\mathit{key}, \\mathit{data}\\right\\rangle\\)    pairs to be written to state.<ul> <li>Naively, these must include all the Keys in \\(\\mathsf{write}(T)\\),    but we have an optimization for cases where \\(T\\) does not actually    update this Key.</li> <li>This new state must be a deterministic result of the inputs.</li> </ul> </li> <li>IO side-effects are allowed, including sending messages to users    or other Identities in the Anoma network.   The Executor may run these IO effects,   but running IO effects is orthogonal to   reading and writing to state,   i.e., running IO effects must not affect the key value store.   Whether or not the executor runs IO effects will (in V2) depend on   additional information provided in   transaction requests that   the worker can pass to the executor (in the ExecuteTransaction message).</li> </ul> <p>When the execution engine group executes a TransactionCandidate,  it read the keys from the state that would be reached by executing  all preceding TransactionCandidates<sup>7</sup>   to compute the \\(\\mathsf{executor\\_function}\\), and then updates its state. After executing a TransactionCandidate, the state of the write  keys must reflect the result of the \\(\\mathsf{executor\\_function}\\) as  applied to the read keys.</p>","boost":2},{"location":"arch/node/ordering/execution/index.html#timestamps","title":"Timestamps","text":"<p>Each Transaction Candidate has a logical Timestamp  which conveys ordering information relative to other  transaction candidates. Timestamps, and thus TransactionCandidates, are  partially ordered. As shards learn more information from consensus or the mempool, they are able to refine this partial order into a total order. Logical timestamps should include:</p> <ul> <li>a mempool worker id</li> <li>a TxFingerprint</li> <li>a hash of the transaction candidate</li> </ul> <p>For each mempool worker, timestamp ordering should be consistent with  the lexicographic order of batch number and transaction number  (where the latter is unique w.r.t. each batch).</p> <p>!!! todo make proper logical timestamp type description file. I think we have one somewhere, and I'm not sure where.</p> <p>The state stored at each Timestamp must be the one  that would result from applying the \\(\\mathsf{executor\\_function}\\) to  each TransactionCandidate in the total order of their  Timestamps.</p>","boost":2},{"location":"arch/node/ordering/execution/index.html#engines-overview","title":"Engines Overview","text":"<p>Todo</p> <p>adapt</p> <p></p>","boost":2},{"location":"arch/node/ordering/execution/index.html#shards","title":"Shards","text":"<p>Shards store and update the state of the RSM. Different shards may be on different machines.<sup>8</sup> Within a Validator, Keys are partitioned across the  Shards for load-balancing. Redistributing state between Shards is called re-sharding. For V2, we assume there will be no re-sharding.</p> <p>For each Key, each Shard maintains a (partially-ordered) timeline  of Timestamps of TransactionCandidates that  read or write to that Key.<sup>9</sup></p> <p>This requires Shards to receive and process ordering information  from mempool and consensus. Shards also store the data written by each  TransactionCandidate that writes to that Key. This is multi-version concurrent storage.</p> <p></p> <p>When a Shard has determined the value a TransactionCandidate  reads from a key, it sends that value to the corresponding  Executor. In the Shard page, we detail optimizations for getting read values  to Executors as quickly as possible.</p>","boost":2},{"location":"arch/node/ordering/execution/index.html#executors-aka-executor-processes","title":"Executors aka Executor Processes","text":"<p>Executors are processes that compute the  Executor Function and communicate results to the Shards. Each TransactionCandidate is assigned its own Executor  process, which receives the full TransactionExecutable from the  mempool workers. The Execution Engines might keep a pool of Executors, or spin a  new one up with each TransactionCandidate.</p> <p></p> <p>The Executor sends read requests to the  relevant Shards to obtain values the TransactionCandidate  needs to read at runtime;  then the Executor computes the Executor Function on the values  received from the Shards, and finally sends any values to be  written to the relevant Shards. To save on communication costs,  Executors  can be co-located with  Shards,  Worker Engines,  or both.</p>","boost":2},{"location":"arch/node/ordering/execution/index.html#read-backend","title":"Read Backend","text":"<p>Read-only Transaction Candidates generalize state reads: any time someone wants to read (or compute something from) the official state on the validator (without changing it), it's a read-only transaction. We need a public-facing process that communicates with the shards and executors much like the mempool. The primary difference between the Read Backend and the mempool in terms of interface is just that its transactions cannot write to state.</p> <p>We detail the Read Backend engine here.</p> (Wiki) links on this page<ul><li>TransactionCandidate</li><li>TransactionLabel</li><li>TransactionCandidate</li><li>Executor</li><li>Ordering Machine</li><li>Consensus Engine</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>Nullifier</li><li>Commitment</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionLabel</li><li>TransactionCandidate</li><li>TransactionLabel</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>Executor</li><li>TransactionRequest</li><li>ExecuteTransaction</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TxFingerprint</li><li>TransactionCandidate</li><li>Shard</li><li>Shard</li><li>Shard</li><li>Shard</li><li>TransactionCandidate</li><li>Shard</li><li>Consensus Engine</li><li>Shard</li><li>TransactionCandidate</li><li>Shard</li><li>TransactionCandidate</li><li>Executor</li><li>Shard</li><li>Executor</li><li>Shard</li><li>TransactionCandidate</li><li>Executor</li><li>TransactionExecutable</li><li>Worker Engine</li><li>Executor</li><li>TransactionCandidate</li><li>Executor</li><li>KVSReadRequest</li><li>Shard</li><li>TransactionCandidate</li><li>Executor</li><li>Shard</li><li>Shard</li><li>Executor</li><li>Shard</li><li>Worker Engine</li></ul> <ol> <li> <p>For V1, the mempool was already determining a total order, because we only had a single unique worker and transaction fingerprints already provide all information of a total order. This is no longer true in V2.\u00a0\u21a9</p> </li> <li> <p>In fact, this could be made precise using abstract data types.\u00a0\u21a9</p> </li> <li> <p>In V2, we make the additional assumption that Keys can have structure. For example, we can arrange them in a forest, to allow us to easily express sub-trees using prefixes.     This would allow labels to express potentially infinite sets of keys in a compact way. This will also require that we address the challenge of re-sharding state, i.e., re-partitioning the state, e.g., due to migration of validators around the globe.\u00a0\u21a9</p> </li> <li> <p>From V2 onwards, mempool interacts with consensus to establish a total order.\u00a0\u21a9</p> </li> <li> <p>Again, note that from V2 onwards, this will be in collaboration with consensus.\u00a0\u21a9</p> </li> <li> <p>However, we also assume mulit-version storage.\u00a0\u21a9</p> </li> <li> <p>Recall that we may known what this state is as soon as all relevant previous transactions are executed, i.e., those that may have an effect on the keys read.\u00a0\u21a9</p> </li> <li> <p>For V2, the number of shards may be variable and the challenge of re-sharding needs to be addressed.\u00a0\u21a9</p> </li> <li> <p>The timeline is based on a shard-specific view of the mempool DAG.\u00a0\u21a9</p> </li> </ol>","boost":2},{"location":"arch/node/ordering/execution/read_backend.html","title":"Read Backend","text":"<p>The ReadBackend is a component intended for light client reads.</p> <p>Todo</p> <p>We have not spent much time thinking about this one.</p>","boost":2},{"location":"arch/node/ordering/execution/read_backend.html#incoming-messages","title":"Incoming Messages","text":"","boost":2},{"location":"arch/node/ordering/execution/read_backend.html#from-light-client-over-network","title":"From Light Client (over network)","text":"<pre><code>type ReadTransactionRequest = SignedMessage&lt;ExecuteReadTransaction&gt;\n</code></pre>","boost":2},{"location":"arch/node/ordering/execution/read_backend.html#outgoing-messages","title":"Outgoing Messages","text":"","boost":2},{"location":"arch/node/ordering/execution/read_backend.html#to-executor","title":"To Executor","text":"<p>See <code>ExecuteReadTransaction</code>.</p> <p>Todo</p> <p>make a folder for the read backend</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html","title":"Taiga","text":"<p>Taiga is a concrete instantiation of the Anoma Resource Machine used to compute and verify state transition proposals. Taiga defines what a valid transaction is and provides the means to produce and verify transactions.</p> <p>A valid transaction is defined by two criteria:</p> <ul> <li>applications the state of which is being affected by the proposed state transition authorize the change</li> <li>the proposed state transition doesn't violate the Taiga rules</li> </ul> <p>Actors and agents use Taiga to produce and verify the proofs required to form transactions. The executor function uses Taiga to verify the transactions before applying them to the state.</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#resource-model","title":"Resource model","text":"<p>Being an instance of the Anoma Resource Machine, Taiga is designed in the resource model, where resources represent atomic units of the state. Taiga supports shielded state transitions with the help of zero-knowledge proofs, commitment schemes, signatures, and other privacy-preserving techniques. Resources are distributed and stored in an encrypted form. Taiga uses proof recursion to provide function privacy for custom logics.</p> <p>Taiga was heavily inspired by Zcash Orchard and ZEXE.</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#functions-provided-by-taiga","title":"Functions provided by Taiga","text":"<ul> <li>create a transaction: users create initial transactions to announce what they offer and request, including constraints. These transactions are sent to the intent gossip network to be matched with other transactions. Solvers create transactions to match the intents of the users.</li> <li>verify a transaction: each transaction contains proofs attesting to its correctness. When a solver receives transactions from the intent gossip network, they must verify the proofs.</li> <li>compose transactions: solvers combine transactions to build a balanced transaction that satisfies the intents of the involved parties.</li> </ul> <p>The following sections describe the protocol for shielded state transitions.</p> <p>Note</p> <p>Instantiations and some of the exact formulas are unstable</p> <p>Note</p> <p>To learn more about Taiga as a standalone component, check the Taiga repository</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#1-proving-systems","title":"1. Proving systems","text":"<p>The table below contains the description of how resource machine proof types are instantiated by Taiga.</p> RM proof Type Instantiation Delta proof Binding signature RedDSA + Pasta curves Compliance proof zk-SNARK Halo2 + IPA FCS + Pasta curves Resource logic proof zk-SNARK Halo2 + IPA FCS + Pasta curves <p>A zero-knowledge proving system is used to produce zero-knowledge proofs for the compliance circuit and resource logic circuits. The compliance circuit is fixed, resource logic circuits are custom and require at least two-layer recursion to achieve function privacy. Currently, Taiga uses Halo2 with IPA FCS and Pasta curves to create proofs for these circuits.</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#11-zk-snark-circuits","title":"1.1 zk-SNARK circuits","text":"<p>A circuit \\(C\\) is represented as polynomials over the chosen curve's scalar field, following plonk-ish arithmetization. Proof elements are generated over the curve's base field.</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#12-elliptic-curves","title":"1.2 Elliptic curves","text":"Name Scalar field Base field Purpose Instantiation \\(E_I\\) Inner curve \\(\\mathbb{F}_q\\) \\(\\mathbb{F}_p\\) ECC gadget Pallas \\(E_M\\) Main curve \\(\\mathbb{F}_p\\) \\(\\mathbb{F}_q\\) compliance and RL circuits Vesta \\(E_O\\) Outer curve \\(\\mathbb{F}_q\\) \\(\\mathbb{F}_p\\) Accumulation circuit Pallas","boost":2},{"location":"arch/node/ordering/execution/taiga.html#13-proving-system-interfaces","title":"1.3 Proving system interfaces","text":"Interface Description Generate Verifying key <code>keygen_vk(C) \u27f6 vk</code> <code>C</code> is turned into a verifying key \u2014 a succint representation of the circuit that the verifier uses to verify a proof Generate Proving key <code>keygen_pk(C, vk) \u27f6 pk</code> Generate a proving key from a verifying key and an instance of the circuit Prove <code>P(pk, x, w) \u27f6 \u03c0</code> Prove that a circuit is satisfied Verify <code>V(vk, x, \u03c0) \u27f6 0/1</code> Verify the proof","boost":2},{"location":"arch/node/ordering/execution/taiga.html#2-resources","title":"2. Resources","text":"<p>A resource is an immutable particle of an application state. The state is updated by consuming and creating resources.</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#21-resource-plaintext","title":"2.1 Resource plaintext","text":"<p>The table below describes the components of a resource, also referred as a resource plaintext.</p> Variable Formula Type/size Description \\(l\\) \\(VKCommit(vk_{logic})\\) Contains the application's RL verifying key. Used to identify the application the resource belongs to. As the verifying key itself is large, resources only store a commitment to it \\(label\\) Contains the application data that affects fungibility of the resource. Along with \\(l\\), it is used to derive resource's kind \\(q\\) \\({0..2^{64} - 1}\\) The quantity of fungible value \\(v\\) Resource value is a commitment to the resource's extra data that doesn't affect the resource's fungibility \\(eph\\) bool Ephemeral resource flag. It indicates whether the resource's commitment Merkle path should be checked when consuming the resource. \\(nonce\\) \\(nonce\\) \\(\\mathbb{F}_p\\) An old nullifier from the same Compliance description \\(npk\\) \\(cm_{nk}\\) Commitment to the nullifier key \\(nk\\) that will be used to derive the resource's nullifier. \\(npk = NKCommit(nk)\\) \\(rseed\\) \\(\\mathbb{F}_p\\) A random commitment trapdoor <p>Note</p> <p>The value size cannot be bigger or close to the curve's scalar field size (to avoid overflowing) but besides that there are no strict reasons for choosing 64. We can use more resources to express a value that doesn't fit in one resource (splitting the value into limbs). Having bigger value size requires fewer resources to express such a value and is more efficient. For example, a value size of 128 bits would require two times less resources to express a maximum value</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#22-computable-fields","title":"2.2 Computable fields","text":"","boost":2},{"location":"arch/node/ordering/execution/taiga.html#221-resource-kind","title":"2.2.1 Resource kind","text":"<p>Each resource has a kind that refers to the application the resource belongs to. It is derived from the resource's logic and label as follows:</p> <p>\\(K = PRF^{kind}(l, label)\\)</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#222-psi","title":"2.2.2 \\(\\psi\\)","text":"<p>This an intermediate computed parameter used in the computation of resource commitment and resource nullifier. \\(\\psi = PRF^{\\psi}(0, rseed, nonce)\\)</p> <p>Note</p> <p>unstable</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#223-rcm","title":"2.2.3 \\(rcm\\)","text":"<p>This parameter is used as randomness when computing the resource commitment.</p> <p>\\(rcm = PRF^{rcm}(1, rseed, nonce)\\)</p> <p>Quote</p> <p>unstable</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#224-resource-commitment","title":"2.2.4 Resource commitment","text":"<p>Resource commitment allows to prove the existence of the resource without revealing the resource plaintext. For a resource \\(r\\), the resource commitment is computed as follows: \\(cm = \\mathrm{ResourceCommit}(r.l, r.label, r.v, r.npk, r.nonce, r.\\psi, r.eph, r.q., r.rcm)\\).</p> <p>Resource commitments are stored in a global append-only commitment tree \\(CMtree\\), which contains commitments to all of the resources that were ever created. \\(CMtree\\) is a cryptographic accumulator implemented as a Merkle tree. To prove the resource's existence, a path to the resource's commitment leaf is provided as a witness (private input).</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#225-nullifier","title":"2.2.5 Nullifier","text":"<p>Revealing the resource's nullifier invalidates the resource. All nullifiers are stored in a global append-only nullifier set \\(NFset\\). Given the nullifier key \\(nk\\) and a resource \\(r\\), the nullifier \\(nf\\) is computed as follows: \\(nf = DeriveNullifier_{nk}(r) = PRF_{nf}(r.nk, r.nonce, r.\\psi, r.cm)\\)</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#2251-nullifier-key-nk","title":"2.2.5.1 Nullifier key \\(nk\\)","text":"<p>Each created resource plaintext contains a nullifier public key \\(npk\\) that commits to some nullifier key \\(nk\\). This nullifier key have to be used to compute the resource's nullifier. The knowledge of the resource's nullifier key is necessary (but not sufficient) to create the resource's nullifier and invalidate the resource.</p> <p>\\(nk \\mathop{\\longleftarrow}\\limits^{R} \\mathbb{F}_p\\)</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#25-verifiable-encryption","title":"2.5 Verifiable encryption","text":"<p>Encryption is used for in-band distribution of resources. Encrypted resources are stored on the blockchain, the receiver can scan the blockhcain trying to decrypt the transactions to find the resources that were sent to them.</p> <p>We want the encryption to be verifiable to make sure the receiver of the resources can decrypt them. In other systems like Zcash the sender and the creator of the resource are the same actor, and it doesn't make sense for the sender to send a corrupted message to the receiver (essentially burning the resource), but in Taiga the resources are often created and sent by different parties.</p> <p>For verifiable encryption, we use the combination of DH key exchange for key derivation and symmetric encryption.</p> <p>\\(sk = DH(pub_{recv}, priv_{send})\\)</p> <p>\\(ce = Encrypt(resource, sk)\\)</p> <p>Not all of the resource fields require to be encrypted (e.g. the resource commitment), and the encrypted fields may vary depending on the application. To make sure it is flexible enough, the encryption check is performed in RL circuits (as opposed to verifying the encryption in the compliance circuit).</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#26-ephemeral-resources","title":"2.6 Ephemeral resources","text":"<p>Ephemeral resources are resources for which the existence (i.e., Merkle path to its commitment in the \\(CMtree\\)) is not checked when the resource is being consumed. Unlike some other systems (e.g., Zcash), resource's ephemerality isn't defined by its quantity (i.e., resources of quantity 0 are not necessarily ephemeral), instead, it is explicitly defined by the ephemerality flag \\(eph\\). Non-zero value ephemeral resources can be handy for carrying additional constraints (e.g. intents) and for balancing transactions.</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#3-circuits","title":"3. Circuits","text":"","boost":2},{"location":"arch/node/ordering/execution/taiga.html#31-the-compliance-circuit","title":"3.1 The Compliance Circuit","text":"<p>The compliance circuit <code>ComplianceCircuit(x; w)</code> checks that a transaction satisfies the Taiga rules. The Compliance circuit performs checks over \\(1\\) input and \\(1\\) output resource, which sometimes referred as a compliance pair. A transaction containing \\(n\\) input and \\(n\\) output resources requires \\(n\\) Compliance proofs. If the number of input and output resources isn't equal, ephemeral notes can be used to make them equal. The circuit is arithmetized over \\(\\mathbb{F}_p\\).</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#inputs","title":"Inputs","text":"<p>Public inputs (\\(x\\)): 1. \\(rt\\) - \\(CMtree\\) root 2. \\(cm\\) - output resource commitment 3. \\(cm_{l}^{out}\\) - commitment to the output resource's logic, 2. \\(nf\\) - input resource nullifier 5. \\(cm_{l}^{in}\\) - commitment to the input resource's logic 6. \\(\\Delta\\) - compliance pair delta</p> <p>Private inputs (\\(w\\)): 1. \\(path\\) - \\(CMtree\\) path from \\(rt\\) to \\(cm\\) 2. \\(r^{in}\\) - input resource plaintext 3. \\((l^{in}, rcm^{in}_{l})\\) - \\(cm_{l}^{in}\\) opening 4. \\(r^{out}\\) - output resource plaintext 5. \\((l^{out}, rcm^{out}_{l})\\) - \\(cm_{l}^{out}\\) opening</p> <p>Note</p> <p>opening of a parameter contains every component of the parameter</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#checks","title":"Checks","text":"<ul> <li>For the input resource:     - If <code>eph = true</code>, check that the resource is a valid resource in \\(rt\\): there is a path in Merkle tree with root \\(rt\\) to a resource commitment \\(cm\\) that opens to \\(r\\)       - \\(path\\) leads from \\(rt\\) to \\(cm\\)       - \\(cm\\) commits to \\(r^{in}\\)     - Nullifier integrity: \\(nf = DeriveNullifier_{nk}(r^{in})\\).     - Resource logic integrity: \\(cm_{l}^{in} = RLCommit(l^{in}, rcm^{in}_{l})\\)     - Kind integrity: \\(K = PRF^{kind}(l^{in}, label^{in})\\)</li> <li>For the output resource:     - Commitment integrity: \\(cm = ResourceCommit(r^{out}, rseed^{out})\\)     - Resource logic integrity: \\(cm_{l}^{out} = RLCommit(l^{out}, rcm^{out}_{l})\\)     - Kind integrity: \\(K = PRF^{kind}(l^{out}, label^{out})\\)</li> <li>Delta integrity: \\(delta = DeltaCommit(q_{in}, q_{out}, K_{in}, K_{out}, rcd)\\)</li> </ul> <p>Note</p> <p>unlike MASP, the value base in Taiga is not used to compute resource's commitment and the compliance circuit doesn't take \\(kind\\) as private input but computes it from the resource fields, and it is checked for both input and output resources.</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#32-resource-logic-rl-circuits","title":"3.2 Resource Logic (RL) circuits","text":"<p>Resource logic is a circuit containing the application logic. Resource logics take \\(m\\) input and \\(n\\) output resources, are represented as Halo2 circuits <code>RL(x; w) \u27f6 0/1</code> and arithmetized over \\(\\mathbb{F}_p\\).</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#inputs_1","title":"Inputs","text":"<p>Public inputs (\\(x\\)):</p> <ul> <li>\\(nf_1, \u2026, nf_m\\) - input resource nullifiers</li> <li>\\(cm_1, \u2026, cm_n\\) - output resource commitments</li> <li>\\(ce_1, \u2026, ce_n\\) - encrypted output resources</li> <li>custom public inputs</li> </ul> <p>Private inputs (\\(w\\)):</p> <ul> <li>\\(r^{in}_1, \u2026, r^{in}_m\\) - input resources openings</li> <li>\\(r^{out}_1, \u2026, r^{out}_n\\) - output resources openings</li> <li>\\(tag\\) that identifies the resource for which the resource logic is being checked</li> <li>custom private inputs</li> </ul> <p>Each resource logic has a fixed number of public inputs and unlimited amount of private inputs. Currently, the allowed number of public inputs is limited to \\(25\\).</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#checks_1","title":"Checks","text":"<p>As the resource plaintexts are private inputs, to make sure that resources that the circuit received indeed the ones that correspond to the public parameters, every RL circuit must check:</p> <ol> <li>Input resource nullifier integrity: for each \\(i \u2208 {1, \u2026, m}, nf_i = DeriveNullifier_{nk}(nonce, \\psi, cm)\\)</li> <li>Output resource commitment integrity: for each \\(i \u2208 {1, \u2026, n}, cm_i = ResourceCommit(r)\\)</li> <li>Encrypted output resource integrity: for each \\(i \u2208 {1, \u2026, n}, ce_i = Encrypt(r, pub\\_recv)\\)</li> </ol> <p>Quote</p> <p>Note: encryption can be customized per application. Some applications might encrypt more fields, others - less. The size of the encrypted resource does leak some information.</p> <p>All other constraints enforced by RL circuits are custom.</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#finding-the-owned-resources","title":"Finding the owned resources","text":"<p>A resource logic takes all resources from the current \\(tx\\) as input which requires a mechanism to determine which resource is the resource being currently checked. Currently, to determine that, Taiga passes the resource commitment (for output resources) or the nullifier (for input resources) of the owned resource as a tag. The RL identifies the resource that is being checked by its tag.</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#rl-commitment","title":"RL commitment","text":"<p>In the presence of a RL proof for a certain resource, RL commitment is used to make sure the right RL is checked for the resource. It makes sure that \\(vk_{logic}\\) the resource refers to and \\(vk_{logic}\\) used to validate the RL proof are the same.</p> <p>RL commitment has a nested structure:</p> <ul> <li>\\(cm_{l} = RLCommit(l, rcm_{l})\\)</li> <li>\\(l = VKCommit(vk_{logic})\\)</li> </ul> <p>The check is done in two steps: 1. The Compliance circuit checks that the RL commitment \\(cm_{l}\\) is derived with the \\(l\\) the resource refers to: \\(cm_{l} = RLCommit(l, rcm_{l})\\) 2. The verifier circuit checks that the RL commitment is computed using the \\(vk_{logic}\\) that is used to validate the RL proof: \\(cm_{l} = RLCommit(VKCommit(vk_{logic}), rcm_{l}) (l = VKCommit(vk_{logic}))\\)</p> <p>Quote</p> <p>\\(VKCommit\\) is not implemented yet and currently \\(l = Blake2b(vk_{logic})\\)</p> <p>As the outer commitment \\(RLCommit\\) is verified in both the compliance and verifier circuit which are arithmetized over different fields, the outer commitment instantiation should be efficient over both fields.</p> <p>As the inner commitment \\(VKCommit\\) is only opened in the verifier circuit, it only needs to be efficient over the \\(E_O\\) scalar field.</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#4-circuit-accumulation","title":"4. Circuit Accumulation","text":"<p>TBD: Halo2 accumulation</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#5-delta-balance-commitment-delta-proof","title":"5. Delta (balance commitment) &amp; delta proof","text":"<p>Delta parameter is used to ensure balance across the resources in a transaction. In Taiga, delta is computed directly for compliance pairs and transactions (not for individual resources).</p> <p>For a compliance pair of one input and one output resources, delta is computed as follows:</p> <p>\\(\\Delta_{compl} = DeltaCommit(q^{in}, K^{in}, q^{out}, K^{out}, rcd) = \\lbrack q^{in} \\rbrack K^{in} - \\lbrack q^{out}\\rbrack K^{out} + \\lbrack rcd\\rbrack R\\)</p> Variable Type/size Description \\(q^{in}\\) \\({0..2^{64} - 1}\\) input resource's quantity \\(q^{out}\\) \\({0..2^{64} - 1}\\) output resource's quantity \\(K^{in}\\) \\(E_O\\) point input resource's kind \\(K^{out}\\) \\(E_O\\) point output resource's kind \\(R\\) \\(E_O\\) point randomness base, fixed \\(rcd\\) \\({0..2^{255} - 1}\\) delta randomness \\(\\Delta_{compl}\\) \\(E_O\\) point compliance pair delta <p>For an initial transaction containing \\(n\\) compliance pairs, delta is computed as follows:</p> <p>\\(\\Delta_{tx} =  \\sum{\\Delta_{compl_i}}\\)</p> <p>For a transaction \\(tx\\) composed from transactions \\(tx_1\\) and \\(tx_2\\), \\(\\Delta_{tx} = \\Delta_{tx_1} + \\Delta_{tx_2}\\).</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#51-binding-signature-delta-proof","title":"5.1 Binding signature (delta proof)","text":"<p>Binding signature is used to prove that the transaction is correctly balanced. Delta parameters produced in each transaction used to compose the current transaction being checked are accumulated and checked against the commitment to the expected net value change. Currently, Taiga uses the same binding signature mechanism as Zcash Orchard.</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#taiga-balance-vs-application-balance","title":"Taiga balance vs Application balance","text":"<p>Taiga transaction is balanced if for each resource kind: \\(\\sum_i{v_i^{in}} - \\sum_j{v_j^{out}} = v^{balance}\\), where \\(v^{balance}\\) is the balancing value. Applications have their own definitions of balance that might differ from the Taiga definition. For example, some applications might allow to create more output value from less input value, which makes the total value change \\(v^{balance}\\) non-zero. In case when Taiga's balancing value is assumed to be zero, the application-specific balance is different from the Taiga balance and the application needs to make sure the transaction is balanced in the Taiga sense by adding some non-zero value ephemeral resources to the transaction.</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#6-instantiations","title":"6. Instantiations","text":"Function Instantiation Domain/Range Description \\(PRF^{nf}\\) Poseidon \\(\\mathbb{F_p^4} \\rightarrow \\mathbb F_p\\) \\(PRF^{nf}_{nk}(nonce, \\psi, cm) = Poseidon(nk, nonce, \\psi, cm)\\) \\(PRF^{kind}\\) Poseidon $\\mathbb{F_p^2} \\rightarrow \\mathbb{E_I} $ \\(PRF^{kind} = \\mathtt{hash\\_to\\_curve}(Poseidon(l, label))\\) \\(PRF^{rcm}\\) Poseidon $ \\mathbb{F_p^3} \\rightarrow \\mathbb F_p$ Used to derive resource commitment randomness \\(PRF^{\\psi}\\) Poseidon \\(\\mathbb{F_p^3} \\rightarrow \\mathbb F_p\\) Used to derive \\(\\psi\\) \\(NKCommit\\) Poseidon \\(\\mathbb{F_p^2} \\rightarrow \\mathbb F_p\\) \\(NKCommit(nk, k) = Poseidon(nk,k)\\); used to compute \\(npk\\), user-derived key \\(k\\) is currently not used \\(ResourceCommit\\) Poseidon \\(\\mathbb{F_p^9} \\rightarrow \\mathbb F_p\\) \\(DeltaCommit\\) Pedersen commitment with variable value base \\(\\mathbb{F_q^2} \\times \\mathbb{E_I^2} \\times \\mathbb{F_q} \\rightarrow \\mathbb{E_I}\\) \\(RLCommit\\) Blake2s - Efficient over both \\(\\mathbb F_p\\) and \\(\\mathbb F_q\\) \\(VKCommit\\) - - Efficient over the \\(E_O\\) scalar field; not implemented yet (it is checked in the verifier circuit that is not implemented) \\(Encrypt\\) DH + Poseidon \\(\\mathbb F_p \\rightarrow \\mathbb F_p\\) \\(Encrypt(r, pub_{recv}, priv_{send}) = Poseidon(r, DH(pub_{recv}, priv_{send}))\\) Binding signature RedDSA","boost":2},{"location":"arch/node/ordering/execution/taiga.html#7-transaction","title":"7. Transaction","text":"","boost":2},{"location":"arch/node/ordering/execution/taiga.html#components","title":"Components","text":"<p>Each Taiga \\(tx\\) contains:</p> <ul> <li>\\(n\\) compliance proof records (one compliance proof covers one input and one output resource), each containing:     - \\(\\pi_{compl}\\) - compliance proof     - \\(vk_{compl}\\) - compliance circuit verifying key     - \\((rt, cm, cm^{out}_{l}, nf, cm^{in}_{l}, \\Delta)\\) - compliance proof public input</li> <li>resource logic's proving record for every resource created/consumed in the \\(tx\\):     - \\(\\pi_{l}\\) - resource logic proof     - \\(vk_{logic}\\) - resource logic verifying key     - public inputs, including commitments and encryptions of the created resources and nullifiers of the consumed resources</li> <li>binding signature</li> <li>transaction delta \\(\\Delta_{tx}\\)</li> <li>extra data \\(extra\\)</li> <li>preference function \\(\\Phi\\)</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#validity-of-a-transaction","title":"Validity of a transaction","text":"<p>A transaction is valid if: 1. For each compliance proof:     - if <code>eph = true</code>, <code>rt</code> must be a valid \\(CMtree\\) root.     - \\(Verify(\\pi_{compl}, vk_{compl}, CompliancePublicInput) = True\\) 2. For each resource logic proof:     - \\(Verify(\\pi_{l}, vk_{logic}, LogicPublicInput) = True\\)     - Public input consistency: resource logic public input \\(nf\\) and \\(cm\\) are the same as in the compliance public input 3. Binding signature is valid for \\(\\Delta_{tx}\\)</p> <p>Note</p> <p>Currently, each resource requires a separate RL proof, even if they belong to the same application. Eventually the RL might be called just once per \\(tx\\), meaning that if the \\(tx\\) has 2 or more resources belonging to the same application, the total amount of non-ephemeral proofs is reduced.</p> <p>Note</p> <p>It is possible that a resource logic requires checks of other logics in order to be satisfied. In that case, the total amount of logic proofs verified could be more than \\(2n\\), but we can count such check as a single check.</p>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#taiga-state","title":"Taiga state","text":"<p>Taiga doesn't store a state, but Taiga produces state changes (that will be executed elsewhere), that include:</p> <ul> <li>For each created resource \\(r\\), \\(CMtree.WRITE(r.cm)\\),</li> <li>For each consumed resource \\(r\\), \\(NFset.WRITE(r.nf)\\),</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/taiga.html#8-communication-between-the-shielded-and-transparent-pools","title":"8. Communication between the shielded and transparent pools","text":"<p>State transitions that do not preserve privacy are called transparent. Assuming that the system allows both transparent and shielded state transitions, we say that all of the valid resources created as a result of shielded state transitions form a shielded pool and the valid resources created as a result of transparent state transitions form a transparent pool. The action of moving data from transparent to shielded pool is called shielding, the opposite is called unshielding. Shielding (or unshielding) is done by consuming resources in one pool and creating the corresponding resources in the other. Balancing value \\(v^{balance}\\) indicates the data move between the pools:</p> <ul> <li>\\(v^{balance} = 0\\) if the current transaction doesn't move data between pools</li> <li>\\(v^{balance} &lt; 0\\) refers to the value moved from the transparent to the shielded pool</li> <li>\\(v^{balance} &gt; 0\\) refers to the value moved from the shielded to the transparent pool</li> </ul> <p>Note</p> <p>That the balancing value corresponds to the data flow between pools only for transactions processed in post-ordering execution. Transactions before ordering might not necessarily correctly represent the data flow between the pools.</p>","boost":2},{"location":"arch/node/ordering/execution/executor/index.html","title":"Executor / Executor Process","text":"<p>Conceptually, Executors  run the  executor function in order to  compute transaction outputs, including state updates  (see here for more on the executor function). Executors may be co-located with shards, or with  mempool workers. The Execution Engines might keep a pool of Executors,  or spin a new one up with each TransactionCandidate.</p>","boost":2},{"location":"arch/node/ordering/execution/executor/index.html#executor-incoming-messages","title":"Executor Incoming Messages","text":"<p>To specify the Executor interface, here are all the messages the Executor needs to be able to receive.</p>","boost":2},{"location":"arch/node/ordering/execution/executor/index.html#executetransaction","title":"ExecuteTransaction","text":"<ul> <li>from Mempool</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/executor/index.html#purpose","title":"Purpose","text":"<p>The mempool engines instruct the Executor that a new  TransactionCandidate has been recorded, its locks are being  acquired, and will eventually need to be executed.</p>","boost":2},{"location":"arch/node/ordering/execution/executor/index.html#structure","title":"Structure","text":"Field Type Description <code>executable</code> TransactionExecutable \"code\" to be executed post-ordering <code>label</code> TransactionLabel information about keys that the transaction can rightfully access <code>timestamp</code> TxFingerprint (partial) ordering information (sufficient for V1) <code>curator</code> ExternalIdentity the Worker Engine to be informed when execution completes (e.g. for logs) <code>issuer</code> ExternalIdentity the ID of the sender of the TransactionRequest","boost":2},{"location":"arch/node/ordering/execution/executor/index.html#effects","title":"Effects","text":"<p>This message is sent to an Executor that is already running. Concurrently, when the Worker Engine sends a KVSAcquireLock to  Shards, they can include eager reads, which will result in  KVSReads sent to this Executor.</p>","boost":2},{"location":"arch/node/ordering/execution/executor/index.html#triggers","title":"Triggers","text":"<ul> <li> <p>{KVSReadRequest, KVSWrite}\u2192Shards:   In the course of evaluating the    executor function,    lazy reads are requested, and final writes are output.</p> <ul> <li>KVSReadRequest to Shard</li> <li>KVSWrite to Shard</li> </ul> </li> </ul> <p>Todo</p> <p>make this precise :-/</p>","boost":2},{"location":"arch/node/ordering/execution/executor/index.html#kvsread","title":"KVSRead","text":"<ul> <li>from Shard</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/executor/index.html#purpose_1","title":"Purpose","text":"<p>Executors have to read data from keys to execute  TransactionCandidates. When a Shard has determined what the value read is at the  appropriate timestamp,  it sends a KVSRead to the appropriate Executor.</p>","boost":2},{"location":"arch/node/ordering/execution/executor/index.html#structure_1","title":"Structure","text":"Field Type Description <code>timestamp</code> TxFingerprint the timestamp at which the datum was read <code>key</code> KVSKey the key from which the datum is read <code>data</code> KVSDatum the datum read <p>The timestamp should match the  timestamp of the TransactionCandidate for this  Executor.</p>","boost":2},{"location":"arch/node/ordering/execution/executor/index.html#effects_1","title":"Effects","text":"<p>These read values are input for the TransactionExecutable. Some may be lazy inputs, and some may never be used, but they're all  inputs. If this lets us finish the TransactionExecutable, it may trigger  KVSWrites (outputs of the executable), and shutting down the  Executor entirely.</p>","boost":2},{"location":"arch/node/ordering/execution/executor/index.html#triggers_1","title":"Triggers","text":"<ul> <li>to Shard: KVSWrite <code>for each</code> value the TransactionExecutable outputs to write   send a KVSWrite message to the appropriate Shard</li> <li>to Shard: KVSReadRequest <code>for each</code> lazy read the TransactionExecutable now requires, and    each lazy read the TransactionExecutable hasn't read when it    terminates:   send a KVSReadRequest message to the appropriate Shard</li> <li> <p>to Worker Engine: ExecutorFinished <code>If</code> TransactionExecutable has terminated   <code>then</code> notify the <code>curator</code> specified in ExecuteTransaction </p> <p>that the transaction is done with an ExecutorFinished. - to User,Solver: ExecutionSummary The issuer of the transaction request is always provided with the ExecutionSummary</p> </li> </ul> (Wiki) links on this page<ul><li>Shard</li><li>Worker Engine</li><li>TransactionCandidate</li><li>ExecuteTransaction</li><li>Executor</li><li>TransactionCandidate</li><li>TransactionExecutable</li><li>TransactionLabel</li><li>TxFingerprint</li><li>Worker Engine</li><li>TransactionRequest</li><li>Executor</li><li>Worker Engine</li><li>KVSAcquireLock</li><li>Shard</li><li>KVSRead</li><li>Executor</li><li>KVSReadRequest</li><li>KVSWrite</li><li>Shard</li><li>KVSReadRequest</li><li>Shard</li><li>KVSWrite</li><li>Shard</li><li>KVSRead</li><li>Shard</li><li>Executor</li><li>TransactionCandidate</li><li>Shard</li><li>TxFingerprint</li><li>KVSRead</li><li>Executor</li><li>TxFingerprint</li><li>KVSKey</li><li>KVSDatum</li><li>TxFingerprint</li><li>TxFingerprint</li><li>TransactionCandidate</li><li>Executor</li><li>TransactionExecutable</li><li>TransactionExecutable</li><li>KVSWrite</li><li>Executor</li><li>Shard</li><li>KVSWrite</li><li>TransactionExecutable</li><li>KVSWrite</li><li>Shard</li><li>Shard</li><li>KVSReadRequest</li><li>TransactionExecutable</li><li>TransactionExecutable</li><li>KVSReadRequest</li><li>Shard</li><li>Worker Engine</li><li>ExecutorFinished</li><li>TransactionExecutable</li><li>ExecuteTransaction</li><li>ExecutorFinished</li><li>ExecutionSummary</li><li>TransactionRequest</li><li>ExecutionSummary</li></ul>","boost":2},{"location":"arch/node/ordering/execution/executor/execute_read_transaction.html","title":"Execute read transaction","text":"","boost":2},{"location":"arch/node/ordering/execution/executor/execute_read_transaction.html#executereadtransaction","title":"ExecuteReadTransaction","text":"<ul> <li>from ReadBackend</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/executor/execute_read_transaction.html#purpose","title":"Purpose","text":"<p>Much like the mempool can start executor threads, so can the Read Backend. It's just that the read backend can only specify read-only transactions.</p>","boost":2},{"location":"arch/node/ordering/execution/executor/execute_read_transaction.html#structure","title":"Structure","text":"Field Type Description <code>executable</code> <code>TransactionExecutable</code> everything this transaction needs to do post-ordering, including any interesting calculations, or proof checks <code>label</code> <code>ReadLabel</code> but used to specify which parts of the KVS this transaction IS ALLOWED to read <code>timestamp</code> <code>Timestamp</code> represents the transaction's position in the Mempool DAG. As the execution engine gets more information (see <code>TimestampOrderingInformation</code>, this lets us order transactions. <code>initiator</code> <code>Identity</code> who should be informed once all the shards and whatnot have acquired all the locks and such? Usually this is any ReadBackend worker or suchlike involved","boost":2},{"location":"arch/node/ordering/execution/executor/execute_read_transaction.html#effects","title":"Effects","text":"<p>This actually creates a new Taiga executor thread (or assigns one from some kind of thread pool) which will have its own Identity, which we will then send to the relevant shards. Relevancy is determined using the label.</p> <p>Note that figuring out how to receive these is hard: we don't want a bottleneck thread that has to receive and process all of these. Instead, they should efficiently spin up and/or assign new Executor threads in parallel.</p>","boost":2},{"location":"arch/node/ordering/execution/executor/execute_read_transaction.html#triggers","title":"Triggers","text":"<ul> <li>to Execution shards: KVSAcquireLock <code>for each</code> key mentioned in this transaction <code>label</code>:    send a KVSAcquireLock to the appropriate shard.</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/executor/execute_transaction.html","title":"ExecuteTransaction","text":"<ul> <li>from Mempool</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/executor/execute_transaction.html#purpose","title":"Purpose","text":"<p>The mempool engines instruct the Executor that a new  TransactionCandidate has been recorded, its locks are being  acquired, and will eventually need to be executed.</p>","boost":2},{"location":"arch/node/ordering/execution/executor/execute_transaction.html#structure","title":"Structure","text":"Field Type Description <code>executable</code> TransactionExecutable \"code\" to be executed post-ordering <code>label</code> TransactionLabel information about keys that the transaction can rightfully access <code>timestamp</code> TxFingerprint (partial) ordering information (sufficient for V1) <code>curator</code> ExternalIdentity the Worker Engine to be informed when execution completes (e.g. for logs) <code>issuer</code> ExternalIdentity the ID of the sender of the TransactionRequest","boost":2},{"location":"arch/node/ordering/execution/executor/execute_transaction.html#effects","title":"Effects","text":"<p>This message is sent to an Executor that is already running. Concurrently, when the Worker Engine sends a KVSAcquireLock to  Shards, they can include eager reads, which will result in  KVSReads sent to this Executor.</p>","boost":2},{"location":"arch/node/ordering/execution/executor/execute_transaction.html#triggers","title":"Triggers","text":"<ul> <li> <p>{KVSReadRequest, KVSWrite}\u2192Shards:   In the course of evaluating the    executor function,    lazy reads are requested, and final writes are output.</p> <ul> <li>KVSReadRequest to Shard</li> <li>KVSWrite to Shard</li> </ul> </li> </ul> <p>Todo</p> <p>make this precise :-/</p>","boost":2},{"location":"arch/node/ordering/execution/executor/execute_transaction.html#notes","title":"Notes","text":"<ul> <li>Getting served read requests amounts to locks being granted by the shards.</li> </ul> <p>Todo</p> <p>contention footprint description</p> (Wiki) links on this page<ul><li>Executor</li><li>TransactionCandidate</li><li>TransactionExecutable</li><li>TransactionLabel</li><li>TxFingerprint</li><li>Worker Engine</li><li>TransactionRequest</li><li>Executor</li><li>Worker Engine</li><li>KVSAcquireLock</li><li>Shard</li><li>KVSRead</li><li>Executor</li><li>KVSReadRequest</li><li>KVSWrite</li><li>Shard</li><li>KVSReadRequest</li><li>Shard</li><li>KVSWrite</li><li>Shard</li></ul>","boost":2},{"location":"arch/node/ordering/execution/executor/kvs_read.html","title":"KVSRead","text":"<ul> <li>from Shard</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/executor/kvs_read.html#purpose","title":"Purpose","text":"<p>Executors have to read data from keys to execute  TransactionCandidates. When a Shard has determined what the value read is at the  appropriate timestamp,  it sends a KVSRead to the appropriate Executor.</p>","boost":2},{"location":"arch/node/ordering/execution/executor/kvs_read.html#structure","title":"Structure","text":"Field Type Description <code>timestamp</code> TxFingerprint the timestamp at which the datum was read <code>key</code> KVSKey the key from which the datum is read <code>data</code> KVSDatum the datum read <p>The timestamp should match the  timestamp of the TransactionCandidate for this  Executor.</p>","boost":2},{"location":"arch/node/ordering/execution/executor/kvs_read.html#effects","title":"Effects","text":"<p>These read values are input for the TransactionExecutable. Some may be lazy inputs, and some may never be used, but they're all  inputs. If this lets us finish the TransactionExecutable, it may trigger  KVSWrites (outputs of the executable), and shutting down the  Executor entirely.</p>","boost":2},{"location":"arch/node/ordering/execution/executor/kvs_read.html#triggers","title":"Triggers","text":"<ul> <li>to Shard: KVSWrite <code>for each</code> value the TransactionExecutable outputs to write   send a KVSWrite message to the appropriate Shard</li> <li>to Shard: KVSReadRequest <code>for each</code> lazy read the TransactionExecutable now requires, and    each lazy read the TransactionExecutable hasn't read when it    terminates:   send a KVSReadRequest message to the appropriate Shard</li> <li> <p>to Worker Engine: ExecutorFinished <code>If</code> TransactionExecutable has terminated   <code>then</code> notify the <code>curator</code> specified in ExecuteTransaction </p> <p>that the transaction is done with an ExecutorFinished. - to User,Solver: ExecutionSummary The issuer of the transaction request is always provided with the ExecutionSummary</p> </li> </ul> (Wiki) links on this page<ul><li>Shard</li><li>Executor</li><li>TransactionCandidate</li><li>Shard</li><li>TxFingerprint</li><li>KVSRead</li><li>Executor</li><li>TxFingerprint</li><li>KVSKey</li><li>KVSDatum</li><li>TxFingerprint</li><li>TxFingerprint</li><li>TransactionCandidate</li><li>Executor</li><li>TransactionExecutable</li><li>TransactionExecutable</li><li>KVSWrite</li><li>Executor</li><li>Shard</li><li>KVSWrite</li><li>TransactionExecutable</li><li>KVSWrite</li><li>Shard</li><li>Shard</li><li>KVSReadRequest</li><li>TransactionExecutable</li><li>TransactionExecutable</li><li>KVSReadRequest</li><li>Shard</li><li>Worker Engine</li><li>ExecutorFinished</li><li>TransactionExecutable</li><li>ExecuteTransaction</li><li>ExecutorFinished</li><li>ExecutionSummary</li><li>TransactionRequest</li><li>ExecutionSummary</li></ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html","title":"Shard","text":"<p>The Shards together store and update the  state of the replicated state machine and   together are a component of the Execution Engines. They provide Executors with input data and update the state  according to the results of Executors' computations.</p> <p>Different shards may be on different physical machines.   </p> <p>Each shard is responsible for a set of KVSKeys and these sets are disjoint for different shards. For each of the keys that a shard is responsible for, the shard maintains a  (partially-ordered) timeline of Timestamps of  transaction candidates that may read or write to keys. Shards also keep a history of data written by each  TransactionCandidate to each key. This is multi-version concurrent storage.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#state-of-the-shard","title":"State (of the shard)","text":"<p>For each Worker Engine, the Shard maintains:</p> <ul> <li>A Timestamp, such that all    write lock requests<sup>1</sup> for    transaction candidates with earlier timestamps that this worker curates    have already been received.   Together, these timestamps represent <code>heardAllWrites</code>.</li> <li>Another Timestamp, before which    the Shard will receive no further read requests from this    Worker Engine.   For WorkerEngine, this cannot be after the corresponding    write Timestamps.   We will also maintain these from each Read Backend worker.   Together, these represent <code>heardAllReads</code>.</li> </ul> <p>For each key (assigned to this Shard):</p> <ul> <li>A set of time\u200dstamps of known    transaction candidates that read and/or write that key, and for    each, some subset of:<ul> <li>A value written to that key at that time\u200dstamps    by that TransactionCandidate using a KVSWrite message</li> <li>A marker indicating that this TransactionCandidate may    (or will) write to this key, but this Shard has not yet received    a corresponding KVSWrite message.</li> <li>A marker indicating that this TransactionCandidate will read    this value, and an ExternalIdentity corresponding to the    relevant Executor.   This marker is only stored so long as the Shard doesn't know the    value.   When this value is determined, this Shard must remove this marker    and send a KVSRead message to the Executor.</li> <li>A marker indicating that this TransactionCandidate may read    this value, and an ExternalIdentity corresponding to the    relevant Executor.   If the Executor sends a KVSReadRequest for this key, the    Shard updates this marker to a \"will read\" marker.</li> </ul> </li> <li>If a Timestamp has no corresponding markers or    values written, we don't have to store it.</li> <li>If a value written is before <code>heardAllReads</code>, and there are no pending    reads or writes before it, then we can remove all earlier values    written.</li> </ul> <p>Additionally, the Shard maintains:</p> <ul> <li>A complete copy of the DAG structure produced by the    Mempool Engines.   This includes a set of all NarwhalBlockHeaders.   For Timestamps before <code>SeenAllRead</code>, if there are    no keys with a pending read or write before that    Timestamp, we can delete old DAG structure.</li> <li>A complete copy of the sequence of Anchors chosen    by Consensus Engine.   This is a sequence of consensus decisions.   For Timestamps before <code>heardAllReads</code>, if there are    no keys with a pending read or write before that    Timestamp, we can delete old anchors.</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#shard-optimizations","title":"Shard Optimizations","text":"<p>We want to execute each TransactionCandidate (evaluate the executor function in order to compute the data written) using the idea of serializability: each TransactionCandidate's reads and writes should be as if they were executed in the total order determined by the mempool (and [[Consensus</p> <p>However, we want to compute concurrently as possible, for minimum latency. We do this using a set of optimizations.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#optimization-per-key-ordering","title":"Optimization: Per-Key Ordering","text":"<p>Mempool  and  consensus provides ordering  information for  the time\u200dstamps. Thus, relative to each key, transaction candidates can be totally ordered by the  Happens Before  relationship. With a total ordering of transaction candidates, Shards can send  read information (KVSReads) to Executors as soon as the  previous TransactionCandidate is complete. However, transaction candidates that access on disjoint sets of  keys can be run in parallel. In the diagram above, for example, transaction candidates <code>c</code> and  <code>d</code> can run concurrently, as can transaction candidates <code>e</code> and  <code>f</code>, and transaction candidates <code>h</code> and <code>j</code>.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#optimization-order-with-respect-to-writes","title":"Optimization: Order With Respect To Writes","text":"<p>In fact, Shards can send read information to an Executor as soon  as the previous write's TransactionCandidate has completed  (sent a KVSWrite). All Shards really need to keep track of is a total order of writes,  and how each read is ordered with respect to writes (which write it  precedes and which write preceded it). As soon as the preceding write is complete (the Shard has received a  KVSWrite), the reads that depend on it can run concurrently. There are no \"read/read\" conflicts. In the diagram above, for example, transaction candidates <code>a</code> and <code>b</code> can run  concurrently.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#optimization-only-wait-to-read","title":"Optimization: Only Wait to Read","text":"<p>Because we store each version written  (multi-version concurrent storage),  we do not have to execute writes in order. A Shard does not have to wait to write a later data version to a key  just because previous reads have not finished executing yet. In the diagram above, for example, only green happens-before arrows  require waiting. transaction candidates <code>a</code>, <code>b</code>, <code>c</code>, and <code>j</code> can all be executed  concurrently, as can transaction candidates <code>d</code>, <code>e</code>, and <code>i</code>.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#optimization-execute-with-partial-order","title":"Optimization: Execute With Partial Order","text":"<p>Some mempools, including Narwhal, can provide partial order information on transactions even before consensus has determined a total order. This allows the Ordering Machine to execute some transactions before a total ordering is known. In general, for a given key, a shard can send read information to an executor when it knows precisely which write happens most recently before the read, and that write has executed.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#heardallwrites","title":"heardAllWrites","text":"<p>In order to know which write happens most recently before a given  read, the Shard must know that no further writes will be added to  the timeline before the read. Mempool and consensus should  communicate a lower bound on timestamps to the Shards, called  <code>heardAllWrites</code>. The Shard is guaranteed to never receive another KVSAcquireLock  with a write operation and   Timestamp before  <code>heardAllWrites</code>. In general, a Shard cannot send a KVSRead for  a Timestamp unless   the Timestamp is before <code>heardAllWrites</code>. <code>heardAllWrites</code> consists of a TxFingerprint from each  worker engine such that the worker engine is certain  (based on KVSLockAcquireds) that the Shard has already seen all  the KVSAcquireLocks it will ever send at or before that  TxFingerprint.</p> <p>This can be on a per-key basis or simply a global lower bound. Occasionally, <code>heardAllWrites</code> should be updated with later timestamps. Each round of consensus should produce a lower bound for <code>heardAllWrites</code>, but the mempool may already have sent better bounds. Each Shard must keep track of <code>heardAllWrites</code> on each key's multi-version timeline.</p> <p>Transactions (like transaction <code>j</code> in the diagram below) containing only write operations can execute with a timestamp after <code>heardAllWrites</code>, but this simply means calculating the data they will write. Since that does not depend on state, this can of course be done at any time.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#heardallreads","title":"heardAllReads","text":"<p>We want to allow Typhon to eventually garbage-collect old state. mempool and consensus should communicate a lower bound timestamp to the execution engine, called <code>heardAllReads</code>, before which there will be no more read transactions send to the execution engine. Occasionally, <code>heardAllReads</code> should be updated with later timestamps. Each Shard must keep track of <code>heardAllReads</code> on each key's multi-version timeline, so it can garbage-collect old values.</p> <p></p> <p>In the example above, our happens-before arrows have been replaced with may-happen-before arrows, representing partial ordering information from the mempool. Note that not all transactions can be executed with this partial order information.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#conflicts","title":"Conflicts","text":"<p>There are three types of conflicts that can prevent a transaction from being executable without more ordering information.</p> <ul> <li>Write/Write Conflicts   occur when a shard cannot identify the most recent write before a given read.   In the diagram above,   transaction <code>e</code> cannot execute because it is not clear whether   transaction <code>b</code> or transaction <code>c</code> wrote most recently to the yellow key.</li> </ul> <ul> <li>Read/Write Conflicts   occur when shard cannot identify whether a read operation occurs before or   after a write,   so it is not clear if it should read the value from that write or   from a previous write.   In the diagram above,   transaction <code>g</code> cannot execute because it is not clear whether   it would read the data written to the blue key by transaction <code>d</code> or   transaction <code>i</code>.</li> </ul> <ul> <li>Transitive Conflicts   occur when a shard cannot get the data for a read because   the relevant write is conflicted.   In the diagram above,   transaction <code>h</code> cannot execute because   it cannot read the data written to the yellow key by transaction <code>g</code>, since   transaction <code>g</code> is conflicted.</li> </ul> <p>As the mempool and consensus provide the execution engine with more and more ordering information, and the partial order of timestamps is refined, all conflicts eventually resolve. In the diagram above, suppose consensus orders transaction <code>g</code> before transaction <code>i</code>. The Read/Write conflict is resolved: transaction <code>g</code> reads the data transaction <code>d</code> writes to the blue key. Then the transitive conflict is also resolved: transaction <code>h</code> will be able to execute. --&gt;</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#optimization-client-reads-as-read-only-transactions","title":"Optimization: Client Reads as Read-Only Transactions","text":"<p>With the above optimizations, transactions containing only read operations do not affect other transactions (or scheduling) at all. Therefore, they can bypass mempool and consensus altogether. Clients can simply send read-only transactions directly to the execution engine (with a label and a timestamp), and if the timestamp is after <code>heardAllReads</code>, the execution engine can simply place the transaction in the timeline of the relevant shards and execute it when possible. In the diagram above, transaction <code>f</code> is read-only.</p> <p>If client reads produce signed responses, then signed responses from a weak quorum of validators would form a light client proof.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#shard-incoming-messages","title":"Shard Incoming Messages","text":"<p>Shards receive and react to the following messages:</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#kvsacquirelock","title":"KVSAcquireLock","text":"<ul> <li>from Mempool Worker </li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#purpose","title":"Purpose","text":"<p>Inform the shard about keys that a transaction may/will read and/or  write, at a transaction fingerprint.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#structure","title":"Structure","text":"Field Type Description <code>lazy_read_keys</code> KVSKey set Keys this transaction may read (only send values read in response to KVSReadRequests) <code>eager_read_keys</code> KVSKey set Keys this transaction will read (send values read as soon as possible) <code>will_write_keys</code> KVSKey set Keys this transaction will write. Future reads are dependent only on the KVSWrite for this TxFingerprint. <code>may_write_keys</code> KVSKey set Keys this transaction may write. Future reads are dependent on the KVSWrite for this TxFingerprint, or, if that has a <code>None</code>, the previous value. <code>curator</code> ExternalIdentity the Worker Engine in charge of the corresponding transactions <code>executor</code> ExternalIdentity the Executor for this TransactionCandidate <code>timestamp</code> TxFingerprint specifies the transaction affiliated with these locks. <p>The <code>lazy_read_keys</code> and <code>eager_read_keys</code> may not overlap. In the same way,  <code>will_write_keys</code> and <code>may_write_keys</code> must be  disjoint. There must be one <code>KVSAcquireLock</code> per Shard  per TxFingerprint: for a given Shard and TxFingerprint,  all information is to be provided in totality or not at all.<sup>1</sup></p> <p>Note that future versions may use some kind of structured <code>Key</code>s to  encode \"Sets\" containing infinitely many <code>Key</code>s. For V1, however, simple HashSets or similar are fine.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#effects","title":"Effects","text":"<ul> <li>The Shard stores the respective \"locks\" for all keys in its timeline.<ul> <li>these are the \"markers\" described in Shard State.</li> </ul> </li> <li>The <code>eager_read_keys</code> will be served as soon as possible   (by sending <code>KVSRead</code>-messages to the executor).</li> <li>The Shard immediately informs the curator that    the locks are acquired, using a KVSLockAcquired message, so the    curator can prepare UpdateSeenAll messages.</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#triggers","title":"Triggers","text":"<ul> <li>to Worker Engine: KVSLockAcquired   send a KVSLockAcquired message to the curator,       signaling that the locks of this message will be accounted for.</li> <li>to executor:  KVSRead <code>for each</code> recorded <code>eager_read_key</code> in this shard's timeline   for which the most recent written value is established:   send a KVSRead message to the Executor.</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#kvsreadrequest","title":"KVSReadRequest","text":"<ul> <li>from Executor</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#purpose_1","title":"Purpose","text":"<p>Informs the Shard about a new read request, which happens in either of the following cases:</p> <ul> <li>An Executor has determined that it actually needs    the value at some key for which it has a lazy read    (a may_read in the TransactionLabel of the    TransactionCandidate).   Now the executor is requesting that value from the Shard that stores    it.</li> <li>A Executor has finished and does not need   the value for some key   for which it has a lazy read (a may_read in the    TransactionLabel).</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#structure_1","title":"Structure","text":"Field Type Description <code>timestamp</code> TxFingerprint we need the value at this logical timestamp <code>key</code> KVSKey the value corresponds to this key <code>actual</code> <code>bool</code> <code>true</code> iff we actually want a response <p>If <code>actual</code> is <code>false</code>, this just means that there is no dependency on  this key in the current execution.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#effects_1","title":"Effects","text":"<p>A Shard should delay processing a KVSReadRequest until it has  completed processing KVSAcquireLock for the  same timestamp.</p> <p>Then, if <code>actual</code> is false, the Shard is done reading the value, and  can remove the may read marker from state.</p> <p>If <code>actual</code> is true, the Shard replaces the may read marker with a  will read marker. If the Shard knows the unique previous value written before  this timestamp, it sends that value in a KVSRead to  the Executor and removes the will read marker from state. Otherwise, future KVSWrites and/or UpdateSeenAlls will  identify this unique previous value written, and trigger the  KVSRead.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#triggers_1","title":"Triggers","text":"<ul> <li>to Executor: KVSRead <code>if</code> the Shard has determined the unique value written prior to this \"lock\"   <code>then</code> send a KVSRead-message to the relevant Executor   to inform them of the value</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#kvswrite","title":"KVSWrite","text":"<ul> <li>from Executor</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#purpose_2","title":"Purpose","text":"<p>Informs the Shard about a new write request, which happens in either of the following two cases:</p> <ul> <li>A TransactionExecutable has determined that it actually will    write the value at some key for which it has a write    (in its TransactionLabel).   Now the Executor is requesting that value from the Shard    that stores it.</li> <li>A TransactionExecutable has finished, and does not actually need    to write a value for some key for which it has a lazy write    (a may_write in the TransactionLabel).</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#structure_2","title":"Structure","text":"Field Type Description <code>timestamp</code> TxFingerprint the logical time at which we are writing this data. <code>key</code> KVSKey the key used. With fancy hierarchical keys or suchlike, we could even specify a range of keys <code>datum</code> KVSDatum option the new data to be associated with the key. No datum should only be used in a \"may_write,\" and means don't change this value","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#effects_2","title":"Effects","text":"<p>A Shard should delay processing a KVSWrite until it has  completed processing KVSAcquireLock for the  same timestamp.</p> <p>If the <code>datum</code> is <code>None</code>, then remove the may write marker from  this timestamp in state. Any reads waiting to read what is written here must instead read from  the previous write. - One way to accomplish this is to copy the previous write as a     \"value written\" at this timestamp in state.</p> <p>If <code>datum</code> is occupied, then remove the may write or will write  marker from  this timestamp in state, and record the  value written at this timestamp in state.</p> <p>This may trigger a KVSRead if there are any will read markers  for which  this timestamp is the unique previous  write.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#triggers_2","title":"Triggers","text":"<ul> <li>to Executor: KVSRead <code>for each</code> will read lock dependent on this write:     send a KVSRead to the  relevant Executor with the value written.</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#updateseenall","title":"UpdateSeenAll","text":"<ul> <li>from Mempool Engines</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#purpose_3","title":"Purpose","text":"<p>In order to actually serve read requests, the Shard needs to know that it will not receive more write requests before a  certain timestamp. These are in general broadcast to all Shards.</p> <p>It is important that  the Worker Engine has received KVSLockAcquired-messages for all KVSAcquireLocks it has sent (or will ever send) at or before the timestamp. In other words, shards know about all possible read and write requests of TransactionCandidates for which the worker is curator and may come earlier.</p> <p>Todo</p> <p>rephrase the above paragraph</p> <p>Each worker engine only needs to send the Shard Engine UpdateSeenAll messages concerning worker-specific ordering (batch number and sequence number within the batch). This means that each Shard Engine needs to hear from  every Worker Engine periodically to be sure it is not waiting for any transactions. From there, the Shard uses TimestampOrderingInformation about the Narwhal DAG and Consensus to fill in a total order.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#structure_3","title":"Structure","text":"Field Type Description <code>timestamp</code> TxFingerprint represents a the position in the total order (in V1) <code>write</code> <code>bool</code> seen all read and seen all write can (and should) be separate. <p>For V1, we only care about <code>write = true</code> because we don't garbage collect and assume multi-version storage. From V2 onward, the Shard is keeping additional ordering information and we do have garbage collection protocols.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#effects_3","title":"Effects","text":"<p>Shards can now identify the unique previous write prior to each read at or before this timestamp.</p> <p>If that unique previous write has a value written, and the read is marked will read, they can send a KVSRead with that value to the relevant Executor.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#triggers_3","title":"Triggers","text":"<ul> <li>to Executor: KVSRead <code>for each</code> will read for which we have established a unique previous write value   send a <code>KVSRead</code> message to the relevant Executor</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#timestamporderinginformation","title":"TimestampOrderingInformation","text":"<ul> <li>from Mempool</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#purpose_4","title":"Purpose","text":"<p>While each transaction comes with a <code>Timestamp</code>, the shards do not actually know the order of those timestamps until the DAG is built, and consensus decisions are made. This message represents the mempool communicating (partial) timestamp ordering. These are broadcast to all shards.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#structure_4","title":"Structure","text":"<p>Todo</p> <p>One way to convey this is to include the entire DAG structure (albeit without the transaction contents of each worker batch). For now, I do not know what the internal structure of this message looks like.</p> <p>Todo</p> <p>check whether, \u2460 worker-timestamp (= tx fingerprint), \u2461 primary-timestamp (= pure DAG structure based on blocks/headers), \u2462 consensus-timestamp (= total order) are sufficiently many cases or we need yet another intermediate gradual step of ordering. E.g., does is make sense to also take into account local headers that (without integrity votes).</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#effects_4","title":"Effects","text":"<p>As shards learn more ordering information, they can finally complete reads (since they learn which writes most recently occurred).</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#triggers_4","title":"Triggers","text":"<ul> <li>to Executor: <code>KVSRead</code> <code>for each</code> locked key for which we have established a unique write value,   send a <code>KVSRead</code> message to the appropriate Executor</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#anchorchosen","title":"AnchorChosen","text":"<ul> <li>from Consensus</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#purpose_5","title":"Purpose","text":"<p>Inform shards about the most recently decided value by the consensus.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#structure_5","title":"Structure","text":"Field Type Description <code>chain_id</code> <code>ChainId</code> the chain Id <code>learner</code> <code>Learner</code> learner (in V2 this is always \\(\\red\\alpha\\)) <code>height</code> <code>Height</code> height of the block <code>anchor</code> <code>NarwhalBlock</code> the value that consensus decided upon","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#effects_5","title":"Effects","text":"<p>The shard learns more ordering information. In particular, with this and enough <code>TimestampOrderingInformation</code> messages, it should be able to order all transactions before the new <code>anchor</code>.</p> <p>Once we have enough ordering information to establish the unique write preceding a key on which there is a read lock, and we have a value for that write, we can send that value to the relevant Executor.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/index.html#triggers_5","title":"Triggers","text":"<ul> <li>to Executor: <code>KVSRead</code> <code>for each</code> locked key for which we have established a unique write value,   send a <code>KVSRead</code> message to the appropriate Executor.</li> </ul> (Wiki) links on this page<ul><li>Executor</li><li>Executor</li><li>KVSKey</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>Worker Engine</li><li>KVSAcquireLock</li><li>Worker Engine</li><li>TxFingerprint</li><li>TransactionCandidate</li><li>TxFingerprint</li><li>TransactionCandidate</li><li>KVSWrite</li><li>TransactionCandidate</li><li>KVSWrite</li><li>TransactionCandidate</li><li>Executor</li><li>KVSRead</li><li>Executor</li><li>TransactionCandidate</li><li>Executor</li><li>Executor</li><li>KVSReadRequest</li><li>Consensus Engine</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>Consensus Engine</li><li>TxFingerprint</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>KVSRead</li><li>Executor</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>Executor</li><li>TransactionCandidate</li><li>KVSWrite</li><li>KVSWrite</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>Consensus Engine</li><li>KVSAcquireLock</li><li>KVSRead</li><li>TxFingerprint</li><li>Worker Engine</li><li>Worker Engine</li><li>KVSLockAcquired</li><li>KVSAcquireLock</li><li>TxFingerprint</li><li>Consensus Engine</li><li>Consensus Engine</li><li>Consensus Engine</li><li>Worker Engine</li><li>Executor</li><li>KVSKey</li><li>KVSReadRequest</li><li>KVSKey</li><li>KVSKey</li><li>KVSWrite</li><li>TxFingerprint</li><li>KVSKey</li><li>KVSWrite</li><li>TxFingerprint</li><li>Worker Engine</li><li>Executor</li><li>TransactionCandidate</li><li>TxFingerprint</li><li>Shard</li><li>TxFingerprint</li><li>Shard</li><li>TxFingerprint</li><li>Shard</li><li>Shard</li><li>Executor</li><li>Shard</li><li>Worker Engine</li><li>KVSLockAcquired</li><li>Worker Engine</li><li>UpdateSeenAll</li><li>Worker Engine</li><li>KVSLockAcquired</li><li>KVSLockAcquired</li><li>Worker Engine</li><li>Executor</li><li>KVSRead</li><li>KVSRead</li><li>Executor</li><li>Executor</li><li>Executor</li><li>TransactionLabel</li><li>TransactionCandidate</li><li>Executor</li><li>TransactionLabel</li><li>TxFingerprint</li><li>KVSKey</li><li>Shard</li><li>KVSReadRequest</li><li>KVSAcquireLock</li><li>TxFingerprint</li><li>TxFingerprint</li><li>KVSRead</li><li>Executor</li><li>KVSWrite</li><li>UpdateSeenAll</li><li>KVSRead</li><li>Executor</li><li>KVSRead</li><li>KVSRead</li><li>Executor</li><li>Executor</li><li>TransactionExecutable</li><li>KVSKey</li><li>TransactionLabel</li><li>Executor</li><li>Shard</li><li>TransactionExecutable</li><li>KVSKey</li><li>TransactionLabel</li><li>TxFingerprint</li><li>KVSKey</li><li>KVSDatum</li><li>Shard</li><li>KVSWrite</li><li>KVSAcquireLock</li><li>TxFingerprint</li><li>TxFingerprint</li><li>TxFingerprint</li><li>TxFingerprint</li><li>TxFingerprint</li><li>KVSRead</li><li>TxFingerprint</li><li>Executor</li><li>KVSRead</li><li>KVSRead</li><li>Executor</li><li>TxFingerprint</li><li>Shard</li><li>Worker Engine</li><li>KVSLockAcquired</li><li>KVSAcquireLock</li><li>TxFingerprint</li><li>TransactionCandidate</li><li>Worker Engine</li><li>UpdateSeenAll</li><li>Worker Engine</li><li>TxFingerprint</li><li>TxFingerprint</li><li>KVSRead</li><li>Executor</li><li>Executor</li><li>KVSRead</li><li>Executor</li><li>KVSAcquireLock</li><li>KVSWrite</li></ul> <ol> <li> <p>For the purpose of this discussion, we call a write lock request a KVSAcquireLock message for a key for which a write request will or may be issued.\u00a0\u21a9\u21a9</p> </li> </ol>","boost":2},{"location":"arch/node/ordering/execution/shard/anchor_chosen.html","title":"Anchor chosen","text":"","boost":2},{"location":"arch/node/ordering/execution/shard/anchor_chosen.html#anchorchosen","title":"AnchorChosen","text":"<ul> <li>from Consensus</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/anchor_chosen.html#purpose","title":"Purpose","text":"<p>Inform shards about the most recently decided value by the consensus.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/anchor_chosen.html#structure","title":"Structure","text":"Field Type Description <code>chain_id</code> <code>ChainId</code> the chain Id <code>learner</code> <code>Learner</code> learner (in V2 this is always \\(\\red\\alpha\\)) <code>height</code> <code>Height</code> height of the block <code>anchor</code> <code>NarwhalBlock</code> the value that consensus decided upon","boost":2},{"location":"arch/node/ordering/execution/shard/anchor_chosen.html#effects","title":"Effects","text":"<p>The shard learns more ordering information. In particular, with this and enough <code>TimestampOrderingInformation</code> messages, it should be able to order all transactions before the new <code>anchor</code>.</p> <p>Once we have enough ordering information to establish the unique write preceding a key on which there is a read lock, and we have a value for that write, we can send that value to the relevant Executor.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/anchor_chosen.html#triggers","title":"Triggers","text":"<ul> <li>to Executor: <code>KVSRead</code> <code>for each</code> locked key for which we have established a unique write value,   send a <code>KVSRead</code> message to the appropriate Executor.</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_acquire_lock.html","title":"KVSAcquireLock","text":"","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_acquire_lock.html#kvsacquirelock","title":"KVSAcquireLock","text":"<ul> <li>from Mempool Worker </li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_acquire_lock.html#purpose","title":"Purpose","text":"<p>Inform the shard about keys that a transaction may/will read and/or  write, at a transaction fingerprint.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_acquire_lock.html#structure","title":"Structure","text":"Field Type Description <code>lazy_read_keys</code> KVSKey set Keys this transaction may read (only send values read in response to KVSReadRequests) <code>eager_read_keys</code> KVSKey set Keys this transaction will read (send values read as soon as possible) <code>will_write_keys</code> KVSKey set Keys this transaction will write. Future reads are dependent only on the KVSWrite for this TxFingerprint. <code>may_write_keys</code> KVSKey set Keys this transaction may write. Future reads are dependent on the KVSWrite for this TxFingerprint, or, if that has a <code>None</code>, the previous value. <code>curator</code> ExternalIdentity the Worker Engine in charge of the corresponding transactions <code>executor</code> ExternalIdentity the Executor for this TransactionCandidate <code>timestamp</code> TxFingerprint specifies the transaction affiliated with these locks. <p>The <code>lazy_read_keys</code> and <code>eager_read_keys</code> may not overlap. In the same way,  <code>will_write_keys</code> and <code>may_write_keys</code> must be  disjoint. There must be one <code>KVSAcquireLock</code> per Shard  per TxFingerprint: for a given Shard and TxFingerprint,  all information is to be provided in totality or not at all.<sup>1</sup></p> <p>Note that future versions may use some kind of structured <code>Key</code>s to  encode \"Sets\" containing infinitely many <code>Key</code>s. For V1, however, simple HashSets or similar are fine.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_acquire_lock.html#effects","title":"Effects","text":"<ul> <li>The Shard stores the respective \"locks\" for all keys in its timeline.<ul> <li>these are the \"markers\" described in Shard State.</li> </ul> </li> <li>The <code>eager_read_keys</code> will be served as soon as possible   (by sending <code>KVSRead</code>-messages to the executor).</li> <li>The Shard immediately informs the curator that    the locks are acquired, using a KVSLockAcquired message, so the    curator can prepare UpdateSeenAll messages.</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_acquire_lock.html#triggers","title":"Triggers","text":"<ul> <li>to Worker Engine: KVSLockAcquired   send a KVSLockAcquired message to the curator,       signaling that the locks of this message will be accounted for.</li> <li>to executor:  KVSRead <code>for each</code> recorded <code>eager_read_key</code> in this shard's timeline   for which the most recent written value is established:   send a KVSRead message to the Executor.</li> </ul> (Wiki) links on this page<ul><li>Worker Engine</li><li>Executor</li><li>KVSKey</li><li>KVSReadRequest</li><li>KVSKey</li><li>KVSKey</li><li>KVSWrite</li><li>TxFingerprint</li><li>KVSKey</li><li>KVSWrite</li><li>TxFingerprint</li><li>Worker Engine</li><li>Executor</li><li>TransactionCandidate</li><li>TxFingerprint</li><li>Shard</li><li>TxFingerprint</li><li>Shard</li><li>TxFingerprint</li><li>Shard</li><li>Shard</li><li>Executor</li><li>Shard</li><li>Worker Engine</li><li>KVSLockAcquired</li><li>Worker Engine</li><li>UpdateSeenAll</li><li>Worker Engine</li><li>KVSLockAcquired</li><li>KVSLockAcquired</li><li>Worker Engine</li><li>Executor</li><li>KVSRead</li><li>KVSRead</li><li>Executor</li></ul> <ol> <li> <p>Note that transaction requests come with all this information at once for each transaction candidate.\u00a0\u21a9</p> </li> </ol>","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_read_request.html","title":"KVSReadRequest","text":"","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_read_request.html#kvsreadrequest","title":"KVSReadRequest","text":"<ul> <li>from Executor</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_read_request.html#purpose","title":"Purpose","text":"<p>Informs the Shard about a new read request, which happens in either of the following cases:</p> <ul> <li>An Executor has determined that it actually needs    the value at some key for which it has a lazy read    (a may_read in the TransactionLabel of the    TransactionCandidate).   Now the executor is requesting that value from the Shard that stores    it.</li> <li>A Executor has finished and does not need   the value for some key   for which it has a lazy read (a may_read in the    TransactionLabel).</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_read_request.html#structure","title":"Structure","text":"Field Type Description <code>timestamp</code> TxFingerprint we need the value at this logical timestamp <code>key</code> KVSKey the value corresponds to this key <code>actual</code> <code>bool</code> <code>true</code> iff we actually want a response <p>If <code>actual</code> is <code>false</code>, this just means that there is no dependency on  this key in the current execution.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_read_request.html#effects","title":"Effects","text":"<p>A Shard should delay processing a KVSReadRequest until it has  completed processing KVSAcquireLock for the  same timestamp.</p> <p>Then, if <code>actual</code> is false, the Shard is done reading the value, and  can remove the may read marker from state.</p> <p>If <code>actual</code> is true, the Shard replaces the may read marker with a  will read marker. If the Shard knows the unique previous value written before  this timestamp, it sends that value in a KVSRead to  the Executor and removes the will read marker from state. Otherwise, future KVSWrites and/or UpdateSeenAlls will  identify this unique previous value written, and trigger the  KVSRead.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_read_request.html#triggers","title":"Triggers","text":"<ul> <li>to Executor: KVSRead <code>if</code> the Shard has determined the unique value written prior to this \"lock\"   <code>then</code> send a KVSRead-message to the relevant Executor   to inform them of the value</li> </ul> (Wiki) links on this page<ul><li>Executor</li><li>Executor</li><li>TransactionLabel</li><li>TransactionCandidate</li><li>Executor</li><li>TransactionLabel</li><li>TxFingerprint</li><li>KVSKey</li><li>Shard</li><li>KVSReadRequest</li><li>KVSAcquireLock</li><li>TxFingerprint</li><li>TxFingerprint</li><li>KVSRead</li><li>Executor</li><li>KVSWrite</li><li>UpdateSeenAll</li><li>KVSRead</li><li>Executor</li><li>KVSRead</li><li>KVSRead</li><li>Executor</li></ul>","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_write.html","title":"KVSWrite","text":"","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_write.html#kvswrite","title":"KVSWrite","text":"<ul> <li>from Executor</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_write.html#purpose","title":"Purpose","text":"<p>Informs the Shard about a new write request, which happens in either of the following two cases:</p> <ul> <li>A TransactionExecutable has determined that it actually will    write the value at some key for which it has a write    (in its TransactionLabel).   Now the Executor is requesting that value from the Shard    that stores it.</li> <li>A TransactionExecutable has finished, and does not actually need    to write a value for some key for which it has a lazy write    (a may_write in the TransactionLabel).</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_write.html#structure","title":"Structure","text":"Field Type Description <code>timestamp</code> TxFingerprint the logical time at which we are writing this data. <code>key</code> KVSKey the key used. With fancy hierarchical keys or suchlike, we could even specify a range of keys <code>datum</code> KVSDatum option the new data to be associated with the key. No datum should only be used in a \"may_write,\" and means don't change this value","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_write.html#effects","title":"Effects","text":"<p>A Shard should delay processing a KVSWrite until it has  completed processing KVSAcquireLock for the  same timestamp.</p> <p>If the <code>datum</code> is <code>None</code>, then remove the may write marker from  this timestamp in state. Any reads waiting to read what is written here must instead read from  the previous write. - One way to accomplish this is to copy the previous write as a     \"value written\" at this timestamp in state.</p> <p>If <code>datum</code> is occupied, then remove the may write or will write  marker from  this timestamp in state, and record the  value written at this timestamp in state.</p> <p>This may trigger a KVSRead if there are any will read markers  for which  this timestamp is the unique previous  write.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/kvs_write.html#triggers","title":"Triggers","text":"<ul> <li>to Executor: KVSRead <code>for each</code> will read lock dependent on this write:     send a KVSRead to the  relevant Executor with the value written.</li> </ul> (Wiki) links on this page<ul><li>Executor</li><li>TransactionExecutable</li><li>KVSKey</li><li>TransactionLabel</li><li>Executor</li><li>Shard</li><li>TransactionExecutable</li><li>KVSKey</li><li>TransactionLabel</li><li>TxFingerprint</li><li>KVSKey</li><li>KVSDatum</li><li>Shard</li><li>KVSWrite</li><li>KVSAcquireLock</li><li>TxFingerprint</li><li>TxFingerprint</li><li>TxFingerprint</li><li>TxFingerprint</li><li>TxFingerprint</li><li>KVSRead</li><li>TxFingerprint</li><li>Executor</li><li>KVSRead</li><li>KVSRead</li><li>Executor</li></ul>","boost":2},{"location":"arch/node/ordering/execution/shard/timestamp_ordering_information.html","title":"Timestamp ordering information","text":"","boost":2},{"location":"arch/node/ordering/execution/shard/timestamp_ordering_information.html#timestamporderinginformation","title":"TimestampOrderingInformation","text":"<ul> <li>from Mempool</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/timestamp_ordering_information.html#purpose","title":"Purpose","text":"<p>While each transaction comes with a <code>Timestamp</code>, the shards do not actually know the order of those timestamps until the DAG is built, and consensus decisions are made. This message represents the mempool communicating (partial) timestamp ordering. These are broadcast to all shards.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/timestamp_ordering_information.html#structure","title":"Structure","text":"<p>Todo</p> <p>One way to convey this is to include the entire DAG structure (albeit without the transaction contents of each worker batch). For now, I do not know what the internal structure of this message looks like.</p> <p>Todo</p> <p>check whether, \u2460 worker-timestamp (= tx fingerprint), \u2461 primary-timestamp (= pure DAG structure based on blocks/headers), \u2462 consensus-timestamp (= total order) are sufficiently many cases or we need yet another intermediate gradual step of ordering. E.g., does is make sense to also take into account local headers that (without integrity votes).</p>","boost":2},{"location":"arch/node/ordering/execution/shard/timestamp_ordering_information.html#effects","title":"Effects","text":"<p>As shards learn more ordering information, they can finally complete reads (since they learn which writes most recently occurred).</p>","boost":2},{"location":"arch/node/ordering/execution/shard/timestamp_ordering_information.html#triggers","title":"Triggers","text":"<ul> <li>to Executor: <code>KVSRead</code> <code>for each</code> locked key for which we have established a unique write value,   send a <code>KVSRead</code> message to the appropriate Executor</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/update_seen_all.html","title":"UpdateSeenAll","text":"","boost":2},{"location":"arch/node/ordering/execution/shard/update_seen_all.html#updateseenall","title":"UpdateSeenAll","text":"<ul> <li>from Mempool Engines</li> </ul>","boost":2},{"location":"arch/node/ordering/execution/shard/update_seen_all.html#purpose","title":"Purpose","text":"<p>In order to actually serve read requests, the Shard needs to know that it will not receive more write requests before a  certain timestamp. These are in general broadcast to all Shards.</p> <p>It is important that  the Worker Engine has received KVSLockAcquired-messages for all KVSAcquireLocks it has sent (or will ever send) at or before the timestamp. In other words, shards know about all possible read and write requests of TransactionCandidates for which the worker is curator and may come earlier.</p> <p>Todo</p> <p>rephrase the above paragraph</p> <p>Each worker engine only needs to send the Shard Engine UpdateSeenAll messages concerning worker-specific ordering (batch number and sequence number within the batch). This means that each Shard Engine needs to hear from  every Worker Engine periodically to be sure it is not waiting for any transactions. From there, the Shard uses TimestampOrderingInformation about the Narwhal DAG and Consensus to fill in a total order.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/update_seen_all.html#structure","title":"Structure","text":"Field Type Description <code>timestamp</code> TxFingerprint represents a the position in the total order (in V1) <code>write</code> <code>bool</code> seen all read and seen all write can (and should) be separate. <p>For V1, we only care about <code>write = true</code> because we don't garbage collect and assume multi-version storage. From V2 onward, the Shard is keeping additional ordering information and we do have garbage collection protocols.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/update_seen_all.html#effects","title":"Effects","text":"<p>Shards can now identify the unique previous write prior to each read at or before this timestamp.</p> <p>If that unique previous write has a value written, and the read is marked will read, they can send a KVSRead with that value to the relevant Executor.</p>","boost":2},{"location":"arch/node/ordering/execution/shard/update_seen_all.html#triggers","title":"Triggers","text":"<ul> <li>to Executor: KVSRead <code>for each</code> will read for which we have established a unique previous write value   send a <code>KVSRead</code> message to the relevant Executor</li> </ul> (Wiki) links on this page<ul><li>TxFingerprint</li><li>Shard</li><li>Worker Engine</li><li>KVSLockAcquired</li><li>KVSAcquireLock</li><li>TxFingerprint</li><li>TransactionCandidate</li><li>Worker Engine</li><li>UpdateSeenAll</li><li>Worker Engine</li><li>TxFingerprint</li><li>TxFingerprint</li><li>KVSRead</li><li>Executor</li><li>Executor</li><li>KVSRead</li><li>Executor</li></ul>","boost":2},{"location":"arch/node/ordering/mempool/index.html","title":"Mempool","text":"<p>The mempool receives transaction requests and stores them such that they are available for the execution engines. The mempool triggers the execution of transaction candidates for all transaction candidates received by any validator. Finally, it also provides partial ordering information to shards, and contributes to the dissemination of future lock requests to the state. In V1, the mempool is roughly a FIFO queue that takes transaction requests and passes them on to execution.</p>","boost":2},{"location":"arch/node/ordering/mempool/index.html#components","title":"Components","text":"<ul> <li>Workers receive   transaction requests from users or solvers and   keep transaction data available for executors,   which they spawn for the purpose of executing transactions   (in cooperation with shards).   After successful execution,   workers keep execution logs available.<sup>1</sup></li> </ul> <ul> <li>Execution Supervisors are the engines that are in charge   of spawning new executor processes that workers then use   to execute transaction requests.</li> </ul> (Wiki) links on this page<ul><li>Worker Engine</li><li>Execution Supervisor</li></ul> <ol> <li> <p>In V2, this will be only for a limited period of time.\u00a0\u21a9</p> </li> </ol>","boost":2},{"location":"arch/node/ordering/mempool/primary.html","title":"Primary","text":"","boost":2},{"location":"arch/node/ordering/mempool/primary.html#newworkerhash-from-worker","title":"<code>NewWorkerHash</code> from Worker","text":"<ul> <li><code>BlockSurrogate</code> \u2192 Execution</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/execution_supervisor/index.html","title":"Execution Supervisor","text":"","boost":2},{"location":"arch/node/ordering/mempool/execution_supervisor/index.html#purpose","title":"Purpose","text":"<p>The execution supervisor in V1 is essentially the engine counterpart to the Erlang or Elixir <code>spawn</code>-command (for a process waiting for ExecuteTransaction-commands). This will be more complicated in future versions where a single transaction might be processed by geo-distributed executors to allow for collocation with shards.</p>","boost":2},{"location":"arch/node/ordering/mempool/execution_supervisor/index.html#spawnexecutor","title":"SpawnExecutor","text":"<ul> <li>from Worker</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/execution_supervisor/index.html#purpose_1","title":"Purpose","text":"<p>Informs the supervisor about the need to spawn a new Executor.</p> <pre><code>&lt;summary&gt;Details&lt;/summary&gt;\n</code></pre> (Wiki) links on this page<ul><li>ExecuteTransaction</li><li>SpawnExecutor</li><li>Worker Engine</li><li>Executor</li><li>ExecutorPIDAssigned</li><li>Worker Engine</li><li>ExecutorPIDAssigned</li></ul>","boost":2},{"location":"arch/node/ordering/mempool/execution_supervisor/index.html#structure","title":"Structure","text":"Field Type Description <code>spawn</code> Unit no information needed in V1","boost":2},{"location":"arch/node/ordering/mempool/execution_supervisor/index.html#effects","title":"Effects","text":"<p>A new Executor instance is spawned or (a finished Executor is reused).</p>","boost":2},{"location":"arch/node/ordering/mempool/execution_supervisor/index.html#triggers","title":"Triggers","text":"<ul> <li>ExecutorPIDAssigned\u2192Worker:   send ExecutorPIDAssigned to the worker that sent the message</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/execution_supervisor/spawn_executor.html","title":"SpawnExecutor","text":"<ul> <li>from Worker</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/execution_supervisor/spawn_executor.html#purpose","title":"Purpose","text":"<p>Informs the supervisor about the need to spawn a new Executor.</p>","boost":2},{"location":"arch/node/ordering/mempool/execution_supervisor/spawn_executor.html#structure","title":"Structure","text":"Field Type Description <code>spawn</code> Unit no information needed in V1","boost":2},{"location":"arch/node/ordering/mempool/execution_supervisor/spawn_executor.html#effects","title":"Effects","text":"<p>A new Executor instance is spawned or (a finished Executor is reused).</p>","boost":2},{"location":"arch/node/ordering/mempool/execution_supervisor/spawn_executor.html#triggers","title":"Triggers","text":"<ul> <li>ExecutorPIDAssigned\u2192Worker:   send ExecutorPIDAssigned to the worker that sent the message</li> </ul> (Wiki) links on this page<ul><li>Worker Engine</li><li>Executor</li><li>ExecutorPIDAssigned</li><li>Worker Engine</li><li>ExecutorPIDAssigned</li></ul>","boost":2},{"location":"arch/node/ordering/mempool/primary/availability_certificate.html","title":"Availability certificate","text":"","boost":2},{"location":"arch/node/ordering/mempool/primary/availability_certificate.html#availabilitycertified","title":"AvailabilityCertified","text":"<ul> <li>from Primary</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/primary/availability_certificate.html#purpose","title":"Purpose","text":"<p>The certificate informs the validator about availability of a header and who has taken on the responsibility of availability.</p>","boost":2},{"location":"arch/node/ordering/mempool/primary/availability_certificate.html#structure","title":"Structure","text":"Field Type Description <code>fingerprint</code> <code>HeaderFingerprint</code> the header that is certified <code>certificate</code> <code>AvailabilityCertificate</code> the broadcast availability certificate","boost":2},{"location":"arch/node/ordering/mempool/primary/availability_certificate.html#effects","title":"Effects","text":"<ul> <li>Receiving the availability certificate means that all further signatures only concern integrity.</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/primary/availability_certificate.html#triggers","title":"Triggers","text":"<p>(none)</p>","boost":2},{"location":"arch/node/ordering/mempool/primary/new_quorums.html","title":"New quorums","text":"","boost":2},{"location":"arch/node/ordering/mempool/primary/new_quorums.html#newquorums","title":"NewQuorums","text":"<ul> <li>from Executor</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/primary/new_quorums.html#purpose","title":"Purpose","text":"<p>Informs primaries about the quorums to use for a range of heights.</p>","boost":2},{"location":"arch/node/ordering/mempool/primary/new_quorums.html#structure","title":"Structure","text":"Field Type Description <code>chain_id</code> ChainId the chain Id <code>quorums</code> Quorums the chain quorums <code>start_height</code> Height start height <code>end_height</code> Height end height","boost":2},{"location":"arch/node/ordering/mempool/primary/new_quorums.html#effects","title":"Effects","text":"<p>The new learner graph structure is known.</p>","boost":2},{"location":"arch/node/ordering/mempool/primary/new_quorums.html#triggers","title":"Triggers","text":"<p>none</p>","boost":2},{"location":"arch/node/ordering/mempool/primary/new_worker_hash.html","title":"New worker hash","text":"","boost":2},{"location":"arch/node/ordering/mempool/primary/new_worker_hash.html#newworkerhash","title":"NewWorkerHash","text":"<ul> <li>from Worker</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/primary/new_worker_hash.html#purpose","title":"Purpose","text":"<p>The worker has completed a worker hash that the primary can process.</p>","boost":2},{"location":"arch/node/ordering/mempool/primary/new_worker_hash.html#structure","title":"Structure","text":"Field Type Description <code>batch_hash</code> bytes the hash of the list of transactions <code>length</code> natural number the number of transactions hashed <code>worker_id</code> ID the identifier of the sending worker <code>signature</code> bytes the signature of the worker over the batch hash","boost":2},{"location":"arch/node/ordering/mempool/primary/new_worker_hash.html#effects","title":"Effects","text":"<ul> <li>The primary's next block header should include this worker hash.</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/primary/new_worker_hash.html#triggers","title":"Triggers","text":"<p>There is nothing to do in <code>v1</code> as all ordering information can be inferred by the execution.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html","title":"Worker","text":"","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#purpose","title":"Purpose","text":"<p>Workers are one of the mempool engines and, in V2, they are the only one and there is only a single worker.</p> <p>The worker receives transaction requests from users and solvers and batches these transaction requests, assigning a unique TxFingerprint to every new transaction. Each transaction candidate will be sent to an Executor inside an ExecuteTransaction message. Once the worker has received a KVSLockAcquired for every part of the transaction request's label (from the shards of the same Anoma validator in response to KVSAcquireLock-messages), it knows that this transaction candidate has been \"seen\" by all Shards, which implies that all shards are prepared to process lock requests from execution processes (see KVSReadRequest and KVSWrite for details). This information about locks being recorded is distributed to all shards via UpdateSeenAll messages, which contain the most recent TxFingerprint for which it is certain that all Shards have \"seen\" this transaction candidate and all previous ones from the same worker (and they are thus prepared to grant locks). Note that if shards receive transaction candidates in a different order than the final total order of transactions, UpdateSeenAll messages are necessary to avoid that shards grant locks before all locks of previous transaction executions have been served.</p> <p>Workers also are in charge of collecting and curating logs of transaction execution. Success is equivalent to all reads and writes being successful and an ExecutorFinished-message from the executor that was spawned to execute the message.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#state","title":"State","text":"<p>Each worker keeps track of</p> <ul> <li>the current batch number (consecutively numbered)</li> </ul> <ul> <li>the list of transaction candidate|s in each batch</li> </ul> <ul> <li>a unique TxFingerprint for each transaction candidate,   at least in previous batches</li> </ul> <ul> <li>the set of relevant received KVSLockAcquired-acquired messages</li> </ul> <ul> <li>the set of relevant sent UpdateSeenAll-messages</li> </ul> <ul> <li>execution summaries for each transaction</li> </ul> <p>There is no precise state representation described by the V2 specs.</p> <p>Todo</p> <p>the following almost certainly are not the template we want --&gt;</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#executorfinished","title":"ExecutorFinished","text":"<ul> <li>from Executor</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#purpose_1","title":"Purpose","text":"<p>Informs the mempool about execution of a transaction.</p> Details","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#structure","title":"Structure","text":"Field Type Description <code>fingerprint</code> TxFingerprint a descriptor for executed transaction <code>log_key</code> Local Storage Key handle to the transaction log of the transaction execution","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#effects","title":"Effects","text":"<p>This message is a pre-requisite for enabling garbage collection in the mempool. The log_key can be used by the user to request data about the transaction. In V1, this is kept as long as the instance is running.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#triggers","title":"Triggers","text":"<p>none</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#transactionrequest","title":"TransactionRequest","text":"<ul> <li>from User, Solver</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#purpose_2","title":"Purpose","text":"<p>A user or solver requests that a transaction candidate be ordered and executed.</p> Details","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#structure_1","title":"Structure","text":"Field Type Description <code>tx</code> TransactionCandidate the actual transaction to be ordered <code>resubmission</code> TxFingerprint option reference to the previous occurrence <p>The resubmission indicates if there was a previous occurrence of the very same transaction candidate which either has failed or a needs to be executed again, e.g., because it is a recurring payment.</p> <p>This is the \"bare-bone\" version for V1. Additional user preferences can be supplied in future versions concerning - how the response will be given - how long duplicate checks are to be performed - etc.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#effects_1","title":"Effects","text":"<ul> <li>The receiving worker is obliged to store the new transaction   (until after execution)   unless it is out of storage.   (Suitable fee mechanisms may be introduced to ensure that     the probability of sufficient storage is relatively high,     which involves a trade-off against cheap fees.)</li> <li>The received transaction request might complete the current batch.  </li> <li>The worker assigns   a batch number   (the number of the current batch)   and a transaction number   (before the closing of the batch)   such that this transaction candidate can be referenced   via the corresponding TxFingerprint\u2014unless   the worker already has received a request   for the same transaction candidate after the <code>resubmission</code> time stamp.   If the exact same transaction candidate has already been ordered,   the request is disregarded;   optional messages may be sent to the sender of the request.  </li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#triggers_1","title":"Triggers","text":"<ul> <li>KVSAcquireLock\u2192Shard, SpawnExecutor \u2192 Execution Supervisor <code>if</code> the worker has not seen this TransactionRequest   before (or \"recently\")   <code>and</code> a TxFingerprint is assigned to the transaction candidate   <code>then</code><ul> <li>send KVSAcquireLock-messages to the relevant Shards</li> <li>send SpawnExecutor to the Execution Supervisor</li> </ul> </li> </ul> <p>Todo</p> <p>move this as a response to EPID message</p> <ul> <li>to Executor: ExecuteTransaction <code>if</code> the worker has not seen this TransactionCandidate     before (or \"recently\") after resubmission <sup>1</sup> <code>and</code> a TxFingerprint is assigned to the transaction candidate     <code>and</code> (as an optional pre-condition)         the worker has seen a KVSLockAcquired message for this transaction     <code>then</code> spawn a new executor process and send it         an ExecuteTransaction message</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#executorpidassigned","title":"ExecutorPIDAssigned","text":"","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#purpose_3","title":"Purpose","text":"<p>Provides the worker with an ID for newly spawned or available executor engine instance.</p> Details","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#structure_2","title":"Structure","text":"Field Type Description <code>epid</code> ExternalIdentity the ID of the spawned Executor-engine instance","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#effects_2","title":"Effects","text":"<p>The receiving worker can request the eager reads and start the execution.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#triggers_2","title":"Triggers","text":"<ul> <li>ExecuteTransaction\u2192Executor, KVSReadRequest\u2192Shards:   for the next transaction to be executed,   the worker sends<ul> <li>the ExecuteTransaction-message to the executor</li> <li>the will-read KVSReadRequests to the relevant Shards</li> </ul> </li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#kvslockacquired","title":"KVSLockAcquired","text":"<ul> <li>from Shards</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#purpose_4","title":"Purpose","text":"<p>This message informs the Worker Engine that the sending Shard  has recorded upcoming read or write requests to a key specified in an  earlier KVSAcquireLock from the Worker Engine. It is an asynchronous response.</p> Details","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#structure_3","title":"Structure","text":"Field Type Description <code>fingerprint</code> TxFingerprint the fingerprint of the TransactionCandidate for which some locks have been recorded <code>key</code> KVSKey the key in the key value store that will be accessed <code>write</code> <code>bool</code> <code>true</code> for write, <code>false</code> for read <code>optional</code> <code>bool</code> <code>true</code> for may_write or may_read, <code>false</code> for will_write or will_read","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#effects_3","title":"Effects","text":"<ul> <li>The Worker Engine adds this lock to a store of lock acquisitions    that have been recorded by the shards such that it may be able to    send  UpdateSeenAll messages with greater TxFingerprints    than the last one sent.<ul> <li>Once an UpdateSeenAll message is sent, all information the    Worker Engine stores concerning KVSLockAcquired-message    for earlier transactions can be freed.</li> </ul> </li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#triggers_3","title":"Triggers","text":"<ul> <li>to Shards: UpdateSeenAll <code>if</code>  we can now be certain that there is some new TxFingerprint <code>T</code>,   after (the last one) of the previously sent UpdateSeenAll,   such that no more KVSAcquireLock-messages featuring timestamps   at or before <code>T</code> will be sent by the same Worker Engine:   <code>then</code>  send UpdateSeenAll with <code>T</code> to all Shards.</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#requestlogs","title":"RequestLogs","text":"<ul> <li>from User, Solver</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#purpose_5","title":"Purpose","text":"<p>Request the log of a finished execution.</p> Details <p>Todo</p> <p>we need to find better places for these footnotes</p> (Wiki) links on this page<ul><li>TxFingerprint</li><li>Executor</li><li>ExecuteTransaction</li><li>KVSLockAcquired</li><li>KVSAcquireLock</li><li>Shard</li><li>KVSReadRequest</li><li>KVSWrite</li><li>Shard</li><li>UpdateSeenAll</li><li>TxFingerprint</li><li>Shard</li><li>Shard</li><li>UpdateSeenAll</li><li>Shard</li><li>ExecutorFinished</li><li>Executor</li><li>TransactionCandidate</li><li>TxFingerprint</li><li>KVSLockAcquired</li><li>UpdateSeenAll</li><li>ExecutionSummary</li><li>ExecutorFinished</li><li>Executor</li><li>TxFingerprint</li><li>TransactionRequest</li><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TxFingerprint</li><li>TxFingerprint</li><li>KVSAcquireLock</li><li>Shard</li><li>SpawnExecutor</li><li>Execution Supervisor</li><li>TransactionRequest</li><li>TxFingerprint</li><li>KVSAcquireLock</li><li>Shard</li><li>SpawnExecutor</li><li>Execution Supervisor</li><li>Executor</li><li>ExecuteTransaction</li><li>TransactionCandidate</li><li>TxFingerprint</li><li>KVSLockAcquired</li><li>ExecuteTransaction</li><li>ExecutorPIDAssigned</li><li>KVSReadRequest</li><li>Shard</li><li>KVSReadRequest</li><li>Shard</li><li>KVSLockAcquired</li><li>Shard</li><li>Worker Engine</li><li>Shard</li><li>KVSAcquireLock</li><li>Worker Engine</li><li>TxFingerprint</li><li>TransactionCandidate</li><li>KVSKey</li><li>Worker Engine</li><li>UpdateSeenAll</li><li>TxFingerprint</li><li>UpdateSeenAll</li><li>Worker Engine</li><li>KVSLockAcquired</li><li>Shard</li><li>UpdateSeenAll</li><li>TxFingerprint</li><li>UpdateSeenAll</li><li>KVSAcquireLock</li><li>Worker Engine</li><li>UpdateSeenAll</li><li>Shard</li><li>RequestLogs</li><li>TxFingerprint</li><li>TransactionCandidate</li></ul> <ol> <li> <p>It might be too expensive to check from genesis; transaction requests could have a parameter for how long the duplicate check is active.\u00a0\u21a9</p> </li> <li> <p>This condidtion can be added to avoid too many waiting/idling executor processes. (This comes at the price of a sliver of additional latencey for the first transactions in a batch.) Note that this cannot lead to deadlocks as the lock acquisition messages (KVSAcquireLock,KVSLockAcquired,UpdateSeenAll) are completely independent of spawning transactions. In more detail, if we were missing a KVSAcquireLock message for a transaction, the executor could not start operating (even if it is spawned).\u00a0\u21a9</p> </li> <li> <p>This can be done by use of a executor process supervisor in the implementation.\u00a0\u21a9</p> </li> <li> <p>In all future versions of Anoma, workers will be organized around primaries; however, in V2, we can omit primaries as they do not serve any purpose. In V2, there is only a single worker, which can be though of as featuring also as its primary.\u00a0\u21a9</p> </li> <li> <p>In future versions, IO is output of results from the responsible workers (and their fellow/mirror workers) to some fixed address. Inputs may allow for non-trivial validator inputs, according to a orthogonal protocol (an may fail deterministically).\u00a0\u21a9</p> </li> <li> <p>In V2, we report all the data about a single transaction back to the submitter as part of execution. --&gt;\u00a0\u21a9</p> </li> </ol>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#structure_4","title":"Structure","text":"Field Type Description <code>fingerprint</code> TxFingerprint the fingerprint of the TransactionCandidate for logs are requested <code>log_key</code> Local Storage Key the key for retrieving the log","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#effects_4","title":"Effects","text":"<p>none</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/index.html#triggers_4","title":"Triggers","text":"<ul> <li>to User, Solver: SendLog   Answer the request with the data requested.</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/executor_finished.html","title":"ExecutorFinished","text":"<ul> <li>from Executor</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/executor_finished.html#purpose","title":"Purpose","text":"<p>Informs the mempool about execution of a transaction.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/executor_finished.html#structure","title":"Structure","text":"Field Type Description <code>fingerprint</code> TxFingerprint a descriptor for executed transaction <code>log_key</code> Local Storage Key handle to the transaction log of the transaction execution","boost":2},{"location":"arch/node/ordering/mempool/worker/executor_finished.html#effects","title":"Effects","text":"<p>This message is a pre-requisite for enabling garbage collection in the mempool. The log_key can be used by the user to request data about the transaction. In V1, this is kept as long as the instance is running.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/executor_finished.html#triggers","title":"Triggers","text":"<p>none</p> (Wiki) links on this page<ul><li>Executor</li><li>TxFingerprint</li></ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/executor_pid_assigned.html","title":"ExecutorPIDAssigned (EPID)","text":"","boost":2},{"location":"arch/node/ordering/mempool/worker/executor_pid_assigned.html#purpose","title":"Purpose","text":"<p>Provides the worker with an ID for newly spawned or available executor engine instance.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/executor_pid_assigned.html#structure","title":"Structure","text":"Field Type Description <code>epid</code> ExternalIdentity the ID of the spawned Executor-engine instance","boost":2},{"location":"arch/node/ordering/mempool/worker/executor_pid_assigned.html#effects","title":"Effects","text":"<p>The receiving worker can request the eager reads and start the execution.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/executor_pid_assigned.html#triggers","title":"Triggers","text":"<ul> <li>ExecuteTransaction\u2192Executor, KVSReadRequest\u2192Shards:   for the next transaction to be executed,   the worker sends<ul> <li>the ExecuteTransaction-message to the executor</li> <li>the will-read KVSReadRequests to the relevant Shards</li> </ul> </li> </ul> (Wiki) links on this page<ul><li>KVSReadRequest</li><li>Shard</li><li>KVSReadRequest</li><li>Shard</li></ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/kvs_lock_acquired.html","title":"KVSLockAcquired","text":"<ul> <li>from Shards</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/kvs_lock_acquired.html#purpose","title":"Purpose","text":"<p>This message informs the Worker Engine that the sending Shard  has recorded upcoming read or write requests to a key specified in an  earlier KVSAcquireLock from the Worker Engine. It is an asynchronous response.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/kvs_lock_acquired.html#structure","title":"Structure","text":"Field Type Description <code>fingerprint</code> TxFingerprint the fingerprint of the TransactionCandidate for which some locks have been recorded <code>key</code> KVSKey the key in the key value store that will be accessed <code>write</code> <code>bool</code> <code>true</code> for write, <code>false</code> for read <code>optional</code> <code>bool</code> <code>true</code> for may_write or may_read, <code>false</code> for will_write or will_read","boost":2},{"location":"arch/node/ordering/mempool/worker/kvs_lock_acquired.html#effects","title":"Effects","text":"<ul> <li>The Worker Engine adds this lock to a store of lock acquisitions    that have been recorded by the shards such that it may be able to    send  UpdateSeenAll messages with greater TxFingerprints    than the last one sent.<ul> <li>Once an UpdateSeenAll message is sent, all information the    Worker Engine stores concerning KVSLockAcquired-message    for earlier transactions can be freed.</li> </ul> </li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/kvs_lock_acquired.html#triggers","title":"Triggers","text":"<ul> <li>to Shards: UpdateSeenAll <code>if</code>  we can now be certain that there is some new TxFingerprint <code>T</code>,   after (the last one) of the previously sent UpdateSeenAll,   such that no more KVSAcquireLock-messages featuring timestamps   at or before <code>T</code> will be sent by the same Worker Engine:   <code>then</code>  send UpdateSeenAll with <code>T</code> to all Shards.</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/kvs_lock_acquired.html#note","title":"Note","text":"<p>Otherwise, a Shard might hear about a  KVSAcquireLock only after  it has heard UpdateSeenAll with a later TxFingerprint,  causing it to execute the \"later\" transaction before it learned of  the \"earlier\" one, which could allow the \"later\" transaction to read  the wrong value from state. Therefore, it is important to let Worker Engines know which  KVSAcquireLocks the shard has received.</p> (Wiki) links on this page<ul><li>Shard</li><li>Worker Engine</li><li>Shard</li><li>KVSAcquireLock</li><li>Worker Engine</li><li>TxFingerprint</li><li>TransactionCandidate</li><li>KVSKey</li><li>Worker Engine</li><li>UpdateSeenAll</li><li>TxFingerprint</li><li>UpdateSeenAll</li><li>Worker Engine</li><li>KVSLockAcquired</li><li>Shard</li><li>UpdateSeenAll</li><li>TxFingerprint</li><li>UpdateSeenAll</li><li>KVSAcquireLock</li><li>Worker Engine</li><li>UpdateSeenAll</li><li>Shard</li><li>KVSAcquireLock</li><li>UpdateSeenAll</li><li>TxFingerprint</li><li>Worker Engine</li><li>KVSAcquireLock</li></ul> <ol> <li> <p>In this way, a lock may be granted without knowing about declared access that would have to be served before.\u00a0\u21a9</p> </li> </ol>","boost":2},{"location":"arch/node/ordering/mempool/worker/kvs_written.html","title":"KVSWritten","text":"","boost":2},{"location":"arch/node/ordering/mempool/worker/kvs_written.html#purpose","title":"Purpose","text":"<p>Inform the worker about all values written for a given executed TxFingerprint.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/kvs_written.html#structure","title":"Structure","text":"Field Type Description fingerprint TxFingerprint the transaction that finished execution <code>values</code> <code>Key</code>\u21c0bytes a map of  values written <code>executor</code> ID-set the (set) of executors involved","boost":2},{"location":"arch/node/ordering/mempool/worker/request_logs.html","title":"RequestLogs","text":"<ul> <li>from User, Solver</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/request_logs.html#purpose","title":"Purpose","text":"<p>Request the log of a finished execution.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/request_logs.html#structure","title":"Structure","text":"Field Type Description <code>fingerprint</code> TxFingerprint the fingerprint of the TransactionCandidate for logs are requested <code>log_key</code> Local Storage Key the key for retrieving the log","boost":2},{"location":"arch/node/ordering/mempool/worker/request_logs.html#effects","title":"Effects","text":"<p>none</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/request_logs.html#triggers","title":"Triggers","text":"<ul> <li>to User, Solver: SendLog   Answer the request with the data requested.</li> </ul> (Wiki) links on this page<ul><li>TxFingerprint</li><li>TransactionCandidate</li></ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/transaction_ack.html","title":"TransactionAck","text":"<ul> <li>from Worker</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/transaction_ack.html#purpose","title":"Purpose","text":"<p>The worker acknowledges a transaction request with local ordering information and a local wall clock time stamp that the requester can use as evidence for submission of a specific transaction candidate.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/transaction_ack.html#structure","title":"Structure","text":"Field Type Description <code>txHash</code> Hash the hash of the acknowledged transaction candidate <code>batch_number</code> natural number the batch into which the transaction will go <code>timeStamp</code> WallClockTime the worker local time stamp of batch opening <code>signature</code> bytes the signature of the acknowledging worker over the above data <p>The time stamp is the time of when the batch with <code>batch_number</code> was opened. The exact inclusion time into the batch is not communicated to the requester.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/transaction_ack.html#effects","title":"Effects","text":"<ul> <li>The user has evidence for having submitted a transaction to a worker.</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/transaction_ack.html#triggers","title":"Triggers","text":"<p>none</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/transaction_request.html","title":"TransactionRequest","text":"<ul> <li>from User, Solver</li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/transaction_request.html#purpose","title":"Purpose","text":"<p>A user or solver requests that a transaction candidate be ordered and executed.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/transaction_request.html#structure","title":"Structure","text":"Field Type Description <code>tx</code> TransactionCandidate the actual transaction to be ordered <code>resubmission</code> TxFingerprint option reference to the previous occurrence <p>The resubmission indicates if there was a previous occurrence of the very same transaction candidate which either has failed or a needs to be executed again, e.g., because it is a recurring payment.</p> <p>This is the \"bare-bone\" version for V1. Additional user preferences can be supplied in future versions concerning - how the response will be given - how long duplicate checks are to be performed - etc.</p>","boost":2},{"location":"arch/node/ordering/mempool/worker/transaction_request.html#effects","title":"Effects","text":"<ul> <li>The receiving worker is obliged to store the new transaction   (until after execution)   unless it is out of storage.   (Suitable fee mechanisms may be introduced to ensure that     the probability of sufficient storage is relatively high,     which involves a trade-off against cheap fees.)</li> <li>The received transaction request might complete the current batch.  </li> <li>The worker assigns   a batch number   (the number of the current batch)   and a transaction number   (before the closing of the batch)   such that this transaction candidate can be referenced   via the corresponding TxFingerprint\u2014unless   the worker already has received a request   for the same transaction candidate after the <code>resubmission</code> time stamp.   If the exact same transaction candidate has already been ordered,   the request is disregarded;   optional messages may be sent to the sender of the request.    </li> </ul>","boost":2},{"location":"arch/node/ordering/mempool/worker/transaction_request.html#triggers","title":"Triggers","text":"<ul> <li>KVSAcquireLock\u2192Shard, SpawnExecutor \u2192 Execution Supervisor <code>if</code> the worker has not seen this TransactionRequest   before (or \"recently\")   <code>and</code> a TxFingerprint is assigned to the transaction candidate   <code>then</code><ul> <li>send KVSAcquireLock-messages to the relevant Shards</li> <li>send SpawnExecutor to the Execution Supervisor</li> </ul> </li> </ul> <p>Todo</p> <p>move this as a response to EPID message</p> <ul> <li>to Executor: ExecuteTransaction <code>if</code> the worker has not seen this TransactionCandidate     before (or \"recently\") after resubmission [^1]     <code>and</code> a TxFingerprint is assigned to the transaction candidate     <code>and</code> (as an optional pre-condition)         the worker has seen a KVSLockAcquired message for this transaction     <code>then</code> spawn a new executor process and send it         an ExecuteTransaction message</li> </ul> (Wiki) links on this page<ul><li>TransactionCandidate</li><li>TransactionCandidate</li><li>TxFingerprint</li><li>TxFingerprint</li><li>KVSAcquireLock</li><li>Shard</li><li>SpawnExecutor</li><li>Execution Supervisor</li><li>TransactionRequest</li><li>TxFingerprint</li><li>KVSAcquireLock</li><li>Shard</li><li>SpawnExecutor</li><li>Execution Supervisor</li><li>Executor</li><li>ExecuteTransaction</li><li>TransactionCandidate</li><li>TxFingerprint</li><li>KVSLockAcquired</li><li>ExecuteTransaction</li></ul>","boost":2},{"location":"arch/node/ordering/types/availability_certificate.html","title":"Availability Certificate","text":"<p>An availability certificate is a block header together with a global weak quorum of signatures from primaries. The signatures might either be a plain list, but aggregated signature are a suitable optimization because the creator of the block header is collecting all the signatures from primaries.</p> Field Type Description <code>header</code> Block Header the block header that is signed <code>signatures</code> bytes list a list of signatures from a global weak quorum of primaries","boost":2},{"location":"arch/node/ordering/types/execution_summary.html","title":"ExecutionSummary","text":"","boost":2},{"location":"arch/node/ordering/types/execution_summary.html#purpose","title":"Purpose","text":"<p>The data structure for holding all information about the execution of a transaction candidate that could be made available to the issuer of the corresponding transaction request.</p>","boost":2},{"location":"arch/node/ordering/types/execution_summary.html#structure","title":"Structure","text":"Field Type Description <code>success</code> boolean true iff the execution finished successfully <code>values_read</code> (KVSKey\u00d7KVSDatum) set the set of values read for keys <code>values_written</code> (KVSKey\u00d7KVSDatum) set the set of values written to keys <code>log_key</code> Local Storage Key the key at which the execution log is stored","boost":2},{"location":"arch/node/ordering/types/execution_summary.html#note","title":"Note","text":"<p>By default, the <code>log_key</code> is the hash of the execution log.</p> (Wiki) links on this page<ul><li>KVSKey</li><li>KVSDatum</li><li>KVSKey</li><li>KVSDatum</li></ul>","boost":2},{"location":"arch/node/ordering/types/header_fingerprint.html","title":"<code>HeaderFingerprint</code>","text":"<p>The header fingerprint describes an actual header succinctly, using easily available information.</p> Field Type Description <code>id</code> Id the \u026a\u1d05 of the primary engine that created the header <code>height</code> natural number the height in the header chain of the same primary <code>batches</code> WHFingerprint list a list of worker hash fingerprints, referencing a list of batches <code>cert_hash</code> Hash the hash of the availability certificate of the previous header (unless at height zero)","boost":2},{"location":"arch/node/ordering/types/kvs_datum.html","title":"KVSDatum","text":"","boost":2},{"location":"arch/node/ordering/types/kvs_datum.html#purpose","title":"Purpose","text":"<p>The datatype used for storing data to keys of the RSM key value store.</p>","boost":2},{"location":"arch/node/ordering/types/kvs_datum.html#structure","title":"Structure","text":"<p>This is a basic data type and could be a type parameter. The default is a byte string, e.g., a binary in Elixir.</p>","boost":2},{"location":"arch/node/ordering/types/kvs_key.html","title":"KVSKey","text":"","boost":2},{"location":"arch/node/ordering/types/kvs_key.html#purpose","title":"Purpose","text":"<p>The datatype for keys of RSM state.</p>","boost":2},{"location":"arch/node/ordering/types/kvs_key.html#structure","title":"Structure","text":"<p>This is a basic type and thus could be a parameter. In V1, the default is a 256-bit hash.</p>","boost":2},{"location":"arch/node/ordering/types/kvs_key.html#note","title":"Note","text":"<p>If \\(n\\) shards are used, for \\(n\\in \\mathbb{N}\\), then shard\u00a0\\(i\\) will be responsible for a key \\(k\\) if, and only if, \\(k \\equiv i \\mod n\\).</p>","boost":2},{"location":"arch/node/ordering/types/narwhal_block_header.html","title":"<code>NarwhalBlockHeader</code>","text":"<p>Primaries organize batches of transactions into block headers that may also contain signed quorums, each of which reference a quorum of blocks.</p> Field Type Description <code>id</code> Identity the \u026a\u1d05 of the creating primary <code>height</code> natural number the creator-relative height of the block header <code>worker_hashes</code> WorkerHash list the list of worker hashes <code>predecessor</code> AvailabilityCertificate option the availability certificate of the preceding header <code>signed_qourums</code> Signed Quorum list the list of signed quorums <code>signature</code> bytes the signature by the primary over the above fields <p>The height of genesis is zero and at that is the only height where the availability certificate is <code>none</code>. The list of signed quorums may be empty and must be empty at genesis, i.e., if <code>height</code> is zero.</p> <p>The predecessor uniquely determines the vector of learner-specific heights and the signed_quorums may only reference the directly preceding block for each learner.</p> <p>Todo</p> <p>spell this out and/or link it</p>","boost":2},{"location":"arch/node/ordering/types/read_label.html","title":"ReadLabel","text":"","boost":2},{"location":"arch/node/ordering/types/read_label.html#purpose","title":"Purpose","text":"<p>The ReadLabel specifies which keys a transaction may and will read from. The rationale behind this information is that if a transaction definitely reads from a set of keys, the corresponding KVSReadRequests can be issued even before spawning an executor.</p>","boost":2},{"location":"arch/node/ordering/types/read_label.html#structure","title":"Structure","text":"Field Type Description <code>will_read</code> KVSKey set in V1, this is a generic set of keys that will be read <code>may_read</code> KVSKey set in V1, this is a generic set of keys that may be read <p>From V2 onward, after imposing a tree-structure on keys (or something similar), we can represent potentially infinite sets of keys.</p>","boost":2},{"location":"arch/node/ordering/types/read_label.html#notes","title":"Notes","text":"<p>Occasionally, we refer to \"may read\"-keys also as lazy reads as they potentially only issued on demand.</p> (Wiki) links on this page<ul><li>KVSReadRequest</li><li>KVSKey</li><li>KVSKey</li></ul>","boost":2},{"location":"arch/node/ordering/types/signed_quroum.html","title":"<code>SignedQuorum</code>","text":"<p>A signed quorum is a signature over a list of blocks whose creators together form a learner-specific quorum.</p> Field Type Description <code>learner</code> Learner the learner in question <code>block_quorum</code> NarwhalBlock list the quorum of blocks <code>id</code> Identifier the \u026a\u1d05 of the signing entity <code>signature</code> bytes the signature over <code>block_quorum</code>","boost":2},{"location":"arch/node/ordering/types/transaction_ack.html","title":"TransactionAck","text":"","boost":2},{"location":"arch/node/ordering/types/transaction_ack.html#purpose","title":"Purpose","text":"<p>A <code>TransactionAck</code> is a potentially instant notification for a received transaction notifying about the batch number of the worker and when this batch was started according to the worker's local time.</p>","boost":2},{"location":"arch/node/ordering/types/transaction_ack.html#structure","title":"Structure","text":"Field Type Description <code>hash</code> bytes the hash of the transaction request acknowledged <code>batch_number</code> natural number the batch number assigned <code>batch_start</code> wall clock time the wall clock time of the worker when opening the batch <code>collector_id</code> ExternalIdentity the \u026a\u1d05 of the worker engine that collected the transaction signature bytes the signature of the collecting worker engine over the above","boost":2},{"location":"arch/node/ordering/types/transaction_ack.html#note","title":"Note","text":"<p>We cannot make use of a TxFingerprint of the transaction, because there might be a slight delay between message reception and assignation of transaction number for the acknowledged transaction candidate that is contained in a request. Also, there might be several requests for the same transaction candidate even if this is the not the standard scenario.</p> (Wiki) links on this page<ul><li>TxFingerprint</li></ul>","boost":2},{"location":"arch/node/ordering/types/transaction_candidate.html","title":"TransactionCandidate","text":"<p>The basic unit of data that users send to the mempool for the purpose of ordering and execution (aka processing) as part of a transaction request is called a transaction candidate.</p> Field Type Description <code>label</code> TransactionLabel keys that may/will be read/written <code>executable</code> TransactionExecutable the payload for post-ordering execution (Wiki) links on this page<ul><li>TransactionRequest</li><li>TransactionLabel</li><li>TransactionExecutable</li></ul>","boost":2},{"location":"arch/node/ordering/types/transaction_executable.html","title":"TransactionExecutable","text":"<p>All information about what to do after a transaction is ordered, e.g., calculations, or proof checks, is given by a string of bytes that we call transaction executable.</p>","boost":2},{"location":"arch/node/ordering/types/transaction_label.html","title":"TransactionLabel","text":"","boost":2},{"location":"arch/node/ordering/types/transaction_label.html#purpose","title":"Purpose","text":"<p>Specifies which keys a transaction execution may/will read/write.</p>","boost":2},{"location":"arch/node/ordering/types/transaction_label.html#structure","title":"Structure","text":"Field Type Description <code>read</code> ReadLabel the keys a transaction may or must read from <code>write</code> WriteLabel the keys a transaction may or must write to (Wiki) links on this page<ul><li>ReadLabel</li><li>WriteLabel</li></ul>","boost":2},{"location":"arch/node/ordering/types/tx_data.html","title":"TxData","text":"","boost":2},{"location":"arch/node/ordering/types/tx_data.html#purpose","title":"Purpose","text":"<p>We define TxData as an alias for a string of bytes that contains all relevant data of a transaction candidate.</p>","boost":2},{"location":"arch/node/ordering/types/tx_data.html#structure","title":"Structure","text":"<p>This is a basic type and could be a type parameter. The default is a byte string, e.g., binary in Elixir.</p> (Wiki) links on this page<ul><li>TransactionCandidate</li></ul>","boost":2},{"location":"arch/node/ordering/types/tx_fingerprint.html","title":"TxFingerprint","text":"","boost":2},{"location":"arch/node/ordering/types/tx_fingerprint.html#purpose","title":"Purpose","text":"<p>The fingerprint of a transaction allows referring to a transaction succinctly and gives additional information about the provenance, primarily used by engines of the ordering machine.</p>","boost":2},{"location":"arch/node/ordering/types/tx_fingerprint.html#structure","title":"Structure","text":"Field Type Description <code>collector_id</code> ExternalIdentity the \u026a\u1d05 of the worker engine that collected the transaction <code>batchNumber</code> natural number the number of the batch into which the transaction was batched <code>txNumber</code> natural number the transaction number within the batch identified by the batch number <code>last</code> boolean true if and only if the txNumber is the maximal one in this batch","boost":2},{"location":"arch/node/ordering/types/tx_fingerprint.html#note","title":"Note","text":"<p>We do not have any field of the hash of the referenced transaction. A <code>TxFingerprint</code> is ordering information that is only used directly within the ordering machine.</p>","boost":2},{"location":"arch/node/ordering/types/wh_fingerprint.html","title":"<code>WHFingerprint</code>","text":"<p>The fingerprint of a worker hash.</p> Field Type Description <code>id</code> Id the \u026a\u1d05 of the worker engine that created the worker hash <code>batch_no</code> natural number the number of the batch into which the transaction was packed <code>length</code> natural number the number of transactions in the batch <code>signature</code> bytes the signature over the hash of the actual transaction list","boost":2},{"location":"arch/node/ordering/types/worker_hash.html","title":"WorkerHash","text":"<p>In V1, we do not use worker hashes in the sense of Narwhal or related DAG-based mempools.</p>","boost":2},{"location":"arch/node/ordering/types/write_label.html","title":"WriteLabel","text":"","boost":2},{"location":"arch/node/ordering/types/write_label.html#purpose","title":"Purpose","text":"<p>The WriteLabel specifies which keys a transaction may and will write to. The rationale behind this information is that if a transaction definitely write to a set of keys, there is no need to wait for previous read or writes to this key.</p>","boost":2},{"location":"arch/node/ordering/types/write_label.html#structure","title":"Structure","text":"Field Type Description <code>will_write</code> KVSKey set in V1, this is a generic set of keys that will be written <code>may_write</code> KVSKey set in V1, this is a generic set of keys that may be written <p>From V2 onward, after imposing a tree-structure on keys (or something similar), we can represent potentially infinite sets of keys.</p> (Wiki) links on this page<ul><li>KVSKey</li><li>KVSKey</li></ul>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html","title":"Types","text":"","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#chainid","title":"<code>ChainId</code>","text":"<p>Typhon might be operating one big multi-instance, several separate base ledgers, a bunch of \"binary\" chimera chains, etc. Each of these is identified by a single value of type <code>ChainId</code>.</p> <pre><code>/// Id of some chain/ instance/ \u2026\ntype ChainId = u64\n</code></pre>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#height","title":"<code>Height</code>","text":"<p>Heights occur in different contexts and flavours, e.g., the height of a consensus instance that is running for a specific anchor block in the mempool, the position of a block header in the chain of block headers relative to a single validator or the learner-specific height of an anchor block in the mempool \u1d05\u1d00\u0262.</p> <pre><code>/// Height\ntype Height = u64\n</code></pre>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#sequencenumber","title":"<code>SequenceNumber</code>","text":"<p>Each transaction in a batch of transactions (or transaction requests) has a sequence number assigned by the receiving worker. This number is relative to the current batch.</p> <pre><code>/// The sequence number of a transaction in a batch.\ntype SequenceNumber = u64\n</code></pre>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#batchnumber","title":"<code>BatchNumber</code>","text":"<p>Batches collected by workers have consecutive numbers. Each <code>BatchNumber</code>-<code>SequenceNumber</code> pair singles out a transaction collected at a worker.</p> <pre><code>/// The batch number of a batch relative to the history of all collected batches of the worker.\ntype SequenceNumber = u64\n</code></pre>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#timestamp","title":"<code>Timestamp</code>","text":"","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#clocktime","title":"<code>ClockTime</code>","text":"<p>Todo</p> <p>Tobias: What do we need this for? is this different from <code>Timestamp</code>?</p> <pre><code>type ClockTime = ()\n</code></pre>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#identity","title":"<code>Identity</code>","text":"<p>see Identity</p> <pre><code>/// Representation of (composable) identity\nstruct Identity {}\n</code></pre>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#hash","title":"<code>Hash</code>","text":"<p>A hash has the shape of sufficiently many bytes. <pre><code>/// Hash value, e.g., https://docs.rs/keccak-hash/latest/keccak_hash/struct.H256.html\ntype Hash = [u8; 32]\n</code></pre></p>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#signature","title":"<code>Signature</code>","text":"<pre><code>/// Digital signature\nstruct Signature {}\n</code></pre>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#learner","title":"<code>Learner</code>","text":"<p>One can think of a learner as a group of individual with the same trust assumptions.</p> <pre><code>/// Description of learner instances\nstruct Learner {\n    id : Identity,\n}\n</code></pre>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#quorums","title":"<code>Quorums</code>","text":"<pre><code>/// all learner-specific quorums in the shap of a map\ntype Quorums = std::collections::BTreeMap&lt;Learner,LiveQuorums&gt;\n</code></pre>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#livequorums","title":"<code>LiveQuorums</code>","text":"<p>This is \"just\" a set of quorums.</p> <pre><code>/// Description of a set of (learner-specific) qourums\ntype LiveQuorums = std::collections::BTreeSet&lt;LiveQuorum&gt;\n</code></pre>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#livequorum","title":"<code>LiveQuorum</code>","text":"<p>This is \"just\" a set of validators.</p> <pre><code>/// Description of a quorum\ntype LiveQuorum = std::collections::BTreeSet&lt;ValidatorId&gt;\n</code></pre>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#narwhalblockheader","title":"<code>NarwhalBlockHeader</code>","text":"<pre><code>/// Narwhal block header\nstruct NarwhalBlockHeader {}\n</code></pre>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#narwhalblock","title":"<code>NarwhalBlock</code>","text":"<pre><code>/// Narwhal block\nstruct NarwhalBlock {}\n</code></pre>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#transaction","title":"<code>Transaction</code>","text":"<pre><code>/// Executable code and the like\nstruct Transaction {}\n</code></pre>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#transactionexecutable","title":"<code>TransactionExecutable</code>","text":"<pre><code>struct TransactionExecutable {}\n</code></pre> <p>Todo</p> <p>Everything this transaction needs to do post-ordering, including any interesting calculations, or proof checks.</p>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#kvskey","title":"<code>KVSKey</code>","text":"<pre><code>struct KVSKey {}\n</code></pre> <p>Todo</p> <p>Keys in the key-value-store that is state. Currently unspecified.</p>","boost":2},{"location":"arch/node/ordering/types/allofthem/index.html#kvsdatum","title":"<code>KVSDatum</code>","text":"<pre><code>struct KVSDatum {}\n</code></pre> <p>Todo</p> <p>Data in the key-value-store that is state. Some kind of binary blob?</p>","boost":2},{"location":"arch/node/types/anoma.html","title":"Anoma","text":"Juvix imports <p><pre><code><pre>module arch.node.types.anoma;import arch.node.types.anoma_message open public;import arch.node.types.anoma_config open public;import arch.node.types.anoma_environment open public;</pre></code></pre></p>","tags":["Anoma","Juvix"]},{"location":"arch/node/types/anoma_config.html","title":"Anoma Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.types.anoma_config;</pre></code></pre></p>","boost":2},{"location":"arch/node/types/anoma_config.html#anoma-engine-configuration","title":"Anoma Engine Configuration","text":"<p>An Anoma engine configuration contains static, read-only configuration for an engine. See Engine Configuration for more information.</p> <p>Below is the definition of the type <code>Config</code>, which represents an Anoma engine configuration. This means that each Anoma engine instance has a constant configuration of type <code>Config</code>, initialised at creation.</p> <p>For example, a configuration for an engine instance of the engine <code>TickerEngine</code> is of type <code>TickerCfg</code>.</p> <pre><code><pre>type Cfg := CfgTicker;</pre></code></pre> (Wiki) links on this page<ul><li>Engine Configuration</li></ul>","boost":2},{"location":"arch/node/types/anoma_environment.html","title":"Anoma Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.types.anoma_environment;import arch.node.engines.template_environment open;import arch.node.engines.ticker_environment open;</pre></code></pre></p>","boost":2},{"location":"arch/node/types/anoma_environment.html#anoma-engine-environments","title":"Anoma Engine Environments","text":"<p>An Anoma engine environment is a collection of all the necessary information/context that an engine instance needs to operate. See Engine Environment for more information on engine environments.</p> <p>Below is the definition of the type <code>Env</code>, which represents an Anoma engine environment. This means, an Anoma engine instance would have an environment of type <code>Env</code>.</p> <p>For example, an environment for an engine instance of the engine <code>TickerEngine</code> is of type <code>TickerEnvironment</code>.</p> <pre><code><pre>type Env :=  | EnvTemplate TemplateEnv  | EnvTicker TickerEnv;</pre></code></pre> (Wiki) links on this page<ul><li>Engine Environment</li></ul>","boost":2},{"location":"arch/node/types/anoma_message.html","title":"Anoma Message","text":"Juvix imports <p><pre><code><pre>module arch.node.types.anoma_message;import arch.node.engines.template_messages open using {TemplateMsg};import arch.node.engines.ticker_messages open using {TickerMsg};</pre></code></pre></p>","tags":["Anoma-Message","Juvix"]},{"location":"arch/node/types/anoma_message.html#anoma-message","title":"Anoma Message","text":"<p>The Anoma message type contains all admissible messages that can be sent between nodes in the network. An Anoma message is of the type <code>Msg</code>. Each constructor of the type <code>Msg</code> corresponds to a specific type of message comming from a specific engine. For example, the engine <code>TickerEngine</code> has a corresponding message type <code>TickerMsg</code>.</p> <pre><code><pre>type Msg :=  | MsgTemplate TemplateMsg  | MsgTicker TickerMsg;</pre></code></pre>","tags":["Anoma-Message","Juvix"]},{"location":"arch/node/types/basics.html","title":"Basics","text":"Juvix imports <p><pre><code><pre>module arch.node.types.basics;import prelude open public;</pre></code></pre></p>","tags":["Juvix-types","Types"],"boost":2},{"location":"arch/node/types/basics.html#juvix-prelude-of-the-anoma-node-architecture","title":"Juvix Prelude of the Anoma Node Architecture","text":"<p>This document describes the basic types and functions used in the node architecture prelude. For a more general prelude, please refer to Juvix Base Prelude. (1)</p> <ol> <li> If you are unfamiliar with Juvix, please refer to the Juvix documentation.</li> </ol>","tags":["Juvix-types","Types"],"boost":2},{"location":"arch/node/types/basics.html#basic-types","title":"Basic types","text":"","tags":["Juvix-types","Types"],"boost":2},{"location":"arch/node/types/basics.html#hash","title":"Hash","text":"<p>Natural numbers are used (for now) to represent hash values, bytes sizes, and other non-negative integers.</p> <pre><code><pre>syntax alias Hash := Nat;</pre></code></pre>","tags":["Juvix-types","Types"],"boost":2},{"location":"arch/node/types/basics.html#reltime","title":"RelTime","text":"<p>Relative time. In seconds from now.</p> <pre><code><pre>syntax alias RelTime := Nat;</pre></code></pre>","tags":["Juvix-types","Types"],"boost":2},{"location":"arch/node/types/basics.html#abstime","title":"AbsTime","text":"<p>Absolute time. In minutes since epoch (2024-01-01 00:00).</p> <pre><code><pre>syntax alias AbsTime := Nat;</pre></code></pre>","tags":["Juvix-types","Types"],"boost":2},{"location":"arch/node/types/basics.html#time","title":"Time","text":"<p>Either absolute or relative time.</p> <pre><code><pre>Time : Type := Either RelTime AbsTime;</pre></code></pre>","tags":["Juvix-types","Types"],"boost":2},{"location":"arch/node/types/basics.html#version","title":"Version","text":"<p>Semantic version number (major.minor.patch).</p> <pre><code><pre>type Version : Type :=  mkVersion@{    major : Nat;    minor : Nat;    patch : Nat;  };</pre></code></pre> (Wiki) links on this page<ul><li>Juvix Base Prelude</li></ul>","tags":["Juvix-types","Types"],"boost":2},{"location":"arch/node/types/crypto.html","title":"Cryptographic Primitives","text":"Juvix imports <p><pre><code><pre>module arch.node.types.crypto;import prelude open;</pre></code></pre></p>","tags":["Juvix-types","Types","Cryptography","Crypto"],"boost":2},{"location":"arch/node/types/crypto.html#cryptographic-primitives","title":"Cryptographic primitives","text":"","tags":["Juvix-types","Types","Cryptography","Crypto"],"boost":2},{"location":"arch/node/types/crypto.html#public-key","title":"Public key","text":"<pre><code><pre>type PublicKey := Curve25519PubKey ByteString;instancePublicKeyOrd : Ord PublicKey :=  mkOrd@{    cmp := \\{_ _ := Equal};  };</pre></code></pre>","tags":["Juvix-types","Types","Cryptography","Crypto"],"boost":2},{"location":"arch/node/types/crypto.html#private-key","title":"Private key","text":"<pre><code><pre>type PrivateKey := Curve25519PrivKey ByteString;instancePrivateKeyOrd : Ord PrivateKey :=  mkOrd@{    cmp := \\{_ _ := Equal};  };</pre></code></pre>","tags":["Juvix-types","Types","Cryptography","Crypto"],"boost":2},{"location":"arch/node/types/crypto.html#signature","title":"Signature","text":"<p>Cryptographic signature.</p> <pre><code><pre>type Signature := Ed25519Signature ByteString;</pre></code></pre>","tags":["Juvix-types","Types","Cryptography","Crypto"],"boost":2},{"location":"arch/node/types/crypto.html#digest","title":"Digest","text":"<p>Message digest. Output of a cryptographic hash function.</p> <pre><code><pre>type Digest := Blake3Digest ByteString;</pre></code></pre>","tags":["Juvix-types","Types","Cryptography","Crypto"],"boost":2},{"location":"arch/node/types/engine.html","title":"Engine","text":"Juvix imports <p><pre><code><pre>module arch.node.types.engine;import prelude open;import arch.node.types.identities open;import arch.node.types.engine_config open public;import arch.node.types.engine_environment open public;import arch.node.types.engine_behaviour open public;</pre></code></pre></p>","tags":["engine-behaviour","engine-type","juvix"]},{"location":"arch/node/types/engine.html#the-type-for-engines","title":"The type for engines","text":"<p>An engine is a computational unit with a specific name and behaviour, plus an initial environment, which comprises the specific state, the mailbox cluster, the acquaintances, and the timers.</p> <p>We refer to the type of engines as <code>Engine</code>, instantiated with the following type parameters:</p> <ul> <li><code>A</code>: the type for the action arguments,</li> <li><code>C</code>: the type for the read-only engine configuration,</li> <li><code>S</code>: the type for the local engine-specific state,</li> <li><code>B</code>: the type for the mailbox state,</li> <li><code>H</code>: the type for the timer handles,</li> <li><code>AM</code>: the type for all engine messages (<code>Msg</code>)</li> <li><code>AC</code>: the type for all engine configurations (<code>Cfg</code>)</li> <li><code>AE</code>: the type for all engine environments (<code>Env</code>)</li> </ul> <p>Each engine, not its type, is associated with:</p> <ul> <li>a specific configuration, which contains the engine name (unique across the system), node ID, and engine-specific configuration,</li> <li>a declaration of its own execution context, that is,   the engine-specific local state, the mailbox cluster, the acquaintances, and the timers,</li> <li>as well as a specific behaviour.</li> </ul> <pre><code><pre>type Engine (C S B H A AM AC AE : Type) :=  mkEngine@{    cfg : EngineCfg C;    env : EngineEnv S B H AM;    behaviour : EngineBehaviour C S B H A AM AC AE;  };</pre></code></pre> <p>Engine type parameters</p> <p>In the related types to <code>Engine</code> such as <code>EngineBehaviour</code>, we try to follow the following convention:</p> <ul> <li>the type parameters are ordered such that they form a subsequence of the   type parameters sequence in the <code>Engine</code> type, and</li> <li>the first type parameter of <code>EngineBehaviour</code> is always <code>C</code>, the type for   the read-only engine configuration.</li> </ul> <p>Voting Engine</p> <p>As an example, we could define an engine type for a voting system:</p> <ul> <li><code>S</code> could be a record with fields like <code>votes</code>, <code>voters</code>, and <code>results</code>.</li> <li>The engine-specific message type might be a coproduct of <code>Vote</code> and <code>Result</code>.</li> <li> <p>The behaviour of this engine may include guarded actions such as:</p> <ul> <li><code>storeVote</code> to store a vote in the local state,</li> <li><code>computeResult</code> to compute the result of the election, and</li> <li><code>announceResult</code> to send the result to some other engine instances.</li> </ul> </li> </ul> <p>With each different election or kind of voters, we obtain a new engine instance, while the underlining voting system, the voting engine family, remains the same.</p> (Wiki) links on this page<ul><li>Engine Behaviour</li><li>Engine Environment</li><li>Engine Environment</li><li>Engine Behaviour</li></ul>","tags":["engine-behaviour","engine-type","juvix"]},{"location":"arch/node/types/engine_behaviour.html","title":"Engine Behaviour","text":"Juvix imports <p><pre><code><pre>module arch.node.types.engine_behaviour;import arch.node.types.basics open;import arch.node.types.messages open;import arch.node.types.identities open;import arch.node.types.engine_config open;import arch.node.types.engine_environment open;</pre></code></pre></p>","tags":["Engine","Behaviour","Juvix"]},{"location":"arch/node/types/engine_behaviour.html#engine-behaviour","title":"Engine behaviour","text":"<p>Each engine processes only one message at a time. The behaviour of an engine is specified by a finite set of guards and an action function, which both determine how engine instances react to received messages or timer notifications.</p>","tags":["Engine","Behaviour","Juvix"]},{"location":"arch/node/types/engine_behaviour.html#guards","title":"Guards","text":"<p>Guards are terms of type <code>Guard</code>, which is a function type, where the trigger of type <code>TimestampedTrigger H</code> is a term that captures the message received with a timestamp or a clock notification about timers that have elapsed during the engine's operation. Guards return data of type <code>GuardOutput A</code> if the precondition of the action that they are guarding is met.</p> <p>Recall that the behaviour is described by a set of guards and an action function. The guard is a function that evaluates conditions in the engine environment to determine what action should be performed; for this, each guard creates an action label, that then is \"interpreted\" by the action function.</p> <p>The guard function receives:</p> <ul> <li>the timestamped trigger that caused guard evaluation,</li> <li>the environment of the engine instance, and</li> <li>an optional time reference for the starting point of the evaluation of all guards.</li> </ul> <p>Given these inputs, the guard function computes an action label, which encodes</p> <ul> <li>all information necessary to infer how the engine will react</li> <li>additional information on how this action contributes to properties of the Anoma protocol instance the engine is part of.</li> </ul> <p>The action function then computes the effects of the action label; besides changes to the engine environment, an action effect comprises sending messages, creating new engine instances, and updating timers.</p>","tags":["Engine","Behaviour","Juvix"]},{"location":"arch/node/types/engine_behaviour.html#actions","title":"Actions","text":"","tags":["Engine","Behaviour","Juvix"]},{"location":"arch/node/types/engine_behaviour.html#action","title":"<code>Action</code>","text":"<p>The input of the action function is parameterised by the types for:</p> <ul> <li><code>C</code>: engine configuration,</li> <li><code>S</code>: local state,</li> <li><code>B</code>: mailbox state,</li> <li><code>H</code>: timer handles,</li> <li><code>A</code>: action arguments,</li> <li><code>AM</code>: type for all engine messages (<code>Msg</code>),</li> <li><code>AC</code>: type for all engine configurations (<code>Cfg</code>), and</li> <li><code>AE</code>: type for all engine environments (<code>Env</code>).</li> </ul> <p>The <code>Action</code> function receives as argument the <code>ActionInput</code>, and returns the <code>ActionEffect</code>.</p> <pre><code><pre>{-# isabelle-ignore: true #-}Action (C S B H A AM AC AE : Type) : Type :=  (input : ActionInput C S B H A AM) -&gt; Option (ActionEffect S B H AM AC AE);</pre></code></pre> On creating new engine instances <p>To create new engine instances, we need to specify the following data:</p> <ul> <li>A unique name for the new engine instance.</li> <li>The initial state of the engine instance.</li> <li>The corresponding set of guards and the action function.</li> </ul> <p>The last point is however implicit.</p> <p>If the guard does not give a result, this means that none of its guarded actions are triggered.</p> On the type signature of the guard function <p>In principle, borrowing terminology from Hoare logic, a guard is a precondition to run an action. The corresponding predicate is activated by a trigger and evaluated within the context of the engine's environment. It then returns a boolean when the predicate is satisfied, specifically of type</p> <pre><code>Trigger H AM -&gt; EngineEnv S B H AM -&gt; Bool;\n</code></pre> <p>However, as a design choice, guards will return additional data of type <code>GuardOutput A</code> that may or may not use the engine environment if the condition is met. Thus, if the guard is satisfied, this data (of type <code>GuardOutput A</code>) is assumed to be passed to the action function. Then, if the guard is not satisfied, no data is returned.</p>","tags":["Engine","Behaviour","Juvix"]},{"location":"arch/node/types/engine_behaviour.html#actioninput","title":"<code>ActionInput</code>","text":"<p>The <code>ActionInput</code> contains:</p> <ul> <li>the action arguments,</li> <li>the engine configuration,</li> <li>the engine environment, and</li> <li>the timestamped trigger that caused the guard evaluation.</li> </ul> <pre><code><pre>type ActionInput (C S B H A AM : Type) :=  mkActionInput@{    args : A;    cfg : EngineCfg C;    env : EngineEnv S B H AM;    trigger : TimestampedTrigger H AM;  };</pre></code></pre>","tags":["Engine","Behaviour","Juvix"]},{"location":"arch/node/types/engine_behaviour.html#actioneffect","title":"<code>ActionEffect</code>","text":"<p>The <code>ActionEffect S B H AM AC AE</code> type defines the effects produced by the action. The action can perform any of the following:</p> <ul> <li>Update the engine environment.</li> <li>Produce a set of messages to be sent to other engine instances.</li> <li>Set, discard, or supersede timers.</li> <li>Define new engine instances to be created.</li> </ul> <pre><code><pre>type ActionEffect (S B H AM AC AE : Type) :=  mkActionEffect@{    env : EngineEnv S B H AM;    msgs : List (EngineMsg AM);    timers : List (Timer H);    engines : List (Pair AC AE);  };</pre></code></pre>","tags":["Engine","Behaviour","Juvix"]},{"location":"arch/node/types/engine_behaviour.html#actionexec","title":"<code>ActionExec</code>","text":"<pre><code><pre>type ActionExec (C S B H A AM AC AE : Type) :=  Seq (List (Action C S B H A AM AC AE));</pre></code></pre>","tags":["Engine","Behaviour","Juvix"]},{"location":"arch/node/types/engine_behaviour.html#guard","title":"<code>Guard</code>","text":"<pre><code><pre>{-# isabelle-ignore: true #-}Guard (C S B H A AM AC AE : Type) : Type :=  (trigger : TimestampedTrigger H AM)    -&gt; (cfg : EngineCfg C)    -&gt; (env : EngineEnv S B H AM)    -&gt; Option (GuardOutput C S B H A AM AC AE);</pre></code></pre>","tags":["Engine","Behaviour","Juvix"]},{"location":"arch/node/types/engine_behaviour.html#guardoutput","title":"<code>GuardOutput</code>","text":"<p>The guard output defines an action sequence, the programmatic action to be performed, and action arguments.</p> <pre><code><pre>type GuardOutput (C S B H A AM AC AE : Type) :=  mkGuardOutput@{    action : ActionExec C S B H A AM AC AE;    args : A;  };</pre></code></pre>","tags":["Engine","Behaviour","Juvix"]},{"location":"arch/node/types/engine_behaviour.html#guardeval","title":"<code>GuardEval</code>","text":"<pre><code><pre>type GuardEval (C S B H A AM AC AE : Type) :=  | First (List (Guard C S B H A AM AC AE))  | Any (List (Guard C S B H A AM AC AE));</pre></code></pre> <p>The <code>GuardEval</code> type defines the criteria for evaluating actions associated with guards inside the given list. The evaluation strategies are as follows:</p> <ul> <li>With <code>First</code>, we say that the first guard in the provided list that holds, i.e., yields a result, upon sequential evaluation is selected, its associated action is performed, and the evaluation stops.</li> <li>With <code>Any</code>, we say that any guard in the provided list that holds upon sequential evaluation is selected, their associated actions are performed, and the evaluation stops.</li> </ul>","tags":["Engine","Behaviour","Juvix"]},{"location":"arch/node/types/engine_behaviour.html#the-type-for-engine-behaviours","title":"The type for engine behaviours","text":"<p>The <code>EngineBehaviour</code> type encapsulates the concept of behaviours within Anoma. Each engine is associated with a specific term of type <code>EngineBehaviour</code> that defines its core dynamics and operational characteristics. The behaviour determines how the engine processes inputs, manages state, and interacts with other components. As defined, it clears up that engines are essentially a collection of guarded state-transition functions. Using the terminology introduced earlier, an <code>EngineBehaviour</code> is a set of guards and an action function.</p> <pre><code><pre>type EngineBehaviour (C S B H A AM AC AE : Type) :=  mkEngineBehaviour@{guards : GuardEval C S B H A AM AC AE};</pre></code></pre>","tags":["Engine","Behaviour","Juvix"]},{"location":"arch/node/types/engine_config.html","title":"Engine Configuration","text":"Juvix imports <p><pre><code><pre>module arch.node.types.engine_config;import arch.node.types.basics open public;import arch.node.types.identities open;import arch.node.types.messages open;</pre></code></pre></p>","tags":["Engine","Config","Configuration","Juvix"]},{"location":"arch/node/types/engine_config.html#engine-configuration","title":"Engine configuration","text":"","tags":["Engine","Config","Configuration","Juvix"]},{"location":"arch/node/types/engine_config.html#engine-configuration-type","title":"Engine configuration type","text":"<p>The engine configuration contains the following static information for engine instances:</p> <ul> <li>A global reference, <code>name</code>, for the engine instance.</li> <li>The local <code>NodeID</code>.</li> <li>Engine-specific configuration.</li> </ul> <p>This is defined in the <code>EngineCfg</code> type, which is parametrized by:</p> <ul> <li><code>C</code>: represents the engine-specific configuration, which corresponds to the <code>Cfg</code> type.</li> </ul> <pre><code><pre>type EngineCfg (C : Type) :=  mkEngineCfg@{    node : NodeID;    name : EngineName;    cfg : C;  };</pre></code></pre>","tags":["Engine","Config","Configuration","Juvix"]},{"location":"arch/node/types/engine_config.html#getengineidfromenginecfg","title":"<code>getEngineIDFromEngineCfg</code>","text":"<ul> <li>Get the local <code>EngineID</code> from an <code>EngineCfg</code>:</li> </ul> <pre><code><pre>getEngineIDFromEngineCfg {C} (cfg : EngineCfg C) : EngineID :=  mkPair (some (EngineCfg.node cfg)) (EngineCfg.name cfg);</pre></code></pre>","tags":["Engine","Config","Configuration","Juvix"]},{"location":"arch/node/types/engine_environment.html","title":"Engine Environment","text":"Juvix imports <p><pre><code><pre>module arch.node.types.engine_environment;import arch.node.types.basics open public;import arch.node.types.identities open;import arch.node.types.messages open;</pre></code></pre></p>","tags":["Engine","Environment","Juvix"]},{"location":"arch/node/types/engine_environment.html#engine-environment","title":"Engine environment","text":"","tags":["Engine","Environment","Juvix"]},{"location":"arch/node/types/engine_environment.html#engine-environment-type","title":"Engine environment type","text":"<p>The engine environment contains the following dynamic information for engine instances:</p> <ul> <li>Local state whose type is specific to the engine.</li> <li>Mailbox cluster, which is a map of mailbox IDs to mailboxes.</li> <li>A set of names of acquainted engine instances. It is implicit that the engine   instance is acquainted with itself, so there is no need to include its own name.</li> <li>A list of timers that have been set.</li> </ul> <p>This data is encapsulated within the <code>EngineEnv</code> type, which is parameterised by four types, which represent:</p> <ul> <li><code>S</code>: the local state,</li> <li><code>B</code>: the type of mailboxes' states,</li> <li><code>H</code>: the type of handles for timers, and</li> <li><code>AM</code>: the type of all engine messages (<code>Msg</code>).</li> </ul> <p>These same letters will be used in the rest of the document to represent these types.</p> <pre><code><pre>type EngineEnv (S B H AM : Type) :=  mkEngineEnv@{    localState : S;    mailboxCluster : Map MailboxID (Mailbox B AM);    acquaintances : Set EngineName;    timers : List (Timer H);  };</pre></code></pre> On the mailbox cluster <p>The mailbox cluster is a map of mailbox IDs to mailboxes. The mailbox ID is an index type, and the mailbox is a record containing the following data:</p> <ul> <li>The enveloped messages that the mailbox contains.</li> <li>The mailbox state, which is of type <code>Option B</code>, i.e., it could be none.</li> </ul> <p>If you don't need multiple mailboxes, you can use any ID as the key. For example, you can use <code>0</code> for a default mailbox.</p>","tags":["Engine","Environment","Juvix"]},{"location":"arch/node/types/identities.html","title":"Identities","text":"Juvix imports <p><pre><code><pre>module arch.node.types.identities;import arch.node.types.crypto open public;import prelude open;</pre></code></pre></p>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#types-for-network-identities","title":"Types for network identities","text":"<p>Types in this section are used to represent identities within the network.</p>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#basic-types","title":"Basic Types","text":"","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#signable","title":"Signable","text":"<p>A type representing data that can be cryptographically signed.</p> <pre><code><pre>Signable : Type := ByteString;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#plaintext","title":"Plaintext","text":"<p>Raw unencrypted data.</p> <pre><code><pre>Plaintext : Type := ByteString;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#ciphertext","title":"Ciphertext","text":"<p>Encrypted data.</p> <pre><code><pre>Ciphertext : Type := ByteString;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#cryptographic-keys","title":"Cryptographic Keys","text":"<pre><code><pre>DecryptionKey : Type := ByteString;SigningKey : Type := ByteString;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#identity-types","title":"Identity Types","text":"","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#externalid","title":"ExternalID","text":"<p>A unique identifier, such as a public key, represented as a natural number.</p> <pre><code><pre>syntax alias ExternalID := PublicKey;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#internalid","title":"InternalID","text":"<p>A unique identifier, such as a private key, used internally within the network.</p> <pre><code><pre>syntax alias InternalID := PrivateKey;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#identity","title":"Identity","text":"<p>A pair combining an <code>ExternalID</code> and an <code>InternalID</code>.</p> <pre><code><pre>Identity : Type := Pair ExternalID InternalID;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#commitment","title":"Commitment","text":"<p>A cryptographic signature or commitment.</p> <pre><code><pre>syntax alias Commitment := Signature;axiom emptyCommitment : Commitment;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#network-identifiers","title":"Network Identifiers","text":"","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#nodeid","title":"NodeID","text":"<p>Cryptographic node identity.</p> <pre><code><pre>syntax alias NodeID := ExternalID;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#topicid","title":"TopicID","text":"<p>Cryptographic topic identity.</p> <pre><code><pre>syntax alias TopicID := ExternalID;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#domainid","title":"DomainID","text":"<p>Cryptographic domain identity.</p> <pre><code><pre>syntax alias DomainID := ExternalID;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#engine-related-types","title":"Engine Related Types","text":"","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#enginename","title":"EngineName","text":"<p>Engine instance name as an opaque string.</p> <pre><code><pre>syntax alias EngineName := String;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#externalidentity","title":"ExternalIdentity","text":"<p>An alias for engine name.</p> <pre><code><pre>syntax alias ExternalIdentity := EngineName;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#engineid","title":"EngineID","text":"<p>Engine instance identity combining node identity and engine name.</p> <pre><code><pre>EngineID : Type := Pair (Option NodeID) EngineName;isLocalEngineID (eid : EngineID) : Bool :=  case eid of    | mkPair none _ := true    | _ := false;isRemoteEngineID (eid : EngineID) : Bool := not (isLocalEngineID eid);</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#engine-helper-functions","title":"Engine Helper Functions","text":"<pre><code><pre>nameGen (str : String) (name : EngineName) (addr : EngineID) : EngineName :=  name ++str \"_\" ++str str ++str \"_\" ++str snd addr;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#string-comparison","title":"String Comparison","text":"<pre><code><pre>axiom stringCmp : String -&gt; String -&gt; Ordering;instanceStringOrd : Ord String :=  mkOrd@{    cmp := stringCmp;  };</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#identity-parameters-and-capabilities","title":"Identity Parameters and Capabilities","text":"","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#idparams","title":"IDParams","text":"<p>Supported identity parameter types.</p> <pre><code><pre>type IDParams :=  | Ed25519  | Secp256k1  | BLS;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#backend","title":"Backend","text":"<p>Backend connection types.</p> <pre><code><pre>type Backend :=  | BackendLocalMemory  | BackendLocalConnection@{subtype : String}  | BackendRemoteConnection@{externalIdentity : ExternalIdentity};</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#capabilities","title":"Capabilities","text":"<p>Available identity capabilities.</p> <pre><code><pre>type Capabilities :=  | CapabilityCommit  | CapabilityDecrypt  | CapabilityCommitAndDecrypt;</pre></code></pre>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#identity-evidence-types","title":"Identity Evidence Types","text":"","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#identityname","title":"IdentityName","text":"<p>Hierarchical identity naming structure.</p> <pre><code><pre>type IdentityName :=  | LocalName@{name : String}  | DotName@{      parent : ExternalIdentity;      child : String;    };</pre></code></pre> Instances <p><pre><code><pre>axiom IdentityNameCmpDummy : IdentityName -&gt; IdentityName -&gt; Ordering;instanceIdentityNameOrd : Ord IdentityName :=  mkOrd@{    cmp := IdentityNameCmpDummy;  };</pre></code></pre></p>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#readsforevidence","title":"ReadsForEvidence","text":"<p>Evidence of read permissions between identities.</p> <pre><code><pre>type ReadsForEvidence :=  mkReadsForEvidence@{    fromIdentity : ExternalIdentity;    toIdentity : ExternalIdentity;    proof : ByteString;  };</pre></code></pre> Instances <p><pre><code><pre>axiom ReadsForCmpDummy : ReadsForEvidence -&gt; ReadsForEvidence -&gt; Ordering;instanceReadsForOrd : Ord ReadsForEvidence :=  mkOrd@{    cmp := ReadsForCmpDummy;  };</pre></code></pre></p>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#signsforevidence","title":"SignsForEvidence","text":"<p>Evidence of signing permissions between identities.</p> <pre><code><pre>type SignsForEvidence :=  mkSignsForEvidence@{    fromIdentity : ExternalIdentity;    toIdentity : ExternalIdentity;    proof : ByteString;  };</pre></code></pre> Instances <p><pre><code><pre>axiom SignsForCmpDummy : SignsForEvidence -&gt; SignsForEvidence -&gt; Ordering;instanceSignsForOrd : Ord SignsForEvidence :=  mkOrd@{    cmp := SignsForCmpDummy;  };</pre></code></pre></p>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/identities.html#identitynameevidence","title":"IdentityNameEvidence","text":"<p>Evidence linking identity names to external identities.</p> <pre><code><pre>type IdentityNameEvidence :=  mkIdentityNameEvidence@{    identityName : IdentityName;    externalIdentity : ExternalIdentity;    proof : ByteString;  };</pre></code></pre> Instances <p><pre><code><pre>axiom IdentityNameEvidenceCmpDummy : IdentityNameEvidence  -&gt; IdentityNameEvidence  -&gt; Ordering;instanceIdentityNameEvidenceOrd : Ord IdentityNameEvidence :=  mkOrd@{    cmp := IdentityNameEvidenceCmpDummy;  };</pre></code></pre></p>","tags":["Juvix-types","Types","ID","Identity"],"boost":2},{"location":"arch/node/types/messages.html","title":"Messages & Mailboxes","text":"Juvix imports <p><pre><code><pre>module arch.node.types.messages;import prelude open public;import arch.node.types.basics open;import arch.node.types.crypto open;import arch.node.types.identities open;</pre></code></pre></p>","tags":["Juvix-types","Types","Message","Mailbox"],"boost":2},{"location":"arch/node/types/messages.html#messages-and-mailboxes","title":"Messages and mailboxes","text":"","tags":["Juvix-types","Types","Message","Mailbox"],"boost":2},{"location":"arch/node/types/messages.html#types","title":"Types","text":"<p>A message is a piece of data dispatched from one engine, termed the sender, to another engine, referred to as the target. When a message is sent, it is enveloped with additional metadata such as the target address and potentially the sender address, in case the sender wants to be identified. Upon arrival at the target engine, the message is stored in the target engine's mailboxes. These mailboxes are indexed by an identifier that are only unique to their engine. If the target engine has only one mailbox, the mailbox identifier is redundant.</p> <p>The following types are used to represent these messages and mailboxes.</p>","tags":["Juvix-types","Types","Message","Mailbox"],"boost":2},{"location":"arch/node/types/messages.html#enginemsg","title":"<code>EngineMsg</code>","text":"<p>An engine message is a message between engines. It consists of a sender, a target, an optional mailbox identifier, and the message itself.</p> <pre><code><pre>type EngineMsg M :=  mkEngineMsg@{    sender : EngineID;    target : EngineID;    mailbox : Option MailboxID;    msg : M;  };</pre></code></pre>","tags":["Juvix-types","Types","Message","Mailbox"],"boost":2},{"location":"arch/node/types/messages.html#enginemsgid","title":"<code>EngineMsgID</code>","text":"<p>An engine message identifier. The cryptographic hash of the corresponding <code>EngineMsg</code>.</p> <pre><code><pre>syntax alias EngineMsgID := Digest;</pre></code></pre>","tags":["Juvix-types","Types","Message","Mailbox"],"boost":2},{"location":"arch/node/types/messages.html#mailbox-s","title":"<code>Mailbox S</code>","text":"<p>A mailbox is a container for engine messages and optionally a mailbox state. The mailbox state could be used to store additional information about the mailbox, such as the priority of the messages in the mailbox.</p> Where does mailbox state come from? <p>The mailbox state is related to the capabilities of mailboxes of the paper <sup>1</sup>. In particular, at any given point in time, a mailbox will have a capability for receiving messages (in later versions of the specs). As mailbox state can be useful in general, we already have it now.</p> <pre><code><pre>type Mailbox S M :=  mkMailbox@{    messages : List (EngineMsg M);    mailboxState : Option S;  };</pre></code></pre>","tags":["Juvix-types","Types","Message","Mailbox"],"boost":2},{"location":"arch/node/types/messages.html#mailboxid","title":"<code>MailboxID</code>","text":"<p>A mailbox identifier is a natural number used to index mailboxes.</p> Where do mailbox identifiers come from? <p>The concept of mailbox identifier is taken from the paper <sup>1</sup> (see also Mailbox Cluster and <sup>2</sup>).</p> <pre><code><pre>syntax alias MailboxID := Nat;</pre></code></pre>","tags":["Juvix-types","Types","Message","Mailbox"],"boost":2},{"location":"arch/node/types/messages.html#timer-h","title":"<code>Timer H</code>","text":"<pre><code><pre>type Timer H :=  mkTimer@{    time : Time;    handle : H;  };</pre></code></pre>","tags":["Juvix-types","Types","Message","Mailbox"],"boost":2},{"location":"arch/node/types/messages.html#trigger-h","title":"<code>Trigger H</code>","text":"<pre><code><pre>type Trigger H M :=  | MessageArrived@{msg : EngineMsg M}  | Elapsed@{timers : List (Timer H)};</pre></code></pre> <ul> <li>Extract the <code>EngineMsg</code> from a trigger in case it has one:<p><pre><code><pre>getEngineMsgFromTrigger {H M} (tr : Trigger H M) : Option (EngineMsg M) :=  case tr of    | MessageArrived@{msg} := some msg    | Elapsed@{} := none;</pre></code></pre></p> </li> </ul> <ul> <li>Extract the <code>Msg</code> from a trigger in case it has one:<p><pre><code><pre>getMsgFromTrigger {H M} (tr : Trigger H M) : Option M :=  case tr of    | MessageArrived@{msg} := some (EngineMsg.msg msg)    | Elapsed@{} := none;</pre></code></pre></p> </li> </ul> <ul> <li>Get the message sender from a trigger:<p><pre><code><pre>getSenderFromTrigger {H M} (tr : Trigger H M) : Option EngineID :=  case tr of    | MessageArrived@{msg} := some (EngineMsg.sender msg)    | Elapsed@{} := none;</pre></code></pre></p> </li> </ul> <ul> <li>Get the target destination from a trigger:<p><pre><code><pre>getTargetFromTrigger {H M} (tr : Trigger H M) : Option EngineID :=  case tr of    | MessageArrived@{msg} := some (EngineMsg.target msg)    | Elapsed@{} := none;</pre></code></pre></p> </li> </ul>","tags":["Juvix-types","Types","Message","Mailbox"],"boost":2},{"location":"arch/node/types/messages.html#timestampedtrigger-h","title":"<code>TimestampedTrigger H</code>","text":"<pre><code><pre>type TimestampedTrigger H M :=  mkTimestampedTrigger@{    time : Time;    trigger : Trigger H M;  };</pre></code></pre> <ul> <li>Get the <code>EngineMsg</code> from a <code>TimestampedTrigger</code>:<p><pre><code><pre>getEngineMsgFromTimestampedTrigger  {H M} (tr : TimestampedTrigger H M) : Option (EngineMsg M) :=  getEngineMsgFromTrigger (TimestampedTrigger.trigger tr);</pre></code></pre></p> </li> </ul> <ul> <li>Get the <code>Msg</code> from a <code>TimestampedTrigger</code>:<p><pre><code><pre>getMsgFromTimestampedTrigger {H M} (tr : TimestampedTrigger H M) : Option M :=  getMsgFromTrigger (TimestampedTrigger.trigger tr);</pre></code></pre></p> </li> </ul> <ul> <li>Get the sender from a <code>TimestampedTrigger</code>:<p><pre><code><pre>getSenderFromTimestampedTrigger  {H M} (tr : TimestampedTrigger H M) : Option EngineID :=  getSenderFromTrigger (TimestampedTrigger.trigger tr);</pre></code></pre></p> </li> </ul> <ul> <li>Get the target from a <code>TimestampedTrigger</code>:<p><pre><code><pre>getTargetFromTimestampedTrigger  {H M} (tr : TimestampedTrigger H M) : Option EngineID :=  getTargetFromTrigger (TimestampedTrigger.trigger tr);</pre></code></pre></p> </li> </ul> <ol> <li> <p>Simon Fowler, Duncan Paul Attard, Franciszek Sowul, Simon J. Gay, and Phil Trinder. Special delivery: programming with mailbox types. Proceedings of the ACM on Programming Languages, 7(ICFP):78\u2013107, August 2023. URL: http://dx.doi.org/10.1145/3607832, doi:10.1145/3607832.\u00a0\u21a9\u21a9</p> </li> <li> <p>Shams M. Imam and Vivek Sarkar. Selectors: actors with multiple guarded mailboxes. AGERE! '14: Proceedings of the 4th International Workshop on Programming based on Actors Agents and Decentralized Control, October 2014. URL: http://dx.doi.org/10.1145/2687357.2687360, doi:10.1145/2687357.2687360.\u00a0\u21a9</p> </li> </ol>","tags":["Juvix-types","Types","Message","Mailbox"],"boost":2},{"location":"arch/system/index.html","title":"Introduction","text":"<p>We first describe on the highest level of abstraction what it means to be a correct implementation of Anoma and how it is structured. This already involves some design choices and assumptions, like identifying the participating entities, their actions, and the hardware needed.</p> <ul> <li>Identity Architecture</li> <li>Network Architecture</li> <li>Service Architecture</li> <li>State Architecture</li> </ul>","boost":2},{"location":"arch/system/prerequisite_primitives.html","title":"Prerequisite primitives","text":"","boost":2},{"location":"arch/system/prerequisite_primitives.html#canonical-compute-representation","title":"Canonical compute representation","text":"<p>The protocol requires a canonical serialisation of Turing-equivalent functions and data.</p> <p>A serialisation can be any function which maps data to a series of bytes. The inverse function which maps a series of bytes to data is referred to as a deserialisation.</p> <p>Being canonical for a serialisation \\(s\\) means that there exists a function \\(d\\) such that, for any function or data \\(x\\), all the agents using the protocol agree that the following equation holds.</p> \\[s(\\mathsf{eval}(d(x))) = x.\\] <p>In what follows, we assume any serialisation is canonical, unless otherwise specified. Internal representations of compute may vary as long as this external equivalence holds. Certain additional correspondences of internal representations may be required for particular verifiable computation schemes (see below).</p> <p>For the remainder of this specification, this canonical representation is taken as implicit, and may be assumed where appropriate (e.g. <code>serialise</code> is called before sending a function over the network).</p>","boost":2},{"location":"arch/system/prerequisite_primitives.html#cryptographic-components","title":"Cryptographic components","text":"","boost":2},{"location":"arch/system/prerequisite_primitives.html#canonical-collision-resistant-one-way-hash-function","title":"Canonical collision-resistant one-way hash function","text":"<p>The protocol requires a so-called \"hash\" function which computes a fixed-length output from a variable-length preimage.</p> <pre><code>hash :: ByteString -&gt; ByteString\n</code></pre> <p><code>hash</code> must be both one-way, in that it is not computationally feasible for any agent to compute the preimage from the hash output, and collision-resistant, in that it is not computationally feasible for any agent to find two different preimages which hash to the same value.</p> <p>Throughout the remainder of this document, serialisation can be assumed to take place first where appropriate, e.g. <code>hash</code> can be treated as synonymous with <code>hash . serialise</code>.</p> <p>This hash function does not necessarily need to be canonical - it could be negotiated between groups of agents - but for the sake of simplicity we will assume henceforth that it is.</p>","boost":2},{"location":"arch/system/prerequisite_primitives.html#verifiable-computation-scheme","title":"Verifiable computation scheme","text":"<p>We assume an abstract verifiable computation scheme operating over arbitrary types and relations such that all agents have access to the following interface:</p> <pre><code>class Proof p where\n    prove :: a -&gt; b -&gt; (a -&gt; b -&gt; Bool) -&gt; p\n    verify :: a -&gt; b -&gt; (a -&gt; b -&gt; Bool) -&gt; p -&gt; Bool\n</code></pre> <p>Subject to scheme-specific assumptions, this scheme should provide correctness:</p> <pre><code>correctness : Type\ncorrectness =\n    predicate a b = 1 -&gt; verify a b predicate (prove a b predicate) = 1\n</code></pre> <p>and also soundness:</p> <pre><code>soundness : Type\nsoundness =\n    predicate a b = 0 -&gt; forall proof . verify a b predicate proof = 0\n</code></pre> <p>This scheme may be instantiated in various ways with different properties and different assumptions, and the correctness, soundness, and scaling properties of compositions thereof will hold modulo the specific assumptions made.</p> <p>For example, let's take three common instantiations:</p> <ul> <li>The trivial scheme is one where computation is simply replicated. The   trivial scheme is defined as <code>verify(a, b, predicate, _) = predicate a b</code>   (with proof type <code>()</code>). It has no extra security assumptions but is not   succinct.</li> </ul> <ul> <li>The trusted delegation scheme is one where computation is delegated to a   known, trusted party whose work is not checked. The trusted delegation scheme   is defined as <code>verify(a, b, predicate, proof) = checkSignature (a, b,   predicate) proof</code>, where the trusted party is assumed to produce such a   signature only if <code>predicate a b = 1</code>. This scheme is succinct but requires a   trusted party assumption (which could be generalised to a threshold quorum in   the obvious way). Note that since the computation is still verifiable, a   signer of <code>(a, b, predicate)</code> where <code>predicate a b = 0</code> could be held   accountable by anyone else who later checked the predicate.</li> </ul> <ul> <li>The succinct proof-of-knowledge scheme is one where the result of computation is attested to with a cryptographic proof (of the sort commonly instantiated by modern-day SNARKs &amp; STARKs). Succint proof-of-knowledge schemes provide succinctness as well as veriability subject to the scheme-specific cryptographic assumptions. They may also possibly be zero-knowledge, in which the verifier learns nothing other than <code>predicate a b = 1</code> (in this case, and in others, <code>a</code> and <code>b</code> will often be \"hidden\" with hash functions, such that the verifier knows only <code>hash a</code> and <code>hash b</code> but the substance of the relation obtains over the preimages).</li> </ul> <p>Global consensus on the verifiable computation scheme is not required, and there is no canonical one, but agents must agree on a particular scheme to use for a particular case of verifiable computation, and agents must know the <code>Proof</code> type and <code>prove</code> / <code>verify</code> functions for any scheme which they use.</p>","boost":2},{"location":"arch/system/concepts/index.html","title":"Basic Concepts","text":"","boost":2},{"location":"arch/system/concepts/index.html#node","title":"Node","text":"<p>A node is run within and by an agent. Specifically, we can say that the agent dedicates a certain amount of storage, compute, and bandwidth resources to the node (these can change over time), configures it with their preferences, and the node runs autonomously using those resources, periodically soliciting or responding to inputs from the agent.</p> <p>In general, we assume that the node runs the protocol as defined in these specification documents. Other nodes running other protocols (including nodes on agents who have modified their implementation of the protocol) are out-of-scope, except insofar as we care about modeling arbitrary software run by potentially Byzantine parties.</p>","boost":2},{"location":"arch/system/concepts/index.html#observation","title":"Observation","text":"<p>Observations are made by agents. One kind of observations (name: TBD?) are made through the node, i.e. observations of state, and we want to reason about this kind for e.g. safety properties. The other kind are arbitrary observations by agents, and we want to reason about this kind for e.g. bounded disclosure properties (since malicious agents might not follow the protocol).=</p>","boost":2},{"location":"arch/system/identity/identity.html","title":"Identity Architecture","text":"Juvix imports <p><pre><code><pre>module arch.system.identity.identity;import prelude open;</pre></code></pre></p>","boost":2},{"location":"arch/system/identity/identity.html#identity-architecture","title":"Identity Architecture","text":"Type definitions <p><pre><code><pre>type OrdKey (OrdKey : Type) := mkOrdkey@{compare : OrdKey -&gt; OrdKey -&gt; Ordering};</pre></code></pre></p> <p><pre><code><pre>type HASH (OrdKeyType Hashable : Type) :=  mkHASH@{    ordKey : OrdKey OrdKeyType;    hash : Hashable -&gt; OrdKeyType;  };</pre></code></pre></p> <p><pre><code><pre>type OrdMap (OrdKeyType : Type) (MapCon : Type -&gt; Type) :=  mkOrdMap@{    ordKey : OrdKey OrdKeyType;    empty : {a : Type} -&gt; MapCon a;    map : {a b : Type} -&gt; (a -&gt; b) -&gt; MapCon a -&gt; MapCon b;    insert : {a : Type} -&gt; Pair (MapCon a) (Pair OrdKeyType a) -&gt; MapCon a;    foldl : {a b : Type} -&gt; (Pair a b -&gt; b) -&gt; b -&gt; MapCon a -&gt; b;    intersectWith : {a b c : Type}      -&gt; (Pair a b -&gt; c)      -&gt; Pair (MapCon a) (MapCon b)      -&gt; MapCon c;    all : {a : Type} -&gt; (a -&gt; Bool) -&gt; MapCon a -&gt; Bool;  };</pre></code></pre></p> <p>The base abstraction of the protocol is a knowledge-based identity  interface, where the identity of an agent is defined entirely on the  basis of whether or not they know some secret information.</p> <p>Agents can use private information (likely randomness) to create an  internal identity, from which they can derive an  external identity to which it corresponds. The external identity can be shared with other parties. The agent who knows the internal identity can sign messages, which any  agent who knows the external identity can verify, and any agent who  knows the external identity can encrypt messages which the agent with  knowledge of the internal identity can decrypt. This identity interface is independent of the particular cryptographic  mechanisms, which may vary.</p>","boost":2},{"location":"arch/system/identity/identity.html#identity-interface","title":"Identity Interface","text":"","boost":2},{"location":"arch/system/identity/identity.html#internal-identity","title":"Internal Identity","text":"<p>An internal identity includes private information necessary for signing and  decryption. Formally, an internal identity has two parts: a Signer and a Decryptor.</p>","boost":2},{"location":"arch/system/identity/identity.html#signer-juvix-type","title":"Signer Juvix Type","text":"<p>A signature describing a type <code>SignerType</code> that can cryptographically  <code>sign</code> (or credibly commit) to something (a <code>Signable</code>), forming a  <code>Commitment</code>. Implementations should ultimately include, for example  BLS keys,   which should be able to sign anything that can be marshaled into a   bitstring.</p> <p>Properties:</p> <ul> <li> <p>In general, every <code>S : Signer</code> needs a corresponding <code>V : Verifier</code>, and   every <code>s : SignerType</code> needs a corresponding <code>v : VerifierType</code>, such that:</p> <ul> <li>For any message <code>m</code> : <code>verify v m x = (x = (sign s m))</code></li> </ul> <ul> <li>for most cryptosystems, a computationally bounded adversary should not be   able to approximate <code>s</code> knowing only <code>v</code>.</li> </ul> </li> </ul> <pre><code><pre>type Signer (SignerType Signable Commitment : Type) :=  mkSigner@{sign : SignerType -&gt; Signable -&gt; Commitment};</pre></code></pre>","boost":2},{"location":"arch/system/identity/identity.html#decryptor-juvix-type","title":"Decryptor Juvix Type","text":"<p>A signature describing a type <code>DecryptorType</code> that can cryptographically  <code>decrypt</code> something (a <code>Ciphertext</code>), resulting in a <code>Plaintext</code>  (or <code>none</code>, if decryption fails). Implementations should ultimately include, for example,  AES-256  keys,  which should be able to decrypt bitstrings into anything that  can be unmarshaled from a bitstring.</p> <p>Properties:</p> <ul> <li>a computationally bounded adversary should not be able to   approximate <code>decrypt d</code> without knowledge of <code>d</code>.</li> </ul> <ul> <li><code>decrypt</code> should take polynomial time (in the size of its inputs)</li> </ul> <ul> <li> <p>Each <code>D : Decryptor</code> should have a corresponding <code>E : Encryptor</code>, and   each <code>d : DecryptorType</code> has a corresponding <code>e : EncryptorType</code> such   that:</p> <ul> <li>for all <code>c : Ciphertext</code>, <code>p : Plaintext</code>:   <code>decrypt d c = Some p</code> iff <code>c = encrypt e p</code></li> </ul> <ul> <li>if <code>d = e</code>, we call this \"symmetric encryption,\" and otherwise   it's \"asymmetric encryption\"</li> </ul> </li> </ul> <pre><code><pre>type Decryptor (DecryptorType Plaintext Ciphertext : Type) :=  mkDecryptor@{decrypt : DecryptorType -&gt; Ciphertext -&gt; Option Plaintext};</pre></code></pre>","boost":2},{"location":"arch/system/identity/identity.html#internal-identity-juvix-type","title":"Internal Identity Juvix Type","text":"<p>An Internal Identity structure simply specifies everything specified by both Signer and Decryptor.</p> <p>An Internal Identity structure specifies the necessary types and  functions for both a Signer and a Decryptor. Implementations should ultimately include, for example,  RSA private keys,  which should be able to decrypt integers into anything that can be  unmarshaled from a bitstring, and sign anything which can be  marshaled into a bytestring to form an integer.</p> <p>An internal_identity includes:</p> <ul> <li>a type <code>SignerType</code> that can cryptographically   <code>sign</code> (or credibly commit) to something (a <code>Signable</code>), forming a   <code>Commitment</code>.</li> </ul> <ul> <li>a type <code>DecryptorType</code> that can cryptographically <code>decrypt</code> something   (a <code>Ciphertext</code>), resulting in a <code>Plaintext</code>   (or <code>none</code>, if decryption fails).</li> </ul> <p>Properties are inherited from <code>Signer</code> and <code>Decryptor</code>.</p> <pre><code><pre>type InternalIdentity (SignerType Signable Commitment DecryptorType Plaintext Ciphertext : Type) :=  mkInternalIdentity@{    signer : Signer SignerType Signable Commitment;    decryptor : Decryptor DecryptorType Plaintext Ciphertext;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/identity.html#external-identity","title":"External Identity","text":"<p>An external identity includes only public information. An external identity can verify signatures produced by an internal identity, and encrypt messages the internal identity can then decrypt. Formally, an external identity has two parts: a verifier and an Encryptor. Each is hashable: any structure specifying verifier and Encryptor types must also specify a hash function, so that external identities can be specified by hash.</p>","boost":2},{"location":"arch/system/identity/identity.html#verifier-juvix-type","title":"Verifier Juvix Type","text":"<p>A signature describing a type <code>VerifierType</code> that can cryptographically  <code>verify</code> that a <code>Commitment</code> (or cryptographic signature) corresponds  to a given message (a <code>Signable</code>), and was signed by the <code>SignerType</code>  corresponding to this <code>VerifierType</code>. A <code>VerifierType</code> can be hashed (producing a unique identifier), so a  structure with signature <code>Verifier</code> must specify a <code>VerifierHash</code>  structure defining a suitable <code>hash</code> function. Implementations should ultimately include, for example  BLS  identities.</p> <p>Properties:</p> <ul> <li> <p>In general, every <code>V : Verifier</code> needs a corresponding <code>S : Signer</code>, and   every <code>s : SignerType</code> needs a corresponding <code>v : VerifierType</code>, such that:</p> <ul> <li>For any message <code>m</code> : <code>verify v m x = (x = (sign s m))</code></li> </ul> <ul> <li>for most cryptosystems, a computationally bounded adversary should not be   able to approximate <code>s</code> knowing only <code>v</code>.</li> </ul> </li> </ul> <pre><code><pre>type Verifier (OrdKey VerifierType Signable Commitment : Type) :=  mkVerifier@{    verify : VerifierType -&gt; Signable -&gt; Commitment -&gt; Bool;    verifierHash : HASH OrdKey VerifierType;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/identity.html#encryptor-juvix-type","title":"Encryptor Juvix Type","text":"<p>A signature describing a type <code>EncryptorType</code> that can cryptographically  <code>encrypt</code> a <code>Plaintext</code> (message) to create a <code>Ciphertext</code> readable  only by the corresponding <code>DecryptorType</code>. An <code>EncryptorType</code> can be hashed (producing a unique identifier), so a  structure with signature <code>Encryptor</code> must specify an <code>encryptorHash</code>  structure defining a suitable hash function. Implementations should ultimately include, for example,  AES-256  keys,  which should be able to decrypt bitstrings into anything that  can be  unmarshaled from a bitstring.</p> <p>Properties:</p> <ul> <li><code>encrypt</code> should take polynomial time (in the size of its inputs)</li> </ul> <ul> <li> <p>Each <code>E : Encryptor</code> should have a corresponding <code>D : Decryptor</code>, and   each <code>d : DecryptorType</code> has a corresponding <code>e : EncryptorType</code> such   that:</p> <ul> <li>for all <code>c : Ciphertext</code>, <code>p : Plaintext</code>:   <code>decrypt d c = Some p</code> iff <code>c = encrypt e p</code></li> </ul> <ul> <li>if <code>d = e</code>, we call this \"symmetric encryption,\" and otherwise   it's \"asymmetric encryption.\"   In an asymmetric cryptosystem, a computationally bounded adversary   should not be able to approximate <code>d</code> knowing only <code>e</code>.</li> </ul> </li> </ul> <pre><code><pre>type Encryptor (OrdKey EncryptorType Plaintext Ciphertext : Type) :=  mkEncryptor@{    encrypt : EncryptorType -&gt; Plaintext -&gt; Ciphertext;    encryptorHash : HASH OrdKey EncryptorType;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/identity.html#external-identity-juvix-type","title":"External Identity Juvix Type","text":"<p>An External Identity structure specifies the necessary types and  functions for both a Verifier and an Encryptor. Implementations should ultimately include, for example,  RSA public keys.</p> <p>An external_identity includes:</p> <ul> <li>a type <code>VerifierType</code> that can cryptographically <code>verify</code> that a   <code>Commitment</code> (or cryptographic signature) corresponds to a given   message (a <code>Signable</code>), and was signed by the <code>SignerType</code>   corresponding to this <code>VerifierType</code>.</li> </ul> <ul> <li>a type <code>EncryptorType</code> that can cryptographically <code>encrypt</code> a   <code>Plaintext</code> (message) to create a <code>Ciphertext</code> readable only by the   corresponding <code>DecryptorType</code>.</li> </ul> <p>Properties are inherited from <code>Verifier</code> and <code>Encryptor</code>.</p> <pre><code><pre>type ExternalIdentity (VerifierOrdKeyType VerifierType Signable Commitment EncryptorOrdKeyType EncryptorType Plaintext Ciphertext : Type) :=  mkExternalIdentity@{    verifier : Verifier VerifierOrdKeyType VerifierType Signable Commitment;    encryptor : Encryptor      EncryptorOrdKeyType      EncryptorType      Plaintext      Ciphertext;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/identity.html#identity-juvix-type","title":"Identity Juvix Type","text":"<p>An Identity structure, formally, specifies all the types for  corresponding internal and external identities. So, for a given Identity structure <code>I</code>, its <code>VerifierType</code> should be the  type of objects that can verify <code>Commitment</code>s produced by a  corresponding object of type <code>SignerType</code>. Likewise, its <code>DecryptorType</code> should be the type of objects that can decrypt  <code>Ciphertext</code>s produced by a corresponding object of type  <code>EncryptorType</code>. Implementations should ultimately include, for example,  RSA  public / private keys sytems.</p> <p>An Identity includes:</p> <ul> <li>a type <code>SignerType</code> that can cryptographically <code>sign</code> (or credibly commit) to something (an <code>InternalSignable</code>), forming an <code>InternalCommitment</code>.</li> </ul> <ul> <li>a type <code>DecryptorType</code> that can cryptographically <code>decrypt</code> something (an <code>InternalCiphertext</code>), resulting in an <code>InternalPlaintext</code> (or <code>none</code>, if decryption fails).</li> </ul> <ul> <li>a type <code>VerifierType</code> that can cryptographically <code>verify</code> that an <code>ExternalCommitment</code> (or cryptographic signature) corresponds to a given message (an <code>ExternalSignable</code>), and was signed by the <code>SignerType</code> corresponding to this <code>VerifierType</code>.</li> </ul> <ul> <li>a type <code>EncryptorType</code> that can cryptographically <code>encrypt</code> an <code>ExternalPlaintext</code> (message) to create an <code>ExternalCiphertext</code> readable only by the corresponding <code>DecryptorType</code>.</li> </ul> <p>Properties are inherited from <code>Verifier</code>, <code>Encryptor</code>, <code>Signer</code>, and <code>Decryptor</code>.</p> <pre><code><pre>type Identity (SignerType InternalSignable InternalCommitment DecryptorType InternalCiphertext InternalPlaintext VerifierOrdKeyType VerifierType ExternalSignable ExternalCommitment EncryptorOrdKeyType EncryptorType ExternalPlaintext ExternalCiphertext : Type) :=  mkIdentity@{    internalIdentity : InternalIdentity      SignerType      InternalSignable      InternalCommitment      DecryptorType      InternalPlaintext      InternalCiphertext;    externalIdentity : ExternalIdentity      VerifierOrdKeyType      VerifierType      ExternalSignable      ExternalCommitment      EncryptorOrdKeyType      EncryptorType      ExternalPlaintext      ExternalCiphertext;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/identity.html#signsfor-relation","title":"SignsFor Relation","text":"<p>Some identities may have the authority to sign statements on behalf of other  identities. For example, Alice might grant Bob the authority to sign arbitrary messages on her behalf. We write this relationship as Bob <code>signsFor</code> Alice.</p> <p>In general, <code>signsFor</code> is a partial order over identities. This means <code>signsFor</code> is transitive: if A <code>signsFor</code> B and B <code>signsFor</code> C, then A <code>signsFor</code> C. The <code>signsFor</code> relation becomes especially useful with regard to composed identities, discussed below.</p>","boost":2},{"location":"arch/system/identity/identity.html#signsfor-evidence","title":"SignsFor Evidence","text":"<p>We do not specify all the ways one might know if one identity <code>signsFor</code> another. In general, an Identity Engine might accept (and perhaps store) a variety of forms of evidence as proof. As one simple form of evidence, we can specify a format for signed statements from B that proves some specified A <code>signsFor</code> B.</p> <p>Note that <code>signsFor</code> evidence cannot be revoked, and so a <code>signsFor</code> relation is not stateful: it cannot depend on the current state of, for example, a blockchain.</p>","boost":2},{"location":"arch/system/identity/identity.html#signsfor-juvix-type","title":"SignsFor Juvix Type","text":"<p>Formally, a <code>signsFor</code> relation requires a type of evidence, and a  <code>Verifier</code> structure. This codifies a belief about what <code>VerifierType</code>'s <code>Commitments</code> are  \"at least as good as\" another <code>VerifierType</code>'s. Evidence can be signed statements, proofs, or even local state about beliefs.</p> <p>For example, suppose <code>Alice</code> wants to grant authority to <code>Bob</code> to  <code>sign</code> on her behalf. Nodes who want to take this into account might accept some sort of  <code>e : Evidence</code>, perhaps a signed statement from <code>Alice</code>, so that they  can recognize that <code>signsFor e (Bob, Alice)</code>.</p> <p>Note that <code>signsFor</code> is not symmetric: <code>signsFor e (x,y)</code> does not  imply that any <code>z</code> exists such that <code>signsFor z (y,x)</code>.</p> <pre><code><pre>type SignsFor (OrdKey VerifierType Signable Commitment Evidence : Type) :=  mkSignsFor@{    verifier : Verifier OrdKey VerifierType Signable Commitment;    signsFor : Evidence -&gt; Pair VerifierType VerifierType -&gt; Bool;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/identity.html#signsfor-equivalence","title":"SignsFor Equivalence","text":"<p>We can also define a kind of identity equivalence : A <code>signsSameAs</code> B  precisely when A <code>signsFor</code> B and B <code>signsFor</code> A. This means that (in  general), if you want to sign a message as A, but for whatever reason it's cheaper to sign a message as B, it's safe to just use B instead, and vice  versa.</p>","boost":2},{"location":"arch/system/identity/identity.html#readsfor-relation","title":"ReadsFor Relation","text":"<p>Similar to <code>signsFor</code>, it is useful to sometimes note that one identity can read  information encrypted to another identity. For example, suppose Alice gives her private <code>DecryptorType</code> to Bob, and wants to let everyone know that Bob can  now read anything encrypted to Alice. Nodes who want to take this into  account might accept some sort of <code>evidence</code>, perhaps a signed statement from Alice, so that they can recognize that Bob <code>readsFor</code> Alice.</p> <p>Like <code>signsFor</code>, <code>readsFor</code> is a partial order over identities. This means <code>readsFor</code> is transitive: if A <code>readsFor</code> B and B <code>readsFor</code> C, then A <code>readsFor</code> C. The <code>readsFor</code> relation becomes especially useful with regard to composed identities, discussed below.</p>","boost":2},{"location":"arch/system/identity/identity.html#readsfor-evidence","title":"ReadsFor Evidence","text":"<p>We do not specify all the ways one might know if one identity <code>readsFor</code>  another. In general, an Identity Engine might accept (and perhaps store) a variety of forms of evidence as proof. As one simple form of  evidence, we can specify a format for signed statements from B that proves A <code>readsFor</code> B.</p>","boost":2},{"location":"arch/system/identity/identity.html#readsfor-juvix-type","title":"ReadsFor Juvix Type","text":"<p>Formally, a <code>readsFor</code> relation requires a type of evidence, and an  <code>Encryptor</code> structure. This codifies a belief about what <code>Decryptor</code>s can read other  <code>Encryptor</code>s ciphertext. Evidence can be signed statements, proofs, or even local state about beliefs.</p> <p>Specifically, if a node expresses a <code>readsFor</code> relation, and  <code>readsFor e (x,y)</code>, then the node believes that any node knowing the  decryptor corresponding to <code>x</code> can decrypt <code>encrypt y p</code>. If there is some Plaintext <code>p</code> such that some node knowing a decryptor  corresponding to <code>x</code> cannot read <code>encrypt y p</code>, then the node's  beliefs, as encoded in the <code>readsFor</code> relation, are incorrect.</p> <p>For example, suppose <code>Alice</code> gives her private <code>DecryptorType</code> to <code>Bob</code>,  and wants to let everyone know that <code>Bob</code> can now read anything  encrypted to <code>Alice</code>. Nodes who want to take this into account might accept some sort of  <code>e : Evidence</code>, perhaps a signed statement from <code>Alice</code>, so that they  can recognize that <code>readsFor e (Bob, Alice)</code>.</p> <p>Note that <code>readsFor</code> is not symmetric: <code>readsFor e (x,y)</code> does not  imply that any <code>z</code> exists such that <code>readsFor z (y,x)</code>.</p> <pre><code><pre>type ReadsFor (OrdKey EncryptorType Plaintext Ciphertext Evidence : Type) :=  mkReadsFor@{    encryptor : Encryptor OrdKey EncryptorType Plaintext Ciphertext;    readsFor : Evidence -&gt; Pair EncryptorType EncryptorType -&gt; Bool;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/identity.html#equivalence","title":"Equivalence","text":"<p>We can also define a kind of identity equivalence: A <code>readsSameAs</code> B precisely when A <code>readsFor</code> B and B <code>readsFor</code> A. This means that, in general, if you want to encrypt a message to A, but for whatever reason it's cheaper to encrypt a message for B, it's safe to just use B instead, and vice versa.</p> <p>In total, A <code>equivalent</code> B when A <code>readsSameAs</code> B and A <code>signsSameAs</code> B. This means that (in general) A and B can be used interchangeably.</p>","boost":2},{"location":"arch/system/identity/identity.html#composition","title":"Composition","text":"<p>There are a variety of ways to refer to groups of identities as  single, larger identities.</p>","boost":2},{"location":"arch/system/identity/identity.html#threshold-composition","title":"Threshold Composition","text":"<p>Suppose we want an identity M that refers to any majority from a  set of shareholders. A signature from M would require that a majority of shareholders  participated in signing, and encrypting information for M would  require that a majority of shareholders participate in decryption. To construct M, we start with a set of shareholder identities, each  paired with a weight (their share), and define a weight threshold  which specifies the minimum weight for a \"majority.\"</p> <p>There are several ways we could imagine constructing Threshold  Composition Identities, but without specifying anything about the  underlying identities:</p> <ul> <li>A threshold composition identity signature is a map from (hashes of)    external identities, to signatures.   To verify a signature for some message <code>x</code>, we verify each signature    with <code>x</code> and its external identity, and check that the weights of    the external identities sum to at least the threshold.</li> </ul> <ul> <li>A threshold composition identity encrypted message is a map from    (hashes of) external identities, to ciphertexts.   To decrypt, any subset of internal identities with weights summing    to at least the threshold must decrypt their corresponding    ciphertexts, and the resulting plaintexts must be combined using an    erasure coding scheme.</li> </ul>","boost":2},{"location":"arch/system/identity/identity.html#threshold-composition-juvix-type-signer-and-verifier","title":"Threshold Composition Juvix Type (Signer and verifier)","text":"<p>A <code>ThresholdCompose</code> <code>VerifierType</code> consists of a  threshold (<code>Nat</code>), and a set of <code>VerifierType</code>s, each paired with a  weight (<code>Nat</code>).  (this set is encoded as a <code>Map.map</code> from hashes of <code>verifiers</code> to   <code>Pair Nat VerifierType</code> pairs). <code>Commitments</code> are simply <code>Map</code>s from hashes of the underlying  identities to <code>Commitments</code> signed by that identitity. A <code>Commitment</code> verifies iff the set of valid Commitments included  correspond to a set of <code>verifiers</code> whose weights sum to at least  the threshold. Note that this satisfies both signatures <code>Verifier</code> and <code>Signer</code>.</p> <p>In general, <code>ThresholdCompose</code> <code>SignerType</code>s and <code>VerifierType</code>s may not be  used much directly. Instead, nodes can make more efficient identities (using cryptographic  signature aggregation techniques), and express their relationship to  <code>ThresholdCompose</code> <code>VerifierType</code>s as a <code>SignsFor</code> relationship. This will let nodes reason about identities using simple  <code>ThresholdCompose</code> <code>VerifierType</code>s, while actually using more efficient  implementations.</p> <p>Formally, to specify a <code>ThresholdCompose</code>, we need:</p> <ul> <li><code>verifier</code>, the structure of the underlying <code>Verifiers</code>.</li> </ul> <ul> <li><code>signer</code>, the corresponding structure of the underlying <code>Signers</code>.</li> </ul> <ul> <li><code>map : OrdMap</code>, to be used to encode weights and <code>Commitment</code>s.   (Note that this needs the <code>OrdKey</code> to be the hash type of the    underlying <code>verifier</code>)</li> </ul> <ul> <li><code>thresholdComposeHash</code>, which specifies a <code>hash</code> function that can    hash our composed <code>VerifierType</code>s (type <code>ComposeHashable VerifierType MapCon</code>).</li> </ul> <pre><code><pre>type ComposeHashable (VerifierType : Type) (MapCon : Type -&gt; Type) :=  mkComposeHashable@{    threshold : Nat;    weights : MapCon (Pair Nat VerifierType);  };</pre></code></pre> <p>A <code>ThresholdCompose</code> structure provides:</p> <ul> <li><code>map : OrdMap</code> the underlying <code>OrdMap</code> used in    <code>VerifierType</code> and <code>Commitment</code></li> </ul> <ul> <li><code>underlyingVerifier : Verifier</code> the structure describing    the types of the underlying <code>VerifierType</code>s which can be composed.</li> </ul> <ul> <li><code>underlyingSigner : Signer</code> the structure describing    the types of the underlying <code>SignerType</code>s which can be composed.</li> </ul> <ul> <li><code>VerifierHash : HASH</code> describes the hash function for    hashing these composed <code>verifiers</code></li> </ul> <ul> <li>The <code>SignerType</code> type of the composed verifiers is the type of composed signers.    These are just <code>MapCon Commitment</code>, meaning each is    stored under the hash of the corresponding    <code>VerifierType</code>.    This <code>SignerType</code> does not need to encode weights or threshold.</li> </ul> <ul> <li>The <code>VerifierType</code> type of composed verifiers. These are    <code>ComposeHashable VerifierType MapCon</code></li> </ul> <ul> <li>The <code>Signable</code> type , being the type of message that can be signed. This is    exactly the same as what the underlying verifiers can sign    (<code>Signable</code> of <code>underlyingVerifier</code>).</li> </ul> <ul> <li>The <code>Commitment</code> type describes composed signatures, these are a    <code>MapCon</code> from hashes of underlying verifiers to signatures    (<code>Commitment</code> of <code>underlyingVerifier</code>)</li> </ul> <ul> <li>The <code>sign</code> function creates a <code>Commitment</code> using all    <code>underlyingSigner</code> <code>SignerType</code>s in the composed <code>SignerType</code>.</li> </ul> <ul> <li>The <code>verify</code> function returns true iff the set of valid Commitments included    correspond to a set of <code>underlyingVerifier</code> <code>VerifierType</code>s whose weights    sum to at least the threshold.</li> </ul> <ul> <li>The <code>signerCompose</code> function constructs a composed <code>SignerType</code> from a list of    <code>Pair VerifierType SignerType</code> pairs.    Note that each <code>SignerType</code> must be paired with its correct <code>VerifierType</code>,     or the composed <code>SignerType</code> will not produce verifiable     <code>Commitment</code>s.</li> </ul> <ul> <li> <p>The <code>verifierCompose</code> function is useful for constructing the composition of    a list of verifiers.   Returns a composed <code>VerifierType</code>.   Its arguments are:</p> <ul> <li>the threshold (<code>Nat</code>)</li> </ul> <ul> <li>a <code>list</code> of weights(<code>Nat</code>), <code>VerifierType</code> pairs.</li> </ul> </li> </ul> <ul> <li>The <code>verifierAnd</code> function creates a composed <code>VerifierType</code> that is the \"&amp;&amp;\" of    two input verifiers: a <code>SignerType</code> must encode the information of the    signers for both <code>x</code> and <code>y</code> to sign statements <code>verifierAnd x y</code>    will verify.</li> </ul> <ul> <li>The <code>verifierOr</code> function creates a composed <code>VerifierType</code> that is the \"||\" of    two input verifiers: a <code>SignerType</code> must encode the information of the    signers for either <code>x</code> or <code>y</code> to sign statements <code>verifierOr x y</code>    will verify.</li> </ul> <pre><code><pre>type ThresholdCompose (OrdKey : Type) (MapCon : Type  -&gt; Type) (VerifierType Signable Commitment SignerType VerifierHashOrdKeyType : Type) :=  mkThresholdCompose@{    map : OrdMap OrdKey MapCon;    underlyingVerifier : Verifier OrdKey VerifierType Signable Commitment;    underlyingSigner : Signer SignerType Signable Commitment;    verifierHash : HASH      VerifierHashOrdKeyType      (ComposeHashable VerifierType MapCon);    sign : MapCon SignerType -&gt; Signable -&gt; MapCon Commitment;    verify : ComposeHashable VerifierType MapCon      -&gt; Signable      -&gt; MapCon Commitment      -&gt; Bool;    signerCompose : List (Pair VerifierType SignerType) -&gt; MapCon SignerType;    verifierCompose : Nat      -&gt; List (Pair Nat VerifierType)      -&gt; ComposeHashable VerifierType MapCon;    verifierAnd : VerifierType      -&gt; VerifierType      -&gt; ComposeHashable VerifierType MapCon;    verifierOr : VerifierType      -&gt; VerifierType      -&gt; ComposeHashable VerifierType MapCon;  };</pre></code></pre> <pre><code><pre>projectVerifier  {MapCon : Type -&gt; Type}  {OrdKey VerifierType Signable Commitment SignerType VerifierHashOrdKeyType : Type}  (tc : ThresholdCompose    OrdKey    MapCon    VerifierType    Signable    Commitment    SignerType    VerifierHashOrdKeyType)  : Verifier    VerifierHashOrdKeyType    (ComposeHashable VerifierType MapCon)    Signable    (MapCon Commitment) :=  mkVerifier@{    verify := ThresholdCompose.verify tc;    verifierHash := ThresholdCompose.verifierHash tc;  };</pre></code></pre> <pre><code><pre>ThresholdComposeFunctor  {MapCon : Type -&gt; Type}  {OrdKey VerifierType Signable Commitment SignerType VerifierHashOrdKeyType : Type}  (verifier : Verifier OrdKey VerifierType Signable Commitment)  (signer : Signer SignerType Signable Commitment)  (mapIn : OrdMap OrdKey MapCon)  (thresholdComposeHash : HASH    VerifierHashOrdKeyType    (ComposeHashable VerifierType MapCon))  : ThresholdCompose    OrdKey    MapCon    VerifierType    Signable    Commitment    SignerType    VerifierHashOrdKeyType :=  mkThresholdCompose@{    map := mapIn;    underlyingVerifier := verifier;    underlyingSigner := signer;    verifierHash := thresholdComposeHash;    sign := \\{s m := OrdMap.map map \\{i := Signer.sign underlyingSigner i m} s};    verify :=      \\{| (mkComposeHashable t ws) s c :=        t          &lt;= OrdMap.foldl            map            \\{(mkPair x y) := x + y}            0            (OrdMap.intersectWith              map              \\{| (mkPair (mkPair w v) x) :=                ite (Verifier.verify underlyingVerifier v s x) w 0}              (mkPair ws c))};    signerCompose :=      \\{l :=        foldl          \\{m (mkPair v s) :=            OrdMap.insert              map              (mkPair                m                (mkPair                  (HASH.hash (Verifier.verifierHash underlyingVerifier) v)                  s))}          (OrdMap.empty map)          l};    verifierCompose :=      \\{threshold weights :=        mkComposeHashable          threshold          (foldl            \\{m (mkPair w v) :=              OrdMap.insert                map                (mkPair                  m                  (mkPair                    (HASH.hash (Verifier.verifierHash underlyingVerifier) v)                    (mkPair w v)))}            (OrdMap.empty map)            weights)};    verifierAnd := \\{x y := verifierCompose 2 [mkPair 1 x; mkPair 1 y]};    verifierOr := \\{x y := verifierCompose 1 [mkPair 1 x; mkPair 1 y]};  };</pre></code></pre> <p>While this construction is rather naive, it is general, and crucially, we can reason about  equivalence with any number of more interesting schemes:</p> <ul> <li>We can show that a threshold RSA signature scheme <code>signsSameAs</code> as a Threshold Composition    Identity.</li> </ul> <ul> <li>We can show that a secret sharing scheme <code>readsSameAs</code> a Threshold Composition Identity.</li> </ul> <p>By phrasing our discussion in terms of equivalence and Threshold Composition Identities, we can  abstract over the actual cryptography used. We can also derive some <code>signsFor</code> and <code>readsFor</code>  relations that must hold, by looking at the relations that must hold for Threshold Composition Identities:</p>","boost":2},{"location":"arch/system/identity/identity.html#signsfor-threshold-composition","title":"<code>signsFor</code> Threshold Composition","text":"<p>Like any identity, Threshold Composition Identities can define any number of ways to delegate signing power, or be delegated signing power. However, some cases should always hold: A <code>signsFor</code> B if every identity in A has no more weight (divided by threshold) than identities it <code>signsFor</code> in B. This implies that any collection of identities that can sign as A can also sign as B.</p> <p>A <code>signsFor</code> relation for easy comparison of   <code>ThresholdCompose</code> <code>VerifierType</code>s  x <code>signsFor</code> y if every underlying VerifierType in x has no more   weight (divided by threshold) as verifiers it <code>signsFor</code> in y. This implies that anything which can sign as x can also sign  as y.</p> <p>This requires an underlying <code>S : SignsFor</code> for comparing the weighted  signers in x and y, which in turn may require evidence. No additional evidence is required.</p> <p>Other parameters necessary to define the <code>ThresholdCompose</code> <code>verifiers</code> include:</p> <ul> <li><code>signer</code>, the corresponding structure of the underlying <code>signers</code>.</li> </ul> <ul> <li><code>map : OrdMap</code>, to be used to encode weights and <code>Commitment</code>s.   (Note that this needs <code>OrdKey</code> to be the hash type of the    underlying <code>verifier</code>)</li> </ul> <ul> <li><code>thresholdComposeHash</code>, which specifies a <code>hash</code> function that can    hash our composed <code>VerifierType</code>s (type    <code>ComposeHashable VerifierType MapCon</code>).</li> </ul> <pre><code><pre>type ThresholdComposeSignsFor (OrdKey VerifierType Signable Commitment Evidence : Type) (MapCon : Type  -&gt; Type) VerifierHashOrdKeyType :=  mkThresholdComposeSignsFor@{    underlyingSignsFor : SignsFor      OrdKey      VerifierType      Signable      Commitment      Evidence;    verifier : ThresholdCompose      OrdKey      MapCon      VerifierType      Signable      Commitment      VerifierType      VerifierHashOrdKeyType;    signsFor : Evidence      -&gt; Pair        (ComposeHashable VerifierType MapCon)        (ComposeHashable VerifierType MapCon)      -&gt; Bool;  };</pre></code></pre> <pre><code><pre>projectSignsFor  {OrdKey VerifierType Signable Commitment Evidence : Type}  {MapCon : Type -&gt; Type}  {VerifierHashOrdKeyType : Type}  (tc : ThresholdComposeSignsFor    OrdKey    VerifierType    Signable    Commitment    Evidence    MapCon    VerifierHashOrdKeyType)  : SignsFor    VerifierHashOrdKeyType    (ComposeHashable VerifierType MapCon)    Signable    (MapCon Commitment)    Evidence :=  mkSignsFor@{    verifier := projectVerifier (ThresholdComposeSignsFor.verifier tc);    signsFor := ThresholdComposeSignsFor.signsFor tc;  };</pre></code></pre> <pre><code><pre>ThresholdComposeSignsForFunctor  {OrdKey VerifierType Signable Commitment Evidence : Type}  {MapCon : Type -&gt; Type}  {VerifierHashOrdKeyType : Type}  (S : SignsFor OrdKey VerifierType Signable Commitment Evidence)  (signer : Signer VerifierType Signable Commitment)  (map : OrdMap OrdKey MapCon)  (thresholdComposeHash : HASH    VerifierHashOrdKeyType    (ComposeHashable VerifierType MapCon))  : ThresholdComposeSignsFor    OrdKey    VerifierType    Signable    Commitment    Evidence    MapCon    VerifierHashOrdKeyType :=  mkThresholdComposeSignsFor@{    underlyingSignsFor := S;    verifier :=      ThresholdComposeFunctor        (SignsFor.verifier underlyingSignsFor)        signer        map        thresholdComposeHash;    signsFor :=      \\{e (mkPair (mkComposeHashable t0 w0) (mkComposeHashable t1 w1)) :=        OrdMap.all          map          \\{(mkPair w v) :=            w * t1              &lt;= OrdMap.foldl                  map                  \\{(mkPair (mkPair x v1) s) :=                    ite                      (SignsFor.signsFor underlyingSignsFor e (mkPair v v1))                      (x + s)                      s}                  0                  w1                * t0}          w0};  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/identity.html#encryptor-threshold-composition","title":"<code>Encryptor</code> Threshold Composition","text":"<p>DANGER: NOT YET IMPLEMENTED</p> <p>Implementing this requires secret sharing.  The threshold composed <code>encryptor</code> is a threshold, and a set of weights  paired with <code>UnderlyingEncryptor.encryptor</code>s. There are stored in a <code>Map.map</code>  under their hashes, to ensure uniqueness.</p> <p>The idea is that an encrypted <code>plaintext</code> should only be  decryptable by a <code>decryptor</code> that encodes the information from a  set of <code>decryptor</code>s corresponding to a set of <code>encryptor</code>s whose  weight sums to at least the threshold.</p> <pre><code><pre>type ThresholdComposeEncryptor (OrdKey EncryptorType Plaintext Ciphertext : Type) (MapCon : Type  -&gt; Type) (EncryptorHashOrdKeyType : Type) :=  mkThresholdComposeEncryptor@{    map : OrdMap OrdKey MapCon;    underlyingEncryptor : Encryptor OrdKey EncryptorType Plaintext Ciphertext;    encryptorHash : HASH      EncryptorHashOrdKeyType      (ComposeHashable EncryptorType MapCon);    compose : Nat      -&gt; List (Pair Nat EncryptorType)      -&gt; ComposeHashable EncryptorType MapCon;    encrypt : ComposeHashable EncryptorType MapCon -&gt; Plaintext -&gt; Ciphertext;  };</pre></code></pre> <pre><code><pre>projectEncryptor  {OrdKey EncryptorType Plaintext Ciphertext}  {MapCon : Type -&gt; Type}  {EncryptorHashOrdKeyType}  (tc : ThresholdComposeEncryptor    OrdKey    EncryptorType    Plaintext    Ciphertext    MapCon    EncryptorHashOrdKeyType)  : Encryptor    EncryptorHashOrdKeyType    (ComposeHashable EncryptorType MapCon)    Plaintext    Ciphertext :=  mkEncryptor@{    encrypt := ThresholdComposeEncryptor.encrypt tc;    encryptorHash := ThresholdComposeEncryptor.encryptorHash tc;  };</pre></code></pre> <pre><code><pre>axiom encrypt_DUMMY : {EncryptorType Plaintext Ciphertext : Type}  -&gt; {MapCon : Type -&gt; Type}  -&gt; ComposeHashable EncryptorType MapCon  -&gt; Plaintext  -&gt; Ciphertext;</pre></code></pre> <pre><code><pre>ThresholdComposeEncryptorFunctor  {OrdKey EncryptorType Plaintext Ciphertext}  {MapCon : Type -&gt; Type}  {EncryptorHashOrdKeyType}  (encryptor : Encryptor OrdKey EncryptorType Plaintext Ciphertext)  (mapIn : OrdMap OrdKey MapCon)  (thresholdComposeHash : HASH    EncryptorHashOrdKeyType    (ComposeHashable EncryptorType MapCon))  : ThresholdComposeEncryptor    OrdKey    EncryptorType    Plaintext    Ciphertext    MapCon    EncryptorHashOrdKeyType :=  mkThresholdComposeEncryptor@{    map := mapIn;    underlyingEncryptor := encryptor;    encryptorHash := thresholdComposeHash;    compose :=      \\{t w :=        mkComposeHashable@{          threshold := t;          weights :=            foldl              \\{m (mkPair w e) :=                OrdMap.insert                  map                  (mkPair                    m                    (mkPair                      (HASH.hash                        (Encryptor.encryptorHash underlyingEncryptor)                        e)                      (mkPair w e)))}              (OrdMap.empty map)              w;        }};    encrypt := encrypt_DUMMY;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/identity.html#readsfor-threshold-composition","title":"<code>readsFor</code> Threshold Composition","text":"<p>Like any identity, ThresholdCompositionIdentities can have arbitrary  <code>readsFor</code> relationships. However, some cases should always hold : A <code>readsFor</code> B if every  identity in A has no more weight (divided by threshold) than  identities it <code>readsFor</code> in B. This implies that any collection of identities that can read messages  encrypted with A can also read messages encrypted as B.</p> <p>A <code>readsFor</code> relation for easy comparison of   <code>ThresholdComposeEncryptor</code> <code>EncryptorType</code>s  x <code>readsFor</code> y if every underlying <code>EncryptorType</code> in x has no more   weight (divided by threshold) as encryptors it <code>readsFor</code> in y. This implies that anything which can decrypt as x can also decrypt  as y.</p> <p>This requires an underlying <code>R : ReadsFor</code> for comparing the weighted  encryptors in  x and y, which in turn may require evidence. No additional evidence is required.</p> <pre><code><pre>type ThresholdComposeReadsFor (OrdKey EncryptorType Plaintext Ciphertext Evidence : Type) (MapCon : Type  -&gt; Type) (EncryptorHashOrdKeyType : Type) :=  mkThresholdComposeReadsFor@{    underlyingReadsFor : ReadsFor      OrdKey      EncryptorType      Plaintext      Ciphertext      Evidence;    encryptor : ThresholdComposeEncryptor      OrdKey      EncryptorType      Plaintext      Ciphertext      MapCon      EncryptorHashOrdKeyType;    readsFor : Evidence      -&gt; Pair        (ComposeHashable EncryptorType MapCon)        (ComposeHashable EncryptorType MapCon)      -&gt; Bool;  };</pre></code></pre> <pre><code><pre>projectReadsFor  {OrdKey VerifierType Signable Commitment Evidence}  {MapCon : Type -&gt; Type}  {EncryptorHashOrdKeyType : Type}  (tc : ThresholdComposeReadsFor    OrdKey    VerifierType    Signable    Commitment    Evidence    MapCon    EncryptorHashOrdKeyType)  : ReadsFor    EncryptorHashOrdKeyType    (ComposeHashable VerifierType MapCon)    Signable    Commitment    Evidence :=  mkReadsFor@{    encryptor := projectEncryptor (ThresholdComposeReadsFor.encryptor tc);    readsFor := ThresholdComposeReadsFor.readsFor tc;  };</pre></code></pre> <pre><code><pre>ThresholdComposeReadsForFunctor  {OrdKey EncryptorType Plaintext Ciphertext Evidence}  {MapCon : Type -&gt; Type}  {EncryptorHashOrdKeyType}  (r : ReadsFor OrdKey EncryptorType Plaintext Ciphertext Evidence)  (map : OrdMap OrdKey MapCon)  (thresholdComposeHash : HASH    EncryptorHashOrdKeyType    (ComposeHashable EncryptorType MapCon))  : ThresholdComposeReadsFor    OrdKey    EncryptorType    Plaintext    Ciphertext    Evidence    MapCon    EncryptorHashOrdKeyType :=  mkThresholdComposeReadsFor@{    underlyingReadsFor := r;    encryptor :=      ThresholdComposeEncryptorFunctor        (ReadsFor.encryptor underlyingReadsFor)        map        thresholdComposeHash;    readsFor :=      \\{e (mkPair (mkComposeHashable t0 w0) (mkComposeHashable t1 w1)) :=        OrdMap.all          map          \\{(mkPair w v) :=            w * t1              &lt;= OrdMap.foldl                  map                  \\{(mkPair (mkPair x v1) s) :=                    ite                      (ReadsFor.readsFor underlyingReadsFor e (mkPair v v1))                      (x + s)                      s}                  0                  w1                * t0}          w0};  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/identity.html#and-identities","title":"\"And\" Identities","text":"<p>We can compose identities with conjunction: A <code>&amp;&amp;</code> B is the identity which requires an agent to have both A's internal identity and B's internal identity to sign or decrypt. It represents A and B working together. In practice, A <code>&amp;&amp;</code> B can be defined as a special case of Threshold composition (see <code>verifierAnd</code> above).</p>","boost":2},{"location":"arch/system/identity/identity.html#or-identities","title":"\"Or\" Identities","text":"<p>We can compose identities with disjunction as well: A <code>||</code> B requires an agent to have either A's internal identity or B's internal identity. It represents either A or B, without specifying which. In practice, A <code>||</code> B can be defined as a special case of Threshold Composition (see <code>verifierOr</code> above).</p> <p>In principle, we could define things differently: Threshold Composition could be defined using <code>&amp;&amp;</code> and <code>||</code> as primitives, by building a disjunction of every possible conjunction that satisfies the threshold. In several important cases, however, this takes much more space to express, so we use the equally general and more numerically efficient threshold composition abstraction.</p>","boost":2},{"location":"arch/system/identity/identity.html#opaque-composition","title":"Opaque Composition","text":"<p>A group of agents can also compose an opaque identity such that composition information is not available to the outside. One example would be using distributed key generation and a threshold cryptosystem e.g. Threshold RSA. Here the agents compute one RSA keypair together, with only shares of the private key being generated by each agent. Decryption of messages encrypted to the single public key then requires cooperation of a subset of agents holding key shares, fulfilling the threshold requirements. This group would have a single External Identity based on a regular RSA public key, and it would not necessarily be clear how the identity was composed.</p> <p>Specific evidence could prove that this threshold cryptosystem identity is <code>equivalent</code> to some  <code>ThresholdCompose</code> identity. This kind of proof requires <code>readsFor</code> and <code>signsFor</code> relations tailored to the cryptosystem used. Once equivalence is proven, however, one could use the threshold  cryptosystem identity for efficiency, but reason using the  <code>ThresholdCompose</code> identity.</p>","boost":2},{"location":"arch/system/identity/identity.html#special-identities","title":"Special identities","text":"<p>The following special identities illustrate the generality of our identity abstractions:</p>","boost":2},{"location":"arch/system/identity/identity.html#true-all","title":"\"true / All\"","text":"<p>Anyone can sign and decrypt (<code>verify</code> returns true and <code>encrypt</code> returns the <code>Plaintext</code>). No secret knowledge is required, so all agents can take on this identity.</p> <p>The true identity preserves structure under conjunction (x <code>&amp;&amp;</code> true <code>equivalent</code> x) and forgets structure under disjunction (x <code>||</code> true <code>equivalent</code> true).</p>","boost":2},{"location":"arch/system/identity/identity.html#false-none","title":"\"false / None\"","text":"<p>No one can sign or decrypt (<code>verify</code> returns false and <code>encrypt</code>  returns empty string). No secret knowledge exists that fulfills these  requirements, so no agent can take on this identity.</p> <p>The false identity forgets structure under disjunction  (x <code>&amp;&amp;</code> false <code>equivalent</code> false) and preserves structure under  disjunction (x <code>||</code> false <code>equivalent</code> x).</p>","boost":2},{"location":"arch/system/identity/identity.html#identity-names","title":"Identity Names","text":"<p>Sometimes it is useful to have a name for an external identity before the relevant cryptographic values are available. For example, we might refer to \"a quorum of validators from chain <code>X</code> at epoch <code>Y</code>\". Before epoch <code>Y</code> has begun, chain <code>X</code> may not have yet decided who constitutes a quorum.</p> <p>It would be possible to build a <code>Verifier</code>, where the evidence that the signers are in fact a quorum of validators from chain <code>X</code> at epoch <code>Y</code> is part of the signature. One might later build a simpler <code>Verifier</code>, which elides this evidence, and then prove that the two <code>signsSameAs</code> using the evidence. However, barring some really exciting cryptography, we'd need to know the quorums from chain <code>X</code> at epoch <code>Y</code> before we could make an <code>Encryptor</code>.</p> <p>We therefore introduce a new type, Identity Name, which represents a placeholder to be filled in when an appropriate external identity can be found. Specifically, each type of identity name comes with a predicate, which can be satisfied by an external identity, and accompanying evidence. Identity names can also be hashed, like external identities.</p> <p>Identity names can be described in two structures: one for checking that  a <code>VerifierType</code> corresponds with an <code>IdentityName</code>, and one for checking  that an <code>EncryptorType</code> corresponds with an <code>IdentityName</code>. The same name can refer to both a <code>VerifierType</code> and an <code>EncryptorType</code>.</p>","boost":2},{"location":"arch/system/identity/identity.html#verifier-name-juvix-type","title":"Verifier Name Juvix Type","text":"<p>An <code>IdentityName</code> can be mapped to an appropriate <code>VerifierType</code>  when suitable <code>Evidence</code> is found. Here, <code>checkVerifierName</code> defines what evidence is acceptable for a  <code>VerifierType</code>.</p> <p>Note that <code>IdentityName</code>s are also hashable: we require a structure  <code>verifierNameHash</code> that details how to hash them.</p> <pre><code><pre>type VerifierName OrdKey VerifierType Signable Commitment Evidence IdentityName VerifierNameHashOrdKeyType :=  mkVerifierName@{    verifier : Verifier OrdKey VerifierType Signable Commitment;    checkVerifierName : IdentityName -&gt; VerifierType -&gt; Evidence -&gt; Bool;    verifierNameHash : HASH VerifierNameHashOrdKeyType IdentityName;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/identity.html#encryptor-name-juvix-type","title":"Encryptor Name Juvix Type","text":"<p>An <code>IdentityName</code> can be mapped to an appropriate Encryptor <code>EncryptorType</code>  when suitable <code>Evidence</code> is found. Here, <code>checkEncryptorName</code> defines what evidence is acceptable for an  <code>Encryptor</code> <code>EncryptorType</code>. Note that <code>IdentityName</code>s are also hashable: we require a structure  <code>encryptorNameHash</code> that details how to hash them.</p> <pre><code><pre>type EncryptorName OrdKey EncryptorType Plaintext Ciphertext Evidence IdentityName EncryptorNameHashOrdKeyType :=  mkEncryptorName@{    verifier : Encryptor OrdKey EncryptorType Plaintext Ciphertext;    checkEncryptorName : IdentityName -&gt; EncryptorType -&gt; Evidence -&gt; Bool;    encryptorNameHash : HASH EncryptorNameHashOrdKeyType IdentityName;  };</pre></code></pre> <p>For example, for the identity name \"a quorum of validators from chain <code>X</code> at epoch <code>Y</code>\", a satisfying external identity would be composed from the validators selected for epoch <code>Y</code>, and the accompanying evidence would be a light-client proof from chain <code>X</code> that these are the correct validators for epoch <code>Y</code>.</p> <p>Note that multiple identity names can refer to the same external identity, and in principle, multiple external identities could have the same identity name. Usually, multiple external identities only have the same identity name when there is Byzantine behaviour, but that is not explicitly part of the identity abstractions at this layer.</p>","boost":2},{"location":"arch/system/identity/identity.html#sub-identities","title":"Sub-Identities","text":"<p>One particularly common case for identity names is when one party (the super-identity) wants to designate a specific name they use to refer to another identity. Here, the super-identity is acting like a certificate authority: they designate which external identity corresponds with this identity name. This sub-identity is often something the super-identity controls: a specific machine they own, or a process they run on that machine. Such a sub-identity might be associated with a string, such as <code>\"acceptor\"</code>, which might designate the process participating in consensus within a validator. In this case, the predicate should check that the super-identity has signed a statement declaring that the external identity matches the sub-identity.</p>","boost":2},{"location":"arch/system/identity/identity.html#notation","title":"\".\" Notation","text":"<p>Because sub-identities using string names are so common, we have a short-cut notation for expressing identity names. Given some identity Alice, for any string <code>\"foo\"</code>, Alice.foo is an identity name. For example, even before they learn anything about Alice, validators might refer to Alice.acceptor to mean the specific process Alice is running to participate in consensus. The identity Alice can sign statements to let people know what external identity they should (immutably) use for Alice.foo or Alice.acceptor. These are left associative, so Alice.foo can designate Alice.foo.bar (shorthand for (Alice.foo).bar) and Alice.foo.bar can designate Alice.foo.bar.baz (shorthand for ((Alice.foo).bar).baz), and so on. These are a special case of sub-identities: X.Y is a sub-identity of X.</p> <p>Formally, we use <code>mkPair (hash Alice) \"foo\"</code> as the Juvix representation of Alice.foo:</p> <p>A specific kind of identity name, wher ethe evidence is a signed  statement from a specified parent saying that it associates this  VerifierType with a specific <code>name</code>.</p> <p>Here,</p> <ul> <li><code>Name</code> is the type the parent identifies with a child.   For example, for <code>name = string</code>, and some identity Alice, we can specify   <code>(hash(Alice),\"bob\")</code>, or Alice.bob, as the identity that   Alice refers to as <code>\"bob\"</code>.</li> </ul> <ul> <li><code>child</code> : <code>Verifier</code> type that can be identified with a name.</li> </ul> <ul> <li> <p><code>parent</code> : <code>Verifier</code> type that signs evidence statements.</p> <p>Crucially, it must be able to sign tuples of the form (string, name, child's hash type) In our example, where Alice refers to Bob as Alice.<code>\"bob\"</code>, <code>child</code> describes Bob, <code>parent</code> describes Alice, and <code>name</code> describes <code>\"bob\"</code>.</p> </li> </ul> <ul> <li><code>hash</code> Describes what will become the <code>verifierNameHash</code>.   Crucially, it must be able to hash pairs of the form   (parent's hash type, name)</li> </ul> <pre><code><pre>SubVerifierFunctor  (OrdKey VerifierType Signable Commitment Name ParentOrdKeyType : Type)  (child : Verifier OrdKey VerifierType Signable Commitment)  (parent : Verifier    ParentOrdKeyType    VerifierType    (Pair String (Pair Name OrdKey))    Commitment)  (hash : HASH ParentOrdKeyType (Pair ParentOrdKeyType Name))  : VerifierName    OrdKey    VerifierType    Signable    Commitment    (Pair VerifierType Commitment)    (Pair ParentOrdKeyType Name)    ParentOrdKeyType :=  mkVerifierName@{    verifier := child;    checkVerifierName :=      \\{(mkPair ph n) c (mkPair pv pc) :=        Verifier.verify            parent            pv            (mkPair              \"I identify this verifier with this name : \"              (mkPair n (HASH.hash (Verifier.verifierHash child) c)))            pc          &amp;&amp; OrdKey.compare              (HASH.ordKey (Verifier.verifierHash parent))              ph              (HASH.hash (Verifier.verifierHash parent) pv)            == Equal};    verifierNameHash := hash;  };</pre></code></pre> <p>In other words, we have a specific, standardized thing an external identity can sign to designate that another external identity corresponds to a \".\" name.</p> <p>Note that we can use \".\" sub-identities for purposes other than identifying identities that the super-identity controls. Alice might have a friend Bob, and designate his external identity as Alice.bob. This is an example of a place where \"sub-identity-ness\" is not transitive: Alice.bob.carol is (Alice.bob).carol, a sub-identity of Alice.bob, so it is up to Bob to designate which external identity he associates with <code>\"carol\"</code>, and Alice has no say: Alice.bob.carol is not a sub-identity of Alice.</p>","boost":2},{"location":"arch/system/identity/identity.html#identity-engine","title":"Identity Engine","text":"<p>In practice, using Identity Names requires each physical machine to maintain a mapping from identity names to known external identities. The machine does not have to store the accompanying evidence for each, although it might be useful to do so sometimes (for example, in order to present to a third party). When any process on that machine wants to do any operation using an identity name instead of an external identity, it can query this mapping to see if there is a known external identity to use for that operation.</p> <p>An Identity Engine can also store evidence for known <code>signsFor</code> and <code>readsFor</code> relationships, and help choose which external identity is most efficient for a task. For example, if an agent wants to encrypt a message to \"a quorum of validators from chain <code>X</code> at epoch <code>Y</code>\", they would first resolving the identity name to an identity (possibly a Threshold Composed Identity), and might then ask if there is some known equivalent identity (such as a threshold encryption identity) with cheaper encryption.</p>","boost":2},{"location":"arch/system/identity/identity.html#identity-name-resolution","title":"Identity Name Resolution","text":"<p>There is no general mechanism for finding external identities (and accompanying evidence) for arbitrary identity names, with arbitrary forms of evidence. However, for some common types of identity names, such as \".\" sub-identities, we can establish a standard server and query language, which participating Identity Engines can query to resolve those identity names.</p>","boost":2},{"location":"arch/system/identity/index.html","title":"Index","text":"Juvix imports <p><pre><code><pre>module arch.system.identity.index;import prelude open;</pre></code></pre></p>","boost":2},{"location":"arch/system/identity/index.html#identity-architecture","title":"Identity Architecture","text":"Type definitions <p><pre><code><pre>type OrdKey (OrdKey : Type) := mkOrdkey@{compare : OrdKey -&gt; OrdKey -&gt; Ordering};</pre></code></pre></p> <p><pre><code><pre>type HASH (OrdKeyType Hashable : Type) :=  mkHASH@{    ordKey : OrdKey OrdKeyType;    hash : Hashable -&gt; OrdKeyType;  };</pre></code></pre></p> <p><pre><code><pre>type OrdMap (OrdKeyType : Type) (MapCon : Type -&gt; Type) :=  mkOrdMap@{    ordKey : OrdKey OrdKeyType;    empty : {a : Type} -&gt; MapCon a;    map : {a b : Type} -&gt; (a -&gt; b) -&gt; MapCon a -&gt; MapCon b;    insert : {a : Type} -&gt; Pair (MapCon a) (Pair OrdKeyType a) -&gt; MapCon a;    foldl : {a b : Type} -&gt; (Pair a b -&gt; b) -&gt; b -&gt; MapCon a -&gt; b;    intersectWith : {a b c : Type}      -&gt; (Pair a b -&gt; c)      -&gt; Pair (MapCon a) (MapCon b)      -&gt; MapCon c;    all : {a : Type} -&gt; (a -&gt; Bool) -&gt; MapCon a -&gt; Bool;  };</pre></code></pre></p> <p>The base abstraction of the protocol is a knowledge-based identity  interface, where the identity of an agent is defined entirely on the  basis of whether or not they know some secret information.</p> <p>Agents can use private information (likely randomness) to create an  internal identity, from which they can derive an  external identity to which it corresponds. The external identity can be shared with other parties. The agent who knows the internal identity can sign messages, which any  agent who knows the external identity can verify, and any agent who  knows the external identity can encrypt messages which the agent with  knowledge of the internal identity can decrypt. This identity interface is independent of the particular cryptographic  mechanisms, which may vary.</p>","boost":2},{"location":"arch/system/identity/index.html#identity-interface","title":"Identity Interface","text":"","boost":2},{"location":"arch/system/identity/index.html#internal-identity","title":"Internal Identity","text":"<p>An internal identity includes private information necessary for signing and  decryption. Formally, an internal identity has two parts: a Signer and a Decryptor.</p>","boost":2},{"location":"arch/system/identity/index.html#signer-juvix-type","title":"Signer Juvix Type","text":"<p>A signature describing a type <code>SignerType</code> that can cryptographically  <code>sign</code> (or credibly commit) to something (a <code>Signable</code>), forming a  <code>Commitment</code>. Implementations should ultimately include, for example  BLS keys,   which should be able to sign anything that can be marshaled into a   bitstring.</p> <p>Properties:</p> <ul> <li> <p>In general, every <code>S : Signer</code> needs a corresponding <code>V : Verifier</code>, and   every <code>s : SignerType</code> needs a corresponding <code>v : VerifierType</code>, such that:</p> <ul> <li>For any message <code>m</code> : <code>verify v m x = (x = (sign s m))</code></li> </ul> <ul> <li>for most cryptosystems, a computationally bounded adversary should not be   able to approximate <code>s</code> knowing only <code>v</code>.</li> </ul> </li> </ul> <pre><code><pre>type Signer (SignerType Signable Commitment : Type) :=  mkSigner@{sign : SignerType -&gt; Signable -&gt; Commitment};</pre></code></pre>","boost":2},{"location":"arch/system/identity/index.html#decryptor-juvix-type","title":"Decryptor Juvix Type","text":"<p>A signature describing a type <code>DecryptorType</code> that can cryptographically  <code>decrypt</code> something (a <code>Ciphertext</code>), resulting in a <code>Plaintext</code>  (or <code>none</code>, if decryption fails). Implementations should ultimately include, for example,  AES-256  keys,  which should be able to decrypt bitstrings into anything that  can be unmarshaled from a bitstring.</p> <p>Properties:</p> <ul> <li>a computationally bounded adversary should not be able to   approximate <code>decrypt d</code> without knowledge of <code>d</code>.</li> </ul> <ul> <li><code>decrypt</code> should take polynomial time (in the size of its inputs)</li> </ul> <ul> <li> <p>Each <code>D : Decryptor</code> should have a corresponding <code>E : Encryptor</code>, and   each <code>d : DecryptorType</code> has a corresponding <code>e : EncryptorType</code> such   that:</p> <ul> <li>for all <code>c : Ciphertext</code>, <code>p : Plaintext</code>:   <code>decrypt d c = Some p</code> iff <code>c = encrypt e p</code></li> </ul> <ul> <li>if <code>d = e</code>, we call this \"symmetric encryption,\" and otherwise   it's \"asymmetric encryption\"</li> </ul> </li> </ul> <pre><code><pre>type Decryptor (DecryptorType Plaintext Ciphertext : Type) :=  mkDecryptor@{decrypt : DecryptorType -&gt; Ciphertext -&gt; Option Plaintext};</pre></code></pre>","boost":2},{"location":"arch/system/identity/index.html#internal-identity-juvix-type","title":"Internal Identity Juvix Type","text":"<p>An Internal Identity structure simply specifies everything specified by both Signer and Decryptor.</p> <p>An Internal Identity structure specifies the necessary types and  functions for both a Signer and a Decryptor. Implementations should ultimately include, for example,  RSA private keys,  which should be able to decrypt integers into anything that can be  unmarshaled from a bitstring, and sign anything which can be  marshaled into a bytestring to form an integer.</p> <p>An internal_identity includes:</p> <ul> <li>a type <code>SignerType</code> that can cryptographically   <code>sign</code> (or credibly commit) to something (a <code>Signable</code>), forming a   <code>Commitment</code>.</li> </ul> <ul> <li>a type <code>DecryptorType</code> that can cryptographically <code>decrypt</code> something   (a <code>Ciphertext</code>), resulting in a <code>Plaintext</code>   (or <code>none</code>, if decryption fails).</li> </ul> <p>Properties are inherited from <code>Signer</code> and <code>Decryptor</code>.</p> <pre><code><pre>type InternalIdentity (SignerType Signable Commitment DecryptorType Plaintext Ciphertext : Type) :=  mkInternalIdentity@{    signer : Signer SignerType Signable Commitment;    decryptor : Decryptor DecryptorType Plaintext Ciphertext;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/index.html#external-identity","title":"External Identity","text":"<p>An external identity includes only public information. An external identity can verify signatures produced by an internal identity, and encrypt messages the internal identity can then decrypt. Formally, an external identity has two parts: a verifier and an Encryptor. Each is hashable: any structure specifying verifier and Encryptor types must also specify a hash function, so that external identities can be specified by hash.</p>","boost":2},{"location":"arch/system/identity/index.html#verifier-juvix-type","title":"Verifier Juvix Type","text":"<p>A signature describing a type <code>VerifierType</code> that can cryptographically  <code>verify</code> that a <code>Commitment</code> (or cryptographic signature) corresponds  to a given message (a <code>Signable</code>), and was signed by the <code>SignerType</code>  corresponding to this <code>VerifierType</code>. A <code>VerifierType</code> can be hashed (producing a unique identifier), so a  structure with signature <code>Verifier</code> must specify a <code>VerifierHash</code>  structure defining a suitable <code>hash</code> function. Implementations should ultimately include, for example  BLS  identities.</p> <p>Properties:</p> <ul> <li> <p>In general, every <code>V : Verifier</code> needs a corresponding <code>S : Signer</code>, and   every <code>s : SignerType</code> needs a corresponding <code>v : VerifierType</code>, such that:</p> <ul> <li>For any message <code>m</code> : <code>verify v m x = (x = (sign s m))</code></li> </ul> <ul> <li>for most cryptosystems, a computationally bounded adversary should not be   able to approximate <code>s</code> knowing only <code>v</code>.</li> </ul> </li> </ul> <pre><code><pre>type Verifier (OrdKey VerifierType Signable Commitment : Type) :=  mkVerifier@{    verify : VerifierType -&gt; Signable -&gt; Commitment -&gt; Bool;    verifierHash : HASH OrdKey VerifierType;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/index.html#encryptor-juvix-type","title":"Encryptor Juvix Type","text":"<p>A signature describing a type <code>EncryptorType</code> that can cryptographically  <code>encrypt</code> a <code>Plaintext</code> (message) to create a <code>Ciphertext</code> readable  only by the corresponding <code>DecryptorType</code>. An <code>EncryptorType</code> can be hashed (producing a unique identifier), so a  structure with signature <code>Encryptor</code> must specify an <code>encryptorHash</code>  structure defining a suitable hash function. Implementations should ultimately include, for example,  AES-256  keys,  which should be able to decrypt bitstrings into anything that  can be  unmarshaled from a bitstring.</p> <p>Properties:</p> <ul> <li><code>encrypt</code> should take polynomial time (in the size of its inputs)</li> </ul> <ul> <li> <p>Each <code>E : Encryptor</code> should have a corresponding <code>D : Decryptor</code>, and   each <code>d : DecryptorType</code> has a corresponding <code>e : EncryptorType</code> such   that:</p> <ul> <li>for all <code>c : Ciphertext</code>, <code>p : Plaintext</code>:   <code>decrypt d c = Some p</code> iff <code>c = encrypt e p</code></li> </ul> <ul> <li>if <code>d = e</code>, we call this \"symmetric encryption,\" and otherwise   it's \"asymmetric encryption.\"   In an asymmetric cryptosystem, a computationally bounded adversary   should not be able to approximate <code>d</code> knowing only <code>e</code>.</li> </ul> </li> </ul> <pre><code><pre>type Encryptor (OrdKey EncryptorType Plaintext Ciphertext : Type) :=  mkEncryptor@{    encrypt : EncryptorType -&gt; Plaintext -&gt; Ciphertext;    encryptorHash : HASH OrdKey EncryptorType;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/index.html#external-identity-juvix-type","title":"External Identity Juvix Type","text":"<p>An External Identity structure specifies the necessary types and  functions for both a Verifier and an Encryptor. Implementations should ultimately include, for example,  RSA public keys.</p> <p>An external_identity includes:</p> <ul> <li>a type <code>VerifierType</code> that can cryptographically <code>verify</code> that a   <code>Commitment</code> (or cryptographic signature) corresponds to a given   message (a <code>Signable</code>), and was signed by the <code>SignerType</code>   corresponding to this <code>VerifierType</code>.</li> </ul> <ul> <li>a type <code>EncryptorType</code> that can cryptographically <code>encrypt</code> a   <code>Plaintext</code> (message) to create a <code>Ciphertext</code> readable only by the   corresponding <code>DecryptorType</code>.</li> </ul> <p>Properties are inherited from <code>Verifier</code> and <code>Encryptor</code>.</p> <pre><code><pre>type ExternalIdentity (VerifierOrdKeyType VerifierType Signable Commitment EncryptorOrdKeyType EncryptorType Plaintext Ciphertext : Type) :=  mkExternalIdentity@{    verifier : Verifier VerifierOrdKeyType VerifierType Signable Commitment;    encryptor : Encryptor      EncryptorOrdKeyType      EncryptorType      Plaintext      Ciphertext;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/index.html#identity-juvix-type","title":"Identity Juvix Type","text":"<p>An Identity structure, formally, specifies all the types for  corresponding internal and external identities. So, for a given Identity structure <code>I</code>, its <code>VerifierType</code> should be the  type of objects that can verify <code>Commitment</code>s produced by a  corresponding object of type <code>SignerType</code>. Likewise, its <code>DecryptorType</code> should be the type of objects that can decrypt  <code>Ciphertext</code>s produced by a corresponding object of type  <code>EncryptorType</code>. Implementations should ultimately include, for example,  RSA  public / private keys sytems.</p> <p>An Identity includes:</p> <ul> <li>a type <code>SignerType</code> that can cryptographically <code>sign</code> (or credibly commit) to something (an <code>InternalSignable</code>), forming an <code>InternalCommitment</code>.</li> </ul> <ul> <li>a type <code>DecryptorType</code> that can cryptographically <code>decrypt</code> something (an <code>InternalCiphertext</code>), resulting in an <code>InternalPlaintext</code> (or <code>none</code>, if decryption fails).</li> </ul> <ul> <li>a type <code>VerifierType</code> that can cryptographically <code>verify</code> that an <code>ExternalCommitment</code> (or cryptographic signature) corresponds to a given message (an <code>ExternalSignable</code>), and was signed by the <code>SignerType</code> corresponding to this <code>VerifierType</code>.</li> </ul> <ul> <li>a type <code>EncryptorType</code> that can cryptographically <code>encrypt</code> an <code>ExternalPlaintext</code> (message) to create an <code>ExternalCiphertext</code> readable only by the corresponding <code>DecryptorType</code>.</li> </ul> <p>Properties are inherited from <code>Verifier</code>, <code>Encryptor</code>, <code>Signer</code>, and <code>Decryptor</code>.</p> <pre><code><pre>type Identity (SignerType InternalSignable InternalCommitment DecryptorType InternalCiphertext InternalPlaintext VerifierOrdKeyType VerifierType ExternalSignable ExternalCommitment EncryptorOrdKeyType EncryptorType ExternalPlaintext ExternalCiphertext : Type) :=  mkIdentity@{    internalIdentity : InternalIdentity      SignerType      InternalSignable      InternalCommitment      DecryptorType      InternalPlaintext      InternalCiphertext;    externalIdentity : ExternalIdentity      VerifierOrdKeyType      VerifierType      ExternalSignable      ExternalCommitment      EncryptorOrdKeyType      EncryptorType      ExternalPlaintext      ExternalCiphertext;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/index.html#signsfor-relation","title":"SignsFor Relation","text":"<p>Some identities may have the authority to sign statements on behalf of other  identities. For example, Alice might grant Bob the authority to sign arbitrary messages on her behalf. We write this relationship as Bob <code>signsFor</code> Alice.</p> <p>In general, <code>signsFor</code> is a partial order over identities. This means <code>signsFor</code> is transitive: if A <code>signsFor</code> B and B <code>signsFor</code> C, then A <code>signsFor</code> C. The <code>signsFor</code> relation becomes especially useful with regard to composed identities, discussed below.</p>","boost":2},{"location":"arch/system/identity/index.html#signsfor-evidence","title":"SignsFor Evidence","text":"<p>We do not specify all the ways one might know if one identity <code>signsFor</code> another. In general, an Identity Engine might accept (and perhaps store) a variety of forms of evidence as proof. As one simple form of evidence, we can specify a format for signed statements from B that proves some specified A <code>signsFor</code> B.</p> <p>Note that <code>signsFor</code> evidence cannot be revoked, and so a <code>signsFor</code> relation is not stateful: it cannot depend on the current state of, for example, a blockchain.</p>","boost":2},{"location":"arch/system/identity/index.html#signsfor-juvix-type","title":"SignsFor Juvix Type","text":"<p>Formally, a <code>signsFor</code> relation requires a type of evidence, and a  <code>Verifier</code> structure. This codifies a belief about what <code>VerifierType</code>'s <code>Commitments</code> are  \"at least as good as\" another <code>VerifierType</code>'s. Evidence can be signed statements, proofs, or even local state about beliefs.</p> <p>For example, suppose <code>Alice</code> wants to grant authority to <code>Bob</code> to  <code>sign</code> on her behalf. Nodes who want to take this into account might accept some sort of  <code>e : Evidence</code>, perhaps a signed statement from <code>Alice</code>, so that they  can recognize that <code>signsFor e (Bob, Alice)</code>.</p> <p>Note that <code>signsFor</code> is not symmetric: <code>signsFor e (x,y)</code> does not  imply that any <code>z</code> exists such that <code>signsFor z (y,x)</code>.</p> <pre><code><pre>type SignsFor (OrdKey VerifierType Signable Commitment Evidence : Type) :=  mkSignsFor@{    verifier : Verifier OrdKey VerifierType Signable Commitment;    signsFor : Evidence -&gt; Pair VerifierType VerifierType -&gt; Bool;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/index.html#signsfor-equivalence","title":"SignsFor Equivalence","text":"<p>We can also define a kind of identity equivalence : A <code>signsSameAs</code> B  precisely when A <code>signsFor</code> B and B <code>signsFor</code> A. This means that (in  general), if you want to sign a message as A, but for whatever reason it's cheaper to sign a message as B, it's safe to just use B instead, and vice  versa.</p>","boost":2},{"location":"arch/system/identity/index.html#readsfor-relation","title":"ReadsFor Relation","text":"<p>Similar to <code>signsFor</code>, it is useful to sometimes note that one identity can read  information encrypted to another identity. For example, suppose Alice gives her private <code>DecryptorType</code> to Bob, and wants to let everyone know that Bob can  now read anything encrypted to Alice. Nodes who want to take this into  account might accept some sort of <code>evidence</code>, perhaps a signed statement from Alice, so that they can recognize that Bob <code>readsFor</code> Alice.</p> <p>Like <code>signsFor</code>, <code>readsFor</code> is a partial order over identities. This means <code>readsFor</code> is transitive: if A <code>readsFor</code> B and B <code>readsFor</code> C, then A <code>readsFor</code> C. The <code>readsFor</code> relation becomes especially useful with regard to composed identities, discussed below.</p>","boost":2},{"location":"arch/system/identity/index.html#readsfor-evidence","title":"ReadsFor Evidence","text":"<p>We do not specify all the ways one might know if one identity <code>readsFor</code>  another. In general, an Identity Engine might accept (and perhaps store) a variety of forms of evidence as proof. As one simple form of  evidence, we can specify a format for signed statements from B that proves A <code>readsFor</code> B.</p>","boost":2},{"location":"arch/system/identity/index.html#readsfor-juvix-type","title":"ReadsFor Juvix Type","text":"<p>Formally, a <code>readsFor</code> relation requires a type of evidence, and an  <code>Encryptor</code> structure. This codifies a belief about what <code>Decryptor</code>s can read other  <code>Encryptor</code>s ciphertext. Evidence can be signed statements, proofs, or even local state about beliefs.</p> <p>Specifically, if a node expresses a <code>readsFor</code> relation, and  <code>readsFor e (x,y)</code>, then the node believes that any node knowing the  decryptor corresponding to <code>x</code> can decrypt <code>encrypt y p</code>. If there is some Plaintext <code>p</code> such that some node knowing a decryptor  corresponding to <code>x</code> cannot read <code>encrypt y p</code>, then the node's  beliefs, as encoded in the <code>readsFor</code> relation, are incorrect.</p> <p>For example, suppose <code>Alice</code> gives her private <code>DecryptorType</code> to <code>Bob</code>,  and wants to let everyone know that <code>Bob</code> can now read anything  encrypted to <code>Alice</code>. Nodes who want to take this into account might accept some sort of  <code>e : Evidence</code>, perhaps a signed statement from <code>Alice</code>, so that they  can recognize that <code>readsFor e (Bob, Alice)</code>.</p> <p>Note that <code>readsFor</code> is not symmetric: <code>readsFor e (x,y)</code> does not  imply that any <code>z</code> exists such that <code>readsFor z (y,x)</code>.</p> <pre><code><pre>type ReadsFor (OrdKey EncryptorType Plaintext Ciphertext Evidence : Type) :=  mkReadsFor@{    encryptor : Encryptor OrdKey EncryptorType Plaintext Ciphertext;    readsFor : Evidence -&gt; Pair EncryptorType EncryptorType -&gt; Bool;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/index.html#equivalence","title":"Equivalence","text":"<p>We can also define a kind of identity equivalence: A <code>readsSameAs</code> B precisely when A <code>readsFor</code> B and B <code>readsFor</code> A. This means that, in general, if you want to encrypt a message to A, but for whatever reason it's cheaper to encrypt a message for B, it's safe to just use B instead, and vice versa.</p> <p>In total, A <code>equivalent</code> B when A <code>readsSameAs</code> B and A <code>signsSameAs</code> B. This means that (in general) A and B can be used interchangeably.</p>","boost":2},{"location":"arch/system/identity/index.html#composition","title":"Composition","text":"<p>There are a variety of ways to refer to groups of identities as  single, larger identities.</p>","boost":2},{"location":"arch/system/identity/index.html#threshold-composition","title":"Threshold Composition","text":"<p>Suppose we want an identity M that refers to any majority from a  set of shareholders. A signature from M would require that a majority of shareholders  participated in signing, and encrypting information for M would  require that a majority of shareholders participate in decryption. To construct M, we start with a set of shareholder identities, each  paired with a weight (their share), and define a weight threshold  which specifies the minimum weight for a \"majority.\"</p> <p>There are several ways we could imagine constructing Threshold  Composition Identities, but without specifying anything about the  underlying identities:</p> <ul> <li>A threshold composition identity signature is a map from (hashes of)    external identities, to signatures.   To verify a signature for some message <code>x</code>, we verify each signature    with <code>x</code> and its external identity, and check that the weights of    the external identities sum to at least the threshold.</li> </ul> <ul> <li>A threshold composition identity encrypted message is a map from    (hashes of) external identities, to ciphertexts.   To decrypt, any subset of internal identities with weights summing    to at least the threshold must decrypt their corresponding    ciphertexts, and the resulting plaintexts must be combined using an    erasure coding scheme.</li> </ul>","boost":2},{"location":"arch/system/identity/index.html#threshold-composition-juvix-type-signer-and-verifier","title":"Threshold Composition Juvix Type (Signer and verifier)","text":"<p>A <code>ThresholdCompose</code> <code>VerifierType</code> consists of a  threshold (<code>Nat</code>), and a set of <code>VerifierType</code>s, each paired with a  weight (<code>Nat</code>).  (this set is encoded as a <code>Map.map</code> from hashes of <code>verifiers</code> to   <code>Pair Nat VerifierType</code> pairs). <code>Commitments</code> are simply <code>Map</code>s from hashes of the underlying  identities to <code>Commitments</code> signed by that identitity. A <code>Commitment</code> verifies iff the set of valid Commitments included  correspond to a set of <code>verifiers</code> whose weights sum to at least  the threshold. Note that this satisfies both signatures <code>Verifier</code> and <code>Signer</code>.</p> <p>In general, <code>ThresholdCompose</code> <code>SignerType</code>s and <code>VerifierType</code>s may not be  used much directly. Instead, nodes can make more efficient identities (using cryptographic  signature aggregation techniques), and express their relationship to  <code>ThresholdCompose</code> <code>VerifierType</code>s as a <code>SignsFor</code> relationship. This will let nodes reason about identities using simple  <code>ThresholdCompose</code> <code>VerifierType</code>s, while actually using more efficient  implementations.</p> <p>Formally, to specify a <code>ThresholdCompose</code>, we need:</p> <ul> <li><code>verifier</code>, the structure of the underlying <code>Verifiers</code>.</li> </ul> <ul> <li><code>signer</code>, the corresponding structure of the underlying <code>Signers</code>.</li> </ul> <ul> <li><code>map : OrdMap</code>, to be used to encode weights and <code>Commitment</code>s.   (Note that this needs the <code>OrdKey</code> to be the hash type of the    underlying <code>verifier</code>)</li> </ul> <ul> <li><code>thresholdComposeHash</code>, which specifies a <code>hash</code> function that can    hash our composed <code>VerifierType</code>s (type <code>ComposeHashable VerifierType MapCon</code>).</li> </ul> <pre><code><pre>type ComposeHashable (VerifierType : Type) (MapCon : Type -&gt; Type) :=  mkComposeHashable@{    threshold : Nat;    weights : MapCon (Pair Nat VerifierType);  };</pre></code></pre> <p>A <code>ThresholdCompose</code> structure provides:</p> <ul> <li><code>map : OrdMap</code> the underlying <code>OrdMap</code> used in    <code>VerifierType</code> and <code>Commitment</code></li> </ul> <ul> <li><code>underlyingVerifier : Verifier</code> the structure describing    the types of the underlying <code>VerifierType</code>s which can be composed.</li> </ul> <ul> <li><code>underlyingSigner : Signer</code> the structure describing    the types of the underlying <code>SignerType</code>s which can be composed.</li> </ul> <ul> <li><code>VerifierHash : HASH</code> describes the hash function for    hashing these composed <code>verifiers</code></li> </ul> <ul> <li>The <code>SignerType</code> type of the composed verifiers is the type of composed signers.    These are just <code>MapCon Commitment</code>, meaning each is    stored under the hash of the corresponding    <code>VerifierType</code>.    This <code>SignerType</code> does not need to encode weights or threshold.</li> </ul> <ul> <li>The <code>VerifierType</code> type of composed verifiers. These are    <code>ComposeHashable VerifierType MapCon</code></li> </ul> <ul> <li>The <code>Signable</code> type , being the type of message that can be signed. This is    exactly the same as what the underlying verifiers can sign    (<code>Signable</code> of <code>underlyingVerifier</code>).</li> </ul> <ul> <li>The <code>Commitment</code> type describes composed signatures, these are a    <code>MapCon</code> from hashes of underlying verifiers to signatures    (<code>Commitment</code> of <code>underlyingVerifier</code>)</li> </ul> <ul> <li>The <code>sign</code> function creates a <code>Commitment</code> using all    <code>underlyingSigner</code> <code>SignerType</code>s in the composed <code>SignerType</code>.</li> </ul> <ul> <li>The <code>verify</code> function returns true iff the set of valid Commitments included    correspond to a set of <code>underlyingVerifier</code> <code>VerifierType</code>s whose weights    sum to at least the threshold.</li> </ul> <ul> <li>The <code>signerCompose</code> function constructs a composed <code>SignerType</code> from a list of    <code>Pair VerifierType SignerType</code> pairs.    Note that each <code>SignerType</code> must be paired with its correct <code>VerifierType</code>,     or the composed <code>SignerType</code> will not produce verifiable     <code>Commitment</code>s.</li> </ul> <ul> <li> <p>The <code>verifierCompose</code> function is useful for constructing the composition of    a list of verifiers.   Returns a composed <code>VerifierType</code>.   Its arguments are:</p> <ul> <li>the threshold (<code>Nat</code>)</li> </ul> <ul> <li>a <code>list</code> of weights(<code>Nat</code>), <code>VerifierType</code> pairs.</li> </ul> </li> </ul> <ul> <li>The <code>verifierAnd</code> function creates a composed <code>VerifierType</code> that is the \"&amp;&amp;\" of    two input verifiers: a <code>SignerType</code> must encode the information of the    signers for both <code>x</code> and <code>y</code> to sign statements <code>verifierAnd x y</code>    will verify.</li> </ul> <ul> <li>The <code>verifierOr</code> function creates a composed <code>VerifierType</code> that is the \"||\" of    two input verifiers: a <code>SignerType</code> must encode the information of the    signers for either <code>x</code> or <code>y</code> to sign statements <code>verifierOr x y</code>    will verify.</li> </ul> <pre><code><pre>type ThresholdCompose (OrdKey : Type) (MapCon : Type  -&gt; Type) (VerifierType Signable Commitment SignerType VerifierHashOrdKeyType : Type) :=  mkThresholdCompose@{    map : OrdMap OrdKey MapCon;    underlyingVerifier : Verifier OrdKey VerifierType Signable Commitment;    underlyingSigner : Signer SignerType Signable Commitment;    verifierHash : HASH      VerifierHashOrdKeyType      (ComposeHashable VerifierType MapCon);    sign : MapCon SignerType -&gt; Signable -&gt; MapCon Commitment;    verify : ComposeHashable VerifierType MapCon      -&gt; Signable      -&gt; MapCon Commitment      -&gt; Bool;    signerCompose : List (Pair VerifierType SignerType) -&gt; MapCon SignerType;    verifierCompose : Nat      -&gt; List (Pair Nat VerifierType)      -&gt; ComposeHashable VerifierType MapCon;    verifierAnd : VerifierType      -&gt; VerifierType      -&gt; ComposeHashable VerifierType MapCon;    verifierOr : VerifierType      -&gt; VerifierType      -&gt; ComposeHashable VerifierType MapCon;  };</pre></code></pre> <pre><code><pre>projectVerifier  {MapCon : Type -&gt; Type}  {OrdKey VerifierType Signable Commitment SignerType VerifierHashOrdKeyType : Type}  (tc : ThresholdCompose    OrdKey    MapCon    VerifierType    Signable    Commitment    SignerType    VerifierHashOrdKeyType)  : Verifier    VerifierHashOrdKeyType    (ComposeHashable VerifierType MapCon)    Signable    (MapCon Commitment) :=  mkVerifier@{    verify := ThresholdCompose.verify tc;    verifierHash := ThresholdCompose.verifierHash tc;  };</pre></code></pre> <pre><code><pre>ThresholdComposeFunctor  {MapCon : Type -&gt; Type}  {OrdKey VerifierType Signable Commitment SignerType VerifierHashOrdKeyType : Type}  (verifier : Verifier OrdKey VerifierType Signable Commitment)  (signer : Signer SignerType Signable Commitment)  (mapIn : OrdMap OrdKey MapCon)  (thresholdComposeHash : HASH    VerifierHashOrdKeyType    (ComposeHashable VerifierType MapCon))  : ThresholdCompose    OrdKey    MapCon    VerifierType    Signable    Commitment    SignerType    VerifierHashOrdKeyType :=  mkThresholdCompose@{    map := mapIn;    underlyingVerifier := verifier;    underlyingSigner := signer;    verifierHash := thresholdComposeHash;    sign := \\{s m := OrdMap.map map \\{i := Signer.sign underlyingSigner i m} s};    verify :=      \\{| (mkComposeHashable t ws) s c :=        t          &lt;= OrdMap.foldl            map            \\{(mkPair x y) := x + y}            0            (OrdMap.intersectWith              map              \\{| (mkPair (mkPair w v) x) :=                ite (Verifier.verify underlyingVerifier v s x) w 0}              (mkPair ws c))};    signerCompose :=      \\{l :=        foldl          \\{m (mkPair v s) :=            OrdMap.insert              map              (mkPair                m                (mkPair                  (HASH.hash (Verifier.verifierHash underlyingVerifier) v)                  s))}          (OrdMap.empty map)          l};    verifierCompose :=      \\{threshold weights :=        mkComposeHashable          threshold          (foldl            \\{m (mkPair w v) :=              OrdMap.insert                map                (mkPair                  m                  (mkPair                    (HASH.hash (Verifier.verifierHash underlyingVerifier) v)                    (mkPair w v)))}            (OrdMap.empty map)            weights)};    verifierAnd := \\{x y := verifierCompose 2 [mkPair 1 x; mkPair 1 y]};    verifierOr := \\{x y := verifierCompose 1 [mkPair 1 x; mkPair 1 y]};  };</pre></code></pre> <p>While this construction is rather naive, it is general, and crucially, we can reason about  equivalence with any number of more interesting schemes:</p> <ul> <li>We can show that a threshold RSA signature scheme <code>signsSameAs</code> as a Threshold Composition    Identity.</li> </ul> <ul> <li>We can show that a secret sharing scheme <code>readsSameAs</code> a Threshold Composition Identity.</li> </ul> <p>By phrasing our discussion in terms of equivalence and Threshold Composition Identities, we can  abstract over the actual cryptography used. We can also derive some <code>signsFor</code> and <code>readsFor</code>  relations that must hold, by looking at the relations that must hold for Threshold Composition Identities:</p>","boost":2},{"location":"arch/system/identity/index.html#signsfor-threshold-composition","title":"<code>signsFor</code> Threshold Composition","text":"<p>Like any identity, Threshold Composition Identities can define any number of ways to delegate signing power, or be delegated signing power. However, some cases should always hold: A <code>signsFor</code> B if every identity in A has no more weight (divided by threshold) than identities it <code>signsFor</code> in B. This implies that any collection of identities that can sign as A can also sign as B.</p> <p>A <code>signsFor</code> relation for easy comparison of   <code>ThresholdCompose</code> <code>VerifierType</code>s  x <code>signsFor</code> y if every underlying VerifierType in x has no more   weight (divided by threshold) as verifiers it <code>signsFor</code> in y. This implies that anything which can sign as x can also sign  as y.</p> <p>This requires an underlying <code>S : SignsFor</code> for comparing the weighted  signers in x and y, which in turn may require evidence. No additional evidence is required.</p> <p>Other parameters necessary to define the <code>ThresholdCompose</code> <code>verifiers</code> include:</p> <ul> <li><code>signer</code>, the corresponding structure of the underlying <code>signers</code>.</li> </ul> <ul> <li><code>map : OrdMap</code>, to be used to encode weights and <code>Commitment</code>s.   (Note that this needs <code>OrdKey</code> to be the hash type of the    underlying <code>verifier</code>)</li> </ul> <ul> <li><code>thresholdComposeHash</code>, which specifies a <code>hash</code> function that can    hash our composed <code>VerifierType</code>s (type    <code>ComposeHashable VerifierType MapCon</code>).</li> </ul> <pre><code><pre>type ThresholdComposeSignsFor (OrdKey VerifierType Signable Commitment Evidence : Type) (MapCon : Type  -&gt; Type) VerifierHashOrdKeyType :=  mkThresholdComposeSignsFor@{    underlyingSignsFor : SignsFor      OrdKey      VerifierType      Signable      Commitment      Evidence;    verifier : ThresholdCompose      OrdKey      MapCon      VerifierType      Signable      Commitment      VerifierType      VerifierHashOrdKeyType;    signsFor : Evidence      -&gt; Pair        (ComposeHashable VerifierType MapCon)        (ComposeHashable VerifierType MapCon)      -&gt; Bool;  };</pre></code></pre> <pre><code><pre>projectSignsFor  {OrdKey VerifierType Signable Commitment Evidence : Type}  {MapCon : Type -&gt; Type}  {VerifierHashOrdKeyType : Type}  (tc : ThresholdComposeSignsFor    OrdKey    VerifierType    Signable    Commitment    Evidence    MapCon    VerifierHashOrdKeyType)  : SignsFor    VerifierHashOrdKeyType    (ComposeHashable VerifierType MapCon)    Signable    (MapCon Commitment)    Evidence :=  mkSignsFor@{    verifier := projectVerifier (ThresholdComposeSignsFor.verifier tc);    signsFor := ThresholdComposeSignsFor.signsFor tc;  };</pre></code></pre> <pre><code><pre>ThresholdComposeSignsForFunctor  {OrdKey VerifierType Signable Commitment Evidence : Type}  {MapCon : Type -&gt; Type}  {VerifierHashOrdKeyType : Type}  (S : SignsFor OrdKey VerifierType Signable Commitment Evidence)  (signer : Signer VerifierType Signable Commitment)  (map : OrdMap OrdKey MapCon)  (thresholdComposeHash : HASH    VerifierHashOrdKeyType    (ComposeHashable VerifierType MapCon))  : ThresholdComposeSignsFor    OrdKey    VerifierType    Signable    Commitment    Evidence    MapCon    VerifierHashOrdKeyType :=  mkThresholdComposeSignsFor@{    underlyingSignsFor := S;    verifier :=      ThresholdComposeFunctor        (SignsFor.verifier underlyingSignsFor)        signer        map        thresholdComposeHash;    signsFor :=      \\{e (mkPair (mkComposeHashable t0 w0) (mkComposeHashable t1 w1)) :=        OrdMap.all          map          \\{(mkPair w v) :=            w * t1              &lt;= OrdMap.foldl                  map                  \\{(mkPair (mkPair x v1) s) :=                    ite                      (SignsFor.signsFor underlyingSignsFor e (mkPair v v1))                      (x + s)                      s}                  0                  w1                * t0}          w0};  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/index.html#encryptor-threshold-composition","title":"<code>Encryptor</code> Threshold Composition","text":"<p>DANGER: NOT YET IMPLEMENTED</p> <p>Implementing this requires secret sharing.  The threshold composed <code>encryptor</code> is a threshold, and a set of weights  paired with <code>UnderlyingEncryptor.encryptor</code>s. There are stored in a <code>Map.map</code>  under their hashes, to ensure uniqueness.</p> <p>The idea is that an encrypted <code>plaintext</code> should only be  decryptable by a <code>decryptor</code> that encodes the information from a  set of <code>decryptor</code>s corresponding to a set of <code>encryptor</code>s whose  weight sums to at least the threshold.</p> <pre><code><pre>type ThresholdComposeEncryptor (OrdKey EncryptorType Plaintext Ciphertext : Type) (MapCon : Type  -&gt; Type) (EncryptorHashOrdKeyType : Type) :=  mkThresholdComposeEncryptor@{    map : OrdMap OrdKey MapCon;    underlyingEncryptor : Encryptor OrdKey EncryptorType Plaintext Ciphertext;    encryptorHash : HASH      EncryptorHashOrdKeyType      (ComposeHashable EncryptorType MapCon);    compose : Nat      -&gt; List (Pair Nat EncryptorType)      -&gt; ComposeHashable EncryptorType MapCon;    encrypt : ComposeHashable EncryptorType MapCon -&gt; Plaintext -&gt; Ciphertext;  };</pre></code></pre> <pre><code><pre>projectEncryptor  {OrdKey EncryptorType Plaintext Ciphertext}  {MapCon : Type -&gt; Type}  {EncryptorHashOrdKeyType}  (tc : ThresholdComposeEncryptor    OrdKey    EncryptorType    Plaintext    Ciphertext    MapCon    EncryptorHashOrdKeyType)  : Encryptor    EncryptorHashOrdKeyType    (ComposeHashable EncryptorType MapCon)    Plaintext    Ciphertext :=  mkEncryptor@{    encrypt := ThresholdComposeEncryptor.encrypt tc;    encryptorHash := ThresholdComposeEncryptor.encryptorHash tc;  };</pre></code></pre> <pre><code><pre>axiom encrypt_DUMMY : {EncryptorType Plaintext Ciphertext : Type}  -&gt; {MapCon : Type -&gt; Type}  -&gt; ComposeHashable EncryptorType MapCon  -&gt; Plaintext  -&gt; Ciphertext;</pre></code></pre> <pre><code><pre>ThresholdComposeEncryptorFunctor  {OrdKey EncryptorType Plaintext Ciphertext}  {MapCon : Type -&gt; Type}  {EncryptorHashOrdKeyType}  (encryptor : Encryptor OrdKey EncryptorType Plaintext Ciphertext)  (mapIn : OrdMap OrdKey MapCon)  (thresholdComposeHash : HASH    EncryptorHashOrdKeyType    (ComposeHashable EncryptorType MapCon))  : ThresholdComposeEncryptor    OrdKey    EncryptorType    Plaintext    Ciphertext    MapCon    EncryptorHashOrdKeyType :=  mkThresholdComposeEncryptor@{    map := mapIn;    underlyingEncryptor := encryptor;    encryptorHash := thresholdComposeHash;    compose :=      \\{t w :=        mkComposeHashable@{          threshold := t;          weights :=            foldl              \\{m (mkPair w e) :=                OrdMap.insert                  map                  (mkPair                    m                    (mkPair                      (HASH.hash                        (Encryptor.encryptorHash underlyingEncryptor)                        e)                      (mkPair w e)))}              (OrdMap.empty map)              w;        }};    encrypt := encrypt_DUMMY;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/index.html#readsfor-threshold-composition","title":"<code>readsFor</code> Threshold Composition","text":"<p>Like any identity, ThresholdCompositionIdentities can have arbitrary  <code>readsFor</code> relationships. However, some cases should always hold : A <code>readsFor</code> B if every  identity in A has no more weight (divided by threshold) than  identities it <code>readsFor</code> in B. This implies that any collection of identities that can read messages  encrypted with A can also read messages encrypted as B.</p> <p>A <code>readsFor</code> relation for easy comparison of   <code>ThresholdComposeEncryptor</code> <code>EncryptorType</code>s  x <code>readsFor</code> y if every underlying <code>EncryptorType</code> in x has no more   weight (divided by threshold) as encryptors it <code>readsFor</code> in y. This implies that anything which can decrypt as x can also decrypt  as y.</p> <p>This requires an underlying <code>R : ReadsFor</code> for comparing the weighted  encryptors in  x and y, which in turn may require evidence. No additional evidence is required.</p> <pre><code><pre>type ThresholdComposeReadsFor (OrdKey EncryptorType Plaintext Ciphertext Evidence : Type) (MapCon : Type  -&gt; Type) (EncryptorHashOrdKeyType : Type) :=  mkThresholdComposeReadsFor@{    underlyingReadsFor : ReadsFor      OrdKey      EncryptorType      Plaintext      Ciphertext      Evidence;    encryptor : ThresholdComposeEncryptor      OrdKey      EncryptorType      Plaintext      Ciphertext      MapCon      EncryptorHashOrdKeyType;    readsFor : Evidence      -&gt; Pair        (ComposeHashable EncryptorType MapCon)        (ComposeHashable EncryptorType MapCon)      -&gt; Bool;  };</pre></code></pre> <pre><code><pre>projectReadsFor  {OrdKey VerifierType Signable Commitment Evidence}  {MapCon : Type -&gt; Type}  {EncryptorHashOrdKeyType}  (tc : ThresholdComposeReadsFor    OrdKey    VerifierType    Signable    Commitment    Evidence    MapCon    EncryptorHashOrdKeyType)  : ReadsFor    EncryptorHashOrdKeyType    (ComposeHashable VerifierType MapCon)    Signable    Commitment    Evidence :=  mkReadsFor@{    encryptor := projectEncryptor (ThresholdComposeReadsFor.encryptor tc);    readsFor := ThresholdComposeReadsFor.readsFor tc;  };</pre></code></pre> <pre><code><pre>ThresholdComposeReadsForFunctor  {OrdKey EncryptorType Plaintext Ciphertext Evidence : Type}  {MapCon : Type -&gt; Type}  {EncryptorHashOrdKeyType : Type}  (r : ReadsFor OrdKey EncryptorType Plaintext Ciphertext Evidence)  (map : OrdMap OrdKey MapCon)  (thresholdComposeHash : HASH    EncryptorHashOrdKeyType    (ComposeHashable EncryptorType MapCon))  : ThresholdComposeReadsFor    OrdKey    EncryptorType    Plaintext    Ciphertext    Evidence    MapCon    EncryptorHashOrdKeyType :=  mkThresholdComposeReadsFor@{    underlyingReadsFor := r;    encryptor :=      ThresholdComposeEncryptorFunctor        (ReadsFor.encryptor underlyingReadsFor)        map        thresholdComposeHash;    readsFor :=      \\{e (mkPair (mkComposeHashable t0 w0) (mkComposeHashable t1 w1)) :=        OrdMap.all          map          \\{(mkPair w v) :=            w * t1              &lt;= OrdMap.foldl                  map                  \\{(mkPair (mkPair x v1) s) :=                    ite                      (ReadsFor.readsFor underlyingReadsFor e (mkPair v v1))                      (x + s)                      s}                  0                  w1                * t0}          w0};  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/index.html#and-identities","title":"\"And\" Identities","text":"<p>We can compose identities with conjunction: A <code>&amp;&amp;</code> B is the identity which requires an agent to have both A's internal identity and B's internal identity to sign or decrypt. It represents A and B working together. In practice, A <code>&amp;&amp;</code> B can be defined as a special case of Threshold composition (see <code>verifierAnd</code> above).</p>","boost":2},{"location":"arch/system/identity/index.html#or-identities","title":"\"Or\" Identities","text":"<p>We can compose identities with disjunction as well: A <code>||</code> B requires an agent to have either A's internal identity or B's internal identity. It represents either A or B, without specifying which. In practice, A <code>||</code> B can be defined as a special case of Threshold Composition (see <code>verifierOr</code> above).</p> <p>In principle, we could define things differently: Threshold Composition could be defined using <code>&amp;&amp;</code> and <code>||</code> as primitives, by building a disjunction of every possible conjunction that satisfies the threshold. In several important cases, however, this takes much more space to express, so we use the equally general and more numerically efficient threshold composition abstraction.</p>","boost":2},{"location":"arch/system/identity/index.html#opaque-composition","title":"Opaque Composition","text":"<p>A group of agents can also compose an opaque identity such that composition information is not available to the outside. One example would be using distributed key generation and a threshold cryptosystem e.g. Threshold RSA. Here the agents compute one RSA keypair together, with only shares of the private key being generated by each agent. Decryption of messages encrypted to the single public key then requires cooperation of a subset of agents holding key shares, fulfilling the threshold requirements. This group would have a single External Identity based on a regular RSA public key, and it would not necessarily be clear how the identity was composed.</p> <p>Specific evidence could prove that this threshold cryptosystem identity is <code>equivalent</code> to some <code>ThresholdCompose</code> identity. This kind of proof requires <code>readsFor</code> and <code>signsFor</code> relations tailored to the cryptosystem used. Once equivalence is proven, however, one could use the threshold cryptosystem identity for efficiency, but reason using the <code>ThresholdCompose</code> identity.</p>","boost":2},{"location":"arch/system/identity/index.html#special-identities","title":"Special identities","text":"<p>The following special identities illustrate the generality of our identity abstractions:</p>","boost":2},{"location":"arch/system/identity/index.html#true-all","title":"\"true / All\"","text":"<p>Anyone can sign and decrypt (<code>verify</code> returns true and <code>encrypt</code> returns the <code>Plaintext</code>). No secret knowledge is required, so all agents can take on this identity.</p> <p>The true identity preserves structure under conjunction (x <code>&amp;&amp;</code> true <code>equivalent</code> x) and forgets structure under disjunction (x <code>||</code> true <code>equivalent</code> true).</p>","boost":2},{"location":"arch/system/identity/index.html#false-none","title":"\"false / None\"","text":"<p>No one can sign or decrypt (<code>verify</code> returns false and <code>encrypt</code> returns empty string). No secret knowledge exists that fulfills these requirements, so no agent can take on this identity.</p> <p>The false identity forgets structure under disjunction (x <code>&amp;&amp;</code> false <code>equivalent</code> false) and preserves structure under disjunction (x <code>||</code> false <code>equivalent</code> x).</p>","boost":2},{"location":"arch/system/identity/index.html#identity-names","title":"Identity Names","text":"<p>Sometimes it is useful to have a name for an external identity before the relevant cryptographic values are available. For example, we might refer to \"a quorum of validators from chain <code>X</code> at epoch <code>Y</code>\". Before epoch <code>Y</code> has begun, chain <code>X</code> may not have yet decided who constitutes a quorum.</p> <p>It would be possible to build a <code>Verifier</code>, where the evidence that the signers are in fact a quorum of validators from chain <code>X</code> at epoch <code>Y</code> is part of the signature. One might later build a simpler <code>Verifier</code>, which elides this evidence, and then prove that the two <code>signsSameAs</code> using the evidence. However, barring some really exciting cryptography, we'd need to know the quorums from chain <code>X</code> at epoch <code>Y</code> before we could make an <code>Encryptor</code>.</p> <p>We therefore introduce a new type, Identity Name, which represents a placeholder to be filled in when an appropriate external identity can be found. Specifically, each type of identity name comes with a predicate, which can be satisfied by an external identity, and accompanying evidence. Identity names can also be hashed, like external identities.</p> <p>Identity names can be described in two structures: one for checking that a  <code>VerifierType</code> corresponds with an <code>IdentityName</code>, and one for checking that an  <code>EncryptorType</code> corresponds with an <code>IdentityName</code>. The same name can refer to both a <code>VerifierType</code> and an <code>EncryptorType</code>.</p>","boost":2},{"location":"arch/system/identity/index.html#verifier-name-juvix-type","title":"Verifier Name Juvix Type","text":"<p>An <code>IdentityName</code> can be mapped to an appropriate <code>VerifierType</code> when suitable <code>Evidence</code> is found. Here, <code>checkVerifierName</code> defines what evidence is acceptable for a <code>VerifierType</code>.</p> <p>Note that <code>IdentityName</code>s are also hashable: we require a structure <code>verifierNameHash</code> that details how to hash them.</p> <pre><code><pre>type VerifierName OrdKey VerifierType Signable Commitment Evidence IdentityName VerifierNameHashOrdKeyType :=  mkVerifierName@{    verifier : Verifier OrdKey VerifierType Signable Commitment;    checkVerifierName : IdentityName -&gt; VerifierType -&gt; Evidence -&gt; Bool;    verifierNameHash : HASH VerifierNameHashOrdKeyType IdentityName;  };</pre></code></pre>","boost":2},{"location":"arch/system/identity/index.html#encryptor-name-juvix-type","title":"Encryptor Name Juvix Type","text":"<p>An <code>IdentityName</code> can be mapped to an appropriate Encryptor <code>EncryptorType</code>  when suitable <code>Evidence</code> is found. Here, <code>checkEncryptorName</code> defines what evidence is acceptable for an  <code>Encryptor</code> <code>EncryptorType</code>. Note that <code>IdentityName</code>s are also hashable: we require a structure  <code>encryptorNameHash</code> that details how to hash them.</p> <pre><code><pre>type EncryptorName OrdKey EncryptorType Plaintext Ciphertext Evidence IdentityName EncryptorNameHashOrdKeyType :=  mkEncryptorName@{    verifier : Encryptor OrdKey EncryptorType Plaintext Ciphertext;    checkEncryptorName : IdentityName -&gt; EncryptorType -&gt; Evidence -&gt; Bool;    encryptorNameHash : HASH EncryptorNameHashOrdKeyType IdentityName;  };</pre></code></pre> <p>For example, for the identity name \"a quorum of validators from chain <code>X</code> at epoch <code>Y</code>\", a satisfying external identity would be composed from the validators selected for epoch <code>Y</code>, and the accompanying evidence would be a light-client proof from chain <code>X</code> that these are the correct validators for epoch <code>Y</code>.</p> <p>Note that multiple identity names can refer to the same external identity, and in principle, multiple external identities could have the same identity name. Usually, multiple external identities only have the same identity name when there is Byzantine behaviour, but that is not explicitly part of the identity abstractions at this layer.</p>","boost":2},{"location":"arch/system/identity/index.html#sub-identities","title":"Sub-Identities","text":"<p>One particularly common case for identity names is when one party (the super-identity) wants to designate a specific name they use to refer to another identity. Here, the super-identity is acting like a certificate authority: they designate which external identity corresponds with this identity name. This sub-identity is often something the super-identity controls: a specific machine they own, or a process they run on that machine. Such a sub-identity might be associated with a string, such as <code>\"acceptor\"</code>, which might designate the process participating in consensus within a validator. In this case, the predicate should check that the super-identity has signed a statement declaring that the external identity matches the sub-identity.</p>","boost":2},{"location":"arch/system/identity/index.html#notation","title":"\".\" Notation","text":"<p>Because sub-identities using string names are so common, we have a short-cut notation for expressing identity names. Given some identity Alice, for any string <code>\"foo\"</code>, Alice.foo is an identity name. For example, even before they learn anything about Alice, validators might refer to Alice.acceptor to mean the specific process Alice is running to participate in consensus. The identity Alice can sign statements to let people know what external identity they should (immutably) use for Alice.foo or Alice.acceptor. These are left associative, so Alice.foo can designate Alice.foo.bar (shorthand for (Alice.foo).bar) and Alice.foo.bar can designate Alice.foo.bar.baz (shorthand for ((Alice.foo).bar).baz), and so on. These are a special case of sub-identities: X.Y is a sub-identity of X.</p> <p>Formally, we use <code>mkPair (hash Alice) \"foo\"</code> as the Juvix representation of Alice.foo:</p> <p>A specific kind of identity name, wher ethe evidence is a signed  statement from a specified parent saying that it associates this  VerifierType with a specific <code>name</code>.</p> <p>Here,</p> <ul> <li><code>Name</code> is the type the parent identifies with a child.   For example, for <code>name = string</code>, and some identity Alice, we can specify   <code>(hash(Alice),\"bob\")</code>, or Alice.bob, as the identity that   Alice refers to as <code>\"bob\"</code>.</li> </ul> <ul> <li><code>child</code> : <code>Verifier</code> type that can be identified with a name.</li> </ul> <ul> <li> <p><code>parent</code> : <code>Verifier</code> type that signs evidence statements.</p> <p>Crucially, it must be able to sign tuples of the form (string, name, child's hash type) In our example, where Alice refers to Bob as Alice.<code>\"bob\"</code>, <code>child</code> describes Bob, <code>parent</code> describes Alice, and <code>name</code> describes <code>\"bob\"</code>.</p> </li> </ul> <ul> <li><code>hash</code> Describes what will become the <code>verifierNameHash</code>.   Crucially, it must be able to hash pairs of the form   (parent's hash type, name)</li> </ul> <pre><code><pre>SubVerifierFunctor  (OrdKey VerifierType Signable Commitment Name ParentOrdKeyType : Type)  (child : Verifier OrdKey VerifierType Signable Commitment)  (parent : Verifier    ParentOrdKeyType    VerifierType    (Pair String (Pair Name OrdKey))    Commitment)  (hash : HASH ParentOrdKeyType (Pair ParentOrdKeyType Name))  : VerifierName    OrdKey    VerifierType    Signable    Commitment    (Pair VerifierType Commitment)    (Pair ParentOrdKeyType Name)    ParentOrdKeyType :=  mkVerifierName@{    verifier := child;    checkVerifierName :=      \\{(mkPair ph n) c (mkPair pv pc) :=        Verifier.verify            parent            pv            (mkPair              \"I identify this verifier with this name : \"              (mkPair n (HASH.hash (Verifier.verifierHash child) c)))            pc          &amp;&amp; OrdKey.compare              (HASH.ordKey (Verifier.verifierHash parent))              ph              (HASH.hash (Verifier.verifierHash parent) pv)            == Equal};    verifierNameHash := hash;  };</pre></code></pre> <p>In other words, we have a specific, standardized thing an external identity can sign to designate that another external identity corresponds to a \".\" name.</p> <p>Note that we can use \".\" sub-identities for purposes other than identifying identities that the super-identity controls. Alice might have a friend Bob, and designate his external identity as Alice.bob. This is an example of a place where \"sub-identity-ness\" is not transitive: Alice.bob.carol is (Alice.bob).carol, a sub-identity of Alice.bob, so it is up to Bob to designate which external identity he associates with <code>\"carol\"</code>, and Alice has no say: Alice.bob.carol is not a sub-identity of Alice.</p>","boost":2},{"location":"arch/system/identity/index.html#identity-engine","title":"Identity Engine","text":"<p>In practice, using Identity Names requires each physical machine to maintain a mapping from identity names to known external identities. The machine does not have to store the accompanying evidence for each, although it might be useful to do so sometimes (for example, in order to present to a third party). When any process on that machine wants to do any operation using an identity name instead of an external identity, it can query this mapping to see if there is a known external identity to use for that operation.</p> <p>An Identity Engine can also store evidence for known <code>signsFor</code> and <code>readsFor</code> relationships, and help choose which external identity is most efficient for a task. For example, if an agent wants to encrypt a message to \"a quorum of validators from chain <code>X</code> at epoch <code>Y</code>\", they would first resolving the identity name to an identity (possibly a Threshold Composed Identity), and might then ask if there is some known equivalent identity (such as a threshold encryption identity) with cheaper encryption.</p>","boost":2},{"location":"arch/system/identity/index.html#identity-name-resolution","title":"Identity Name Resolution","text":"<p>There is no general mechanism for finding external identities (and accompanying evidence) for arbitrary identity names, with arbitrary forms of evidence. However, for some common types of identity names, such as \".\" sub-identities, we can establish a standard server and query language, which participating Identity Engines can query to resolve those identity names.</p>","boost":2},{"location":"arch/system/network/index.html","title":"Network Architecture","text":"<p>For now, see this paper.</p>","boost":2},{"location":"arch/system/service/index.html","title":"Service Architecture","text":"<p>Basic promises:</p> <ul> <li>respond to messages under certain conditions (liveness)</li> <li>never send messages satisfying certain criteria (safety)</li> </ul> <p>Kinds of services:</p> <ul> <li>ordering</li> <li>storage</li> <li>compute</li> <li>bandwidth</li> </ul>","boost":2},{"location":"arch/system/service/index.html#heterogeneous-trust","title":"Heterogeneous trust","text":"<p>Suppose that program \\(P\\) instantiates the Anoma protocol, and that an observer \\(O\\) can interact with \\(P\\) by sending and receiving messages (locally, in the sense that the interface is trusted).</p> <p>Assume that:</p> <ul> <li>The agent \\(A\\) makes some trust assumptions about how other agents \\(A_1, A_2, ... A_n\\) will behave. These trust assumptions, for an agent \\(A\\), are always of the form of a predicate over messages which \\(A\\) is expected to send, possibly in response to messages they have received. For example, an assumption could be of the form that \\(A\\) will never send two messages \\(M_1\\) and \\(M_2\\) such that, for some predicate \\(P\\), \\(P(M_1, M_2) = 1\\) (safety-related), or of the form that in response to receiving message \\(M\\), \\(A\\) will eventually respond with message \\(M'\\), where, for some predicate \\(P\\), \\(P(M, M') = 1\\) (liveness-related).</li> </ul> <p>A valid instantiation of Anoma must guarantee:</p> <ul> <li>Consistency: if in fact \\(O\\) is correct about their trust assumptions, i.e. for each \\(A_n\\) about which \\(O\\) makes a trust assumption, \\(A_n\\) does in fact behave in the way in which \\(O\\) assumes that they will, then for any other observer \\(O'\\), if \\(O\\) and \\(O'\\) are both running program \\(P\\), in response to an arbitrary query message \\(Q\\), \\(P\\) will respond to \\(O\\) and \\(O'\\) with the same response \\(R\\).</li> <li>Liveness: if in fact \\(O\\) is correct about their liveness-related trust assumptions, i.e. for each \\(A_n\\) about which \\(O\\) makes a trust assumption, \\(A_n\\) does in fact behave in the way in which \\(O\\) assumes that they will, then for any other observer \\(O'\\), if \\(O\\) and \\(O'\\) are both running program \\(P\\), in response to an arbitrary input message \\(M\\), \\(P\\) will eventually respond to \\(O\\) and \\(O'\\). (note: \\(P\\) needs to have the same private information)</li> </ul>","boost":2},{"location":"arch/system/service/index.html#information-flow-control","title":"Information flow control","text":"<p>Suppose that program \\(P\\) instantiates the Anoma protocol, and that an agent \\(A\\) can interact with \\(P\\) by sending and receiving messages locally.</p> <p>Assume that:</p> <ul> <li>The agent \\(A\\) makes some trust assumptions about how other agents \\(A_1, A_2, ... A_n\\) will behave. These trust assumptions, for an agent \\(A\\), are always of the form of a predicate over messages which \\(A\\) is expected to send, possibly in response to messages they have received. For example, an assumption could be of the form that, given that \\(A\\) has received some message \\(M_1\\), \\(A\\) will never send a message \\(M_2\\) such that, for some predicate \\(P\\), \\(P(M_1, M_2) = 1\\) (this could indicate, for example, that \\(M_2\\) discloses some information in \\(M_1\\)).</li> </ul> <p>A valid instantiation of Anoma must guarantee:</p> <ul> <li>Bounded disclosure: if \\(A\\) discloses certain information \\(I\\) to a set of parties $A_1 ... \\(A_n\\), with instructions not to disclose it to further parties, and in fact \\(A\\) is correct about their trust assumptions, i.e., for each \\(A_n\\) about which \\(A\\) makes a trust assumption, \\(A_n\\) does in fact behave in the way in which \\(A\\) assumes that they will, for all agents \\(A'\\) not in \\(A_1 ... A_n\\), \\(A'\\) will not learn the information as a result of \\(A\\)'s disclosure of it.</li> <li>Orthogonal disclosure: if \\(A\\) knows certain information \\(I\\), for an arbitrary function \\(F_I\\), \\(A\\) can disclose the result of \\(F_I\\) to arbitrary other agents without disclosing anything else.</li> </ul>","boost":2},{"location":"arch/system/state/index.html","title":"State Architecture","text":"<ul> <li>Resource machine</li> <li>Intent machine</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/index.html","title":"Introduction","text":"<p>The Anoma Resource Machine (ARM) is the part of the Anoma protocol that defines and enforces the rules for valid state updates that satisfy users' preferences. The new proposed state is then agreed on by the consensus participants. In that sense the role of the Anoma Resource Machine in the Anoma protocol is similar to the role of the Ethereum Virtual Machine in the Ethereum protocol.</p> <p>The atomic unit of the ARM state is called a resource. Resources are immutable, they can be created once and consumed once, which indicates that the system state has been updated.</p>","tags":["resource-machine","protocol","commitment","nullifier","accumulator","resource logic"],"boost":2},{"location":"arch/system/state/resource_machine/index.html#resource-model","title":"Resource model","text":"<p>The ARM transaction model is neither the account nor UTXO model. Unlike the Bitcoin UTXO model, which sees UTXOs as currency units and is limited in expressivity, the resource model is generalised and provides flexibility \u2014 resource logics \u2014 programmable predicates associated with each resource \u2014 can be defined in a way to construct applications that operate in any desired transaction model, including the account and UTXO models.</p> <p>For example, a token operating in the account model would be represented by a single resource containing a map \\(user: balance\\) (unlike the UTXO model, where the token would be represented by a collection of resources of the token type, each of which would correspond to a portion of the token total supply and belong to some user owning this portion). Only one resource of that kind can exist at a time. When users want to perform a transfer, they consume the old balance table resource and produce a new balance table resource.</p>","tags":["resource-machine","protocol","commitment","nullifier","accumulator","resource logic"],"boost":2},{"location":"arch/system/state/resource_machine/index.html#properties","title":"Properties","text":"<p>The Anoma Resource Machine has the following properties:</p> <ul> <li>Atomic state transitions of unspecified complexity \u2014 the number of resources created and consumed in every atomic state transition is not bounded by the system.</li> <li>Information flow control \u2014 the users of the system can decide how much of the information about their state to reveal and to whom. From the resource machine perspective, states with different visibility settings are treated equally (e.g., there is no difference between transparent \u2014 visible to anyone \u2014 and shielded \u2014 visible only to the parties holding the viewing keys \u2014 resources), but the amount of information revealed about the states differs. It is realised with the help of shielded execution, in which the state transition is only visible to the parties involved.</li> <li>Account abstraction \u2014 each resource is controlled by a resource logic \u2014 a custom predicate that encodes constraints on valid state transitions for that kind of resource and determines when a resource can be created or consumed. A valid state transition requires a resource logic validity proof for every resource created or consumed in the proposed state transition.</li> <li>Intent-centric architecture \u2014 the ARM provides means to express intents and ensures their correct and complete fulfilment and settlement.</li> </ul> <p>The design of the Anoma Resource Machine was significantly inspired by the Zcash protocol.</p> <p>The rest of the document contains the definitions of the ARM building blocks and the necessary and sufficient requirements to build the Anoma Resource Machine.</p> <ul> <li>10.5281/zenodo.10498991</li> <li>ART Index</li> </ul>","tags":["resource-machine","protocol","commitment","nullifier","accumulator","resource logic"],"boost":2},{"location":"arch/system/state/resource_machine/index.html#notation","title":"Notation","text":"<p>For a function \\(h\\), we denote the output finite field of \\(h\\) as \\(\\mathbb{F}_h\\). If a function \\(h\\) is used to derive a component \\(x\\), we refer to the function as \\(h_x\\), and the corresponding to \\(h\\) finite field is denoted as \\(\\mathbb{F}_{h_x}\\), or, for simplicity, \\(\\mathbb{F}_x\\).</p> <ul> <li>Keywords: anoma, blockchain technology, protocol design, resource machine</li> </ul>","tags":["resource-machine","protocol","commitment","nullifier","accumulator","resource logic"],"boost":2},{"location":"arch/system/state/resource_machine/action.html","title":"Action","text":"<p>An action is a composite structure \\(A = (cms, nfs, \\Pi, app\\_data)\\), where:</p> <ul> <li>\\(cms \\subseteq  \\mathbb{F}_{cm}\\) is a set of created resources' commitments.</li> <li>\\(nfs \\subseteq \\mathbb{F}_{nf}\\) is a set of consumed resources' nullifiers.</li> <li>\\(\\Pi: \\{ \\pi: PS.Proof\\}\\) is a set of proofs.</li> <li>\\(app\\_data: \\{(k, (d, deletion\\_criterion)): k \\in \\mathbb{F}_{key}, d \\subseteq \\mathbb{F}_{d}\\}\\) contains application-specific data needed to create resource logic proofs. The deletion criterion field is described here.</li> </ul> <p>Actions partition the state change induced by a transaction and limit the resource logics evaluation context: proofs created in the context of an action have guaranteed access only to the resources associated with the action. A resource is said to be associated with an action if its commitment or nullifier is present in the action's \\(cms\\) or \\(nfs\\) correspondingly. A resource is said to be consumed in the action for a valid action if its nullifier is present in the action's \\(nfs\\) set. A resource is said to be created in the action for a valid action if its commitment is in the action's \\(cms\\) set.</p>","boost":2},{"location":"arch/system/state/resource_machine/action.html#proofs","title":"Proofs","text":"<p>Each action refers to a set of resources to be consumed and a set of resources to be created. Creation and consumption of a resource requires a set of proofs that attest to the correctness of the proposed action. There are two proof types associated with each action:</p> <ul> <li>Resource logic proof \\(\\pi_{RL}\\). For each resource consumed or created in the action, it is required to provide a proof that the logic of the resource evaluates to \\(1\\) given the input parameters that describe the state transition induced by the action (the exact resource machine instantiation defines the exact set of parameters). The number of such proofs in an action equals to the amount of resources (both created and consumed) in that action, even if the resources have the same logic.</li> <li>Resource machine compliance proofs - a set of proofs that ensures that the provided action complies with the resource machine definitions.</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/action.html#compliance-proofs-and-compliance-units","title":"Compliance proofs and compliance units","text":"<p>Each compliance proof maps to some compliance unit. The set of resources in each action is implicitly partitioned into compliance units, the size of a single compliance unit is determined by a concrete resource machine instantiation. The total number of compliance proofs required for an action is determined by the number of compliance units that comprise the action, and can vary from 1 (one proof for all resources in the action at the same time) to the total number of resources in the action (one compliance proof per one resource). For example, if the instatiation defines a single compliance proof to include 1 input and 1 output resource, and an action contains 3 input and 2 output resources, the total number of compliance units will be 3 (the third output resource can be \"dummy\").</p>","boost":2},{"location":"arch/system/state/resource_machine/action.html#input-existence-check","title":"Input existence check","text":"<p>Each resource machine compliance proof must check the following:</p> <ul> <li>each consumed resource was created (its commitment is included in \\(CMtree\\))</li> <li>the resource commitments and nullifiers are derived according to the commitment and nullifier derivation rules (including the commitments of the consumed resources)</li> <li>resource deltas are computed correctly</li> <li>the resource logics of created and consumed resources are satisfied</li> </ul> <p>Compliance proofs must be composition-independent: composing two actions, the compliance proof sets can be simply united to provide a valid composed action compliance proof set.</p>","boost":2},{"location":"arch/system/state/resource_machine/action.html#unproven-and-proven-actions","title":"Unproven and proven actions","text":"<p>An action that contains all of the required proofs is considered proven. Such an action is bound to the resources it contains and cannot be modified without reconstructing the proofs.</p> <p>In case an action doesn't contain all of the expected proofs, it is called unproven. Unproven actions are, strictly speaking, not valid actions (because they don't contain the required proofs), but might be handy when the proving context for the resource logics is still being constructed.</p>","boost":2},{"location":"arch/system/state/resource_machine/action.html#unproven-proven-action","title":"Unproven \u2192 proven action","text":"<p>After adding the required proofs to an unproven action, the action becomes proven.</p>","boost":2},{"location":"arch/system/state/resource_machine/action.html#creation","title":"Creation","text":"<p>Given a set of input resource plaintexts \\(\\{r_{{in}_1}, \\cdots, r_{{in}_n}\\}\\), a set of output resource plaintexts \\(\\{r_{{out}_1}, \\cdots, r_{{out}_m}\\}\\), a set of nullifier keys corresponding to the input resources \\(\\{nk_1,\\cdots,nk_n\\}\\), \\(app\\_data\\), and a set of custom inputs required by resource logics, a proven action \\(A\\) is computed as:</p> <ul> <li>\\(cms = \\{h_{cm}(r_{{out}_i}, i = 1 \\cdots m\\}\\)</li> <li>\\(nfs = \\{h_{nf}(nk_i, r_{{in}_i}), i = 1 \\cdots n\\}\\)</li> <li>\\(\\Pi\\):     \\(\\{\\pi_{RL}^{{in}_i}, i = 1 \\cdots n \\} \\cup \\{\\pi_{RL}^{{out}_i}, i = 1 \\cdots m \\} \\cup \\{\\pi_{compl}^j, 1 \\leq j \\leq m + n \\}\\)</li> <li>\\(app\\_data\\)</li> </ul> <p>An unproven action would be computed the same way, except the resource logic proofs wouldn't be computed yet.</p>","boost":2},{"location":"arch/system/state/resource_machine/action.html#composition","title":"Composition","text":"<p>Since proven actions already contain all of the required proofs, there is no need to expand the evaluation context of such actions, therefore proven actions are not composable.</p> <p>Right now we assume that each action is created by exactly one party in one step, meaning that unproven actions are not composable.</p>","boost":2},{"location":"arch/system/state/resource_machine/action.html#validity","title":"Validity","text":"<p>Validity of an action cannot be determined for actions that are not associated with some transaction. Assuming that an action is associated with a transaction, an action is considered valid if the following holds:</p> <ul> <li>action input resources have valid resource logic proofs associated with them</li> <li>action output resources have valid resource logic proofs associated with them</li> <li>all compliance proofs are valid</li> <li>transaction's \\(rts\\) field contains correct \\(CMtree\\) roots (that were actual \\(CMtree\\) roots at some epochs) used to prove the existence of consumed resources in the compliance proofs.</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/action.html#action-delta-computable-component","title":"Action delta (computable component)","text":"<p>Action \\(\\Delta\\) is a computable component used to compute transaction \\(\\Delta\\). It is computed from \\(\\Delta\\) of the resources that comprise the action and defined as \\(a.\\Delta = \\sum{r^{in}.\\Delta} - \\sum{r^{out}.\\Delta}\\)</p> <p>From the homomorphic properties of \\(h_\\Delta\\), for the resources of the same kind \\(kind\\): \\(\\sum_j{h_\\Delta(kind, r_{i_j}.q)} - \\sum_j{h_\\Delta(kind, r_{o_j}.q)} = \\sum_j{r_{i_j}.\\Delta} - \\sum_j{r_{o_j}.\\Delta} =  h_\\Delta(kind, q_{kind})\\). The kind-distinctness property of \\(h_\\Delta\\) allows computing \\(\\Delta_{tx} = \\sum_j{r_{i_j}.\\Delta} - \\sum_j{r_{o_j}.\\Delta}\\) adding resources of all kinds together without the need to account for distinct resource kinds explicitly: \\(\\sum_j{r_{i_j}.\\Delta} - \\sum_j{r_{o_j}.\\Delta} = \\sum_j{h_\\Delta(kind_j, q_{kind_j})}\\).</p> <p>When action delta is provided as input and not computed directly, it has to be explicitly checked that the action delta is correctly computed from the resource deltas.</p> <p>Unlike transactions, actions don't need to be balanced, but if an action is valid and balanced, it is sufficient to create a balanced transaction.</p>","boost":2},{"location":"arch/system/state/resource_machine/applications.html","title":"Applications","text":"<p>The ARM applications are characterised by a set of resource logics and its read and write interfaces.</p> <p>\\(Application = (AppLogic, AppReadInterface, AppWriteInterface)\\), where</p> <ul> <li>\\(AppLogic \\subseteq \\mathbb{F}_l\\) is a set of resource logics.</li> <li>\\(AppWriteInterface = \\{tf: TransactionFunction\\}\\) is a set of functions that represents what kinds of state transitions the application offers.</li> <li>\\(AppReadInterface = \\{pf: ProjectionFunction\\}\\) is a set of functions that interprete the current state. Projection functions are defined as \\(ProjectionFunction: AppState \\rightarrow T\\), where \\(AppState = AppResources \\times AppData\\), with \\(AppResources\\) containing all resources bound to the application\u2019s logic and \\(AppData\\) referring to the non-linear data the application might assume.</li> </ul> <p>As any abstract state transition can be represented as a transaction consuming and creating resources of certain kinds (or a transaction function that evaluates to such a transaction), the transaction functions associated with the application represent the set of actions that the application can provide to its users. Each transaction function would require a subset of the application resource logics to approve the transaction in order to realise the desired action. The transaction function evaluated with the exact resources to be created and consumed forms a transaction.</p> <p>The resources that are bound with the application resource logics are said to belong to the application and, along with some non-linear data the application might assume, constitute the application state. When the application does not have any resources that were created but not consumed yet, the application only exists virtually but not tangibly.</p> <p>The abstraction of an application is virtual - applications are not deployed or tracked in any sort of global registry, and the ARM is unaware of the existence of applications.</p> <p>We define \\(AppKinds \\subseteq \\mathbb{F}_{kind}\\) as a union of all resource kinds that are involved in the transaction functions that comprise the application interface.</p>","boost":2},{"location":"arch/system/state/resource_machine/applications.html#composition","title":"Composition","text":"<p>Applications are composable. The composition of two (or more) applications would be a composition of the corresponding logics and interfaces.</p> <p>\\(App_12 = App_1 \\circ App_2\\):</p> <ul> <li>\\(AppLogic_{12} = AppLogic_1 \\cup AppLogic_2\\)</li> <li>\\(AppWriteInterface_{12} = AppWriteInterface_1 \\cup AppWriteInterface_2\\)</li> <li>\\(AppReadInterface_{12} = AppReadInterface_1 \\cup AppReadInterface_2\\)</li> <li>\\(AppKinds_{12} = AppKinds_1 \\cup AppKinds_2\\)</li> </ul> <p>In this type of composition the order in which the applications are composed doesn't matter.</p>","boost":2},{"location":"arch/system/state/resource_machine/applications.html#application-extension","title":"Application extension","text":"<p>Application extension is a way to generate a new application starting from an existing one by enhancing the application logic and the application interface with operations on more resource kinds. The new application is dependent on the initial one, meaning that the new application logic includes constraints involving the first application resource kinds, and the new interface requires the presence of resources of the first application kinds.</p>","boost":2},{"location":"arch/system/state/resource_machine/applications.html#distributed-application-state-synchronisation","title":"Distributed application state synchronisation","text":"<p>In the controllers report, a controller is defined as a component that orders transactions. The resource machine is designed to work in both single-controller and multi-controller environments, such as Anoma. In the context of multi-controller environments, each resource contains information about its current controller, can only be consumed on its controller, and can be transferred from one controller to another, meaning that a new controller becomes responsible for the correct resource consumption. Transferring a resource can be done by consuming a resource on the old controller and creating a similar resource on the new controller.</p> <p>Applications do not have to exist within the bounds of a single controller, and can maintain a single virtual state while the application resources being distributed among multiple controllers, which forms a distributed application state. To make sure such a distributed state correctly represents the application state, state synchronisation between multiple controllers is required.</p>","boost":2},{"location":"arch/system/state/resource_machine/applications.html#controller-state-synchronisation","title":"Controller state synchronisation","text":"<p>Each controller would have their own commitment tree associated with it. Treated as subtrees of a larger Merkle tree, the controller commitment trees comprise a global commitment tree, where the leaves are the roots of the controller trees.</p>","boost":2},{"location":"arch/system/state/resource_machine/roles_and_requirements.html","title":"Roles and requirements","text":"<p>The table below contains a list of resource-related roles. In the Anoma protocol, the role of the resource creator will often be taken by a solver, which creates additional security requirements compared to the case when protocol users solve their own intents. Because of that, extra measures are required to ensure reliable distribution of the information about the created resource to the resource receiver.</p> Role Description Authorizer approves the resource consumption on the application level. The resource logic encodes the mechanism that connects the authorizer's external identity (public key) to the decision-making process Annuler knows the data required to nullify a resource Creator creates the resource and shares the data with the receiver Owner can both authorize and annul a resource Sender owns the resources that were consumed to create the created resource Receiver owns the created resource","boost":2},{"location":"arch/system/state/resource_machine/roles_and_requirements.html#reliable-resource-plaintext-distribution","title":"Reliable resource plaintext distribution","text":"<p>In the case of in-band distribution of created resources in contexts with higher security requirements, the resource creator is responsible for encrypting the resource plaintext. Verifiable encryption must be used to ensure the correctness of the encrypted data: the encrypted plaintext must be proven to correspond to the resource plaintext, which is passed as a private input.</p>","boost":2},{"location":"arch/system/state/resource_machine/roles_and_requirements.html#reliable-nullifier-key-distribution","title":"Reliable nullifier key distribution","text":"<p>Knowing the resource\u2019s nullifier reveals information about when the resource is consumed, as the nullifier will be published when it happens, which might be undesirable in the contexts with higher security requirements. For that reason, it is advised to keep the number of parties who can compute the resource\u2019s nullifier as low as possible in such contexts.</p> <p>In particular, the resource creator should not be able to compute the resource nullifier, and as the nullifier key allows to compute the resource's nullifier, it shouldn't be known to the resource creator. At the same time, the resource plaintext must contain some information about the nullifier key. One way to fulfil both requirements is, instead of sharing the nullifier key itself with the resource creator, to share some parameter derived from the nullifier key, but that does not allow computing the nullifier key or any meaningful information about it. This parameter is called a nullifier key commitment and is computed as \\(cnk = h_{cnk}(nk)\\).</p> <p>These concerns are not meaningful in the contexts with lower security requirements.</p>","boost":2},{"location":"arch/system/state/resource_machine/transaction.html","title":"Transaction","text":"<p>A transaction is a necessary and sufficient collection of fields required to apply a state update to the state. It is a composite structure \\(TX = (rts, actions, \\Delta, \\pi_{\\Delta})\\), where:</p> <ul> <li>\\(rts \\subseteq \\mathbb{F}_{rt}\\) is a set of roots of \\(CMtree\\).</li> <li>\\(actions: \\{a: Action\\}\\) - a set of actions.</li> <li>\\(\\Delta_{tx}: \\mathbb{F}_{\\Delta}\\) is computed from \\(\\Delta\\) parameters of the actions in that transaction. It represents the total quantity change per resource kind induced by the transaction, which is also referred to as transaction balance.</li> <li>\\(\\Pi_{\\Delta}\\) - transaction balance proof. It makes sure that \\(\\Delta_{tx}\\) is correctly derived from actions \\(\\Delta\\) and commits to the expected publicly known value, called a balancing value. There is just one delta proof per transaction.</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/transaction.html#creation","title":"Creation","text":"<p>Given a set of \\(CMtree\\) roots \\(rts\\) and a set of actions \\(actions\\), \\(tx = (rts, actions, \\pi_{\\Delta}, \\Delta_{tx})\\), where:</p> <ul> <li>\\(rts = rts\\)</li> <li>\\(actions = actions\\)</li> <li>\\(\\pi_{\\Delta_{tx}}\\)</li> <li>$\\Delta_{tx} = \\(\\Delta_{tx} = \\sum{a.\\Delta}, a \\in actions\\)</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/transaction.html#composition","title":"Composition","text":"<p>Having two transactions \\(tx_1\\) and \\(tx_2\\), their composition \\(tx_1 \\circ tx_2\\) is defined as a transaction \\(tx\\), where:</p> <ul> <li>\\(rts_{tx} = rts_1 \\cup rts_2\\)</li> <li>\\(actions_{tx} = actions_1 \\cup actions_2\\)</li> <li>\\(\\Pi^{\\Delta}_{tx} = AGG(\\Pi^{\\Delta}_1, \\Pi^{\\Delta}_2\\)), where \\(AGG\\) is a delta proof aggregation function, s.t. for \\(bv_1\\) being the balancing value of the first delta proof, \\(bv_2\\) being the balancing value of the second delta proof, and \\(bv_{tx}\\) being the balancing value of the composed delta proof, it satisfies \\(bv_{tx} = bv_1 + bv_2\\). The aggregation function takes two delta proofs as input and outputs a delta proof. The aggregation function is defined by the proving system and might require creation of a new proof.</li> <li>\\(\\Delta_{tx} = \\Delta_1 + \\Delta_2\\)</li> </ul> <p>When composing transactions, action sets are simply united without composing the actions. For example, composing a transaction with two actions and another transaction with three actions will result in a transaction with five actions.</p>","boost":2},{"location":"arch/system/state/resource_machine/transaction.html#validity","title":"Validity","text":"<p>A transaction is considered valid if the following statements hold:</p> <p>Checks that do not require access to global structures: - all actions in the transaction are valid, as defined per action validity rules - actions partition the state change induced by the transaction:   - there is no resource created more than once across actions   - there is no resource consumed more than once across actions - \\(\\pi_\\Delta\\) is valid</p> <p>Checks that require access to global \\(CMtree\\) and \\(NFset\\): - each created resource wasn't created in prior transactions - each consumed resource wasn't consumed in prior transactions</p> <p>A transaction is executable if it is valid and \\(\\Delta_{tx}\\) commits to the expected balancing value.</p>","boost":2},{"location":"arch/system/state/resource_machine/transaction.html#transaction-with-metadata","title":"Transaction with Metadata","text":"<p>Transaction with metadata is a data structure that contains a transaction, the executable part, and metadata used by actors to make more informed decisions and enforce some policies: \\(TransactionWithMetadata = (Transaction, Metadata)\\).</p> <p>Architecture-level \\(Metadata\\) components:</p> <ul> <li>\\(\\Phi: PREF\\) where \\(PREF = TX \\rightarrow [0, 1]\\) is a preference function that takes a transaction as input and outputs a normalised value in the interval \\([0,1]\\) that reflects the users' satisfaction with the given transaction. For example, a user who wants to receive at least \\(q=5\\) of resource of kind A for a fixed amount of resource of kind B might set the preference function to implement a linear function that returns \\(0\\) at \\(q=5\\) and returns \\(1\\) at \\(q = q_{max} = |\\mathbb{F}_q| - 1\\).</li> <li>\\(IFCPredicate: TX \\rightarrow ExternalIdentity \\rightarrow \\mathbb{F}_2\\) is a predicate that specifies the transaction visibility.</li> </ul> <p>A concrete resource machine instantiation might require more \\(Metadata\\) components.</p>","boost":2},{"location":"arch/system/state/resource_machine/transaction.html#information-flow-control","title":"Information flow control","text":"<p>The transaction visibility specified by the \\(IFCPredicate\\) describes what parties are and are not allowed to process the transaction. In the current version it is assumed that every node is following the policy and enforcing the conditions specified by the predicate.</p> <p>In principle, the information flow predicate can be arbitrary as long as it satisfies the defined signature, but for now we define a set of allowed options to instantiate the IFC predicate as \\(BasePredicate: BaseData \\rightarrow IFCPredicate\\), where \\(BaseData\\) can be:</p> <ul> <li>\\(AllowAny\\) - always returns 1</li> <li>\\(AllowOnly (Set\\ ExternalIdentity)\\) - returns 1 for the specified set of identities</li> <li>\\(RequireShielded (Set\\ Hash)\\) - returns 1 if the transaction does not contain the specified set of hashes in its fields</li> <li>\\(And (Set\\ Predicate)\\) - returns 1 when all the specified predicates (instantiated by one of the base predicates) are satisfied</li> <li>\\(Or (Set\\ Predicate)\\) - returns 1 when at least one of the specified predicates (instantiated by one of the base predicates) is satisfied</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/transaction.html#composing-transactions-with-metadata","title":"Composing transactions with metadata","text":"<p>When transactions with \\(Metadata\\) are composed, transactions are composed according to the transaction composition rules, and \\(MetaData\\) fields are composed as follows:</p> <ul> <li>\\(\\Phi_{tx} = G(\\Phi_1, \\Phi_2)\\), where \\(G: PREF \\times PREF \\rightarrow PREF\\), and \\(G\\) is a preference function composition function</li> <li>\\(IFCPredicate_{tx} = IFCPredicate_1 \\wedge IFCPredicate_2\\)</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/transaction.html#transaction-function","title":"Transaction function","text":"<p>A transaction function is a function that outputs a transaction: \\(TransactionFunction: () \\rightarrow Transaction\\).</p> <p>Transaction functions take no input but can perform I/O operations to read information about global state either by reading data at the specified global storage address or by fetching data by index. The requirements for transaction functions are further described here.</p>","boost":2},{"location":"arch/system/state/resource_machine/function_formats/nockma.html","title":"Nockma","text":"<p>Nockma (Nock-Anoma) is a modification of the Nock4K specification and a Nock standard library altered and extended for use with Anoma. Nockma is designed to support the transaction function interpreter requirements, namely, global storage read and deterministic bounded computation costs.</p> <p>Nockma is parameterized over a specific finite field \\(\\mathbb{F}_h\\) and function \\(h\\). The function \\(h\\) takes an arbitrary noun (a data unit in Nockma) as input and returns an element of \\(\\mathbb{F}_h\\). This function is used for verifying reads from content-addressed storage.</p> <p>A scry (inspired by Urbit\u2019s concept of the same name) is a read-only request to Anoma\u2019s global content-addressed namespace or indices computed over values stored in this namespace. Scrying is used to read data that would be inefficient to store in the noun, to read indices whose value might only be known at execution time, or to read data that may not be accessible to the author of the noun.</p> <p>Scrying comes in two types: \"direct\" or \"index\". A direct lookup simply returns the value stored at the address (integrity can be checked using \\(h\\)), or an error if a value is not found. An index lookup uses the value stored at the address as an index function and returns the results of computing that index or an error if the index is not found, invalid, or uncomputable. The lookup type is the only parameter required apart from the content address (which must be an element of \\(\\mathbb{F}_h\\)).</p> <p>Typically, the index functions allowed will be very restricted, e.g. current unspent resources of a particular kind. Gas costs of scrying will depend on the index function and the size of the results returned.</p> <p>Scrying may be used to avoid unnecessary, redundant transmission of common Nockma subexpressions, such as the standard library.</p> <p>Nockma is a combinator interpreter defined as a set of reduction rules over nouns. A noun is an atom or a cell, where an atom is a natural number and a cell is an ordered pair of nouns.</p> <p>The Nockma reduction rules as presented in the table below are applied from top to bottom, the first rule from the top matches. Variables match any noun. As in regular Nock4K, a formula that reduces to itself is an infinite loop, which we define as a crash (\"bottom\" in formal logic). A real interpreter can detect this crash and produce an out-of-band value instead.</p> <p>The only difference between Nockma and Nock4K reduction rules is that instruction 12 is defined for scrying.</p> <p>Used with the resource machine, Nockma should return a set of modifications to the state transition expressed by the input transaction:</p> <ul> <li>a set of resources to additionally create (resource plaintexts)</li> <li>a set of resources to additionally consume (addresses)</li> <li>a set of storage writes (in the format specified here)</li> </ul> <p>The Nockma standard library must include the following functions.</p>","boost":2},{"location":"arch/system/state/resource_machine/function_formats/nockma.html#finite-field","title":"Finite field","text":"<p>For a finite field \\(\\mathbb{F}_n\\) of order \\(n\\), it should support:</p> <ul> <li>additive identity of type \\(\\mathbb{F}_n\\)</li> <li>addition operation \\(\\mathbb{F}_n \\times \\mathbb{F}_n \\rightarrow \\mathbb{F}_n\\)</li> <li>additive inversion \\(\\mathbb{F}_n \\rightarrow \\mathbb{F}_n\\)</li> <li>multiplicative identity of type \\(\\mathbb{F}_n\\)</li> <li>multiplication operation \\(\\mathbb{F}_n \\times \\mathbb{F}_n \\rightarrow \\mathbb{F}_n\\)</li> <li>multiplicative inversion \\(\\mathbb{F}_n \\rightarrow \\mathbb{F}_n\\)</li> <li>equality operation \\(\\mathbb{F}_n \\times \\mathbb{F}_n \\rightarrow \\mathbb{F}_2\\)</li> <li>comparison operation based on canonical ordering \\(\\mathbb{F}_n \\times \\mathbb{F}_n \\rightarrow \\mathbb{F}_2\\)</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/function_formats/nockma.html#ring-z_n","title":"Ring \\(Z_n\\)","text":"<p>For a ring \\(Z_n\\) of unsigned integers \\(\\mathrm{mod}~n\\), it should support:</p> <ul> <li>additive identity of type \\(Z_n\\)</li> <li>addition operation \\(Z_n \\times Z_n \\rightarrow Z_n \\times \\mathbb{F}_2\\) (with overflow indicator)</li> <li>subtraction operation \\(Z_n \\times Z_n \\rightarrow Z_n \\times \\mathbb{F}_2\\) (with overflow indicator)</li> <li>multiplicative identity of type \\(Z_n\\)</li> <li>multiplication operation \\(Z_n \\times Z_n \\rightarrow Z_n \\times \\mathbb{F}_2\\) (with overflow indicator)</li> <li>division operation (floor division) \\(Z_n \\times Z_n \\rightarrow Z_n\\)</li> <li>equality \\(Z_n \\times Z_n \\rightarrow \\mathbb{F}_2\\)</li> <li>comparison \\(Z_n \\times Z_n \\rightarrow \\mathbb{F}_2\\)</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/function_formats/nockma.html#parametrized-conversion-function","title":"Parametrized conversion function","text":"<p>Additionally, it should provide a parametrized conversion function \\(conv_{i,j,k,l}\\), where:</p> <ul> <li>\\(i\\) is a flag that defines the input type: \\(i = 0\\) corresponds to a finite field, \\(i = 1\\) corresponds to a ring of unsigned integers</li> <li>\\(j\\) is the input structure order</li> <li>\\(k\\) is a flag that defines the output type: \\(k = 0\\) corresponds to a finite field, \\(k = 1\\) corresponds to a ring of unsigned integers</li> <li>\\(l\\) is the output structure order</li> </ul> <p>If the order of the input structure is bigger than the order of the output structure (\\(j &gt; l\\)), the conversion function would return a flag (of type \\(\\mathbb{F}_2\\)) indicating if overflow happened in addition to the converted value.</p> <p>The conversion function must use canonical ordering and respect the inversion laws.</p>","boost":2},{"location":"arch/system/state/resource_machine/function_formats/preference_function.html","title":"Preference Function","text":"<p>Preference functions do not require I/O communication or have any other special requirements. They are stateless. It may make sense to interpret them using the same system used for transaction functions for simplicity.</p>","boost":2},{"location":"arch/system/state/resource_machine/function_formats/resource_logic.html","title":"Resource Logic","text":"<p>A resource logic is a predicate associated with a resource that checks that the provided data satisfies a set of constraints. It does not require I/O communication and is represented by or can feasibly be turned into a zk-SNARK circuit if desired to support shielded execution.</p> <p>Each resource logic has a set of public and private input values. Resource logics are customizable on both implementation of the ARM (different instantiations might have different requirements for all resource logics compatible with this instantiation) and resource logic creation level (each instantiation supports arbitrary resource logics as long as they satisfy the requirements). A concrete implementation of the ARM can specify more mandatory inputs and checks (e.g., if the resources are distributed in-band, resource logics have to check that the distributed encrypted value indeed encrypts the resources created/consumed in the action), but the option of custom inputs and constraints must be supported to enable different resource logic instances existing on the application level.</p> <p>The proving system used to interpret resource logics must provide the following properties:</p> <ul> <li>Verifiability. It must be possible to produce and verify a proof of type \\(PS.Proof\\) that given a certain set of inputs, the resource logic output is true value.</li> <li>The system \\(PS\\) used to interpret resource logics must be zero-knowledge- and function-privacy-friendly to support privacy-preserving contexts.</li> </ul> <p>Resource logics take as input resources created and consumed in the action:</p>","boost":2},{"location":"arch/system/state/resource_machine/function_formats/resource_logic.html#resource-logic-public-inputs","title":"Resource Logic Public Inputs","text":"<ul> <li>\\(nfs \\subseteq nfs_{tx}\\)</li> <li>\\(cms \\subseteq cms_{tx}\\)</li> <li>\\(tag: \\mathbb{F}_{tag}\\) \u2014  identifies the resources being checked</li> <li>\\(extra \\subseteq tx.extra\\)</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/function_formats/resource_logic.html#resource-logic-private-inputs","title":"Resource Logic Private Inputs","text":"<ul> <li>input resources corresponding to the elements of \\(nfs\\)</li> <li>output resource corresponding to the elements of \\(cms\\)</li> <li>custom inputs</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/function_formats/resource_logic.html#resource-logic-constraints","title":"Resource Logic Constraints","text":"<ul> <li>for each output resource, check that the corresponding \\(cm\\) value is derived according to the rules specified by the resource machine instance</li> <li>for each input resource, check that the corresponding \\(nf\\) value is derived according to the rules specified by the resource machine instantiation</li> <li>custom checks</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/function_formats/transaction_function.html","title":"Transaction function","text":"","boost":2},{"location":"arch/system/state/resource_machine/function_formats/transaction_function.html#transaction-function","title":"Transaction function","text":"<p>The system used to represent and interpret transaction functions must have a deterministic computation model; each operation should have a fixed cost of space and time (for total cost computation). To support content addressing, it must have memory and support memory operations (specifically <code>read</code>, <code>write</code>, <code>allocate</code>).</p> <p>The system must support the following I/O operations:</p> <ul> <li><code>READ_STORAGE</code>(<code>address</code>: \\(\\mathbb{F}_{cm}\\)): read the global content-addressed storage at the specified address and return the value stored at the address. If the value is not found, the operation should return an error. Storage not accessible to the machine should be treated as non-existent.</li> <li><code>DATA_BY_INDEX</code>(<code>index_function)</code>: read data from the storage (either resources or arbitrary data kept in the storage requested by the transaction function) at the execution time by the specified index function. If the index function output is invalid or uncomputable, or the data cannot be located, the operation should return an error. Typically, the index functions allowed will be very restricted, e.g. an index function returning current unspent resources of a particular kind.</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/function_formats/transaction_function.html#gas-model","title":"Gas model","text":"<p>To compute and bound the total cost of computation, the transaction function system must support a gas model. Each evaluation would have a gas limit \\(g_{limit}\\), and the evaluation would start with \\(g_{count} = 0\\). Evaluating an operation, the system would add the cost of the operation to the counter \\(g_{count}\\) and compare it to \\(g_{limit}\\). When making recursive calls, \\(g_{count}\\) is incremented before the recursion occurs. If the value of \\(g_{count}\\) is greater than \\(g_{limit}\\), the execution is terminated with an error message indicating that the gas limit has been surpassed.</p>","boost":2},{"location":"arch/system/state/resource_machine/resource/definition.html","title":"Resource","text":"<p>A resource is a composite structure \\(R = (l, label, q, v, eph, nonce, cnk, rseed): Resource\\) where:</p> <ul> <li>\\(Resource = \\mathbb{F}_{l} \\times \\mathbb{F}_{label} \\times \\mathbb{F}_Q \\times \\mathbb{F}_{v} \\times \\mathbb{F}_b \\times \\mathbb{F}_{nonce} \\times  \\mathbb{F}_{cnk} \\times \\mathbb{F}_{rseed}\\)</li> <li>\\(l: \\mathbb{F}_{l}\\) is a succinct representation of the predicate associated with the resource (resource logic)</li> <li>\\(label: \\mathbb{F}_{label}\\) specifies the fungibility domain for the resource. Resources within the same fungibility domain are seen as equivalent kinds of different quantities. Resources from different fungibility domains are seen and treated as distinct asset kinds. This distinction comes into play in the balance check described later.</li> <li>\\(q: \\mathbb{F}_Q\\) is a number representing the quantity of the resource</li> <li>\\(v: \\mathbb{F}_{v}\\) is the fungible data associated with the resource. It contains extra information but does not affect the resource's fungibility</li> <li>\\(eph: \\mathbb{F}_b\\) is a flag that reflects the resource's ephemerality. Ephemeral resources do not get checked for existence when being consumed</li> <li>\\(nonce: \\mathbb{F}_{nonce}\\) guarantees the uniqueness of the resource computable components</li> <li>\\(cnk: \\mathbb{F}_{cnk}\\) is a nullifier key commitment. Corresponds to the nullifier key \\(nk\\) used to derive the resource nullifier (nullifiers are further described here)</li> <li>\\(rseed: \\mathbb{F}_{rseed}\\): randomness seed used to derive whatever randomness needed</li> </ul> <p>To distinguish between the resource data structure consisting of the resource components and a resource as a unit of state identified by just one (or some) of the resource computed fields, we sometimes refer to the former as a resource plaintext.</p>","boost":2},{"location":"arch/system/state/resource_machine/resource/non_linear_resources.html","title":"Non-linear resources","text":"<p>Non-linear resource is a resource that can be consumed multiple times, as opposed to a linear resource, that can only be consumed exactly once. Such resources could be useful to hold external data (e.g., the current gas price) that can be read multiple times. However, having native non-linear resources introduces some challenges as some basic assumptions about resources (e.g., nullifier uniqueness) wouldn't hold any more. At the same time, the resource structure might be unnecessary and excessive for storing such data. For these reasons, the ARM doesn't support native non-linear resources.</p> <p>Without having non-linear resources, such functionality can be achieved from storing the data intended to be read separately and passing it to resource logics as arbitrary input. The authenticity of the provided data has to be verified first, and then it can be used by the resource logic as a valid source of information.</p>","boost":2},{"location":"arch/system/state/resource_machine/resource/computable_components/commitment.html","title":"Resource Commitment","text":"<p>Information flow control property implies working with flexible privacy requirements, varying from transparent contexts, where almost everything is publicly known, to contexts with stronger privacy guarantees, where as little information as possible is revealed.</p> <p>From the resource model perspective, stronger privacy guarantees require operating on resources that are not publicly known in a publicly verifiable way. Therefore, proving the resource's existence has to be done without revealing the resource's plaintext.</p> <p>One way to achieve this would be to publish a commitment to the resource plaintext. For a resource \\(r\\), the resource commitment is computed as \\(r.cm = h_{cm}(r)\\). Resource commitment has binding and hiding properties, meaning that the commitment is tied to the created resource but does not reveal information about the resource beyond the fact of creation. From the moment the resource is created, and until the moment it is consumed, the resource is a part of the system's state.</p> <p>The resource commitment is also used as the resource's address \\(r.addr\\) in the content-addressed storage. Consumption of the resource does not necessarily affect the resource's status in the storage (e.g., it doesn't get deleted).</p>","boost":2},{"location":"arch/system/state/resource_machine/resource/computable_components/commitment.html#commitment-accumulator","title":"Commitment accumulator","text":"<p>All resource commitments are stored in an append-only data structure called a commitment accumulator \\(CMacc\\). Every time a resource is created, its commitment is added to the commitment accumulator. The resource commitment accumulator \\(CMacc\\) is external to the resource machine, but the resource machine can read from it. A commitment accumulator is a cryptographic accumulator that allows to prove membership for elements accumulated in it, provided a witness and the accumulated value.</p> <p>Each time a commitment is added to the \\(CMacc\\), the accumulator and all witnesses of the already accumulated commitments are updated. For a commitment that existed in the accumulator before a new one was added, both the old witness and the new witness (with the corresponding accumulated value parameter) can be used to prove membership. However, the older the witness (and, consequently, the accumulator) that is used in the proof, the more information about the resource it reveals (an older accumulator gives more concrete boundaries on the resource's creation time). For that reason, it is recommended to use fresher parameters when proving membership.</p>","boost":2},{"location":"arch/system/state/resource_machine/resource/computable_components/commitment.html#accumulator-functionality","title":"Accumulator functionality","text":"<p>The commitment accumulator \\(Acc\\) must support the following functionality:</p> <ul> <li><code>ADD(acc, cm)</code> adds an element to the accumulator, returning the witness used to prove membership.</li> <li><code>WITNESS(acc, cm)</code> for a given element, returns the witness used to prove membership if the element is present, otherwise returns nothing.</li> <li><code>VERIFY(cm, w, val)</code> verifies the membership proof for an element \\(cm\\) with a membership witness \\(w\\) for the accumulator value \\(val\\).</li> <li><code>VALUE(acc)</code> returns the accumulator value.</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/resource/computable_components/commitment.html#instantiation","title":"Instantiation","text":"<p>Currently, the commitment accumulator is assumed to be a Merkle tree \\(CMtree\\) of depth \\(depth_{CMtree}\\), where the leaves contain the resource commitments and the intermediate nodes' values are computed using a hash function \\(h_{CMtree}\\).</p> <p>The hash function \\(h_{CMtree}\\) used to compute the nodes of the \\(CMtree\\) Merkle tree is not necessarily the same as the function used to compute commitments stored in the tree \\(h_{cm}\\).</p> <p>For a Merkle tree, the witness is the path to the resource commitment, and the tree root represents the accumulated value. To support the systems with stronger privacy requirements, the witness for such a proof must be a private input when proving membership.</p>","boost":2},{"location":"arch/system/state/resource_machine/resource/computable_components/delta.html","title":"Resource Delta","text":"<p>Resource deltas are used to reason about the total quantities of different kinds of resources in transactions. For a resource \\(r\\), its delta is computed as \\(r.\\Delta = h_{\\Delta}(r.kind, r.q)\\).</p> <p>The function used to derive \\(r.\\Delta\\) must have the following properties:</p> <ul> <li>For resources of the same kind \\(kind\\), \\(h_{\\Delta}\\) should be additively homomorphic: \\(r_1.\\Delta + r_2.\\Delta = h_{\\Delta}(kind, r_1.q + r_2.q)\\)</li> <li>For resources of different kinds, \\(h_\\Delta\\) has to be kind-distinct: if there exists \\(kind\\) and \\(q\\) s.t. \\(h_\\Delta(r_1.kind, r_1.q) + h_\\Delta(r_2.kind, r_2.q) = h_\\Delta(kind, q)\\), it is computationally infeasible to compute \\(kind\\) and \\(q\\).</li> </ul> <p>An example of a function that satisfies these properties is the Pedersen commitment scheme: it is additively homomorphic, and its kind-distinctness property comes from the discrete logarithm assumption.</p>","boost":2},{"location":"arch/system/state/resource_machine/resource/computable_components/introduction.html","title":"Introduction","text":"<p>Resource computable components are the components that are derivable from the resource components, other computed components, and possibly some secret data by applying a function from class \\(H\\).</p>","boost":2},{"location":"arch/system/state/resource_machine/resource/computable_components/kind.html","title":"Resource Kind","text":"<p>For a resource \\(r\\), its kind is computed as \\(r.kind = h_{kind}(r.l, r.label)\\).</p>","boost":2},{"location":"arch/system/state/resource_machine/resource/computable_components/nullifier.html","title":"Resource Nullifier","text":"<p>A resource nullifier is a computed field, the publishing of which consumes the associated with the nullifier resource. For a resource \\(r\\), the nullifier is computed from the resource's plaintext and a key called a nullifier key: \\(r.nf = h_{nf}(nk, r)\\). A resource can be consumed only once. Nullifiers of consumed resources are stored in a public add-only structure called the resource nullifier set (\\(NFset\\)). This structure is external to the resource machine, but the resource machine can read from it.</p> <p>Every time a resource is consumed, it has to be checked that the resource existed before (the resource's commitment is in the \\(CMtree\\)) and has not been consumed yet (the resource's nullifier is not in the \\(NFset\\)).</p> <p>The nullifier set must support the following functionality:</p> <ul> <li><code>WRITE(nf)</code> adds an element to the nullifier set.</li> <li><code>EXISTS(nf)</code> checks if the element is present in the set, returning a boolean.</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/rm_def/definition.html","title":"Resource machine","text":"<p>A resource machine is a deterministic stateless machine that creates, composes, and verifies transaction functions.</p> <p>It has read-only access to the external global state, which includes the content-addressed storage system (which in particular stores resources), global commitment accumulator, and the global nullifier set, and can produce writes to the external local state that will later be applied to the system state.</p> <p>The resource machine has two layers: the outer layer, the resource machine shell, that creates and processes transaction functions, and the inner layer, the resource machine core, that creates and processes transactions.</p> <p>We assume the shell is trivial in this version of the ARM: it only evaluates the transaction function without any verification steps. The result is a transaction that is then passed to the core. The distribution of responsibilities between the shell and the core is expected to change.</p> <p>To support the shell layer, the resource machine must have the functionality to produce, compose, and evaluate transaction functions. Assuming the shell is trivial in the current version of the specification, the following description of the resource machine functionality describes the functionality of the resource machine core.</p>","boost":2},{"location":"arch/system/state/resource_machine/rm_def/definition.html#resource-machine-functions","title":"Resource machine functions","text":"<p>A resource machine provides the following functions:</p> <ul> <li>Create: given a set of components required to produce a transaction, the create function produces a transaction data structure according to the transaction creation rules.</li> <li>Compose: taking two transactions \\(tx_1\\) and \\(tx_2\\) as input, produces a new transaction \\(tx = tx_1 \\circ tx_2\\) according to the transaction composition rules.</li> <li>Verify: taking a transaction as input, verifies its validity according to the transaction validity rules. If the transaction is valid, the resource machine outputs a state update. Otherwise, the output is empty.</li> </ul>","boost":2},{"location":"arch/system/state/resource_machine/rm_def/definition.html#post-and-pre-ordering-execution","title":"Post- and pre-ordering execution","text":"<p>Pre-ordering execution implies partial evaluation of the transaction function. In practice pre-ordering execution happens before the transactions are ordered by the ordering machine external to the ARM.</p> <p>Post-ordering execution implies full evaluation of the transaction function. As the name suggests, post-ordering execution happens after the ordering machine external to the ARM completed the ordering of transaction functions.</p>","boost":2},{"location":"arch/system/state/resource_machine/rm_def/definition.html#arms-as-intent-machines","title":"ARMs as intent machines","text":"<p>Together with \\((CMtree, NFset)\\), the Anoma Resource Machine forms an instantiation of the intent machine, where the state \\(S = (CMtree, NFset)\\), a batch \\(B = Transaction\\), and the transaction verification function of the resource machine corresponds to the state transition function of the intent machine. To formally satisfy the intent machine's signature, the resource machine's verify function may return the processed transaction along with the new state.</p>","boost":2},{"location":"arch/system/state/resource_machine/rm_def/storage.html","title":"Stored data format","text":"<p>The ARM state that needs to be stored includes resource plaintexts, the commitment accumulator and the nullifier set. The table below defines the format of that data assumed by the ARM.</p> Name Structure Key Type Value Type Commitment accumulator (node) Cryptographic accumulator timestamp \\(\\mathbb{F}\\) Commitment accumulator (leaf) - (<code>timestamp</code>, \\(\\mathbb{F}\\)) \\(\\mathbb{F}\\) Nullifier set Set \\(\\mathbb{F}\\) \\(\\mathbb{F}\\) Hierarchical index Chained Hash sets Tree path \\(\\mathbb{F}\\) Data blob storage Key-value store with deletion criterion \\(\\mathbb{F}\\) (<code>variable length byte array</code>, <code>deletion criterion</code>)","boost":2},{"location":"arch/system/state/resource_machine/rm_def/storage.html#cmtree","title":"\\(CMtree\\)","text":"<p>Each commitment tree node has a timestamp associated with it, such that a lower depth (closer to the root) tree node corresponds to a less specified timestamp: a parent node timestamp is a prefix of the child node timestamp, and only the leaves of the tree have fully specified timestamps (i.e. they are only prefixes of themselves). For a commitment tree of depth \\(d\\), a timestamp for a commitment \\(cm\\) would look like \\(t_{cm} =t_1:t_2:..:t_d\\), with the parent node corresponding to it having a timestamp \\(t_1:t_2:..:*\\). The timestamps are used as keys for the key-value store. For the tree leaves, \\(&lt;cm, t_{cm}&gt;\\) pairs are used as keys. Merkle paths to resource commitments can be computed from the hierarchy of the timestamps.</p>","boost":2},{"location":"arch/system/state/resource_machine/rm_def/storage.html#nfset","title":"\\(NFset\\)","text":"<p>Nullifiers are used as keys in the key-value store. In future versions, a more complex structure that supports efficient non-membership proofs might be used for storing the nullifier set.</p>","boost":2},{"location":"arch/system/state/resource_machine/rm_def/storage.html#hierarchical-index","title":"Hierarchical index","text":"<p>The hierarchical index is organised as a tree where the leaves refer to the resources, and the intermediate nodes refer to resource subkinds that form a hierarchy. The label of a resource \\(r\\) stored in the hierarchical index tree is interpreted as an array of sublabels: \\(r.label = [label_1, label_2, label_3, ...]\\), and the i-th subkind is computed as \\(r.subkind_i = H_{kind}(r.l, r.label_i)\\).</p> <p>In the current version, only the subkinds derived from the same resource logic can be organized in the same hierarchical index path.</p> <p>The interface of the tree enables efficient querying of all children of a specific path and verifying that the returned children are the requested nodes. Permissions to add data to the hierarchical index are enforced by the resource logics and do not require additional checks.</p>","boost":2},{"location":"arch/system/state/resource_machine/rm_def/storage.html#data-blob-storage","title":"Data blob storage","text":"<p>Data blob storage stores data without preserving any specific structure. The data is represented as a variable length byte array and comes with a deletion criterion that determines for how long the data will be stored. The deletion criterion, in principle, is an arbitrary predicate, which in practice currently is assumed to be instantiated by one of the following options:</p> <ul> <li>delete after \\(block\\)</li> <li>delete after \\(timestamp\\)</li> <li>delete after \\(sig\\) over \\(data\\)</li> <li>delete after either predicate \\(p_1\\) or \\(p_2\\) is true; the predicates are instantiated by options from this list</li> <li>store forever</li> </ul>","boost":2},{"location":"basic_abstractions/index.html","title":"Basic Abstractions","text":"<p>This section describes the basic abstractions used throughout the protocol specification.</p> <p>Following preliminaries, basic abstractions are grouped into three areas of concern:</p> <ul> <li>encooding, covering how data and code are represented, evaluated, and converted between representations</li> <li>proving, covering how proofs are made and verified, what assumptions are required, and how these are tracked</li> <li>cryptographic primitives, covering the basic cryptographic primitives used throughout the protocol</li> </ul> <p>Info</p> <p>Note for authors: this section should be complete - all abstractions used across the protocol and required for agreement between nodes should be defined here.</p> (Wiki) links on this page<ul><li>Preliminaries</li></ul>","boost":2},{"location":"basic_abstractions/cryptographic_primitives/index.html","title":"Cryptographic primitives","text":"<ul> <li>Hash function</li> <li>Accumulator</li> <li>Proof system</li> </ul> (Wiki) links on this page<ul><li>Hash function</li><li>Accumulator</li><li>Proof</li></ul>","boost":2},{"location":"basic_abstractions/cryptographic_primitives/accumulator.html","title":"Accumulator","text":"<p>The protocol is parameterized over an accumulator type which must support the following functionality:</p> <ul> <li>\\(WRITE(cm)\\) adds an element to the accumulator, returning the witness used to prove membership.</li> <li>\\(WITNESS(cm)\\) for a given element, returns the witness used to prove membership if the element is present, otherwise returns nothing.</li> <li>\\(VERIFY(cm, w, acc)\\) verifies the membership proof for an element \\(cm\\) with a membership witness \\(w\\) in the accumulator \\(acc\\).</li> <li>\\(ACC()\\) returns the accumulator.</li> </ul>","boost":2},{"location":"basic_abstractions/cryptographic_primitives/hash_function.html","title":"Hash function","text":"<p>The protocol is parameterized over a set of hash functions \\(h\\). For a function \\(h\\), we denote the output finite field of \\(h\\) as \\(\\mathbb{F}_h\\). If a function \\(h\\) is used to derive a component \\(x\\), we refer to the function as \\(h_x\\), and the corresponding to \\(h\\) finite field is denoted as \\(\\mathbb{F}_{h_x}\\), or, for simplicity, \\(\\mathbb{F}_x\\).</p> <p>All \\(h_x\\) must be:</p> <ul> <li>one-way, in that it is not computationally feasible for any agent to compute the preimage from the hash output</li> <li>collision-resistant, in that it is not computationally feasible for any agent to find two different preimages which hash to the same value</li> </ul>","boost":2},{"location":"basic_abstractions/cryptographic_primitives/hash_function.html#multihashing","title":"Multihashing","text":"<p>We define the multihash function multihash as the concatenation of:</p> <ul> <li>a k-bit unsigned integer prefix \\(n\\)</li> <li>the output of \\(h_n\\)</li> </ul> <p>Canonical commitments are generated by multihash.</p>","boost":2},{"location":"basic_abstractions/encoding/index.html","title":"Encoding","text":"<p>The protocol does not pick a single canonical encoding scheme (serialization format) or virtual machine, both because:</p> <ul> <li>fashions in serialization schemes and virtual machines change over time, and   what scheme / VM makes most sense or is most suitable depends on specific   hardware and specific applications</li> </ul> <ul> <li>the protocol does not need to, and so avoiding doing so makes the protocol   simpler and easier to understand, since we can abstract the implementation   details of serialization schemes and virtual machines, and one can understand   how the protocol works without understanding those details (or being misled   into thinking that they\u2019re specially relevant for how the protocol works,   which they aren\u2019t)</li> </ul> <p>In order to facilitate interoperability between encoding schemes and virtual machines, the protocol standardises:</p> <ul> <li>a type of data types, which allows for data to be deserialized based on a   known type and for inputs and outputs to functions represented in different   virtual machines to be typechecked</li> </ul> <ul> <li>a multiformat for encoding schemes</li> </ul> <ul> <li>a multiformat for virtual machines</li> </ul> <ul> <li>the functions each encoding scheme must provide, and the expected properties   of those functions</li> </ul> <ul> <li>the functions each virtual machine must provide, and the expected properties   of those functions</li> </ul>","boost":2},{"location":"basic_abstractions/encoding/index.html#content","title":"Content","text":"<ul> <li>Data type</li> <li>Virtual machine</li> <li>Encoding scheme</li> <li>Multiencoding</li> </ul> (Wiki) links on this page<ul><li>Data type</li><li>Virtual machine</li><li>Encoding scheme</li></ul>","boost":2},{"location":"basic_abstractions/encoding/data_type.html","title":"Data type","text":"<p>The protocol standardises basic types and general algebraic data types. All messages sent and received within and between nodes and all parts of state must have an associated data type. Data types used by the protocol itself are fixed a priori (by this specification). Implementation languges will typically represent these types as native types in their typesystem, such that the implementation language can provide typechecking. Data types used by applications are chosen by application authors, serialised, and passed around at runtime in order to handle data appropriately.</p>","boost":2},{"location":"basic_abstractions/encoding/data_type.html#types","title":"Types","text":"","boost":2},{"location":"basic_abstractions/encoding/data_type.html#basic-types","title":"Basic types","text":"<p>A basic type is defined as either:</p> <ul> <li>a finite set type, of order \\(n\\)</li> <li>a natural number type (arbitrary-size)</li> <li>a function type from one data type to another data type</li> </ul> <pre><code>type BasicType :=\n  | FinSetT Nat\n  | NatT\n  | FunctionT DataType DataType\n</code></pre> <p>Note</p> <p>This set of basic types is minimal, designed only to distinguish between fixed-size values, variable-size values, and functions. Other semantic information (e.g. whether a finite set value is intended to represent a ring or a finite field) will be tracked at a separate layer.</p>","boost":2},{"location":"basic_abstractions/encoding/data_type.html#data-types","title":"Data types","text":"<p>A data type is defined as either:</p> <ul> <li>a basic type</li> <li>a product of other data types</li> <li>a coproduct of other data types</li> </ul> <p>Note</p> <p>Here <code>[]</code> is used as shorthand notation for an ordered list of at least one element.</p> <p>Note</p> <p>Here <code>[]</code> is used as shorthand notation for an ordered list of at least one element.</p> <pre><code>type DataType :=\n  | BasicT BasicType\n  | ProductT [DataType]\n  | CoproductT [DataType]\n</code></pre>","boost":2},{"location":"basic_abstractions/encoding/data_type.html#values","title":"Values","text":"","boost":2},{"location":"basic_abstractions/encoding/data_type.html#basic-values","title":"Basic values","text":"<p>A basic value is defined as either:</p> <ul> <li>a natural number value \\(n\\)</li> <li>a function value (represented with a particular virtual machine, identified by a natural number)</li> </ul> <pre><code>type BasicValue :=\n  | NatV Nat\n  | FunctionV Nat Bytestring\n</code></pre>","boost":2},{"location":"basic_abstractions/encoding/data_type.html#data-values","title":"Data values","text":"<p>A data value is defined as either:</p> <ul> <li>a basic value</li> <li>a tuple of other data values (inhabitant of a product type)</li> <li>a option with an index and a data value (inhabitant of a coproduct type)</li> </ul> <pre><code>type DataValue :=\n  | BasicV BasicValue\n  | TupleV [DataValue]\n  | OptionV Nat DataValue\n</code></pre>","boost":2},{"location":"basic_abstractions/encoding/data_type.html#typechecking","title":"Typechecking","text":"<p>The typechecking relation</p> <pre><code>typecheck : DataValue -&gt; DataType -&gt; Boolean\n</code></pre> <p>can be implemented in the obvious manner. Typechecking functions would require typechecking support from particular virtual machines, which isn\u2019t covered for now, but could be added in the future in a straightforward way.</p>","boost":2},{"location":"basic_abstractions/encoding/encoding_scheme.html","title":"Encoding scheme","text":"<p>An encoding scheme is a mapping between structured data and a series of bytes, uniquely defined by the pair of serialization and deserialization functions.</p>","boost":2},{"location":"basic_abstractions/encoding/encoding_scheme.html#serialization","title":"Serialization","text":"<p>The serialize function serializes a data value into a bytestring.</p> <pre><code>type Serialize = DataValue -&gt; Bytes\n</code></pre>","boost":2},{"location":"basic_abstractions/encoding/encoding_scheme.html#deserialization","title":"Deserialization","text":"<p>The deserialize function attempts to deserialize a bytestring into a data value of the specified type.</p> <pre><code>type Deserialize = DataType -&gt; Bytestring -&gt; Maybe DataValue\n</code></pre>","boost":2},{"location":"basic_abstractions/encoding/encoding_scheme.html#properties","title":"Properties","text":"<ul> <li>The serialize function must be injective (distinct data values have distinct encodings).</li> </ul> <ul> <li>The deserialize function must be surjective (any data value can be represented by a serialized value)</li> </ul> <ul> <li>Fixing a type, the deserialize function must be injective (no two serialized values deserialize to the same data value). An injective mapping without fixing a type can be achieved simply by also serializing the type.</li> </ul>","boost":2},{"location":"basic_abstractions/encoding/encoding_scheme.html#multiformat","title":"Multiformat","text":"<p>The protocol standardizes a table of encoding schemes, where each encoding scheme is associated with a unique natural number.</p> <p>Nodes running the protocol then associate each number with a pair of serialialize and deserialize functions. In order to interoperate correctly, nodes must agree on which number is associated with which encoding scheme, so this table is part of the definition of any particular protocol version, and new entries to the table, once added, cannot be changed. In general, adding new entries to the table should not break anything - a node encountering an encoding scheme it does not know simply fails.</p> <p>The concrete table is provided in the Implementation section of the specs.</p> (Wiki) links on this page<ul><li>Implementation</li></ul>","boost":2},{"location":"basic_abstractions/encoding/multifunctions.html","title":"Multifunctions","text":"","boost":2},{"location":"basic_abstractions/encoding/multifunctions.html#multiencoding","title":"Multiencoding","text":"<p>The multiencode function takes a <code>DataValue</code> and a set of preferences, and tries to encode it in a bytestring according to those preferences. Preferences determine which encoding scheme(s) is/are chosen, and whether or not we attempt to convert between virtual machine representations (requiring compilation, which may not be supported in all cases). Multiformat codes will be included to indicate which formats are in use (see here for a longer description of how this works). In general, canonical commitments to data and code are made over the output of multiencode. Multiencoding is also used before storing data or sending it over the network. Any party should be able to take any piece of stored or sent data and a type and attempt to deserialise it with multidecode.</p> <pre><code>multiencode : Preferences -&gt; DataValue -&gt; Bytestring\n</code></pre>","boost":2},{"location":"basic_abstractions/encoding/multifunctions.html#multidecoding","title":"Multidecoding","text":"<p>The multidecode function takes a value in bytestring representation and tries to decode it into an internal representation, according to the multiformat information and the encoding schemes known by the decoding party. Attempting to decode unknown formats will result in an error.</p> <pre><code>multidecode : Bytestring -&gt; DataType -&gt; Maybe DataValue\n</code></pre>","boost":2},{"location":"basic_abstractions/encoding/multifunctions.html#equality","title":"Equality","text":"<p>Note that, in general, equality of multiencoded representations implies equality of data values, but equality of data values does not imply equality of multiencoded representations (as different encoding schemes may be used). Phrased more succinctly:</p> <ol> <li><code>multiencode a = multiencode b</code> \u2192 <code>a = b</code></li> <li><code>multiencode a /= multiencode b</code> does not imply <code>a != b</code></li> </ol>","boost":2},{"location":"basic_abstractions/encoding/multifunctions.html#usage","title":"Usage","text":"<p>In general, canonical commitments to data and code are made over the output of multiencode. Implication (1) guarantees that (subject to the usual cryptographic assumptions) equality of two succinct commitments (cryptographic hash function applied to the multiencoded value) implies equality of the data values so encoded and committed to.</p> <p>Multiencoding is also used before storing data or sending it over the network. Any party who knows the encoding scheme table should be able to take any piece of stored or sent data and deserialise it with multidecode.</p>","boost":2},{"location":"basic_abstractions/encoding/multifunctions.html#multievaluation","title":"Multievaluation","text":"<p>The multievaluate function evaluates the application of a function to a value. Whenever multievaluate encounters a <code>FunctionV n f</code>, it looks up the appropriate virtual machine as specified by the natural index \\(n\\), decodes \\(f\\) using \\(decode_n\\), then calls \\(evaluate_n\\), tracking and summing the gas used in subsequent evaluations.</p> <p>Note</p> <p>This implies a uniform gas scale, which we elide the details of for now, but would probably require e.g. benchmarking on the hardware in question.</p> <pre><code>multievaluate :\n  DataValue -&gt;\n  [DataValue] -&gt;\n  Natural -&gt;\n  Maybe (DataValue, Natural)\n</code></pre>","boost":2},{"location":"basic_abstractions/encoding/multifunctions.html#recursive-multievaluation","title":"Recursive multievaluation","text":"<p>What if one VM is passed a data value including a <code>FunctionV</code> represented in a different VM? The VM in question can treat this code as data - in the sense that it can examine, introspect, modify it, etc. - but it cannot treat this code as code, since it doesn't know how to interpret functions represented in another VM (in general). However, we can allow one VM to call another easily enough simply by passing a pointer to <code>multievaluate</code> itself into the evaluation context. Then, when it encounters a function encoded for a different VM which it wishes to evaluate, the VM can simply call <code>multievaluate</code>, tracking gas consumption as appropriate. This technique can also be used to allow for something such as a data query, where data queries are represented as functions understood by a specific, specialized VM.</p> <p>Note</p> <p>There's some ABI/FFI memory layout logic to be figured out here - <code>multievaluate</code> must be called with a function and arguments formatted as <code>DataValue</code>s - this should be specified in detail.</p>","boost":2},{"location":"basic_abstractions/encoding/multifunctions.html#multicompilation","title":"Multicompilation","text":"<p>What if we wish to convert functions between different VM representations? We can define a multicompile function which attempts to compile functions represented in a data value based on a set of preferences. For example, preferences could be to convert all functions to a particular VM, or to convert where conversions are known in some order of preference. Compilation will fail if unknown VM conversions are attempted.</p> <p>Multicompilation depends on a known set of conversions \\(compile_{i,j}\\) which convert between \\(VM_i.t\\) and \\(VM_j.t\\) representations of functions, which must preserve extensional equality under evaluation.</p> <pre><code>multicompile :\n  Preferences -&gt;\n  DataValue -&gt;\n  Maybe DataValue\n</code></pre>","boost":2},{"location":"basic_abstractions/encoding/multifunctions.html#equality-proofs","title":"Equality proofs","text":"<p>With multicompilation, we can create evidence that <code>a = b</code>, where <code>a</code> and <code>b</code> are arbitrary data values, including functions (where <code>multiencode a /= multiencode b</code>). This evidence would consist simply of a proof that <code>multicompile prefs a = b</code> for some preferences <code>prefs</code>. This proof could be of varying practical forms - the verifier could simply run <code>multicompile</code> themselves, the verifier could trust another's run of <code>multicompile</code>, or the verifier could check a succinct proof of computational correctness. Many details are elided here for now.</p>","boost":2},{"location":"basic_abstractions/encoding/multifunctions.html#smart-multievaluation","title":"Smart multievaluation","text":"<p>With multicompilation and equality proofs, we can also define a version of <code>multievaluate</code> which uses available evidence + preferences intelligently at evaluation time to use certain known-to-be-equivalent versions of functions (e.g. compiled versions) instead of others. Then known optimized versions of functions can be used, and even something like \u201cJIT\u201d compilation can happen e.g. asychronously once certain statistical thresholds are met. Optionally, this \u201csmart multievaluate\u201d can also use known proofs of the results of certain evaluations (instead of repeating the evaluations), where provable VMs are involved.</p>","boost":2},{"location":"basic_abstractions/encoding/virtual_machine.html","title":"Virtual machine","text":"<p>A virtual machine is a specific way to represent functions, uniquely defined by three functions encode, decode, and evaluate. The protocol uses virtual machines in several places:</p> <ul> <li>wherever we need canonical commitments to and evaluatable representations of functions, such as external identities</li> <li>in the resource machine, for resource logics</li> <li>in the resource machine, for transaction functions</li> <li>in application definitions, for projection functions</li> </ul> <p>In general, the protocol does not require the same virtual machine to be used in all of these places, or even a specific virtual machine to be used in a specific place. However, agents who wish to interoperate must agree on the definitions of the virtual machines which they are using, and different virtual machines may have different performance characteristics in different contexts. In order to facilitate interoperability, the protocol standardizes a multiformat of virtual machines, where each virtual machine is associated with a unique natural number. We will refer to the virtual machine associated with \\(n\\) as \\(VM_n\\), and associated functions as \\(encode_n\\), \\(decode_n\\), and \\(evaluate_n\\). Each virtual machine, in the implementation language, also comes with an opaque internal representation type \\(VM_n.t\\).</p>","boost":2},{"location":"basic_abstractions/encoding/virtual_machine.html#decoding","title":"Decoding","text":"<p>The decoding function \\(decode_n\\) attempts to decode a <code>DataValue</code> into an internal representation \\(VM_n.t\\). Decoding which encounters a <code>FunctionV</code> associated with a different virtual machine will simply represent that as data (instead of code) in the internal representation type.</p> <pre><code>type Decode = DataValue -&gt; Maybe VM_n.t\n</code></pre>","boost":2},{"location":"basic_abstractions/encoding/virtual_machine.html#encoding","title":"Encoding","text":"<p>The encoding function \\(encode_n\\) encodes an internal representation of a function and/or data into a <code>DataValue</code>. Functions in the internal representation will be serialized in some fashion and paired with the natural number associated with the virtual machine in a <code>FunctionV</code>.</p> <pre><code>type Encode = VM_n.t -&gt; DataValue\n</code></pre>","boost":2},{"location":"basic_abstractions/encoding/virtual_machine.html#properties","title":"Properties","text":"<p>The encoding and decoding functions must be inverses of each other, in that:</p> <ul> <li>decoding an encoded value will result in <code>Just &lt;that value&gt;</code></li> <li>encoding a decoded value will result in the original internal representation</li> </ul>","boost":2},{"location":"basic_abstractions/encoding/virtual_machine.html#evaluation","title":"Evaluation","text":"<p>The evaluation function \\(evaluate_n\\) calls a function (in the internal representation) on the provided list of arguments (in the original representation). Evaluation must be deterministic. Evaluation must also meter gas, a measure of compute and memory resource expenditure. Different virtual machines will have different gas scales. Evaluation takes a gas limit. During VM internal execution, gas must be tracked, and evaluation must terminate if the gas limit is exceeded. Should execution complete successfully within the gas limit, the VM must return the gas actually used.</p> <pre><code>type Evaluate =\n  VM_n.t -&gt;\n  [VM_n.t] -&gt;\n  Natural -&gt;\n  (Maybe VM_n.t, Natural)\n</code></pre> <p>Note</p> <p>In the future, gas will likely change from a scalar to a vector to allow for metering compute and memory resources differently.</p>","boost":2},{"location":"basic_abstractions/encoding/virtual_machine.html#provable-virtual-machines","title":"Provable virtual machines","text":"<p>A provable virtual machine is a virtual machine with a proof type \\(P_n\\) and two additional functions parameterized over \\(P_n\\), \\(prove_n\\) and \\(verify_n\\).</p>","boost":2},{"location":"basic_abstractions/encoding/virtual_machine.html#proving","title":"Proving","text":"<p>The proving function \\(prove_n\\) generates a proof for a given program (logical relation), public input, and private input.</p> <p>Note</p> <p>Parentheses here are used to indicate the expected type of the arguments. Calling <code>prove</code> with arguments of the wrong type will fail.</p> <pre><code>type Prove =\n  VM_n.t (T0 -&gt; T1 -&gt; boolean) -&gt;\n  VM_n.t (T0) -&gt;\n  VM_n.t (T1) -&gt;\n  P_n\n</code></pre>","boost":2},{"location":"basic_abstractions/encoding/virtual_machine.html#verification","title":"Verification","text":"<p>The verification function \\(verify_n\\) verifies a proof for a given program and public input.</p> <p>Note</p> <p>Parentheses here are used to indicate the expected type of the arguments. Calling <code>verify</code> with arguments of the wrong type will fail.</p> <pre><code>type Verify =\n  VM_n.t (T0 -&gt; T1 -&gt; boolean) -&gt;\n  VM_n.t (T1) -&gt;\n  P_n -&gt;\n  boolean\n</code></pre>","boost":2},{"location":"basic_abstractions/encoding/virtual_machine.html#properties_1","title":"Properties","text":"<p>These functions must be sound and complete, in that:</p> <ul> <li>valid proofs can only be created for valid inputs (soundness), and a valid proof can be created for any valid input (completeness)</li> <li>i.e. <code>verify f public proof = true</code> if and only if <code>proof = prove f public' private'</code> where <code>public = public'</code> and <code>evaluate f [public', private'] g = (true, _)</code> for some sufficient gas limit <code>g</code> (we could probably split evaluation into gassy and gassless versions)</li> </ul> <p>Should <code>P_n</code> not reveal any information about <code>VM_n.t (T0)</code>, the provable virtual machine can be said to be zero-knowledge.</p>","boost":2},{"location":"basic_abstractions/preliminaries/index.html","title":"Preliminaries","text":"<p>This section includes background conceptual content for basic abstractions.</p> <ul> <li>Multiformats</li> </ul> (Wiki) links on this page<ul><li>Multiformats</li></ul>","boost":2},{"location":"basic_abstractions/preliminaries/multiformats.html","title":"Multiformats","text":"<p>A multiformat (directly inspired by the concept of the same name by Protocol Labs) is an interface consisting of typed functions associated with a table of multiple implementations of that interface, each associated with a unique natural number (non-negative integer), such that the numerical code can be included to indicate which implementation should be used to interpret/process some data. Conceptually, multiformats can also be understood as an implementation of runtime-updateable typeclasses (in the Haskell sense), where new instances can be added associated with new codes.</p> <p>An example table for an encoding scheme multiformat could look like:</p> Code Encoding scheme 0x01 SSZ 0x02 JSON 0x03 Borsh","boost":2},{"location":"basic_abstractions/proving/index.html","title":"Proving","text":"<p>What exactly is a proof? If a proof - operationally - is simply whatever is necessary to convince a particular party to believe that a statement is true, then in a heterogeneous trust system such as Anoma, there can be no single definition of what a proof must include, as different parties will be willing to make different assumptions and will thus accept different proofs. Rather, the protocol standardizes a type of assumptions, such that parties can specify which assumptions they are willing to make, and a multiformat for proofs, where each proof must describe what assumptions are required in order to consider it valid.</p>","boost":2},{"location":"basic_abstractions/proving/index.html#content","title":"Content","text":"<ul> <li>Assumption</li> <li>Proof</li> <li>Multifunctions</li> </ul> <p>Todo</p> <p>Fix links to multifunctions.</p> (Wiki) links on this page<ul><li>Assumption</li><li>Proof</li></ul>","boost":2},{"location":"basic_abstractions/proving/assumption.html","title":"Assumption","text":"<p>What is an assumption? Operationally speaking, the protocol characterizes assumptions as beliefs about logical impliciations (\\(a \\implies b\\) for some \\(a\\) and some \\(b\\)); for example:</p> <ul> <li>\\(a\\) could be that a particular trusted party has signed over a statement, and \\(b\\) could be that the statement is</li> </ul> <ul> <li>\\(a\\) could be nothing, and \\(b\\) could be that the algebraic group model   holds (this assumption is often relied   upon by cryptographic proof systems)</li> </ul> <ul> <li>\\(a\\) could be nothing, and \\(b\\) could be that \\(c = c\\) (the identity case)</li> </ul> <p>In an ideal world, the protocol could characterize all of these assumptions exactly (e.g. as mathematical statements) - however, that will not be feasible in the short term (precisely expressing cryptographic assumptions will require a sophisticated specification language), so for now the protocol standardizes an extensible sum type that can evolve along with the <code>Proof</code> multiformat (to add new types of assumptions).</p> <p>Note</p> <p>The encoding here needs to allow for additions to the sum type without breaking backwards compatibility (which may be a property we often want in general).</p>","boost":2},{"location":"basic_abstractions/proving/assumption.html#data-structure","title":"Data structure","text":"<pre><code>type Assumption :=\n  | HashRandomOracle\n  | FullyTrust ExternalIdentity\n</code></pre>","boost":2},{"location":"basic_abstractions/proving/multifunctions.html","title":"Multifunctions","text":"","boost":2},{"location":"basic_abstractions/proving/multifunctions.html#proof-aware-multievaluation","title":"Proof-aware multievaluation","text":"<p>We can define a version of multievaluate which is \"proof-aware\", in that, each evaluation step, <code>multievaluate</code> can also search through known assumptions and proofs, and use them if applicable to replace the term being evaluated (or parts of the term being evaluated) with other terms known to be equal given the known proofs and selected assumptions.</p> <p>Todo</p> <p>There are some efficiency questions to reason through here - obviously searching for all possible simplifications each step is not going to be performant - we may need to pass hints somehow of when simplification should be attempted.</p>","boost":2},{"location":"basic_abstractions/proving/proof.html","title":"Proof","text":"<p>Todo</p> <p>This whole page needs to be reworked.</p> <p>Questions:</p> <ul> <li>What should this type be now?</li> <li>Is everything just a provable VM?</li> <li>VM gives the semantics to interpret the function, which seems necessary.</li> <li>We have some type of assumptions \\(Assumption\\)</li> <li>\\(prove_n\\) generates the proof of type \\(Proof_n\\)</li> <li>\\(assumptions_n\\) returns the assumptions required for a proof</li> <li>\\(verify_n\\) verifies a proof of type \\(Proof_n\\)</li> </ul>","boost":2},{"location":"basic_abstractions/proving/proof.html#proof","title":"Proof","text":"<p>We define a set of structures required to define a proving system \\(PS\\) as follows:</p> <ul> <li>Proof \\(\\pi: PS.Proof\\)</li> <li>Instance \\(x: PS.Instance\\) is the public input used to produce a proof.</li> <li>Witness \\(w: PS.Witness\\) is the private input used to produce a proof.</li> <li>Proving key \\(pk: PS.ProvingKey\\) contains the secret data required to produce a proof for a pair \\((x, w)\\).</li> <li>Verifying key \\(vk: PS.VerifyingKey\\) contains the data required, along with the witness \\(x\\), to verify a proof \\(\\pi\\).</li> </ul> <p>A proof record carries the components required to verify a proof. It is defined as a composite structure \\(PR = (\\pi, x, vk): ProofRecord\\), where:</p> <ul> <li>\\(ProofRecord = PS.VerifyingKey \\times PS.Instance \\times PS.Proof\\)</li> <li>\\(vk: PS.VerifyingKey\\)</li> <li>\\(x: PS.Instance\\)</li> <li>\\(\\pi: PS.Proof\\) is the proof of the desired statement</li> </ul> <p>A proving system \\(PS\\) consists of a pair of algorithms, \\((Prove, Verify)\\):</p> <ul> <li>\\(Prove(pk, x, w): PS.ProvingKey \\times PS.Instance \\times PS.Witness \\rightarrow PS.Proof\\)</li> <li>\\(Verify(pr): PS.ProofRecord \\rightarrow \\mathbb{F}_b\\)</li> </ul> <p>A proving system must have the following properties:</p> <ul> <li>Completeness: it must be possible to make a proof for a statement which is true.</li> <li>Soundness: it must not be possible to make a proof for a statement which is false.</li> </ul> <p>Certain proving systems may also be Zero-Knowledge, meaning that the produced proofs reveal no information other than their own validity.</p> <p>A proof \\(\\pi\\) for which \\(Verify(pr) = 1\\) is considered valid.</p> <p>For example, let's take three common instantiations:</p> <ul> <li>The trivial scheme is one where computation is simply replicated. The   trivial scheme is defined as <code>verify(a, b, predicate, _) = predicate a b</code>   (with proof type <code>()</code>). It has no extra security assumptions but is not   succinct.</li> </ul> <ul> <li>The trusted delegation scheme is one where computation is delegated to a   known, trusted party whose work is not checked. The trusted delegation scheme   is defined as <code>verify(a, b, predicate, proof) = checkSignature (a, b,   predicate) proof</code>, where the trusted party is assumed to produce such a   signature only if <code>predicate a b = 1</code>. This scheme is succinct but requires a   trusted party assumption (which could be generalised to a threshold quorum in   the obvious way). Note that since the computation is still verifiable, a   signer of <code>(a, b, predicate)</code> where <code>predicate a b = 0</code> could be held   accountable by anyone else who later checked the predicate.</li> </ul> <ul> <li>The succinct proof-of-knowledge scheme is one where the result of computation is attested to with a cryptographic proof (of the sort commonly instantiated by modern-day SNARKs &amp; STARKs). Succint proof-of-knowledge schemes provide succinctness as well as veriability subject to the scheme-specific cryptographic assumptions. They may also possibly be zero-knowledge, in which the verifier learns nothing other than <code>predicate a b = 1</code> (in this case, and in others, <code>a</code> and <code>b</code> will often be \"hidden\" with hash functions, such that the verifier knows only <code>hash a</code> and <code>hash b</code> but the substance of the relation obtains over the preimages).</li> </ul>","boost":2},{"location":"basic_types/index.html","title":"Basic Types","text":"<p>Quote</p> <p>\"There are two kinds of data structures: DAGs, and bad data structures.\" unknown</p> <p>Anoma's protocol layers themselves form an information-theoretic DAG, in that higher layers can depend on information from lower layers, but not vice-versa --lower layers are blind to the syntax and semantics of higher layers, and data of concern to higher layers is represented in lower layers as opaque bytestrings. This rule, however, is partially broken in one place-- an identity can be defined in such a way that it evolves in logical time, and thus depends on a particular view of a logical DAG --but there is still a DAG in time, the cycle is only in this document.</p> <p>The protocol architecture described herein makes no decisions --it is completely constrained by the context and desiderata heretofore enumerated, and modulo the two unique up to isomorphism. The protocol is not general for generality's sake, but rather because only a correct disentanglement of abstractions and relations can provide the requisite theoretical basis for understanding what it is exactly that the system does and ensure complete deduplication of engineering efforts.</p> <p>Todo</p> <p>Question: \"Prove this (unique up to isomorphism)\" If it doesn't hold we've probably described something slightly incorrectly.</p> <p>Parameters are external input to the system, or derived from the combination of external inputs to the system over time, and since external inputs may depend on the state of the system, which is accessible to agents choosing those inputs, as intermediated by the agents making choices the gestalt forms a feedback mechanism.</p> <p>Note</p> <p>Although this document does not use the language or process and cannot claim a similar depth of expertise, we have taken some inspiration from Conal Elliot's denotational design.</p> <pre><code>flowchart LR\n  BasicTypes(\"Basic Types\")\n  SystemArchitecture(\"System Architecture\")\n  NodeArchitecture(\"Node Architecture\")\n  BasicTypes --&gt; SystemArchitecture\n  BasicTypes --&gt; NodeArchitecture</code></pre> <p>Basic types are types which are used across multiple Anoma nodes and must be defined in order to describe what properties the system itself provides.</p> <ul> <li>Identity</li> <li>Resource</li> <li>Resource Machine</li> </ul>","boost":2},{"location":"basic_types/resource.html","title":"Resource","text":"<p>Resources are the atomic units of state in Anoma.</p>","boost":2},{"location":"basic_types/resource.html#data-structure","title":"Data structure","text":"<p>Define a resource \\(R\\) as a seven-tuple \\((F, F, F, F, F, F, 0 | 1)\\) with fields named as follows:</p> <ul> <li>\\(R_{logic\\_hash}\\) of type \\(F\\)</li> </ul> <ul> <li>\\(R_{label\\_hash}\\) of type \\(F\\)</li> </ul> <ul> <li>\\(R_{quantity}\\) of type \\(F\\)</li> </ul> <ul> <li>\\(R_{value\\_hash}\\) of type \\(F\\)</li> </ul> <ul> <li>\\(R_{nonce}\\) of type \\(F\\)</li> </ul> <ul> <li>\\(R_{nc}\\) of type \\(F\\) (\"nullifier commitment\")</li> </ul> <ul> <li>\\(R_{ephemerality}\\) of type \\({ 0_P | 1_P }\\)</li> </ul> <p>Resources are constant-size (\\(6F + 1\\)).</p>","boost":2},{"location":"basic_types/resource.html#computed-fields","title":"Computed fields","text":"<p>Resources with \\(R_{ephemerality} = 0_P\\) are known as ephemeral, while resources with \\(R_{ephemerality} = 1_P\\) are known as persistent.</p> <p>Define the commitment of a resource \\(R_{commitment}\\) as \\(hash(R)\\).</p> <p>Define the address of a resource \\(R_{address}\\) as \\(R_{commitment}\\).</p> <p>Todo</p> <p>Same as the commitment for now.</p> <p>Define the nullifier of a resource \\(R_{nullifier}\\) as \\(n\\) such that \\(hash(n) = R_{nc}\\).</p> <p>Define the kind of resource \\(R_{kind}\\) as \\(hash(R_{logic}, R_{label})\\).</p> <p>Define the delta of a resource \\(R_{delta}\\) as the two-tuple \\((R_{kind}, R_{quantity})\\).</p>","boost":2},{"location":"basic_types/resource_machine.html","title":"Resource Machine","text":"<p>The Anoma Resource Machine is a key component of the Anoma protocol, responsible for managing state updates based on user preferences.</p> <ul> <li>10.5281/zenodo.10498991</li> <li>ART Index</li> </ul>","tags":["resource-machine","protocol","commitment","nullifier","accumulator","resource logic"],"boost":2},{"location":"basic_types/resource_machine.html#abstract","title":"Abstract","text":"<p>The article explores the Anoma Resource Machine (ARM) within the Anoma protocol, providing a comprehensive understanding of its role in facilitating state updates based on user preferences. Drawing parallels with the Ethereum Virtual Machine, the ARM introduces a flexible transaction model, diverging from traditional account and UTXO models. Key properties such as atomic state transitions, information flow control, account abstraction, and an intent-centric architecture contribute to the ARM's robustness and versatility. Inspired by the Zcash protocol, the ARM leverages commitment accumulators to ensure transaction privacy. The article outlines essential building blocks, computable components, and requirements for constructing the ARM, highlighting its unique approach to resource-based state management....</p> <ul> <li>Keywords: Anoma, blockchain technology, protocol design, resource machine</li> </ul>","tags":["resource-machine","protocol","commitment","nullifier","accumulator","resource logic"],"boost":2},{"location":"implementation/index.html","title":"Index","text":"<ul> <li>Data encoding</li> <li>Resource machine backends</li> </ul> (Wiki) links on this page<ul><li>Data encoding</li><li>Resource machine backends</li></ul>","boost":2},{"location":"implementation/cairo.html","title":"Cairo","text":"","boost":2},{"location":"implementation/cairo.html#primitive-choices","title":"Primitive choices","text":"<p>Primitive choices</p> <p>Fill in all primitive choices made in the implementation.</p>","boost":2},{"location":"implementation/cairo.html#encoding-choices","title":"Encoding choices","text":"<p>Encoding choices</p> <p>Fill in all encoding choices made in the implementation.</p>","boost":2},{"location":"implementation/cairo.html#other-decisions","title":"Other decisions","text":"<p>Other decisions</p> <p>Fill in all other decisions made in the implementation.</p>","boost":2},{"location":"implementation/data_encoding.html","title":"Data encoding","text":"<p>The protocol uses SSZ, with the following mapping:</p> <p>Todo</p> <p>Define a mapping from abstract data types to SSZ.</p>","boost":2},{"location":"implementation/resource_machine_backends.html","title":"Resource machine backends","text":"<p>The following resource machine backends must be supported:</p> <ul> <li>Transparent Backend</li> <li>Cairo Backend</li> <li>RISC0 Backend</li> </ul> (Wiki) links on this page<ul><li>Transparent Backend</li><li>Cairo Backend</li><li>RISC0 Backend</li></ul>","boost":2},{"location":"implementation/risc0.html","title":"RISC0","text":"","boost":2},{"location":"implementation/risc0.html#primitive-choices","title":"Primitive choices","text":"<p>Primitive choices</p> <p>Fill in all primitive choices made in the implementation.</p>","boost":2},{"location":"implementation/risc0.html#encoding-choices","title":"Encoding choices","text":"<p>Encoding choices</p> <p>Fill in all encoding choices made in the implementation.</p>","boost":2},{"location":"implementation/risc0.html#other-decisions","title":"Other decisions","text":"<p>Other decisions</p> <p>Fill in all other decisions made in the implementation.</p>","boost":2},{"location":"implementation/transparent.html","title":"Transparent","text":"<p>Transparent Resource Machine Implementation Details per v0.25.0</p> <p>Elixir typespec can be found here</p> <p>Nock specification can here</p> <p>Below, all instances of \"a\", \"is , \"is a\" is to be interpreted as \"of type\" when describing encoded data types.</p>","boost":2},{"location":"implementation/transparent.html#primitive-choices","title":"Primitive choices","text":"","boost":2},{"location":"implementation/transparent.html#commitment-hash","title":"Commitment Hash","text":"<p>We commit a resource compiled to Nock by jamming a resource and pre-pending the binary with \"CM_\":</p>","boost":2},{"location":"implementation/transparent.html#hoon-primitive","title":"Hoon Primitive","text":"<pre><code>++  commit  ::  commit to a resource\n  |=  =resource\n  ^-  commitment\n  (~(cat block 3) 'CM_' (jam resource))\n</code></pre>","boost":2},{"location":"implementation/transparent.html#elixir-primitive","title":"Elixir Primitive","text":"<pre><code>@spec commitment(Resource.t()) :: binary()\ndef commitment(resource = %Resource{}) do\n    binary_resource = resource |&gt; to_noun() |&gt; Nock.Jam.jam()\n    \"CM_\" &lt;&gt; binary_resource\nend\n</code></pre>","boost":2},{"location":"implementation/transparent.html#nullifier-hash","title":"Nullifier Hash","text":"<p>We nullify a resource compiled to Nock by jamming a resource and pre-pending the binary with \"NF_\":</p>","boost":2},{"location":"implementation/transparent.html#hoon-primitive_1","title":"Hoon Primitive","text":"<pre><code>++  nullify  ::  nullify a resource\n  |=  =resource\n  ^-  nullifier\n  (~(cat block 3) 'NF_' (jam resource))\n</code></pre>","boost":2},{"location":"implementation/transparent.html#elixir-primitive_1","title":"Elixir Primitive","text":"<pre><code>@spec nullifier(Resource.t()) :: binary()\ndef nullifier(resource = %Resource{}) do\n    binary_resource = resource |&gt; to_noun() |&gt; Nock.Jam.jam()\n    \"NF_\" &lt;&gt; binary_resource\nend\n</code></pre>","boost":2},{"location":"implementation/transparent.html#merkle-tree-hash","title":"Merkle Tree Hash","text":"<p>Our hash used for the Merkle Tree instantiation is <code>sha 256</code>:</p>","boost":2},{"location":"implementation/transparent.html#hoon-primitive_2","title":"Hoon Primitive","text":"<p>Not instantiated.</p>","boost":2},{"location":"implementation/transparent.html#elixir-primitive_2","title":"Elixir Primitive","text":"<pre><code>@spec sha256(iodata()) :: binary()\ndef sha256(a) do\n  :crypto.hash(:sha256, a)\nend\n</code></pre>","boost":2},{"location":"implementation/transparent.html#encoding-choices","title":"Encoding choices","text":"","boost":2},{"location":"implementation/transparent.html#public-and-private-inputs","title":"Public and Private Inputs","text":"","boost":2},{"location":"implementation/transparent.html#hoon-encoding","title":"Hoon Encoding","text":"<p>The Hoon <code>public-inputs</code> record with fields: - <code>commitments</code>   - a list of atoms - <code>nullifiers</code>   - a list of atoms - <code>self-tag</code>   - an atom - <code>other-public</code>   - a noun</p> <p>The Hoon <code>private-inputs</code> record with fields: - <code>committed-resources</code>   - a list of resources - <code>nullified-resources</code>   - a list of atoms - <code>other-private</code>   - a noun</p> <pre><code>+$  public-inputs\n  $:\n    commitments=(list @)\n    nullifiers=(list @)\n    self-tag=@\n    other-public=*\n  ==\n+$  private-inputs\n  $:\n    committed-resources=(list resource)\n    nullified-resources=(list resource)\n    other-private=*\n  ==\n</code></pre>","boost":2},{"location":"implementation/transparent.html#elixir-encoding","title":"Elixir Encoding","text":"<p>Not instantiated.</p>","boost":2},{"location":"implementation/transparent.html#resource-logic","title":"Resource Logic","text":"","boost":2},{"location":"implementation/transparent.html#hoon-encoding_1","title":"Hoon Encoding","text":"<p>The Hoon <code>resource-logic</code> type: - a boolean-valued function <pre><code>+$  resource-logic\n  $~  =&gt;(~ |=(* &amp;))\n  $-([public-inputs private-inputs] ?)\n</code></pre></p>","boost":2},{"location":"implementation/transparent.html#elixir-encoding_1","title":"Elixir Encoding","text":"<p>Not instantiated.</p>","boost":2},{"location":"implementation/transparent.html#resource","title":"Resource","text":"","boost":2},{"location":"implementation/transparent.html#hoon-encoding_2","title":"Hoon Encoding","text":"<p>The Hoon <code>public-inputs</code> record with fields: - <code>label</code>   - a UTF-8 Text - <code>logic</code>   - a <code>resource-logic</code> - <code>ephemeral</code>   - a boolean - <code>data</code>   - a cell <code>[a b]</code> where     - <code>a</code> is an unsigned integer     - <code>b</code> is an atom - <code>nullifier-key</code>   - a 256-bit atom - <code>nonce</code>   - a 256-bit atom - <code>rseed</code>   - a string \"fake\"</p> <pre><code>+$  resource\n  $~  :*\n    label=*@t\n    logic=*resource-logic\n    ephemeral=|\n    quantity=`@u`1\n    data=*[@u @]\n    nullifier-key=*@I\n    nonce=*@I\n    rseed=%fake\n  ==\n  $:\n    label=@t\n    logic=resource-logic\n    ephemeral=?\n    quantity=@u\n    data=[len=@u val=@]\n    nullifier-key=@I\n    nonce=@I\n    rseed=%fake\n  ==\n</code></pre>","boost":2},{"location":"implementation/transparent.html#elixir-encoding_2","title":"Elixir Encoding","text":"<p>The Elixir <code>Resource.t()</code> record with fields: - <code>label</code>   - a binary - <code>logic</code>   - a Nock noun - <code>ephemeral</code>   - a boolean - <code>quantity</code>   - a non-negative integer - <code>data</code>   - a binary - <code>nullifier_key</code>   - 256-bit bitstring - <code>nonce</code>   - 256-bit bitstring - <code>rseed</code>   - bitstring</p> <pre><code>typedstruct enforce: true do\n    field(:label, binary(), default: \"\")\n    field(:logic, Noun.t(), default: [[1 | 0], 0 | 0])\n    field(:ephemeral, bool(), default: false)\n    field(:quantity, non_neg_integer(), default: 1)\n    field(:data, binary(), default: &lt;&lt;&gt;&gt;)\n    field(:nullifier_key, &lt;&lt;_::256&gt;&gt;, default: &lt;&lt;0::256&gt;&gt;)\n    field(:nonce, &lt;&lt;_::256&gt;&gt;, default: &lt;&lt;0::256&gt;&gt;)\n    field(:rseed, &lt;&lt;&gt;&gt;, default: &lt;&lt;&gt;&gt;)\nend\n</code></pre>","boost":2},{"location":"implementation/transparent.html#complicance-proof","title":"Complicance Proof","text":"","boost":2},{"location":"implementation/transparent.html#hoon-encoding_3","title":"Hoon Encoding","text":"<p>The Hoon <code>compliance proof</code> type: - a string \"compliance\"</p> <pre><code>+$  compliance-proof  %compliance\n</code></pre>","boost":2},{"location":"implementation/transparent.html#elixir-encoding_3","title":"Elixir Encoding","text":"<p>Not instantiated.</p>","boost":2},{"location":"implementation/transparent.html#logic-proof","title":"Logic Proof","text":"","boost":2},{"location":"implementation/transparent.html#hoon-encoding_4","title":"Hoon Encoding","text":"<p>The Hoon <code>logic-proof</code> type: - a cell <code>[a b]</code> where   - <code>a</code> is a <code>resource</code>   - <code>b</code> is a cell <code>[c d]</code> where     - <code>c</code> is <code>public-inputs</code>     - <code>d</code> is <code>private-inputs</code> <pre><code>+$  logic-proof\n  [resource=resource inputs=[public-inputs private-inputs]]\n</code></pre></p>","boost":2},{"location":"implementation/transparent.html#elixir-encoding_4","title":"Elixir Encoding","text":"<p>The Elixir <code>LogicProof.t()</code> record with fields: - <code>resource</code>   - a <code>Resource.t()</code> - <code>commitments</code>   - a set of binaries   - seen as a public input - <code>nullifiers</code>   - a set of binaries   - seen as a public input - <code>self-tag</code>   - a tuple <code>{a, b}</code> where     - a is either <code>:committed</code> or <code>:nullified</code>     - b is a binary   - seen as a public input - <code>other_public</code>   - a Nock noun   - seen as a public input - <code>committed_plaintexts</code>   - a set of <code>Resource.t()</code> records   - seen as a private input - <code>nullified_plaintexts</code>   - a set of <code>Resource.t()</code> records   - seens as a private input - <code>other_private</code>   - a Nock noun   - seen as a private input</p> <pre><code>typedstruct enforce: true do\n    field(:resource, Resource.t())\n    field(:commitments, MapSet.t(binary()), default: MapSet.new())\n    field(:nullifiers, MapSet.t(binary()), default: MapSet.new())\n    field(:self_tag, {:committed | :nullified, binary()})\n    field(:other_public, Noun.t(), default: &lt;&lt;&gt;&gt;)\n    field(:committed_plaintexts, MapSet.t(Resource.t()),\n      default: MapSet.new()\n    )\n    field(:nullified_plaintexts, MapSet.t(Resource.t()),\n      default: MapSet.new()\n    )\n    field(:other_private, Noun.t(), default: &lt;&lt;&gt;&gt;)\nend\n</code></pre>","boost":2},{"location":"implementation/transparent.html#proof","title":"Proof","text":"","boost":2},{"location":"implementation/transparent.html#hoon-encoding_5","title":"Hoon Encoding","text":"<p>The Hoon <code>proof</code> type: - either a <code>compliance-proof</code> or <code>logic-proof</code></p> <pre><code>+$  proof  ?(compliance-proof logic-proof)\n</code></pre>","boost":2},{"location":"implementation/transparent.html#elixir-encoding_5","title":"Elixir Encoding","text":"<p>Not instantiated.</p>","boost":2},{"location":"implementation/transparent.html#action","title":"Action","text":"","boost":2},{"location":"implementation/transparent.html#hoon-encoding_6","title":"Hoon Encoding","text":"<p>The Hoon <code>action</code> record with fields: - <code>commitments</code>   - a list of atoms - <code>nullifiers</code>   - a list of atoms - <code>proofs</code>   - a list of <code>proof</code> values - <code>app-data</code>   - a cell <pre><code>+$  action\n  $~  :*\n    commitments=~\n    nullifiers=~\n    proofs=~\n    app-data=**\n  ==\n  $:\n    commitments=(list @)\n    nullifiers=(list @)\n    proofs=(list proof)\n    app-data=*\n  ==\n</code></pre></p>","boost":2},{"location":"implementation/transparent.html#elixir-encoding_6","title":"Elixir Encoding","text":"<p>The Elixir <code>Action.t()</code> record with fields: - <code>commitments</code>   - a set of binaries - <code>nullifiers</code>   - a set of binaries - <code>proofs</code>   - a set of <code>Logic.Proof.t()</code> records - <code>app_data</code>   - a binary</p> <pre><code>typedstruct enforce: true do\n    field(:commitments, MapSet.t(binary()), default: MapSet.new())\n    field(:nullifiers, MapSet.t(binary()), default: MapSet.new())\n    field(:proofs, MapSet.t(LogicProof.t()), default: MapSet.new())\n    field(:app_data, binary(), default: &lt;&lt;&gt;&gt;)\nend\n</code></pre>","boost":2},{"location":"implementation/transparent.html#delta","title":"Delta","text":"","boost":2},{"location":"implementation/transparent.html#hoon-encoding_7","title":"Hoon Encoding","text":"<p>The Hoon <code>delta</code> type: - an list of <code>[a b]</code> where   - <code>a</code> is a <code>[c d]</code> where     - <code>c</code> is a UTF-8 text     - <code>d</code> is a <code>resource-logic</code>   - <code>b</code> is a signed integer <pre><code>+$  delta  (list [[@t resource-logic] @s])\n</code></pre></p>","boost":2},{"location":"implementation/transparent.html#elixir-encoding_7","title":"Elixir Encoding","text":"<p>The Elixir <code>Delta.t()</code> type: - a map from binaries to integers</p> <pre><code>@type Delta.t() :: %{binary() =&gt; integer()}\n</code></pre>","boost":2},{"location":"implementation/transparent.html#transaction","title":"Transaction","text":"","boost":2},{"location":"implementation/transparent.html#hoon-encoding_8","title":"Hoon Encoding","text":"<p>The Hoon <code>transaction</code> record with fields: - <code>roots</code>   - a list of atoms - <code>actions</code>   - a list of <code>action</code> records - <code>delta</code>   - a <code>delta</code> - <code>delta-proof</code>   - a string \"delta\" <pre><code>+$  transaction\n  $~  :*\n    roots=~\n    actions=~\n    delta=*delta\n    delta-proof=%delta\n  ==\n  $:\n    roots=(list @)\n    actions=(list action)\n    delta=delta\n    delta-proof=%delta\n  ==\n</code></pre></p>","boost":2},{"location":"implementation/transparent.html#elixir-encoding_8","title":"Elixir Encoding","text":"<p>The Elixir <code>Transaction.t()</code> record with fields: - <code>roots</code>   - a list of binaries - <code>actions</code>   - a list of <code>Action.t()</code> records - <code>delta</code>   - a list of <code>Delta.t()</code> values - <code>delta_proof</code>   - bitstring <pre><code>typedstruct enforce: true do\n    field(:roots, MapSet.t(binary()), default: MapSet.new())\n    field(:actions, MapSet.t(Action.t()), default: MapSet.new())\n    field(:delta, Delta.t(), default: %{})\n    field(:delta_proof, &lt;&lt;&gt;&gt;, default: &lt;&lt;&gt;&gt;)\nend\n</code></pre></p>","boost":2},{"location":"implementation/transparent.html#other-decisions","title":"Other decisions","text":"","boost":2},{"location":"implementation/transparent.html#compliance-verification","title":"Compliance Verification","text":"<pre><code>@spec verify_tx_action_compliance(t()) :: true | {:error, String.t()}\n  def verify_tx_action_compliance(%Transaction{actions: actions}) do\n    failed =\n      actions\n      |&gt; Enum.map(&amp;Action.verify_correspondence/1)\n      |&gt; Enum.reject(&amp;(&amp;1 == true))\n\n    Enum.empty?(failed) or\n      {:error, Enum.join(Enum.map(failed, &amp;elem(&amp;1, 1)), \"\\n\")}\nend\n</code></pre> <p>with <code>verify_correspondence</code> defined as:</p> <pre><code>@spec verify_correspondence(t()) :: true | {:error, String.t()}\n  def verify_correspondence(action = %Action{}) do\n    # Bail out early, if there are more committed and nullified\n    # resources than there are actual resource proofs\n    if MapSet.size(action.proofs) &lt;\n         MapSet.size(action.commitments) + MapSet.size(action.nullifiers) do\n      {:error,\n       \"there are more commitments and nullifiers than actual logic proofs\\n\" &lt;&gt;\n         \"#{inspect(action, pretty: true)}\"}\n    else\n      # TODO Should I check that LogicProof.commitments =\n      # Action.commitments, as well as the nullifiers? Or can I assume\n      # that they are the same context. I could technically make it\n      # lie if I constructed it to lie, no?\n      failed_proofs =\n        action.proofs\n        |&gt; Enum.map(fn proof = %LogicProof{} -&gt;\n          cond do\n            not LogicProof.verify_resource_corresponds_to_tag(proof) -&gt;\n              \"Logic Proof failed, the resource's commitment\\nullifier:\\n\" &lt;&gt;\n                \"#{inspect(proof.resource, pretty: true)}\\n\" &lt;&gt;\n                \"does not match the commitment/nullifier: #{inspect(proof.self_tag)}\"\n\n            not verify_resource_is_accounted_for?(action, proof) -&gt;\n              \"The resource:\\n\" &lt;&gt;\n                \"#{inspect(proof.resource, pretty: true)}\\n\" &lt;&gt;\n                \"Is not found in the Action's commitment/nullifier set\"\n\n            not verify_action_resources_correspond_to_proofs?(action, proof) -&gt;\n              \"Either the action's commitments:\\n\" &lt;&gt;\n                \"#{inspect(action.commitments, pretty: true)}\" &lt;&gt;\n                \"does not match the proof's commitments:\" &lt;&gt;\n                \"#{inspect(proof.commitments, pretty: true)}\" &lt;&gt;\n                \"or the action's nullifiers:\" &lt;&gt;\n                \"#{inspect(action.nullifiers, pretty: true)}\" &lt;&gt;\n                \"does not match the proof's nullifiers:\" &lt;&gt;\n                \"#{inspect(proof.nullifiers, pretty: true)}\"\n\n            true -&gt;\n              true\n          end\n        end)\n        |&gt; Enum.reject(&amp;(&amp;1 == true))\n\n      Enum.empty?(failed_proofs) ||\n        {:error,\n         \"The following correspondence proofs failed:\\n\" &lt;&gt;\n           Enum.join(failed_proofs, \"\\n\")}\n    end\nend\n</code></pre>","boost":2},{"location":"implementation/data_encoding/index.html","title":"Data encoding","text":"<p>Data is encoded as the pair of a natural number identifier (specifying a particular encoding format) and a bytestring (to be interpreted by the encoding format):</p> <pre><code>type Data = mkData {\n  formatIdentifier : Natural;\n  formatBytestring : []byte;\n}\n</code></pre> Identifier Encoding format 0x00 - (reserved for the future) 0x01 - (reserved for the future) 0x02 SSZ <p>We then define the canonical data encoding functions as a switch-case over these particular schemes.</p>","boost":2},{"location":"implementation/data_encoding/ssz.html","title":"SSZ","text":"<p>The SimpleSerialize (SSZ) format is defined by Ethereum 2 here.</p> <p>SSZ defines encoding, decoding, Merkleization, Merkle multiproofs, and a canonical JSON mapping for the <code>SSZObject</code> type</p> <pre><code>type SSZBasicType :=\n  uint8 |\n  uint16 |\n  uint32 |\n  uint64 |\n  uint128 |\n  uint256 |\n  byte |\n  boolean\n\ntype SSZObjectType :=\n  Container [(String, SSZObjectType)] |\n  Vector SSZObjectType Natural |\n  List SSZObjectType Natural |\n  Bitvector Natural |\n  Bitlist Natural |\n  Union [SSZObjectType]\n</code></pre> <p>We thus define functions to map between general algebraic data types and <code>SSZObject</code>:</p> <p>Todo</p> <p>Define functions to map between general algebraic data types and SSZObject.</p>","boost":2},{"location":"implementation/function_encoding/index.html","title":"Function encoding","text":"<p>Functions are encoded as the pair of a natural number identifier (specifying a particular virtual machine) and bytecode (to be interpreted by the virtual machine):</p> <pre><code>type Function := mkFunction {\n    vmIdentifier : Natural;\n    vmBytecode : []byte;\n};\n</code></pre> Identifier Virtual machine 0x00 - (reserved for the future) 0x01 - (reserved for the future) 0x02 Nockma 0x03 Cairo 0x04 RISC0 <p>We then define the canonical function encoding functions as a switch-case over these particular virtual machines.</p>","boost":2},{"location":"implementation/function_encoding/cairo.html","title":"Cairo","text":"","boost":2},{"location":"implementation/function_encoding/nockma.html","title":"Nockma","text":"<p>Nockma (Nock-Anoma) is a modification of the Nock4K specification and a Nock standard library altered and extended for use with Anoma. Nockma is designed to support the transaction function interpreter requirements - namely, global storage read and deterministic bounded computation costs.</p> <p>Nockma is parameterized over a specific finite field \\(\\mathbb{F}_h\\) and function \\(h\\). The function \\(h\\) takes an arbitrary noun (a data unit in Nockma) as input and returns an element of \\(\\mathbb{F}_h\\). This function is used for verifying reads from content-addressed storage.</p> <p>A \\textit{scry} (inspired by Urbit\u2019s concept of the same name) is a read-only request to Anoma\u2019s global content-addressed namespace or indices computed over values stored in this namespace. Scrying is used to read data that would be inefficient to store in the noun, to read indices whose value might only be known at execution time, or to read data that may not be accessible to the author of the noun.</p> <p>Scrying comes in two types: \\say{direct} or \\say{index}. A direct lookup simply returns the value stored at the address (integrity can be checked using \\(h\\)), or an error if a value is not found. An index lookup uses the value stored at the address as an index function and returns the results of computing that index or an error if the index is not found, invalid, or uncomputable. The lookup type is the only parameter required apart from the content address (which must be an element of \\(\\mathbb{F}_h\\)).</p> <p>Typically, the index functions allowed will be very restricted, e.g. current unspent resources of a particular kind. Gas costs of scrying will depend on the index function and the size of the results returned.</p> <p>Scrying may be used to avoid unnecessary, redundant transmission of common Nockma subexpressions, such as the standard library.</p> <p>Nockma is a combinator interpreter defined as a set of reduction rules over nouns. A noun is an atom or a cell, where an atom is a natural number and a cell is an ordered pair of nouns.</p> <p>The Nockma reduction rules as presented in \\Cref{table:nockma} are applied from top to bottom, the first rule from the top matches. Variables match any noun. As in regular Nock4K, a formula that reduces to itself is an infinite loop, which we define as a crash (\\say{bottom} in formal logic). A real interpreter can detect this crash and produce an out-of-band value instead.</p> <p>The only difference between Nockma and Nock4K reduction rules is that instruction 12 is defined for scrying.</p> <p>Used with the resource machine, Nockma should return a set of modifications to the state transition expressed by the input transaction:</p> <ul> <li>a set of resources to additionally create (resource plaintexts)</li> <li>a set of resources to additionally consume (addresses)</li> <li>a set of storage writes (in the format specified in \\Cref{storage})</li> </ul> <p>The Nockma standard library must include the following functions.</p> <p>For a finite field \\(\\mathbb{F}_n\\) of order \\(n\\), it should support:</p> <ul> <li>additive identity of type \\(\\mathbb{F}_n\\)</li> <li>addition operation \\(\\mathbb{F}_n \\times \\mathbb{F}_n \\rightarrow \\mathbb{F}_n\\)</li> <li>additive inversion \\(\\mathbb{F}_n \\rightarrow \\mathbb{F}_n\\)</li> <li>multiplicative identity of type \\(\\mathbb{F}_n\\)</li> <li>multiplication operation \\(\\mathbb{F}_n \\times \\mathbb{F}_n \\rightarrow \\mathbb{F}_n\\)</li> <li>multiplicative inversion \\(\\mathbb{F}_n \\rightarrow \\mathbb{F}_n\\)</li> <li>equality operation \\(\\mathbb{F}_n \\times \\mathbb{F}_n \\rightarrow \\mathbb{F}_2\\)</li> <li>comparison operation based on canonical ordering \\(\\mathbb{F}_n \\times \\mathbb{F}_n \\rightarrow \\mathbb{F}_2\\)</li> </ul> <p>For a ring \\(Z_n\\) of unsigned integers \\(\\mathrm{mod}~n\\), it should support:</p> <ul> <li>additive identity of type \\(Z_n\\)</li> <li>addition operation \\(Z_n \\times Z_n \\rightarrow Z_n \\times \\mathbb{F}_2\\) (with overflow indicator)</li> <li>subtraction operation \\(Z_n \\times Z_n \\rightarrow Z_n \\times \\mathbb{F}_2\\) (with overflow indicator)</li> <li>multiplicative identity of type \\(Z_n\\)</li> <li>multiplication operation \\(Z_n \\times Z_n \\rightarrow Z_n \\times \\mathbb{F}_2\\) (with overflow indicator)</li> <li>division operation (floor division) \\(Z_n \\times Z_n \\rightarrow Z_n\\)</li> <li>equality \\(Z_n \\times Z_n \\rightarrow \\mathbb{F}_2\\)</li> <li>comparison \\(Z_n \\times Z_n \\rightarrow \\mathbb{F}_2\\)</li> </ul> <p>Additionally, it should provide a parametrized conversion function \\(conv_{i,j,k,l}\\), where:</p> <ul> <li>\\(i\\) is a flag that defines the input type: \\(i = 0\\) corresponds to a finite field, \\(i = 1\\) corresponds to a ring of unsigned integers</li> <li>\\(j\\) is the input structure order</li> <li>\\(k\\) is a flag that defines the output type: \\(k = 0\\) corresponds to a finite field, \\(k = 1\\) corresponds to a ring of unsigned integers</li> <li>\\(l\\) is the output structure order</li> </ul> <p>If the order of the input structure is bigger than the order of the output structure (\\(j &gt; l\\)), the conversion function would return a flag (of type \\(\\mathbb{F}_2\\)) indicating if overflow happened in addition to the converted value.</p> <p>The conversion function must use canonical ordering and respect the inversion laws.</p>","boost":2},{"location":"implementation/function_encoding/risc0.html","title":"RISC0","text":"","boost":2},{"location":"implementation/hash_encoding/index.html","title":"Hash encoding","text":"<p>Hashes are encoded as the pair of a natural number identifier (specifying a particular hash function) and bytes (the output of the hash function).</p> <pre><code>type Hash := mkHash {\n    hashIdentifier : Natural;\n    hashBytes : []byte;\n};\n</code></pre> Identifier Hash function 0x00 - (reserved for the future) 0x01 - (reserved for the future) 0x02 SHA3 <p>We then define the canonical hash function as a switch-case over these particular virtual machines.</p>","boost":2},{"location":"implementation/hash_encoding/sha3.html","title":"SHA3","text":"<p>Todo</p> <p>Define sha3.</p>","boost":2},{"location":"implementation/proof_encoding/index.html","title":"Proof encoding","text":"<p>Proof are encoded as the pair of a natural number identifier (specifying a particular proof system) and bytes (the proof content).</p> <pre><code>type Proof := mkProof {\n    proofSystemIdentifier : Natural;\n    proofSystemBytes : []byte;\n};\n</code></pre> Identifier Hash function 0x00 - (reserved for the future) 0x01 - (reserved for the future) <p>We then define the canonical proof verifier as a switch-case over these proving systems.</p>"},{"location":"indexes/index.html","title":"Indexes","text":"<ul> <li>Quick links</li> <li>Juvix modules</li> </ul>"},{"location":"indexes/juvix_modules.html","title":"Modules in Juvix","text":""},{"location":"indexes/juvix_modules.html#juvix-package-version","title":"Juvix Package version","text":"<pre><code>package : Package :=\n  defaultPackage@{\n    name := \"nspec\";\n    version := mkVersion 0 1 1;\n    dependencies :=\n      [github \"anoma\" \"juvix-stdlib\" \"v0.8.0\"]\n  };\n</code></pre>"},{"location":"indexes/juvix_modules.html#modules-by-letter","title":"Modules by letter","text":""},{"location":"indexes/juvix_modules.html#a","title":"A","text":"<ul> <li>anoma</li> </ul> <ul> <li>anoma_config</li> </ul> <ul> <li>anoma_environment</li> </ul> <ul> <li>anoma_message</li> </ul>"},{"location":"indexes/juvix_modules.html#b","title":"B","text":"<ul> <li>basics</li> </ul>"},{"location":"indexes/juvix_modules.html#c","title":"C","text":"<ul> <li>commitment</li> </ul> <ul> <li>commitment_behaviour</li> </ul> <ul> <li>commitment_environment</li> </ul> <ul> <li>commitment_messages</li> </ul> <ul> <li>compute</li> </ul> <ul> <li>configurator</li> </ul> <ul> <li>crypto</li> </ul>"},{"location":"indexes/juvix_modules.html#d","title":"D","text":"<ul> <li>decryption</li> </ul> <ul> <li>decryption_behaviour</li> </ul> <ul> <li>decryption_environment</li> </ul> <ul> <li>decryption_messages</li> </ul>"},{"location":"indexes/juvix_modules.html#e","title":"E","text":"<ul> <li>encryption</li> </ul> <ul> <li>encryption_behaviour</li> </ul> <ul> <li>encryption_environment</li> </ul> <ul> <li>encryption_messages</li> </ul> <ul> <li>engine</li> </ul> <ul> <li>engine_behaviour</li> </ul> <ul> <li>engine_config</li> </ul> <ul> <li>engine_environment</li> </ul> <ul> <li>everything</li> </ul>"},{"location":"indexes/juvix_modules.html#i","title":"I","text":"<ul> <li>identities</li> </ul> <ul> <li>identity</li> </ul> <ul> <li>identity_management</li> </ul> <ul> <li>identity_management_behaviour</li> </ul> <ul> <li>identity_management_environment</li> </ul> <ul> <li>identity_management_messages</li> </ul> <ul> <li>index</li> </ul>"},{"location":"indexes/juvix_modules.html#m","title":"M","text":"<ul> <li>messages</li> </ul>"},{"location":"indexes/juvix_modules.html#n","title":"N","text":"<ul> <li>naming</li> </ul> <ul> <li>naming_behaviour</li> </ul> <ul> <li>naming_environment</li> </ul> <ul> <li>naming_messages</li> </ul>"},{"location":"indexes/juvix_modules.html#p","title":"P","text":"<ul> <li>p2p</li> </ul> <ul> <li>prelude</li> </ul>"},{"location":"indexes/juvix_modules.html#r","title":"R","text":"<ul> <li>reads_for</li> </ul> <ul> <li>reads_for_behaviour</li> </ul> <ul> <li>reads_for_environment</li> </ul> <ul> <li>reads_for_messages</li> </ul>"},{"location":"indexes/juvix_modules.html#s","title":"S","text":"<ul> <li>signs_for</li> </ul> <ul> <li>signs_for_behaviour</li> </ul> <ul> <li>signs_for_environment</li> </ul> <ul> <li>signs_for_messages</li> </ul>"},{"location":"indexes/juvix_modules.html#t","title":"T","text":"<ul> <li>template</li> </ul> <ul> <li>template_behaviour</li> </ul> <ul> <li>template_config</li> </ul> <ul> <li>template_environment</li> </ul> <ul> <li>template_messages</li> </ul> <ul> <li>ticker</li> </ul> <ul> <li>ticker_behaviour</li> </ul> <ul> <li>ticker_config</li> </ul> <ul> <li>ticker_environment</li> </ul> <ul> <li>ticker_messages</li> </ul> <ul> <li>types</li> </ul>"},{"location":"indexes/juvix_modules.html#v","title":"V","text":"<ul> <li>verification</li> </ul> <ul> <li>verification_behaviour</li> </ul> <ul> <li>verification_environment</li> </ul> <ul> <li>verification_messages</li> </ul>"},{"location":"indexes/links.html","title":"Quick Links","text":""},{"location":"indexes/links.html#a","title":"A","text":"<ul> <li>Accumulator</li> </ul> <ul> <li>Action</li> </ul> <ul> <li>Add Juvix code for specification</li> </ul> <ul> <li>Add diffs for versioning</li> </ul> <ul> <li>Add literature references</li> </ul> <ul> <li>Add pending tasks with Todos admonition</li> </ul> <ul> <li>Anoma Configuration</li> </ul> <ul> <li>Anoma Environment</li> </ul> <ul> <li>Anoma Message</li> </ul> <ul> <li>AppendValueV1</li> </ul> <ul> <li>Application Architecture</li> </ul> <ul> <li>Applications</li> </ul> <ul> <li>Archetypal Applications</li> </ul> <ul> <li>Archetypal applications</li> </ul> <ul> <li>Assumption</li> </ul> <ul> <li>Attestation</li> </ul> <ul> <li>Authorization</li> </ul> <ul> <li>Availability Certificate</li> </ul> <ul> <li>AvailabilityCommitment</li> </ul>"},{"location":"indexes/links.html#b","title":"B","text":"<ul> <li>Basic Abstractions</li> </ul> <ul> <li>Basic Concepts</li> </ul> <ul> <li>Basic Types</li> </ul> <ul> <li>Bibliography</li> </ul> <ul> <li>BlockGetRequest</li> </ul> <ul> <li>BlockLookupRequest</li> </ul> <ul> <li>BlockPutRequest</li> </ul> <ul> <li>BlockPutResponse</li> </ul> <ul> <li>BlockResponse</li> </ul> <ul> <li>BlockResult</li> </ul> <ul> <li>BlockSearchRandom</li> </ul> <ul> <li>BlockSearchTopic</li> </ul>"},{"location":"indexes/links.html#c","title":"C","text":"<ul> <li>Cairo</li> </ul> <ul> <li>Cairo Backend</li> </ul> <ul> <li>Change Log</li> </ul> <ul> <li>Changelog</li> </ul> <ul> <li>Clustering</li> </ul> <ul> <li>ClusteringView</li> </ul> <ul> <li>Commitment</li> </ul> <ul> <li>Commitment Behaviour</li> </ul> <ul> <li>Commitment Engine</li> </ul> <ul> <li>Commitment Environment</li> </ul> <ul> <li>Commitment Messages</li> </ul> <ul> <li>Common types</li> </ul> <ul> <li>ConnectRequest</li> </ul> <ul> <li>ConnectRequestV1</li> </ul> <ul> <li>ConnectResponse</li> </ul> <ul> <li>ConnectResponseV1</li> </ul> <ul> <li>ConnectedNodesRequest</li> </ul> <ul> <li>ConnectedNodesResponseV1</li> </ul> <ul> <li>ConnectionPrefs</li> </ul> <ul> <li>Consensus (Old)</li> </ul> <ul> <li>Consensus Engine</li> </ul> <ul> <li>Consensus V1</li> </ul> <ul> <li>Counter</li> </ul> <ul> <li>Cryptographic Primitives</li> </ul> <ul> <li>Cryptographic primitives</li> </ul>"},{"location":"indexes/links.html#d","title":"D","text":"<ul> <li>Data encoding</li> </ul> <ul> <li>Data type</li> </ul> <ul> <li>DataChangedTimeSeriesDB</li> </ul> <ul> <li>Decryption Engine</li> </ul> <ul> <li>Decryption Engine Behaviour</li> </ul> <ul> <li>Decryption Engine Environment</li> </ul> <ul> <li>Decryption Engine Messages</li> </ul> <ul> <li>Definition</li> </ul> <ul> <li>Definitions</li> </ul> <ul> <li>DeleteDataTimeSeriesDBRequest</li> </ul> <ul> <li>DeleteDataTimeSeriesDBRequestV1</li> </ul> <ul> <li>DeleteDataTimeSeriesDBResponse</li> </ul> <ul> <li>DeleteDataTimeSeriesDBResponseV1</li> </ul> <ul> <li>DeleteValueKVStoreRequest</li> </ul> <ul> <li>DeleteValueKVStoreRequestV1</li> </ul> <ul> <li>DeleteValueKVStoreResponse</li> </ul> <ul> <li>DeleteValueKVStoreResponseV1</li> </ul> <ul> <li>Delta</li> </ul> <ul> <li>DestinationIdentity</li> </ul> <ul> <li>DisconnectRequest</li> </ul> <ul> <li>DisconnectRequestV1</li> </ul> <ul> <li>DisconnectResponse</li> </ul> <ul> <li>DisconnectResponseV1</li> </ul> <ul> <li>Domain</li> </ul> <ul> <li>Domain Routing</li> </ul> <ul> <li>DomainAdvert</li> </ul> <ul> <li>DomainAdvertV1</li> </ul> <ul> <li>DomainID</li> </ul> <ul> <li>DomainIdentity</li> </ul> <ul> <li>DomainIdentityRecord</li> </ul> <ul> <li>DomainRequest</li> </ul> <ul> <li>DomainResponse</li> </ul> <ul> <li>Dumper Engine</li> </ul> <ul> <li>Dynamic code loading</li> </ul>"},{"location":"indexes/links.html#e","title":"E","text":"<ul> <li>Encoding</li> </ul> <ul> <li>Encoding scheme</li> </ul> <ul> <li>Encryption Engine</li> </ul> <ul> <li>Encryption Engine Behaviour</li> </ul> <ul> <li>Encryption Engine Environment</li> </ul> <ul> <li>Encryption Engine Messages</li> </ul> <ul> <li>Engine</li> </ul> <ul> <li>Engine Behaviour</li> </ul> <ul> <li>Engine Configuration</li> </ul> <ul> <li>Engine Environment</li> </ul> <ul> <li>Engine Models</li> </ul> <ul> <li>Engine Templates</li> </ul> <ul> <li>Engine Types</li> </ul> <ul> <li>Engine Writing Conventions</li> </ul> <ul> <li>Engine writing conventions</li> </ul> <ul> <li>EngineAdvert</li> </ul> <ul> <li>EngineAdvertV1</li> </ul> <ul> <li>EngineIdentity</li> </ul> <ul> <li>EngineIdentityRecord</li> </ul> <ul> <li>EngineMessage</li> </ul> <ul> <li>EngineMessage to PubSub</li> </ul> <ul> <li>EngineMessageV1</li> </ul> <ul> <li>Engines</li> </ul> <ul> <li>Engines in Anoma</li> </ul> <ul> <li>EpochTimestampV1</li> </ul> <ul> <li>Event</li> </ul> <ul> <li>EventV1</li> </ul> <ul> <li>Everything</li> </ul> <ul> <li>ExecuteTransaction</li> </ul> <ul> <li>Execution</li> </ul> <ul> <li>Execution Supervisor</li> </ul> <ul> <li>Execution engines</li> </ul> <ul> <li>ExecutionSummary</li> </ul> <ul> <li>Executor</li> </ul> <ul> <li>Executor / Executor Process</li> </ul> <ul> <li>ExecutorFinished</li> </ul> <ul> <li>ExecutorPIDAssigned</li> </ul> <ul> <li>ExecutorPIDAssigned (EPID)</li> </ul> <ul> <li>ExtRequest</li> </ul> <ul> <li>ExtResponse</li> </ul>"},{"location":"indexes/links.html#f","title":"F","text":"<ul> <li>File naming conventions</li> </ul> <ul> <li>Function encoding</li> </ul>"},{"location":"indexes/links.html#g","title":"G","text":"<ul> <li>GetDataTimeSeriesDBRequest</li> </ul> <ul> <li>GetDataTimeSeriesDBRequestV1</li> </ul> <ul> <li>GetDataTimeSeriesDBResponse</li> </ul> <ul> <li>GetDataTimeSeriesDBResponseV1</li> </ul> <ul> <li>GetValueKVStoreRequest</li> </ul> <ul> <li>GetValueKVStoreRequestV1</li> </ul> <ul> <li>GetValueKVStoreResponse</li> </ul> <ul> <li>GetValueKVStoreResponseV1</li> </ul> <ul> <li>Git branching strategy</li> </ul>"},{"location":"indexes/links.html#h","title":"H","text":"<ul> <li>Hardware Abstraction Machine</li> </ul> <ul> <li>Hardware Machine</li> </ul> <ul> <li>Hash encoding</li> </ul> <ul> <li>Hash function</li> </ul> <ul> <li>HeaderFingerprint</li> </ul> <ul> <li>Headers and other Markdown conventions</li> </ul> <ul> <li>Headers and other Markdown formatting conventions</li> </ul> <ul> <li>Home</li> </ul>"},{"location":"indexes/links.html#i","title":"I","text":"<ul> <li>Identities</li> </ul> <ul> <li>Identity Architecture</li> </ul> <ul> <li>Identity Management Engine</li> </ul> <ul> <li>Identity Management Engine Behaviour</li> </ul> <ul> <li>Identity Management Engine Environment</li> </ul> <ul> <li>Identity Management Engine Messages</li> </ul> <ul> <li>IdentityRecord</li> </ul> <ul> <li>IdentityStore</li> </ul> <ul> <li>IdentityUpdated</li> </ul> <ul> <li>IdentityUpdatedV1</li> </ul> <ul> <li>Implementation</li> </ul> <ul> <li>Include code snippets</li> </ul> <ul> <li>Include images in Markdown</li> </ul> <ul> <li>Indexes</li> </ul> <ul> <li>IntegrityVote</li> </ul> <ul> <li>Inter-domain P2P protocols</li> </ul> <ul> <li>Interaction</li> </ul> <ul> <li>Intra domain protocols</li> </ul> <ul> <li>Intra node &amp; inter node protocols</li> </ul> <ul> <li>Intra-domain P2P protocols</li> </ul> <ul> <li>Intra-node &amp; inter-node protocols</li> </ul> <ul> <li>Introduction</li> </ul>"},{"location":"indexes/links.html#j","title":"J","text":"<ul> <li>JoinRequest</li> </ul> <ul> <li>JoinResponse</li> </ul> <ul> <li>Juvix Base Prelude</li> </ul> <ul> <li>Juvix Documentation</li> </ul> <ul> <li>Juvix Module Index</li> </ul>"},{"location":"indexes/links.html#k","title":"K","text":"<ul> <li>KVSAcquireLock</li> </ul> <ul> <li>KVSDatum</li> </ul> <ul> <li>KVSKey</li> </ul> <ul> <li>KVSLockAcquired</li> </ul> <ul> <li>KVSRead</li> </ul> <ul> <li>KVSReadRequest</li> </ul> <ul> <li>KVSWrite</li> </ul> <ul> <li>KVSWritten</li> </ul> <ul> <li>Kind</li> </ul> <ul> <li>Kudos</li> </ul>"},{"location":"indexes/links.html#l","title":"L","text":"<ul> <li>Local Key Value Storage Engine</li> </ul> <ul> <li>Local Logging Engine</li> </ul> <ul> <li>Local Storage Engines</li> </ul> <ul> <li>Local Time Series Storage Engine</li> </ul> <ul> <li>Local Wall Clock Engine</li> </ul> <ul> <li>LocalLoggingAppend</li> </ul> <ul> <li>LocalLoggingAppendV1</li> </ul> <ul> <li>LocalWallClockGetTime</li> </ul> <ul> <li>LocalWallClockGetTimeResult</li> </ul> <ul> <li>LocalWallClockGetTimeResultV1</li> </ul> <ul> <li>LocalWallClockGetTimeV1</li> </ul> <ul> <li>LookupIdentityRequest</li> </ul> <ul> <li>LookupIdentityRequestV1</li> </ul> <ul> <li>LookupIdentityResponse</li> </ul> <ul> <li>LookupIdentityResponseV1</li> </ul>"},{"location":"indexes/links.html#m","title":"M","text":"<ul> <li>Managing the Changelog</li> </ul> <ul> <li>Markdown Basics for Anoma Documentation</li> </ul> <ul> <li>Mempool</li> </ul> <ul> <li>Mempool engines</li> </ul> <ul> <li>Messages &amp; Mailboxes</li> </ul> <ul> <li>Modules</li> </ul> <ul> <li>Modules in Juvix</li> </ul> <ul> <li>Multiformats</li> </ul> <ul> <li>Multifunctions</li> </ul>"},{"location":"indexes/links.html#n","title":"N","text":"<ul> <li>Naming Engine</li> </ul> <ul> <li>Naming Engine Behaviour</li> </ul> <ul> <li>Naming Engine Environment</li> </ul> <ul> <li>Naming Engine Messages</li> </ul> <ul> <li>NarwhalBlockHeader</li> </ul> <ul> <li>Network Architecture</li> </ul> <ul> <li>Network Identity Store</li> </ul> <ul> <li>Networking Machine</li> </ul> <ul> <li>Nockma</li> </ul> <ul> <li>Node Architecture</li> </ul> <ul> <li>NodeAdvert</li> </ul> <ul> <li>NodeAdvertV1</li> </ul> <ul> <li>NodeConnectFailed</li> </ul> <ul> <li>NodeConnected</li> </ul> <ul> <li>NodeDisconnected</li> </ul> <ul> <li>NodeIdentity</li> </ul> <ul> <li>NodeIdentityRecord</li> </ul> <ul> <li>NodeTransportAddress</li> </ul> <ul> <li>Non-linear resources</li> </ul> <ul> <li>Notifications</li> </ul> <ul> <li>Nullifier</li> </ul>"},{"location":"indexes/links.html#o","title":"O","text":"<ul> <li>Ordering Machine</li> </ul> <ul> <li>OrderingPrefs</li> </ul>"},{"location":"indexes/links.html#p","title":"P","text":"<ul> <li>P2P</li> </ul> <ul> <li>P2PMessage</li> </ul> <ul> <li>P2PMessage to Transport</li> </ul> <ul> <li>P2PMessageV1</li> </ul> <ul> <li>Peer Sampling</li> </ul> <ul> <li>PeerSamplingView</li> </ul> <ul> <li>Pinger Engine</li> </ul> <ul> <li>Preference Function</li> </ul> <ul> <li>Preference function</li> </ul> <ul> <li>Preliminaries</li> </ul> <ul> <li>Prepare working environment</li> </ul> <ul> <li>Preparing the local environment for writing documentation</li> </ul> <ul> <li>Prerequisite primitives</li> </ul> <ul> <li>Primary</li> </ul> <ul> <li>Primitives</li> </ul> <ul> <li>Proof</li> </ul> <ul> <li>Proof encoding</li> </ul> <ul> <li>Proof of stake</li> </ul> <ul> <li>Proof-of-stake</li> </ul> <ul> <li>Protocol Architecture</li> </ul> <ul> <li>Protocol desiderata</li> </ul> <ul> <li>Proving</li> </ul> <ul> <li>PubSub</li> </ul> <ul> <li>PubSubRoutingTable</li> </ul> <ul> <li>PubSubRoutingTableEntry</li> </ul>"},{"location":"indexes/links.html#q","title":"Q","text":"<ul> <li>Quick Links</li> </ul> <ul> <li>Quick links</li> </ul>"},{"location":"indexes/links.html#r","title":"R","text":"<ul> <li>RISC0</li> </ul> <ul> <li>RISC0 Backend</li> </ul> <ul> <li>Read Backend</li> </ul> <ul> <li>ReadLabel</li> </ul> <ul> <li>Reads For Engine</li> </ul> <ul> <li>Reads For Engine Behaviour</li> </ul> <ul> <li>Reads For Engine Environment</li> </ul> <ul> <li>Reads For Engine Messages</li> </ul> <ul> <li>RecordDataTimeSeriesDBRequest</li> </ul> <ul> <li>RecordDataTimeSeriesDBRequestV1</li> </ul> <ul> <li>RecordDataTimeSeriesDBResponse</li> </ul> <ul> <li>RecordDataTimeSeriesDBResponseV1</li> </ul> <ul> <li>RelayMessage</li> </ul> <ul> <li>RelayMessageV1</li> </ul> <ul> <li>ReliabilityPrefs</li> </ul> <ul> <li>Render Juvix code</li> </ul> <ul> <li>ReputationValue</li> </ul> <ul> <li>RequestLogs</li> </ul> <ul> <li>Resource</li> </ul> <ul> <li>Resource Commitment</li> </ul> <ul> <li>Resource Delta</li> </ul> <ul> <li>Resource Kind</li> </ul> <ul> <li>Resource Logic</li> </ul> <ul> <li>Resource Machine</li> </ul> <ul> <li>Resource Nullifier</li> </ul> <ul> <li>Resource logic</li> </ul> <ul> <li>Resource machine</li> </ul> <ul> <li>Resource machine backends</li> </ul> <ul> <li>Roles</li> </ul> <ul> <li>Roles and requirements</li> </ul> <ul> <li>Router</li> </ul> <ul> <li>RoutingPrefs</li> </ul> <ul> <li>RoutingScope</li> </ul> <ul> <li>RoutingTable</li> </ul> <ul> <li>RoutingTableDest</li> </ul> <ul> <li>RoutingTableDomain</li> </ul> <ul> <li>RoutingTableEntry</li> </ul> <ul> <li>RoutingTableTopic</li> </ul> <ul> <li>Run pre commit checks</li> </ul> <ul> <li>Run pre-commit checks</li> </ul>"},{"location":"indexes/links.html#s","title":"S","text":"<ul> <li>snake_case convention for naming files and folders</li> </ul>"},{"location":"indexes/links.html#t","title":"T","text":"<ul> <li>Taiga</li> </ul> <ul> <li>Techniques</li> </ul> <ul> <li>Template Behaviour</li> </ul> <ul> <li>Template Engine</li> </ul> <ul> <li>Template Environment</li> </ul> <ul> <li>Template Messages</li> </ul> <ul> <li>Ticker Behaviour</li> </ul> <ul> <li>Ticker Engine</li> </ul> <ul> <li>Ticker Environment</li> </ul> <ul> <li>Ticker Messages</li> </ul> <ul> <li>TimeSeriesDBDataV1</li> </ul> <ul> <li>TimeSeriesDBQueryV1</li> </ul> <ul> <li>Title v1</li> </ul> <ul> <li>Title v2</li> </ul> <ul> <li>Tokens</li> </ul> <ul> <li>TopicAdvert</li> </ul> <ul> <li>TopicAdvertReceived</li> </ul> <ul> <li>TopicAdvertV1</li> </ul> <ul> <li>TopicCreateRequest</li> </ul> <ul> <li>TopicCreateRequestV1</li> </ul> <ul> <li>TopicCreateResponse</li> </ul> <ul> <li>TopicCreateResponseV1</li> </ul> <ul> <li>TopicDeleteRequest</li> </ul> <ul> <li>TopicDeleteRequestV1</li> </ul> <ul> <li>TopicDeleteResponse</li> </ul> <ul> <li>TopicDeleteResponseV1</li> </ul> <ul> <li>TopicId</li> </ul> <ul> <li>TopicIdentity</li> </ul> <ul> <li>TopicIdentityRecord</li> </ul> <ul> <li>TopicRequestV1</li> </ul> <ul> <li>TopicResponseV1</li> </ul> <ul> <li>TopicSubRequest</li> </ul> <ul> <li>TopicSubRequestV1</li> </ul> <ul> <li>TopicSubResponse</li> </ul> <ul> <li>TopicSubResponseV1</li> </ul> <ul> <li>TopicSubscribed</li> </ul> <ul> <li>TopicUnsubRequest</li> </ul> <ul> <li>TopicUnsubRequestV1</li> </ul> <ul> <li>TopicUnsubResponse</li> </ul> <ul> <li>TopicUnsubResponseV1</li> </ul> <ul> <li>TopicUnsubscribed</li> </ul> <ul> <li>Topology</li> </ul> <ul> <li>Transaction</li> </ul> <ul> <li>Transaction function</li> </ul> <ul> <li>TransactionAck</li> </ul> <ul> <li>TransactionCandidate</li> </ul> <ul> <li>TransactionExecutable</li> </ul> <ul> <li>TransactionLabel</li> </ul> <ul> <li>TransactionRequest</li> </ul> <ul> <li>Transparent</li> </ul> <ul> <li>Transparent Backend</li> </ul> <ul> <li>Transport</li> </ul> <ul> <li>TransportAddress</li> </ul> <ul> <li>TransportMessage</li> </ul> <ul> <li>TransportMessageV1</li> </ul> <ul> <li>TransportOrderingPrefs</li> </ul> <ul> <li>TransportPrefs</li> </ul> <ul> <li>TransportReliabilityPrefs</li> </ul> <ul> <li>TransportSecurityPrefs</li> </ul> <ul> <li>TrustValue</li> </ul> <ul> <li>Tutorials and guidelines for writing Anoma Specification documentation</li> </ul> <ul> <li>Tutorials for contributors</li> </ul> <ul> <li>Tutorials on Engine Families</li> </ul> <ul> <li>TxData</li> </ul> <ul> <li>TxFingerprint</li> </ul> <ul> <li>Types</li> </ul>"},{"location":"indexes/links.html#u","title":"U","text":"<ul> <li>Unsubscribe</li> </ul> <ul> <li>UnsubscribeAck</li> </ul> <ul> <li>UnsubscribeRequest</li> </ul> <ul> <li>UpdateIdentityRequest</li> </ul> <ul> <li>UpdateIdentityRequestV1</li> </ul> <ul> <li>UpdateIdentityResponse</li> </ul> <ul> <li>UpdateIdentityResponseV1</li> </ul> <ul> <li>UpdateSeenAll</li> </ul> <ul> <li>Updating the changelog</li> </ul> <ul> <li>Use Git and GitHub</li> </ul> <ul> <li>Use Wiki style links</li> </ul>"},{"location":"indexes/links.html#v","title":"V","text":"<ul> <li>ValueChangedKVStore</li> </ul> <ul> <li>Verification Engine</li> </ul> <ul> <li>Verification Engine Behaviour</li> </ul> <ul> <li>Verification Engine Environment</li> </ul> <ul> <li>Verification Engine Messages</li> </ul> <ul> <li>Versioning</li> </ul> <ul> <li>Virtual machine</li> </ul>"},{"location":"indexes/links.html#w","title":"W","text":"<ul> <li>WHFingerprint</li> </ul> <ul> <li>Worker</li> </ul> <ul> <li>Worker Engine</li> </ul> <ul> <li>WorkerHash</li> </ul> <ul> <li>World model</li> </ul> <ul> <li>Write Markdown</li> </ul> <ul> <li>WriteLabel</li> </ul>"},{"location":"scope/index.html","title":"Scope","text":"<p>This section describes the scope of Anoma.</p> <p>The scope defines the basic conceptual model on the basis of which the protocol operates and the high-level functionality which the protocol aims to provide.</p> <p>The scope section is split into two sub-sections:</p> <ul> <li>World model describes the world context in which the   protocol is designed to operate.</li> <li>Protocol desiderata describes what it is   that the protocol must do.</li> </ul>","boost":2},{"location":"scope/protocol_desiderata.html","title":"Protocol desiderata","text":"","boost":2},{"location":"scope/protocol_desiderata.html#cybernetic-agency","title":"Cybernetic agency","text":"<p>We assume that the world is of interest to agents: in general, agents may be interested in choosing their actions in such a manner as to regulate the probability distribution of their future observations, the probability distributions of future observations of other agents, and in general the probability distribution of inferred latent state of the world - which requires observing the world and building an internal model of it in order to better predict how actions may affect it. This capacity - to observe, record, model, predict, act, and thereby regulate - we refer to as cybernetic agency. Note in particular that many actions may simply be oriented towards crafting a better model, in expectation of said model being useful for prediction of the results of future actions.</p> <pre><code>flowchart LR\n      OldWorld[\"Old World\"]\n      Observe\n      Model\n      Predict\n      Desire\n      Act\n      NewWorld[\"New World\"]\n      OldWorld --&gt; Observe\n      Observe --&gt; Model\n      Model --&gt; Predict\n      Desire --&gt; Predict\n      Predict --&gt; Act\n      Act --&gt; NewWorld\n      NewWorld --Next timestep--&gt; OldWorld</code></pre>","boost":2},{"location":"scope/protocol_desiderata.html#coordination","title":"Coordination","text":"<p>We assume that - perhaps in order to increase their degree of cybernetic agency - agents may wish to coordinate with other agents, which may include:</p> <ul> <li>sharing observations with other agents, for improved modeling and prediction</li> <li>sharing storage and comptuational resources with other agents (storing data or performing computations upon request)</li> <li>coordinating actions which may have causally interdependent effects, especially when the interdependence may be crucial in determining whether the effect upon the world would be desired or not</li> </ul> <p>In a sense, we can understand coordination as composition of cybernetic agency, in that it allows many agents who elect to do so to act \"as if\" they were one.</p> <p>We define a protocol as a way to automatically respond to messages, i.e.</p> <pre><code>flowchart LR\n      subgraph Alice\n      P_1[\"Protocol instance 1\"]\n      I_1[\"Internal observation and control\"]\n      end\n      subgraph Bob\n      P_2[\"Protocol instance 2\"]\n      I_2[\"Internal observation and control\"]\n      end\n      subgraph Charlie\n      P_3[\"Protocol instance 3\"]\n      I_3[\"Internal observation and control\"]\n      end\n      I_1 &lt;--&gt; P_1\n      I_2 &lt;--&gt; P_2\n      I_3 &lt;--&gt; P_3\n      P_1 &lt;--&gt; P_2\n      P_2 &lt;--&gt; P_3\n      P_1 &lt;--&gt; P_3</code></pre> <p>We define a compositional cybernetic agency protocol as a protocol which allows for all of these functions, without loss of generality. The remainder of this specification document describes the structure of such a protocol.</p>","boost":2},{"location":"scope/world_model.html","title":"World model","text":"<p>Anoma operates with the fundamental conceptual frame of agents in a world who may often seek to share their observations of the world, pool their storage and computational resources, and coordinate their actions taken within the world for mutually preferred effect.</p>","boost":2},{"location":"scope/world_model.html#agents","title":"Agents","text":"<p>Agent is a primary notion that aims to unify the notions of process in the distributed systems literature, organism in the theoretical biology literature (e.g. active inference), and the subject of experience as articulated by Kant.</p> <p>An agent is a corporeal being possessed of memory, the ability to perform computation, internal unity, and transcendental freedom. To spell out each of these in turn:</p> <ul> <li>An agent is a corporeal being in the sense of being possessed of a physical form and a boundary which delineates that which is part of the agent from that which is not. That which is not the agent is the world. That which is part of the agent is not revealed to the world except through messages sent outwards.</li> <li>An agent is possessed of memory which can store the agent's own history of experience, computations derived from it, or any other data.</li> <li>An agent is possessed of the ability to perform arbitrary computation. For the time being, we assume that this computation is classical in nature, but the notion could be extended to quantum computation in the future.</li> <li>An agent is possessed of internal unity, in the sense that whatever parts compose the agent act in unison and may be modelled both internally and externally as a unified whole.</li> <li>An agent is possessed of transcendental freedom in the Kantian sense, in that the agent can originate an action purely from itself, and that in response to certain inputs, the agent can always do otherwise. We furthermore assume that this self-origination of action is sufficient to provide a random oracle whose output is not predictable.</li> </ul> <p>In general, Anoma does not assume that agent identity is fixed and temporally invariant. Agents may split themselves, merge with or absorb other agents, or otherwise alter their boundaries continuously. However, reasoning about the evolution of the system over time will require the assumption that the information known to the agents at the start of the period in question is in some form preserved.</p> <p>Agents may be composed of many parts which may be variously of physical or biological natures. Roughly, Anoma understands the identity of an agent on the basis of unity of corporeality, memory, computation, and freedom of action. For example, a person and their smartphone or personal computer held in hand would together comprise a singular agent in the sense defined here, while two separate people or a person and a computer across the world would not.</p>","boost":2},{"location":"scope/world_model.html#world","title":"World","text":"<p>An agent always exists in a world. The world, in some sense, is simply the sum totality of that which is not the agent. The world, we assume, is generally of interest to agents: they may seek information from it, send information into it, depend on physical resources from it for their continued survival, and simply care about it for transcendental reasons of their own. It is only through the world that one agent can communicate with another, and the distinction in the identity of the other from the rest of the world must simply be inferred.</p>","boost":2},{"location":"scope/world_model.html#observations-actions","title":"Observations &amp; actions","text":"<p>Agents can interact with the world in two ways: by taking observations of it, and by performing actions within it. Observations can be understood as messages received from the world, while actions can be understood as messages sent to it.</p> <p>Observations may be directed by a particular conceptualization of phenomena, in which case they are called measurements, and accompanied by a name of semantic significance to the agent taking the measurement, or undirected, in which case they are called perceptions and unaccompanied. Observations may be initiated by the agent itself or initiated by the world.</p> <p>Example</p> <p>For example, an observation might be \\(12988388\\).</p> <p>Example</p> <p>For example, a measurement might be \\((temperature, 25.5)\\).</p> <p>Actions, similarly, may be directed by a particular conceptualization of the agent-world boundary, in which case they are accompanied by a name of semantic significance to the agent taking the action, or undirected, in which case they are unaccompanied.</p> <p>Example</p> <p>For example, a directed action might be \\((setThermostat, 22)\\).</p> <p>Example</p> <p>For example, an undirected action might be \\(23123412\\).</p>","boost":2},{"location":"scope/world_model.html#causal-structure","title":"Causal structure","text":"<p>In general, the world which the agents inhabit is assumed to have causal structure which is unknown but connected and agent-invariant, i.e.:</p> <ul> <li>The world is connected: for at least some actions, the probability distribution of at least one other agent's future observations, conditioned on an agent's action, is not equal to the probability distribution not so conditioned. In other words, we assume that actions have effects. In a world where this does not hold, coordination would be pointless.</li> <li>The world is agent-invariant:       - Agents observing the world in the same way (the definition of this is left a bit vague, but suppose e.g. measuring the temperature at the same time in the same place) will receive the same result.       - Agents taking actions in the same way (the definition of this is left a bit vague, but suppose e.g. setting the same thermostat to the same level) will result in the same effects.</li> </ul> <p>In order for the agents to build up a model of the behaviour of the world over time which will be useful in predicting the results of future actions, the world's causal structure must also be invariant under spatial and temporal translation (as, say, the known laws of physics are).</p>","boost":2},{"location":"system_architecture/state/intent_machine/index.html","title":"Index","text":"<p>icon: material/file-document-outline search:   exclude: false   boost: 2 tags:   - intent-machine   - intent   - solver   - protocol   hide: - toc</p>"},{"location":"system_architecture/state/intent_machine/index.html#intent-machine","title":"Intent Machine","text":""},{"location":"system_architecture/state/intent_machine/index.html#introduction","title":"Introduction","text":"<p>The Intent Machine is an abstraction describing the process of counterparty discovery and settlement in the Anoma protocol. Intent machines take sets of intents, search for possible valid and balanced transactions, and select transactions to actually execute. An abstract description can be found in the following report:</p> <ul> <li>Zenodo</li> <li>ART Index</li> </ul>"},{"location":"system_architecture/state/intent_machine/index.html#intents","title":"Intents","text":"<p>In the abstract, an intent is an expression of preference by an agent over future states of the system. Concretely, intents define which of the resources owned by an agent they offer for consumption, and which they desire to be created, in a transaction.</p>"},{"location":"system_architecture/state/intent_machine/index.html#solving","title":"Solving","text":"<p>The way that balanced transactions are derived from sets of intents is called solving. The act of solving involves aggregation of intents, as well as matching sets of intents, s.t. the resources to be consumed and created encoded in the intents of this set are balanced.</p>"},{"location":"system_architecture/state/intent_machine/index.html#data-format","title":"Data Format","text":""},{"location":"system_architecture/state/intent_machine/index.html#intent","title":"Intent","text":"<p>An intent is represented in Anoma as a (potentially unbalanced) transaction. Some intents contain ephemeral resources, the resource logic of which encodes the constraints for the intent. Other intents can express their unfulfilled constraints solely by means of unbalanced parts of the delta term.</p>"},{"location":"system_architecture/state/intent_machine/index.html#solver-interface","title":"Solver Interface","text":"<p>Solvers receive sets of unbalanced transactions from agents, run matching algorithms of their choice over them, and return balanced transactions, which are sent to the execution engine.</p>"},{"location":"tutorial/index.html","title":"Tutorials and guidelines for writing Anoma Specification documentation","text":"<p>The following tutorials and guidelines are available. If you want to contribute to this website in anyhow, ask for access to the anoma/nspec repository, and submit a pull request with your changes.</p> <ul> <li>Prepare working environment</li> </ul> <ul> <li>Use Git and GitHub</li> </ul> <ul> <li>Updating the changelog</li> </ul> <ul> <li>Versioning</li> </ul> <ul> <li>File naming conventions</li> </ul> <ul> <li>Write Markdown</li> </ul> <ul> <li>Headers and other Markdown formatting conventions</li> </ul> <ul> <li>Use Wiki style links</li> </ul> <ul> <li>Include images in Markdown</li> </ul> <ul> <li>Include code snippets</li> </ul> <ul> <li>Add Juvix code for specification</li> </ul> <ul> <li>Add pending tasks with Todos admonition</li> </ul> <ul> <li>Add literature references</li> </ul> <ul> <li>Add diffs for versioning</li> </ul> <ul> <li>Run pre commit checks</li> </ul> <ul> <li>Engines in Anoma</li> </ul> (Wiki) links on this page<ul><li>Prepare working environment</li><li>Use Git and GitHub</li><li>Updating the changelog</li><li>Versioning</li><li>File naming conventions</li><li>Write Markdown</li><li>Headers and other Markdown formatting conventions</li><li>Use Wiki style links</li><li>Include images in Markdown</li><li>Include code snippets</li><li>Add Juvix code for specification</li><li>Add pending tasks with Todos admonition</li><li>Add literature references</li><li>Add diffs for versioning</li><li>Run pre commit checks</li><li>Engines in Anoma</li></ul>","tags":["guidelines","documentation"]},{"location":"tutorial/branch.html","title":"Git branching strategy","text":"<p>The general workflow is to branch off from the latest version's branch, perform your changes, open a pull request, and merge your updates.</p>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#branching-strategy","title":"Branching strategy","text":"","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#for-changes-to-the-latest-version","title":"For changes to the latest version","text":"<p>For changes to the latest version, branch off from <code>main</code>. Name your branch by prefixing your name and an issue identifier, like <code>your-name/issue-identifier</code>.</p> <pre><code>git fetch\ngit checkout -b your-name/issue-identifier origin/main\n</code></pre>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#for-changes-to-older-published-versions","title":"For changes to older published versions","text":"<p>For patching older versions, branch off from the specific version branch. Published versions follow the pattern <code>vX</code>, where <code>X</code> is the version number. For example, say the latest version is <code>v0.1.0</code>.</p> <p>Name your branch by prefixing your name and an patch topic, like <code>your-name/patch-topic</code>.</p> <pre><code>git checkout -b your-name/patch-topic v0.1.0\n</code></pre> <p>The git graph will look like:</p> <pre><code>%%{init: { 'theme': 'neutral' } }%%\ngitGraph:\n    commit\n    branch vX\n    checkout vX\n    commit\n    branch your-name/issue-identifier\n    checkout your-name/issue-identifier\n    commit\n    checkout vX\n    merge your-name/issue-identifier</code></pre> <p>So, if your PR is merged, the changes will be incorporated into the version branch and on the website.</p>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#pushing-changes","title":"Pushing changes","text":"<p>When pushing changes for the first time in a new branch, set the upstream tracking branch:</p> <pre><code>git push -u origin some-branch:some-branch\n</code></pre> <p>Afterwards, for subsequent pushes the following is sufficient: <pre><code>git push\n</code></pre></p>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#rebasing-your-work","title":"Rebasing your work","text":"<p>Every once in a while, you should rebase your branch onto the base branch, if the current version has been updated. This will incorporate the latest changes from the base branch into your branch. The steps to rebase are usually the following.</p> <ul> <li>Switch to your working branch:<pre><code>git checkout your-name/issue-identifier\n</code></pre> </li> </ul> <ul> <li>Initiate the rebase onto the target branch:<pre><code>git pull origin main --rebase\n</code></pre> <p>Or merge the changes from the base branch which is convenient most of the   time:</p> <pre><code>git merge main\n</code></pre> </li> </ul>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#resolve-conflicts","title":"Resolve conflicts","text":"<ul> <li>Git will pause for conflict resolution.</li> <li> <p>After resolving each conflict:</p> <pre><code>git rebase --continue\n</code></pre> </li> </ul> <ul> <li> <p>To stop the rebase process:</p> <pre><code>git rebase --abort\n</code></pre> </li> </ul>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#push-your-changes","title":"Push your changes","text":"<ul> <li>Once rebase is complete, push changes:<pre><code>git push origin your-name/issue-identifier\n</code></pre> </li> </ul> <ul> <li>A force push may be required:<pre><code>git push origin your-name/issue-identifier --force-with-lease\n</code></pre> </li> </ul>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#important-notes","title":"Important notes","text":"<ul> <li>Ensure you are on the correct branch before making changes.</li> <li>Regularly update your branch to minimise conflicts.</li> <li>Ask for help if you encounter any issues to the maintainers.</li> </ul>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#merging-prs","title":"Merging PRs","text":"<p>Before a PR can be merged into the <code>main</code> branch, it must be able to build the whole codebase. The CI checks this automatically, and can be also verified manually:</p> <p>First, we must check the Juvix codebase, running the following command:</p> <pre><code>juvix typecheck docs/everything.juvix.md\n</code></pre> <p>Next, we must verify the MkDocs site build by running the following command:</p> <pre><code>poetry run mkdocs build\n</code></pre>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#integration-branches-for-complex-changes","title":"Integration branches for complex changes","text":"<p>When making complex changes that consist of a set of interdependent changes, it's best to split them up into smaller PRs that each address a single topic.</p> <p>For example, making a change to a type can be in one PR, a change to a different type in a second PR, and applying the type changes in the rest of the code base in a third one. In this case, branch 3 needs to merge branch 1 &amp; 2 first.</p> <p>We also need to create an integration branch, which becomes the base branch for all the interdependent PRs, and a corresponding integration PR to be merged into the <code>main</code> branch.</p> <p>On GitHub, make sure to include the list of auxiliary PRs as part of the description of the integration PR.</p> <p>This way the topic branches need not be able to build the whole codebase, while the integration branch must be able to build it once all the topic branches are merged into it.</p> <p>A possible diagram of the integration branch and topic branches is the following, assuming the integration branch is <code>example/integration</code> against <code>main</code>, and the topic branches are <code>example/topic-1</code> against <code>main</code>, <code>example/topic-2</code> against <code>main</code>, and <code>example/topic-3</code> against <code>main</code>. The topic branches are squashed-and-merged into the integration branch.</p> <pre><code>%%{init: { 'theme': 'neutral' } }%%\ngitGraph:\n    commit\n    branch example/topic-1\n    checkout example/topic-1\n    commit\n    checkout main\n    branch example/topic-2\n    checkout example/topic-2\n    commit\n    checkout main\n    branch example/integration\n    checkout example/integration\n    merge example/topic-1\n    merge example/topic-2\n    commit \"Fix merge conflicts\"\n    checkout main\n    merge example/integration</code></pre>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#fetch-the-latest-updates","title":"Fetch the latest updates","text":"<pre><code>git fetch\n</code></pre>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#create-integration-branch","title":"Create integration branch","text":"<pre><code>git branch example/integration origin/main\n</code></pre>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#create-topic-branches","title":"Create topic branches","text":"<pre><code>git branch example/topic-1 example/integration\ngit branch example/topic-2 example/integration\ngit branch example/topic-3 example/integration\n</code></pre>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#merge-dependencies","title":"Merge dependencies","text":"<pre><code>git checkout example/topic-3\ngit merge example/topic-1\ngit merge example/topic-2\n</code></pre>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#using-git-worktrees","title":"Using Git Worktrees","text":"<p>When working on multiple branches simultaneously, git worktrees come handy. Here's how to use them.</p>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#fetch-the-latest-updates_1","title":"Fetch the latest updates","text":"<pre><code>git fetch\n</code></pre>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#create-a-branch","title":"Create a branch","text":"<pre><code>git branch some-branch origin/main\n</code></pre>","tags":["GitHub","Git"]},{"location":"tutorial/branch.html#create-a-worktree-for-the-branch","title":"Create a Worktree for the branch","text":"<p>Either inside the repo starting with a dot (to avoid build issues): <pre><code>git worktree add /path/to/repo/.tree/some-branch some-branch\n</code></pre></p> <p>Or outside the repo: <pre><code>git worktree add /path/to/repo-some-branch some-branch\n</code></pre></p>","tags":["GitHub","Git"]},{"location":"tutorial/changelog.html","title":"Managing the Changelog","text":"<p>We use the <code>unclog</code> utility to manage our changelog entries. This ensures consistent formatting and makes it easier to maintain changelog entries. To install <code>unclog</code>, run:</p> <pre><code>cargo install unclog\n</code></pre>","tags":["tutorial","changelog"],"boost":3},{"location":"tutorial/changelog.html#adding-a-new-unreleased-entry","title":"Adding a New Unreleased Entry","text":"<p>There are two ways to add a new changelog entry:</p> <ol> <li>Using the CLI directly (recommended)</li> <li>Using your default text editor</li> </ol>","tags":["tutorial","changelog"],"boost":3},{"location":"tutorial/changelog.html#using-the-cli-directly","title":"Using the CLI Directly","text":"","tags":["tutorial","changelog"],"boost":3},{"location":"tutorial/changelog.html#available-sections","title":"Available Sections","text":"<p>Use one of these sections when adding entries:</p> <ul> <li><code>features</code> - For new features (NEW)</li> <li><code>changes</code> - For changes in existing functionality (CHANGED)</li> <li><code>fixes</code> - For bug fixes (FIXED)</li> <li><code>deprecations</code> - For soon-to-be removed features (REMOVED)</li> </ul>","tags":["tutorial","changelog"],"boost":3},{"location":"tutorial/changelog.html#available-components","title":"Available Components","text":"<p>Use one of the following components for your entry: - <code>node</code>: For changes to the node architecture - <code>sys</code>: For changes to the system architecture - <code>spec</code>: For changes to the general specification - <code>types</code>: For changes to the fundamentals (basic abstractions, types, etc.) - <code>apps</code>: For changes to the applications - <code>juvix</code>: For changes related to the Juvix language/compiler - <code>tutorial</code>: For changes to the tutorial for Spec writers</p>","tags":["tutorial","changelog"],"boost":3},{"location":"tutorial/changelog.html#recommended-call-syntax","title":"Recommended Call Syntax","text":"<p>For consistency,</p> <ul> <li>Take into account the number of the pull request</li> <li>Use the component that best describes the change</li> <li>Use the section that best describes the change</li> <li>Add an issue number if the change is related to an issue</li> </ul> <p>The following flags are used:</p> <ul> <li><code>-i</code> for the entry identifier (filename)</li> <li><code>-p</code> for the pull request number</li> <li><code>-c</code> for the component (e.g. <code>node</code>, <code>system</code>, <code>juvix</code>, <code>apps</code>, <code>fundamentals</code>)</li> <li><code>-s</code> for the section (e.g. <code>features</code>, <code>fixes</code>, <code>deprecations</code>,:)</li> <li><code>-m</code> for the message</li> <li><code>--editor</code> for the editor to use (e.g. <code>nano</code>, <code>vim</code>, <code>code</code>) More information about the command syntax can be found in the unclog documentation.</li> </ul>","tags":["tutorial","changelog"],"boost":3},{"location":"tutorial/changelog.html#examples","title":"Examples","text":"<p>The following are examples used to populate the changelog for the v0.1.0 release.</p> <ul> <li>System and Node Architecture</li> </ul> <pre><code>unclog add -p 210 -i sys210 --editor nano -c sys \\\n  -s breaking-changes -m \"Fix engine message, environment and behavior layout\"\n</code></pre> <ul> <li>Node Architecture</li> </ul> <pre><code>unclog add -p 179 -i node179 --editor nano -c node \\\n  -s breaking-changes -m \"Reorganize node architecture documentation structure\"\n</code></pre> <ul> <li>Juvix Types and Updates</li> </ul> <pre><code>unclog add -p 128 -i types128 --editor nano -c types \\\n  -s features -m \"Add new Juvix definitions from PR-84\"\n</code></pre> <ul> <li>Repository Maintenance and</li> </ul> <pre><code>unclog add -p 135 -i repo135 --editor nano -c repo \\\n  -s features -m \"Show PR number in the site name\"\n</code></pre> <ul> <li>Tutorial and Documentation</li> </ul> <pre><code>unclog add -p 134 -i tut134 --editor nano -c tutorial \\\n  -s features -m \"Refactor tutorial for wiki-style links\"\n</code></pre> <ul> <li>Application Documentation</li> </ul> <pre><code>unclog add -p 198 -i apps198 --editor nano -c apps \\\n  -s features -m \"Add transparent RM implementation documentation\"\n</code></pre> <ul> <li>General Specification Changes</li> </ul> <pre><code>unclog add -p 192 -i spec192 --editor nano -c spec \\\n  -s breaking-changes -m \"Port identity engines to v2 template\"\n</code></pre> <ul> <li>Python-related Changes</li> </ul> <pre><code>unclog add -p 133 -i py133 --editor nano -c python \\\n  -s features -m \"Add support for multi-line wiki-style links\"\n</code></pre>","tags":["tutorial","changelog"],"boost":3},{"location":"tutorial/changelog.html#releasing-a-new-version","title":"Releasing a New Version","text":"<ol> <li> <p>Update the version number in <code>docs/Package.juvix</code> accordingly to the new release:</p> docs/Package.juvix<pre><code>module Package;\n...\n-    version := mkVersion 0 1 1\n+    version := mkVersion 0 1 2;\n...\n</code></pre> </li> <li> <p>Create the release:</p> <p>See Versioning for more details about version numbering.</p> <pre><code>unclog release v0.X.Y --editor nano\n</code></pre> <p>This will: - Let you edit the summary of the release - Move entries from <code>.changelog/unreleased/</code> to a new version section</p> </li> <li> <p>Update the changelog file in the docs directory:</p> <pre><code>unclog build &gt; ./docs/changelog.md\n</code></pre> </li> <li> <p>Tag the release:</p> <pre><code>git tag -a v0.X.Y -m \"Release v0.X.Y\"\n</code></pre> </li> </ol> <p>And push the tag to the repository. The PR corresponding to a release must contain the changelog entries for that release, and a tag.</p> <p>Do not squash-merge release PRs!</p> <p>Tags associated with individual commits are not preserved when squashing.</p> (Wiki) links on this page<ul><li>Versioning</li></ul>","tags":["tutorial","changelog"],"boost":3},{"location":"tutorial/commit_checks.html","title":"Run pre-commit checks","text":"<p>Pre-commit hooks are scripts that run before each commit to ensure code quality by checking for common issues.</p>","boost":3},{"location":"tutorial/commit_checks.html#running-pre-commit-checks","title":"Running pre-commit checks","text":"<p>If you have the Python environment ready, you can, for example, invoke all checks, by running the following command:</p> <pre><code>pre-commit run --all-files\n</code></pre>","boost":3},{"location":"tutorial/commit_checks.html#customizing-hooks","title":"Customizing hooks","text":"<p>No satisfied with the checks, customize hooks by editing <code>.pre-commit-config.yaml</code>. Refer to pre-commit documentation for more details.</p>","boost":3},{"location":"tutorial/file_naming.html","title":"snake_case convention for naming files and folders","text":"<p>The Anoma Specification uses the snake case convention for naming files and folders.</p>","tags":["file naming","conventions"]},{"location":"tutorial/file_naming.html#guidelines","title":"Guidelines","text":"<ul> <li>Use lowercase letters.</li> <li>Separate words with underscores <code>_</code>, instead of dashes <code>-</code> or camel case.</li> <li>No special characters or spaces.</li> </ul>","tags":["file naming","conventions"]},{"location":"tutorial/file_naming.html#pros","title":"Pros","text":"<ul> <li>Readability: Improves readability by clearly separating words in names, making   code more understandable.</li> <li>Consistency: Creates a uniform naming style throughout the codebase.</li> <li>Compatibility: Widely supported across different programming languages and   platforms, no issues with case sensitivity.</li> </ul>","tags":["file naming","conventions"]},{"location":"tutorial/file_naming.html#cons","title":"Cons","text":"<ul> <li>Length: Can make names longer.</li> <li>Visual Clutter: The underscores can create visual clutter, especially in   longer names. We suffer from this, specially in engine's description files.</li> </ul> <p>Info</p> <p>If you find any file or folder that does not follow this convention, please create an issue or a pull request to fix it. Thank you for your help!</p>","tags":["file naming","conventions"]},{"location":"tutorial/juvix.html","title":"Render Juvix code","text":"<p>Another feature of the Anoma documentation is the inclusion of Juvix code throughout its Markdown support. Here we assume you have Juvix already installed.</p> <p>A Juvix Markdown file is a file with extension <code>.juvix.md</code>. These files are preprocesses by the Juvix compiler to generate the final Markdown file. For this website, we are using <code>mkdocs-juvix-plugin</code>.</p>","tags":["Juvix"]},{"location":"tutorial/juvix.html#juvix-markdown-file-structure","title":"Juvix Markdown file structure","text":"<p>Very important to note is that the first Juvix code block must declare a module with the name of the file, and each block should be a sequence of well-defined expressions. This means submodules cannot be split across blocks. The name of  module must follow the folder structure of the file is in. For example, the  file <code>tutorial/basics.juvix.md</code> must declare the module <code>tutorial.basics</code>.</p> <pre><code>```juvix\nmodule tutorial.basics;\n-- ...\n```</code></pre> <p>Refer to the <code>everything.juvix.md</code> file located in the <code>docs</code> folder to see an example.</p>","tags":["Juvix"]},{"location":"tutorial/juvix.html#hide-juvix-code-blocks","title":"Hide Juvix code blocks","text":"<p>Juvix code blocks come with a few extra features, such as the ability to hide the code block from the final output. This is done by adding the <code>hide</code> attribute to the code block. For example:</p> <pre><code>```juvix hide\nmodule tutorial.basics;\n-- ...\n```</code></pre>","tags":["Juvix"]},{"location":"tutorial/juvix.html#extract-inner-module-statements","title":"Extract inner module statements","text":"<p>Another feature is the ability to extract inner module statements from the code block. This is done by adding the <code>extract-module-statements</code> attribute to the code block. This option can be accompanied by a number to indicate the number of statements to extract. For example, the following would only display the content inside the module <code>B</code>, that is, the module <code>C</code>.</p> <pre><code>```juvix extract-module-statements\nmodule B;\nmodule C;\n-- ...\n```</code></pre>","tags":["Juvix"]},{"location":"tutorial/juvix.html#snippets-of-juvix-code","title":"Snippets of Juvix code","text":"<p>You can also include snippets of Juvix code in your Markdown files. This is done by adding the <code>--8&lt;--</code> comment followed by the path to the file, and optionally a snippet identifier.</p> <p>Note</p> <p>If the path of the file ends with <code>!</code>, the raw content of the file will be included. Otherwise, for Juvix Markdown files, the content will be preprocessed by the Juvix compiler and then the generated HTML will be included.</p> <p>Snippet identifier</p> <p>To use a snippet identifier, you must wrap the Juvix code block with the syntax <code>&lt;!-- --8&lt;-- [start:snippet_identifier] --&gt;</code> and <code>&lt;!-- --8&lt;-- [end:snippet_identifier] --&gt;</code>. This technique is useful for including specific sections of a file. Alternatively, you use the standard <code>--8&lt;--</code> markers within the code and extract the snippet by appending a ! at the end of the path.</p>","tags":["Juvix"]},{"location":"tutorial/versioning.html","title":"Versioning","text":"<p>The Anoma Specification follows semantic versioning.</p> <pre><code>MAJOR.MINOR.PATCH\n</code></pre> <ul> <li>MAJOR version when you make incompatible API changes</li> <li>MINOR version when you add functionality in a backward compatible manner</li> <li>PATCH version when you make backward compatible bug fixes</li> </ul>","tags":["GitHub","Git"]},{"location":"tutorial/versioning.html#more-on-versioning-criteria","title":"More on versioning criteria","text":"<ul> <li>Major version (X.0.0): Incremented for backwards-incompatible changes, like:<p>- Breaking changes to core interfaces or types   - Removal of deprecated functionality   - Major architectural changes</p> </li> </ul> <ul> <li>Minor version (0.X.0): Incremented for backwards-compatible feature additions:<p>- New engines, message types, or behaviours   - New functionality that doesn't break existing code   - Deprecation notices for future breaking changes</p> </li> </ul> <ul> <li>Patch version (0.0.X): Incremented for backwards-compatible bug fixes:<p>- Documentation improvements   - Bug fixes that don't change interfaces   - Minor code clean-up and refactoring</p> </li> </ul>","tags":["GitHub","Git"]},{"location":"tutorial/versioning.html#preparing-a-new-version","title":"Preparing a new version","text":"<ul> <li> Update <code>mkdocs.yml</code></li> <li> Update <code>docs/Package.juvix</code></li> <li> Update <code>docs/references/ref.bib</code></li> <li> Git tag the new version</li> <li> Release a new changelog entry</li> </ul>","tags":["GitHub","Git"]},{"location":"tutorial/versioning.html#update-mkdocsyml","title":"Update <code>mkdocs.yml</code>","text":"<p>Update the <code>site_version</code> to the new version.</p> mkdocs.yml<pre><code>- site_version: !ENV [SITE_VERSION, \"v0.1.0\"]\n+ site_version: !ENV [SITE_VERSION, \"v0.1.1\"]\n</code></pre>","tags":["GitHub","Git"]},{"location":"tutorial/versioning.html#update-nspec-juvix-package-version","title":"Update <code>nspec</code> Juvix package version","text":"docs/Package.juvix<pre><code>package : Package :=\n  defaultPackage@{\n    name := \"nspec\";\n-    version := mkVersion 0 1 0;\n+    version := mkVersion 0 1 1;\n    dependencies :=\n      [github \"anoma\" \"juvix-stdlib\" \"v0.6.0\"; github \"anoma\" \"juvix-containers\" \"v0.14.1\"]\n  };\n</code></pre>","tags":["GitHub","Git"]},{"location":"tutorial/versioning.html#update-docsreferencesreferencesbib","title":"Update <code>docs/references/references.bib</code>","text":"<p>Update the version of the <code>nspec</code> package in the <code>references.bib</code> file.</p> docs/references/references.bib<pre><code>@software{nspec,\n  author = {Anoma},\n  title = {Anoma Specification},\n-  version = {0.1.0},\n+  version = {0.1.1},\n  url = {https://github.com/anoma/nspec}\n}\n</code></pre>","tags":["GitHub","Git"]},{"location":"tutorial/versioning.html#git-tag-the-new-version","title":"Git tag the new version","text":"<pre><code>git tag v0.1.1\n</code></pre>","tags":["GitHub","Git"]},{"location":"tutorial/versioning.html#release-a-new-changelog-entry","title":"Release a new changelog entry","text":"<p>Follow the Updating the changelog tutorial for more information on how to release a new changelog entry. This tutorial uses <code>unclog</code> to create a new changelog entry.</p> <p>The package started at version 0.1.0 as the initial release.</p> (Wiki) links on this page<ul><li>Updating the changelog</li></ul>","tags":["GitHub","Git"]},{"location":"tutorial/differ/index.html","title":"Show Diff","text":"<p>A custom script renders diffs between file versions. The files must reside in the same directory, named following the pattern <code>filename-vX.md</code>, where <code>X</code> is a version number.</p> <p>For example:</p> <pre><code>file_v1.md\nfile_v2.md\n</code></pre> <p>The rendered diff is displayed in tabs, with the left tab showing the previous, and the right tab showing the current version. If no previous version is found, the left tab is empty. If no current version is found, the right tab is empty.</p> <p>See here for an example on how it renders.</p>","tags":["diff"]},{"location":"tutorial/differ/file_v1.html","title":"File v1","text":"<p>Next version</p>"},{"location":"tutorial/differ/file_v1.html#title-v1","title":"Title v1","text":"<p>This is the first version of the file.</p> Changes to next version <ul> <li>This file: tutorial/differ/file_v1.html</li> <li>Next file: tutorial/differ/file_v2.html</li> </ul> <pre><code>--- file_v1.md  2024-11-26 03:21:34.189739843 +0000\n+++ file_v2.md  2024-11-26 03:21:34.189739843 +0000\n@@ -1,8 +1,4 @@\n----\n-icon: material/file-document-check\n----\n\n+# Title v2\n\n-# Title v1\n-\n-This is the first version of the file.\n\\ No newline at end of file\n+This is the second version of the file.\n\\ No newline at end of file\n</code></pre>"},{"location":"tutorial/differ/file_v2.html","title":"File v2","text":"<p>Previous version</p>"},{"location":"tutorial/differ/file_v2.html#title-v2","title":"Title v2","text":"<p>This is the second version of the file.</p> Changes from previous version <ul> <li>This file: tutorial/differ/file_v2.html</li> <li>Previous file: tutorial/differ/file_v1.html</li> </ul> <pre><code>--- file_v1.md  2024-11-26 03:21:34.189739843 +0000\n+++ file_v2.md  2024-11-26 03:21:34.189739843 +0000\n@@ -1,8 +1,4 @@\n----\n-icon: material/file-document-check\n----\n\n+# Title v2\n\n-# Title v1\n-\n-This is the first version of the file.\n\\ No newline at end of file\n+This is the second version of the file.\n\\ No newline at end of file\n</code></pre>"},{"location":"tutorial/engines/index.html","title":"Tutorials on Engine Families","text":"<ul> <li>Conventions for writing engines</li> </ul> <ul> <li>Engine template:<ul> <li>Template Engine Overview</li> <li>Template Messages</li> <li>Template Environment</li> <li>Template Behaviour</li> </ul> </li> </ul> <ul> <li>Examples:<ul> <li>Ticker Engine:<ul> <li>Ticker Engine Overview</li> <li>Ticker Messages</li> <li>Ticker Environment</li> <li>Ticker Behaviour</li> </ul> </li> </ul> </li> </ul>","tags":["engines","conventions"]},{"location":"tutorial/engines/writing_conventions.html","title":"Engine Writing Conventions","text":"","tags":["engines","conventions"]},{"location":"tutorial/engines/writing_conventions.html#naming","title":"Naming","text":"<ul> <li>Engine files and folders: Named in lowercase using <code>snake_case</code> format. See File naming conventions.</li> </ul> <ul> <li>File extension: Files must be written in Juvix Markdown when applicable, that is, the file   must end with the extension <code>.juvix.md</code>. See Juvix Markdown and include Juvix code blocks.</li> </ul> <ul> <li> <p>File naming prefix: The engine's name is used as a prefix for all   files related to the engine in use. For example, the Ticker Engine   would have the following files, all prefixed with <code>ticker</code>:</p> <ul> <li><code>ticker.juvix.md</code></li> <li><code>ticker_messages.juvix.md</code></li> <li><code>ticker_environment.juvix.md</code></li> <li><code>ticker_behaviour.juvix.md</code></li> </ul> </li> </ul> <p>Warning</p> <p>Juvix Markdownm files have always need to define the corresponding module at the first Juvix code block. See the Juvix Markdown and include Juvix code blocks's tutorial. For example if the file is <code>ticker.juvix.md</code>, it must have the following code block:</p> <pre><code>module arch.node.engines.ticker;\n</code></pre>","tags":["engines","conventions"]},{"location":"tutorial/engines/writing_conventions.html#file-structure-within-the-engines-directory","title":"File structure within the <code>engines</code> directory","text":"<p>The files as listed above must be stored in the <code>engines</code> directory of the <code>arch/node</code> directory. For example, the <code>ticker</code> engine would have the following directory structure:</p> <pre><code>arch/node/\n\u2514\u2500\u2500 ...\n\u2514\u2500\u2500 engines/\n    \u251c\u2500\u2500 ...\n    \u251c\u2500\u2500 ticker.juvix.md\n    \u251c\u2500\u2500 ticker_messages.juvix.md\n    \u251c\u2500\u2500 ticker_environment.juvix.md\n    \u2514\u2500\u2500 ticker_behaviour.juvix.md\n</code></pre> <p>The <code>ticker.juvix.md</code> file then would contain a brief overview and list of all its components. Check out Ticker Engine as an example for the expected structure.</p> <p>So next time, if you want to use the <code>ticker</code> engine, then you can import the <code>arch.node.engines.ticker</code> module, adding only one line at the top of the Juvix file where the imports are declared:</p> <pre><code>...\n+ import arch.node.engines.ticker open;\n</code></pre>","tags":["engines","conventions"]},{"location":"tutorial/engines/writing_conventions.html#update-indexes","title":"Update indexes","text":"<p>As part of defining an engine type, you must update a few files that act as indexes.</p>","tags":["engines","conventions"]},{"location":"tutorial/engines/writing_conventions.html#juvix-everything-index","title":"Juvix Everything Index","text":"<p>Add import statements of all the modules related to the new engine to the <code>docs/everything.juvix.md</code> file. The new lines must be added in the \"Engines\" section. That is, if the engine is the <code>ticker</code>, we expect the following lines:</p> docs/everything.juvix.md<pre><code>module everything;\n...\n{- Engines -}\n+ import arch.node.engines.ticker;\n+ import arch.node.engines.ticker_messages;\n+ import arch.node.engines.ticker_environment;\n+ import arch.node.engines.ticker_behaviour;\n</code></pre>","tags":["engines","conventions"]},{"location":"tutorial/engines/writing_conventions.html#anoma-message","title":"Anoma Message","text":"<p>All message types must be added to the <code>arch/node/types/anoma_message.juvix.md</code> file. Use the same pattern as the existing message types. For example, if the engine is the <code>ticker</code>, the new type constructor should be <code>MsgTicker</code> along with the corresponding type for the messages, that is, <code>TickerMsg</code>.</p> arch/node/types/anoma_message.juvix.md<pre><code>...\nmodule arch.ode.types.anoma_message;\n+ import arch.node.engines.ticker_messages open using {TickerMsg};\n\ntype Msg :=\n+  | MsgTicker TickerMsg\n</code></pre>","tags":["engines","conventions"]},{"location":"tutorial/engines/writing_conventions.html#anoma-environment-index","title":"Anoma Environment Index","text":"<p>All environment types must be added to the <code>arch/node/types/anoma_environment.juvix.md</code> file. Similarly to the message types, the new type constructor should be <code>EnvTicker</code> along with the corresponding type for the environment, that is, <code>TickerEnvironment</code>. Do not forget to import the environment type in the <code>Env</code> type.</p> arch/node/types/anoma_environment.juvix.md<pre><code>module arch.node.types.anoma_environment;\n...\n+ import arch.node.engines.ticker_environment open using {TickerEnvironment};\n...\ntype Env :=\n+  | EnvTicker TickerEnvironment\n</code></pre> (Wiki) links on this page<ul><li>File naming conventions</li><li>Add Juvix code for specification</li><li>Ticker Engine</li><li>Add Juvix code for specification</li><li>Ticker Engine</li></ul>","tags":["engines","conventions"]},{"location":"tutorial/engines/template/index.html","title":"Engine Templates","text":"","tags":["engine-behaviour","engine-template"]},{"location":"tutorial/engines/template/index.html#engine-templates_1","title":"Engine templates","text":"<p>For each engine, we have three different files; accordingly, we mainly have three different template files. Each template file comes with an example using the Ticker engine, which can be opened side by side.</p> <ol> <li>Template Engine | Ticker Engine</li> <li>Template Environment | Ticker Environment</li> <li>Template Behaviour | Ticker Behaviour</li> </ol> <p>Related to the template files, we have Juvix files defining the types in the following files:</p> <ul> <li>Engine</li> <li>Engine Environment</li> <li>Engine Behaviour</li> </ul> <p>The organisation of these files, in particular the folder structure, are explained in the Folder structure's conventions page.</p> <p>Template syntax and conventions</p> <p>In the template files, we may use text in square brackets to describe generic content. For example, <code>[engine name]</code> is a placeholder for the name of an engine that is to be described. Text in pairs of braces, i.e., <code>{</code> and <code>}</code>, are short explanations, comments, or remarks (used only in titles). Occasionally, we use angled parentheses and italics for variables, i.e., \u27e8[variableName]\u27e9; for example, \u27e8hash\u27e9 is a variable for hashes. We add footnotes to point out related topics, give pointers to further reading, or digress on relevant detail.</p> <ol> <li> <p>We use different Juvix files for \"static\" and \"dynamic\" aspects of engine families; the \"dynamic\" aspect rely on the static aspects of all engines. In more detail, we require definitions of all engine-specific message types before we can form the type of any message to be sent. Finally, we have split off the engine overview page, which should be a self-contained description of engine families in broad terms.\u00a0\u21a9</p> </li> </ol>","tags":["engine-behaviour","engine-template"]},{"location":"tutorial/install/index.html","title":"Preparing the local environment for writing documentation","text":"","tags":["GitHub","python","MkDocs","Makefile"]},{"location":"tutorial/install/index.html#getting-started","title":"Getting Started","text":"<p>We use Markdown with extensions according to the Material for MkDocs reference.</p> <p>To set up the project for development and testing on your local machine, please follow these steps. Alternatively, you can edit the Markdown files directly on GitHub, open a pull request (PR), and the CI/CD pipeline will manage the build and deployment process after the changes are merged.</p> <p>For <code>.juvix.md</code> files, which include Juvix code examples, ensure that Juvix is installed. You can install the Juvix plugin for VS Code from the marketplace.</p>","tags":["GitHub","python","MkDocs","Makefile"]},{"location":"tutorial/install/index.html#installing-with-python","title":"Installing with Python","text":"<ol> <li> <p>Install prerequisites</p> <p>The following are the prerequisites to build the website locally:</p> <ul> <li>Python or higher which includes <code>pip</code></li> </ul> <ul> <li>Poetry: You can install by running <code>pip install poetry</code>.</li> </ul> <ul> <li>To deploy the website locally, you would need to install <code>graphviz</code> to   generate SVG files for dot files and <code>juvix</code> to render the Juvix code   examples.</li> </ul> </li> <li> <p>Install the required packages (preferably in the virtual environment) using Poetry:</p> <pre><code>poetry install\n</code></pre> </li> </ol>","tags":["GitHub","python","MkDocs","Makefile"]},{"location":"tutorial/install/index.html#building-and-serving-the-website","title":"Building and serving the website","text":"<ol> <li> <p>To generate the website in the <code>site/</code> directory, run:</p> <pre><code>poetry run mkdocs build\n</code></pre> </li> <li> <p>To serve the website locally, run the following command:</p> <pre><code>poetry run mkdocs serve\n</code></pre> <p>Take into account that this web server will automatically reload the website   when you make any changes to the files, and it is not especially fast.</p> </li> </ol>","tags":["GitHub","python","MkDocs","Makefile"]},{"location":"tutorial/install/index.html#development-shell-with-nix","title":"Development shell with Nix","text":"<ol> <li> <p>Install Nix: https://nixos.org/download/</p> </li> <li> <p>Enable Nix Flakes: https://nixos.wiki/wiki/flakes</p> </li> <li> <p>Enter development shell:</p> <pre><code>nix develop\n</code></pre> </li> </ol>","tags":["GitHub","python","MkDocs","Makefile"]},{"location":"tutorial/md/index.html","title":"Markdown Basics for Anoma Documentation","text":"<p>Our theme and main Markdown reference is Material for MkDocs. You may use anything found in this reference, including all possible Markdown extensions.</p> <p>This guide provides an overview of the key markdown features we use in the documentation. Please note that this guide is a work-in-progress.</p>","tags":["wikilinks","images","snippets"]},{"location":"tutorial/md/index.html#front-matter","title":"Front Matter","text":"<p>Each markdown file should begin with a front matter section. It typically includes metadata such as <code>icon</code>, <code>tags</code>, <code>categories</code>. For more examples, refer to other files within the documentation. For example, the icons name can be found here.</p>","tags":["wikilinks","images","snippets"]},{"location":"tutorial/md/index.html#example-front-matter","title":"Example Front Matter","text":"<pre><code>---\nicon: material/auto-download\nsearch:\n  exclude: false\n  boost: 3\ntags:\n  - GitHub\n  - python\n  - MkDocs\n  - Makefile\ncategories:\n  - tutorial\n---\n</code></pre> <p>Warning</p> <p>Any new markdown file added to the <code>docs</code> directory must, in principle, have an entry in the <code>mkdocs.yml</code> file, specifically in the <code>nav</code> section.</p> <p>The filename may be relevant depending on where it is placed in the navigation. For example, any file intended to be the landing page of a section, say Section X, must be named <code>index.md</code> and placed right below the <code>Section X</code> item. Children of <code>Section X</code> do not need to follow any specific naming convention.</p> <pre><code>...\n- Section X:\n    - ./path-to/index.md\n    - NameRef Child1 : ./path-to/child1.md\n    - NameRef Child2 : ./path-to/child2.md\n</code></pre>","tags":["wikilinks","images","snippets"]},{"location":"tutorial/md/citations.html","title":"Bibliography","text":"<p>Place your <code>.bib</code> files within the <code>docs/references</code> directory. For convenience, we have included all the ART published papers in the <code>docs/references/art.bib</code> file.</p> <p>Any new <code>.bib</code> file added to this folder will automatically be processed.</p>","tags":["references","bibtex"]},{"location":"tutorial/md/citations.html#citing-in-markdown","title":"Citing in Markdown","text":"<p>Use the citation key from your <code>.bib</code> files to cite references in your markdown files. The syntax is as follows:</p> <pre><code>This statement requires a citation [@citation_key].\n</code></pre> <p>Info</p> <p>We have <code>docs/references/update_repo_bibtexs.py</code> script that can be used to update the <code>docs/references/anoma_repos.bib</code> file to cite Anoma repositories in the documentation.</p>","tags":["references","bibtex"]},{"location":"tutorial/md/citations.html#references-available","title":"References available","text":"Anoma Research Topics (ART) papers <pre><code>% https://art.anoma.net\n\n\n@article{ art-2024-compiling-zkvms,\n    author    = { Centelles, Alberto },\n    title     = { {Compiling to ZKVMs} },\n    journal   = { Anoma Research Topics },\n    month     = { Apr },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { April 19, 2024 },\n    doi       = { 10.5281/zenodo.10998758 },\n    url       = { https://doi.org/10.5281/zenodo.10498994 }\n}\n\n\n@article{ art-2024-intent-machines,\n    author    = { Hart, Anthony and Reusche, D },\n    title     = { {Intent Machines} },\n    journal   = { Anoma Research Topics },\n    month     = { Feb },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { February 21, 2024 },\n    doi       = { 10.5281/zenodo.10654543 },\n    url       = { https://doi.org/10.5281/zenodo.10498992 }\n}\n\n\n@article{ art-2024-anoma-resource-machine-specification,\n    author    = { Khalniyazova, Yulia and Goes, Christopher },\n    title     = { {Anoma Resource Machine Specification} },\n    journal   = { Anoma Research Topics },\n    month     = { Jan },\n    year      = { 2024 },\n    publisher = { Zenodo },\n    version   = { January 26, 2024 },\n    doi       = { 10.5281/zenodo.10498991 },\n    url       = { https://doi.org/10.5281/zenodo.10498990 }\n}\n\n\n@article{ art-2023-vampir-bestiary,\n    author    = { Fitzgerald, Joshua and Centelles, Alberto },\n    title     = { {VampIR Bestiary} },\n    journal   = { Anoma Research Topics },\n    month     = { Nov },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { November 13, 2023 },\n    doi       = { 10.5281/zenodo.10118865 },\n    url       = { https://doi.org/10.5281/zenodo.10118864 }\n}\n\n\n@article{ art-2023-constraint-satisfaction-problems-survey,\n    author    = { Hart, Anthony },\n    title     = { {Constraint Satisfaction Problems: A Survey for Anoma} },\n    journal   = { Anoma Research Topics },\n    month     = { Oct },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { October 18, 2023 },\n    doi       = { 10.5281/zenodo.10019113 },\n    url       = { https://doi.org/10.5281/zenodo.10019112 }\n}\n\n\n@article{ art-2023-exploring-cryptographic-approaches-enhance,\n    author    = { Khalniyazova, Yulia },\n    title     = { {Exploring Cryptographic Approaches to Enhance Privacy in Intent Solving} },\n    journal   = { Anoma Research Topics },\n    month     = { Oct },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { October 02, 2023 },\n    doi       = { 10.5281/zenodo.8321167 },\n    url       = { https://doi.org/10.5281/zenodo.8321166 }\n}\n\n\n@article{ art-2023-core-language-juvix,\n    author    = { Lukasz Czajka },\n    title     = { {The Core language of Juvix} },\n    journal   = { Anoma Research Topics },\n    month     = { Aug },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { August 29, 2023 },\n    doi       = { 10.5281/zenodo.8268850 },\n    url       = { https://doi.org/10.5281/zenodo.8268849 }\n}\n\n\n@article{ art-2023-rethinking-vampir,\n    author    = { Anthony Hart },\n    title     = { {Rethinking VampIR} },\n    journal   = { Anoma Research Topics },\n    month     = { Aug },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { August 29, 2023 },\n    doi       = { 10.5281/zenodo.8262815 },\n    url       = { https://doi.org/10.5281/zenodo.8262814 }\n}\n\n\n@article{ art-2023-anoma-unified-architecture,\n    author    = { Christopher Goes and Awa Sun Yin and Adrian Brink },\n    title     = { {Anoma: a unified architecture for full-stack decentralised applications} },\n    journal   = { Anoma Research Topics },\n    month     = { Aug },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { August 24, 2023 },\n    doi       = { 10.5281/zenodo.8279842 },\n    url       = { https://doi.org/10.5281/zenodo.8279841 }\n}\n\n\n@article{ art-2023-geb-pipeline,\n    author    = { Artem Gureev and Jonathan Prieto-Cubides },\n    title     = { {Geb Pipeline} },\n    journal   = { Anoma Research Topics },\n    month     = { Aug },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { August 21, 2023 },\n    doi       = { 10.5281/zenodo.8262747 },\n    url       = { https://doi.org/10.5281/zenodo.8262746 }\n}\n\n\n@article{ art-2023-juvix-vampir-pipeline,\n    author    = { Lukasz Czajka },\n    title     = { {Juvix to VampIR Pipeline} },\n    journal   = { Anoma Research Topics },\n    month     = { Aug },\n    year      = { 2023 },\n    publisher = { Zenodo },\n    version   = { August 14, 2023 },\n    doi       = { 10.5281/zenodo.8252903 },\n    url       = { https://doi.org/10.5281/zenodo.8246535 }\n}\n</code></pre> Anoma Public GitHub repositories <pre><code>  author = {anoma},\n  title = {juvix},\n  year = {2017},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/juvix}\n}\n\n@misc{github-masp-mpc,\n  author = {anoma},\n  title = {masp-mpc},\n  year = {2020},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/masp-mpc}\n}\n\n@misc{github-masp,\n  author = {anoma},\n  title = {masp},\n  year = {2020},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/masp}\n}\n\n@misc{github-ferveo,\n  author = {anoma},\n  title = {ferveo},\n  year = {2020},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/ferveo}\n}\n\n@misc{github-anoma-archive,\n  author = {anoma},\n  title = {anoma-archive},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/anoma-archive}\n}\n\n@misc{github-group-threshold-crypto,\n  author = {anoma},\n  title = {group-threshold-crypto},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/group-threshold-crypto}\n}\n\n@misc{github-research,\n  author = {anoma},\n  title = {research},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/research}\n}\n\n@misc{github-plonkup-hash,\n  author = {anoma},\n  title = {plonkup-hash},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/plonkup-hash}\n}\n\n@misc{github-plonkup,\n  author = {anoma},\n  title = {plonkup},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/plonkup}\n}\n\n@misc{github-typhon,\n  author = {anoma},\n  title = {typhon},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/typhon}\n}\n\n@misc{github-exhibit_plonkup,\n  author = {anoma},\n  title = {exhibit_plonkup},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/exhibit_plonkup}\n}\n\n@misc{github-taiga,\n  author = {anoma},\n  title = {taiga},\n  year = {2021},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/taiga}\n}\n\n@misc{github-juvix-stdlib,\n  author = {anoma},\n  title = {juvix-stdlib},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/juvix-stdlib}\n}\n\n@misc{github-namada-trusted-setup,\n  author = {anoma},\n  title = {namada-trusted-setup},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/namada-trusted-setup}\n}\n\n@misc{github-alucard,\n  author = {anoma},\n  title = {alucard},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/alucard}\n}\n\n@misc{github-masp-phase2,\n  author = {anoma},\n  title = {masp-phase2},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/masp-phase2}\n}\n\n@misc{github-vamp-ir,\n  author = {anoma},\n  title = {vamp-ir},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/vamp-ir}\n}\n\n@misc{github-namada-testnets,\n  author = {anoma},\n  title = {namada-testnets},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/namada-testnets}\n}\n\n@misc{github-ethereum-bridge,\n  author = {anoma},\n  title = {ethereum-bridge},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/ethereum-bridge}\n}\n\n@misc{github-vscode-juvix,\n  author = {anoma},\n  title = {vscode-juvix},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/vscode-juvix}\n}\n\n@misc{github-whitepaper,\n  author = {anoma},\n  title = {whitepaper},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/whitepaper}\n}\n\n@misc{github-devchain-container,\n  author = {anoma},\n  title = {devchain-container},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/devchain-container}\n}\n\n@misc{github-wasm-workspace,\n  author = {anoma},\n  title = {wasm-workspace},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/wasm-workspace}\n}\n\n@misc{github-devtool,\n  author = {anoma},\n  title = {devtool},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/devtool}\n}\n\n@misc{github-anoma-wasm-multitoken,\n  author = {anoma},\n  title = {anoma-wasm-multitoken},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/anoma-wasm-multitoken}\n}\n\n@misc{github-dev-utils,\n  author = {anoma},\n  title = {dev-utils},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/dev-utils}\n}\n\n@misc{github-namada,\n  author = {anoma},\n  title = {namada},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/namada}\n}\n\n@misc{github-namada-interface,\n  author = {anoma},\n  title = {namada-interface},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/namada-interface}\n}\n\n@misc{github-zkp-compiler-shootout,\n  author = {anoma},\n  title = {zkp-compiler-shootout},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/zkp-compiler-shootout}\n}\n\n@misc{github-homebrew-juvix,\n  author = {anoma},\n  title = {homebrew-juvix},\n  year = {2022},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  url = {https://github.com/anoma/homebrew-juvix}\n}\n</code></pre> Other literature <pre><code>  title={Heterogeneous Paxos: Technical Report},\n  author={Isaac Sheff and Xinwen Wang and Robbert van Renesse and Andrew C. Myers},\n  year={2020},\n  eprint={2011.08253},\n  archivePrefix={arXiv},\n  primaryClass={cs.DC}\n}\n\n@misc{karbyshevsheff2024heterogeneous,\n  title={Heterogeneous Paxos 2.0: the Specs},\n  author={Aleksandr Karbyshev and Isaac Sheff},\n  year={2024},\n  url={https://pomf2.lain.la/f/owqf7ws.pdf},\n}\n\n@misc{goes2024anoma,\n  author = {Christopher Goes},\n  title = {Anoma as the Universal Intent Machine for Ethereum},\n  year = {2024},\n  howpublished = {{Ethereum Research}},\n  note = {Draft},\n  url = {https://ethresear.ch/t/rfc-draft-anoma-as-the-universal-intent-machine-for-ethereum/19109},\n  urldate = {2024-06-17}\n}\n\n@inproceedings{Hewitt2006,\n  title     = {What Is Commitment? Physical, Organizational, and Social (Revised)},\n  author    = {Hewitt, Carl},\n  year      = 2007,\n  publisher = {Springer Berlin Heidelberg},\n  address   = {Berlin, Heidelberg},\n  pages     = {293--307}\n}\n\n@phdthesis{clinger1981,\n  title     = {Foundations of Actor Semantics},\n  author    = {William Douglas Clinger},\n  year      = 1981,\n  url       = {https://dspace.mit.edu/handle/1721.1/6935},\n  school    = {Massachusetts Institute of Technology (MIT)}\n}\n\n@inproceedings{Hewitt1973,\n  title     = {A Universal Modular Actor Formalism for Artificial Intelligence},\n  author    = {Carl Hewitt and Peter Bishop and Richard Steiger},\n  year      = 1973,\n  location  = {San Francisco, CA, USA},\n  publisher = {Morgan Kaufmann Publishers Inc.},\n  pages     = {235--245}\n}\n\n@book{Scott1976,\n  title     = {Toward a Mathematical Semantics for Computer Languages},\n  author    = {Dana Scott and Christopher Strachey},\n  year      = 1976,\n  publisher = {Prentice-Hall}\n}\n\n@book{Agha1986,\n  title     = {Actors: A Model of Concurrent Computation in Distributed Systems},\n  author    = {Gul A. Agha},\n  year      = 1986,\n  publisher = {MIT Press}\n}\n\n@article{agha-overview-actor-languages,\n  title     = {An overview of actor languages},\n  author    = {Agha, Gul},\n  year      = 1986,\n  month     = {jun},\n  journal   = {SIGPLAN Not.},\n  publisher = {Association for Computing Machinery},\n  address   = {New York, NY, USA},\n  volume    = 21,\n  number    = 10,\n  pages     = {58\u201367},\n  doi       = {10.1145/323648.323743},\n  url       = {https://doi.org/10.1145/323648.323743},\n}\n\n@article{erlang,\n  title     = {The development of Erlang},\n  author    = {Armstrong, Joe},\n  year      = 1997,\n  month     = {aug},\n  journal   = {SIGPLAN Not.},\n  publisher = {Association for Computing Machinery},\n  address   = {New York, NY, USA},\n  volume    = 32,\n  number    = 8,\n  pages     = {196\u2013203},\n  doi       = {10.1145/258949.258967},\n  url       = {https://doi.org/10.1145/258949.258967}\n}\n\n@book{milner-concurrency,\n  title     = {Communication and Concurrency},\n  author    = {Milner, R.},\n  year      = 1989,\n  publisher = {Prentice-Hall, Inc.},\n  address   = {USA}\n}\n\n@article{behavioural-timed-systems,\n  title     = {{Behavioural equivalences for timed systems}},\n  author    = {Tomasz Brengos and Marco Peressotti},\n  year      = 2019,\n  month     = Feb,\n  journal   = {{Logical Methods in Computer Science}},\n  volume    = {{Volume 15, Issue 1}},\n  doi       = {10.23638/LMCS-15(1:17)2019},\n  url       = {https://lmcs.episciences.org/5220}\n}\n\n@inproceedings{actario,\n  title     = {Actario: A framework for reasoning about actor systems},\n  author    = {Yasutake, Shohei and Watanabe, Takuo},\n  year      = 2015\n}\n\n@article{Talcott1998,\n  title     = {Composable Semantic Models for Actor Theories},\n  author    = {Talcott,  Carolyn L.},\n  year      = 1998,\n  journal   = {Higher Order Symbolic Computation},\n  publisher = {Springer Science and Business Media LLC},\n  volume    = 11,\n  number    = 3,\n  pages     = {281\u2013343},\n  doi       = {10.1023/a:1010042915896},\n  url       = {http://dx.doi.org/10.1023/A:1010042915896}\n}\n\n@article{lamport-global-states,\n  title     = {Distributed snapshots: determining global states of distributed systems},\n  author    = {Chandy, K. Mani and Lamport, Leslie},\n  year      = 1985,\n  month     = {feb},\n  journal   = {ACM Transactions on Computer Systems},\n  publisher = {Association for Computing Machinery},\n  address   = {New York, NY, USA},\n  volume    = 3,\n  number    = 1,\n  pages     = {63\u201375},\n  doi       = {10.1145/214451.214456},\n  url       = {https://doi.org/10.1145/214451.214456},\n}\n\n@article{selectors-actors-2014,\n  title     = {Selectors: Actors with Multiple Guarded Mailboxes},\n  author    = {Imam,  Shams M. and Sarkar,  Vivek},\n  year      = 2014,\n  month     = oct,\n  publisher = {ACM},\n  journal   = {AGERE! '14: Proceedings of the 4th International Workshop on Programming based on Actors Agents and Decentralized Control},\n  series    = {SPLASH '14},\n  doi       = {10.1145/2687357.2687360},\n  url       = {http://dx.doi.org/10.1145/2687357.2687360},\n  collection = {SPLASH '14}\n}\n\n@article{special-delivery-mailbox-types-2023,\n  title     = {Special Delivery: Programming with Mailbox Types},\n  author    = {Fowler,  Simon and Attard,  Duncan Paul and Sowul,  Franciszek and Gay,  Simon J. and Trinder,  Phil},\n  year      = 2023,\n  month     = aug,\n  journal   = {Proceedings of the ACM on Programming Languages},\n  publisher = {Association for Computing Machinery (ACM)},\n  volume    = 7,\n  number    = {ICFP},\n  pages     = {78\u2013107},\n  doi       = {10.1145/3607832},\n  url       = {http://dx.doi.org/10.1145/3607832}\n}\n\n@article{there-is-no-now-2015,\n  title     = {There is No Now: Problems with simultaneity in distributed systems},\n  author    = {Sheehy, Justin},\n  year      = 2015,\n  month     = {mar},\n  journal   = {Queue},\n  publisher = {Association for Computing Machinery},\n  address   = {New York, NY, USA},\n  volume    = 13,\n  number    = 3,\n  pages     = {20\u201327},\n  doi       = {10.1145/2742694.2745385},\n  url       = {https://doi.org/10.1145/2742694.2745385}\n}\n\n@article{why-local-clocks-are-easy-2016,\n  title     = {Why Logical Clocks are Easy: Sometimes all you need is the right language.},\n  author    = {Baquero, Carlos and Pregui\\c{c}a, Nuno},\n  year      = 2016,\n  month     = {feb},\n  journal   = {Queue},\n  publisher = {Association for Computing Machinery},\n  address   = {New York, NY, USA},\n  volume    = 14,\n  number    = 1,\n  pages     = {53\u201369},\n  doi       = {10.1145/2898442.2917756},\n  url       = {https://doi.org/10.1145/2898442.2917756}\n}\n\n@article{lamport-time-clocks-1978,\n  title     = {Time, clocks, and the ordering of events in a distributed system},\n  author    = {Lamport, Leslie},\n  year      = 1978,\n  month     = {jul},\n  journal   = {Commun. ACM},\n  publisher = {Association for Computing Machinery},\n  address   = {New York, NY, USA},\n  volume    = 21,\n  number    = 7,\n  pages     = {558\u2013565},\n  doi       = {10.1145/359545.359563},\n  url       = {https://doi.org/10.1145/359545.359563},\n}\n\n@inproceedings{taxonomy-of-actor-models-2016,\n  title     = {43 years of actors: a taxonomy of actor models and their key properties},\n  author    = {De Koster, Joeri and Van Cutsem, Tom and De Meuter, Wolfgang},\n  year      = 2016,\n  location  = {Amsterdam, Netherlands},\n  publisher = {Association for Computing Machinery},\n  address   = {New York, NY, USA},\n  series    = {AGERE 2016},\n  pages     = {31\u201340},\n  doi       = {10.1145/3001886.3001890},\n  url       = {https://doi.org/10.1145/3001886.3001890}\n}\n</code></pre>","tags":["references","bibtex"]},{"location":"tutorial/md/headers_and_other_conventions.html","title":"Headers and other Markdown conventions","text":"<ul> <li> <p>Use semantic headers to structure your content.</p> <ul> <li>Use <code>#</code> for the main title, <code>##</code> for the first-level header, <code>###</code> for the   second-level header.</li> <li>Only use up to the third level of headers. If you need more levels, consider   restructuring your content.</li> </ul> </li> </ul> <ul> <li> <p>Use sentence case for headers. For example,</p> <ul> <li>use \"How to use this Glossary\" instead of \"How to Use This Glossary\", or,</li> <li>use \"Anoma protocol\" instead of  \"Anoma Protocol\", or</li> <li>use \"On engine systems for the Anoma Specification\" instead of \"On Engine   Systems For The Anoma Specification\".</li> </ul> </li> </ul> <ul> <li>Always add a front matter as described in Write using Markdown.</li> </ul> <ul> <li>The (Juvix) Markdown filenames should follow the convention as described in File naming conventions.</li> </ul> (Wiki) links on this page<ul><li>File naming conventions</li></ul>","tags":["references","bibtex"]},{"location":"tutorial/md/images.html","title":"Support for including images","text":"<p>Images should be stored in the <code>docs/images</code> folder. Use the File Naming Conventions also for naming images.</p>"},{"location":"tutorial/md/images.html#syntax","title":"Syntax","text":"<p>To add an image, apply the following syntax:</p> <pre><code>![Alt Text](https://anoma.github.io/nspec/main/images/logo.svg){: width=\"200\"}\n</code></pre>"},{"location":"tutorial/md/images.html#displayed-image-example","title":"Displayed Image Example","text":"<p>The syntax above will render the image in your document like so:</p> <p></p> <p>Enhanced Image Display</p> <p>Use an HTML <code>&lt;figure&gt;</code> element with a <code>&lt;figcaption&gt;</code> for a refined presentation with captions. Markdown can also be used within the caption:</p> <pre><code>&lt;figure markdown=\"1\"&gt;\n  &lt;img src=\"docs/images/image-name.png\" alt=\"Alt Text\"&gt;\n  &lt;figcaption markdown=\"span\"&gt;Image caption text can include *Markdown*!&lt;/figcaption&gt;\n&lt;/figure&gt;\n</code></pre>"},{"location":"tutorial/md/links.html","title":"Support for Wiki Links","text":"<p>Wiki links offer a simple method for citing and referencing other pages in the documentation without lengthy URLs. Wiki links are the preferred method for linking to other pages in the documentation, so please use them whenever possible.</p>","tags":["wikilinks","images","snippets"]},{"location":"tutorial/md/links.html#basic-syntax","title":"Basic Syntax","text":"<p>The basic syntax for a wiki link is:</p> <pre><code>[[page]]\n</code></pre> <p>Where:</p> <ul> <li><code>page</code> is the title of the target page</li> </ul>","tags":["wikilinks","images","snippets"]},{"location":"tutorial/md/links.html#full-syntax","title":"Full Syntax","text":"<p>The full syntax for a wiki link is: Wiki Link Syntax<pre><code>  [[hintpath/to:page#anchor|Custom caption]]\n</code></pre></p> <p>When resolving a wiki link, the system follows these rules:</p>","tags":["wikilinks","images","snippets"]},{"location":"tutorial/md/links.html#page-title","title":"Page Title","text":"<p>(Mandatory) The 'page' in a wiki link refers to the title specified in the <code>nav</code> attribute of the <code>mkdocs.yml</code> file. For example,</p> mkdocs.yml<pre><code>nav:\n  - Home: index.md\n  - MyRef X: reference.md\n</code></pre> <p>provides the following wiki link:</p> <pre><code>[[MyRef X]]\n</code></pre>","tags":["wikilinks","images","snippets"]},{"location":"tutorial/md/links.html#path-hints","title":"Path Hints","text":"<p>(Optional) You can use path hints to specify the location of the file. The syntax is:</p> Path Hints<pre><code>[[hintpath/to:page]]\n</code></pre> <p>Where:</p> <ul> <li><code>hintpath/to</code> is the path (or prefix) to the file</li> <li><code>page</code> is the title of the target page</li> </ul>","tags":["wikilinks","images","snippets"]},{"location":"tutorial/md/links.html#anchors","title":"Anchors","text":"<p>(Optional) Use anchors to link to specific sections within a page. If the page does not have an anchor, the link would render as the caption provided, and you'll find a warning in the build process.</p> Anchors<pre><code>[[page#anchor]]\n</code></pre> <p>Where:</p> <ul> <li><code>page</code> is the title of the target page</li> <li><code>anchor</code> is a specific section within the page</li> </ul>","tags":["wikilinks","images","snippets"]},{"location":"tutorial/md/links.html#custom-captions","title":"Custom captions","text":"<p>(Optional) Provide custom text to display for the link instead of the page title.</p> Custom Captions<pre><code>[[page#anchor|Custom caption]]\n</code></pre> <p>Where:</p> <ul> <li><code>page</code> is the title of the target page</li> <li><code>anchor</code> is a specific section within the page</li> </ul> <p>Captions can include icons, for example:</p> MarkdownPreview <pre><code>[[Home | :material-link: this is a caption with an icon ]]\n</code></pre> <p> this is a caption with an icon</p>","tags":["wikilinks","images","snippets"]},{"location":"tutorial/md/links.html#list-of-wiki-style-links-per-page","title":"List of wiki-style links per Page","text":"<p>By default, the build process will generate a list of all wiki-style links per page. This list is displayed at the bottom of the page, and it is useful for identifying broken links or pages that are not linked to from other pages.</p> <p>To disable this feature, set the <code>list_wikilinks</code> option to <code>false</code> in the front matter of the page.</p> <pre><code>list_wikilinks: false\n</code></pre> <p>Additionally, you could see a mermaid graph of the links by setting the <code>graph_wikilinks</code> option to <code>true</code> in the front matter of the page. This, however, may render graphs that are too large to be useful. Thus, it is set to <code>false</code> by default.</p> <pre><code>graph_wikilinks: true\n</code></pre> (Wiki) links on this page<ul><li>Home</li></ul>","tags":["wikilinks","images","snippets"]},{"location":"tutorial/md/snippets.html","title":"Include code snippets","text":""},{"location":"tutorial/md/snippets.html#code-snippets","title":"Code Snippets","text":"<p>Include excerpts from other files using the Snippet extension detailed here: PyMdown Extensions - Snippets.</p>"},{"location":"tutorial/md/snippets.html#excerpt-wrapping-syntax","title":"Excerpt Wrapping Syntax","text":"<p>Enclose the excerpt with the following tags:</p> <pre><code>&lt;!-- Start snippet --&gt;\n;--8&lt;-- [start:TAG]\n...\n;--8&lt;-- [end:TAG]\n&lt;!-- End snippet --&gt;\n</code></pre>"},{"location":"tutorial/md/snippets.html#snippet-inclusion-syntax","title":"Snippet Inclusion Syntax","text":"<p>To incorporate the excerpt elsewhere, specify its path and tag:</p> <pre><code>--8&lt;-- \"path/to/file.ext:TAG\"\n</code></pre> <p>Following these practices ensures consistency, navigability, and professionalism in the Anoma documentation.</p>"},{"location":"tutorial/md/todos.html","title":"Add pending tasks with Todos admonition","text":""},{"location":"tutorial/md/todos.html#todos","title":"Todos","text":"<p>Incorporate todos with the following syntax:</p> <pre><code>!!! todo\n\n    Content of the todo\n</code></pre> <p>The above renders as:</p> <p>Todo</p> <p>Content of the todo</p> <p>Info</p> <p>Be aware that todos are automatically removed from the online version. If you want to keep them, set <code>todos: True</code> in the front matter.</p>"}]}